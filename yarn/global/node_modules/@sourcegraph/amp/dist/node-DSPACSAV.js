#!/usr/bin/env node
import * as oe from "node:os";
import { resolve as he } from "node:path";
import { aQ as ce, aR as le, aS as re, aT as ue, aU as fe, aV as _e, O as te, aW as de, aX as ie, aY as pe } from "./color-Bf2jGwiV.js";
import { loadProfileEnvironmentVariables as ge } from "./load-profile-Bu7wgoOq.js";
var se = {}, ne;
function ve() {
  return ne || (ne = 1, function(W) {
    (() => {
      var V = { 349: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.CircularList = void 0;
        const _ = l(460), d = l(844);
        class n extends d.Disposable {
          constructor(a) {
            super(), this._maxLength = a, this.onDeleteEmitter = this.register(new _.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new _.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new _.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
          }
          get maxLength() {
            return this._maxLength;
          }
          set maxLength(a) {
            if (this._maxLength === a) return;
            const h = new Array(a);
            for (let u = 0; u < Math.min(a, this.length); u++) h[u] = this._array[this._getCyclicIndex(u)];
            this._array = h, this._maxLength = a, this._startIndex = 0;
          }
          get length() {
            return this._length;
          }
          set length(a) {
            if (a > this._length) for (let h = this._length; h < a; h++) this._array[h] = void 0;
            this._length = a;
          }
          get(a) {
            return this._array[this._getCyclicIndex(a)];
          }
          set(a, h) {
            this._array[this._getCyclicIndex(a)] = h;
          }
          push(a) {
            this._array[this._getCyclicIndex(this._length)] = a, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
          }
          recycle() {
            if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
            return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
          }
          get isFull() {
            return this._length === this._maxLength;
          }
          pop() {
            return this._array[this._getCyclicIndex(this._length-- - 1)];
          }
          splice(a, h, ...u) {
            if (h) {
              for (let e = a; e < this._length - h; e++) this._array[this._getCyclicIndex(e)] = this._array[this._getCyclicIndex(e + h)];
              this._length -= h, this.onDeleteEmitter.fire({ index: a, amount: h });
            }
            for (let e = this._length - 1; e >= a; e--) this._array[this._getCyclicIndex(e + u.length)] = this._array[this._getCyclicIndex(e)];
            for (let e = 0; e < u.length; e++) this._array[this._getCyclicIndex(a + e)] = u[e];
            if (u.length && this.onInsertEmitter.fire({ index: a, amount: u.length }), this._length + u.length > this._maxLength) {
              const e = this._length + u.length - this._maxLength;
              this._startIndex += e, this._length = this._maxLength, this.onTrimEmitter.fire(e);
            } else this._length += u.length;
          }
          trimStart(a) {
            a > this._length && (a = this._length), this._startIndex += a, this._length -= a, this.onTrimEmitter.fire(a);
          }
          shiftElements(a, h, u) {
            if (!(h <= 0)) {
              if (a < 0 || a >= this._length) throw new Error("start argument out of range");
              if (a + u < 0) throw new Error("Cannot shift elements in list beyond index 0");
              if (u > 0) {
                for (let s = h - 1; s >= 0; s--) this.set(a + s + u, this.get(a + s));
                const e = a + h + u - this._length;
                if (e > 0) for (this._length += e; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
              } else for (let e = 0; e < h; e++) this.set(a + e + u, this.get(a + e));
            }
          }
          _getCyclicIndex(a) {
            return (this._startIndex + a) % this._maxLength;
          }
        }
        i.CircularList = n;
      }, 439: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.clone = void 0, i.clone = function l(_, d = 5) {
          if (typeof _ != "object") return _;
          const n = Array.isArray(_) ? [] : {};
          for (const c in _) n[c] = d <= 1 ? _[c] : _[c] && l(_[c], d - 1);
          return n;
        };
      }, 969: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.CoreTerminal = void 0;
        const _ = l(844), d = l(585), n = l(348), c = l(866), a = l(744), h = l(302), u = l(83), e = l(460), s = l(753), r = l(480), t = l(994), f = l(282), p = l(435), m = l(981), y = l(660);
        let C = !1;
        class T extends _.Disposable {
          get onScroll() {
            return this._onScrollApi || (this._onScrollApi = this.register(new e.EventEmitter()), this._onScroll.event((E) => {
              this._onScrollApi?.fire(E.position);
            })), this._onScrollApi.event;
          }
          get cols() {
            return this._bufferService.cols;
          }
          get rows() {
            return this._bufferService.rows;
          }
          get buffers() {
            return this._bufferService.buffers;
          }
          get options() {
            return this.optionsService.options;
          }
          set options(E) {
            for (const w in E) this.optionsService.options[w] = E[w];
          }
          constructor(E) {
            super(), this._windowsWrappingHeuristics = this.register(new _.MutableDisposable()), this._onBinary = this.register(new e.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new e.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new e.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new e.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new e.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new e.EventEmitter()), this._instantiationService = new n.InstantiationService(), this.optionsService = this.register(new h.OptionsService(E)), this._instantiationService.setService(d.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(d.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(c.LogService)), this._instantiationService.setService(d.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(u.CoreService)), this._instantiationService.setService(d.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(s.CoreMouseService)), this._instantiationService.setService(d.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(r.UnicodeService)), this._instantiationService.setService(d.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(t.CharsetService), this._instantiationService.setService(d.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(y.OscLinkService), this._instantiationService.setService(d.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new p.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, e.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, e.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, e.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, e.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((w) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this.register(this._inputHandler.onScroll((w) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            })), this._writeBuffer = this.register(new m.WriteBuffer((w, L) => this._inputHandler.parse(w, L))), this.register((0, e.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
          }
          write(E, w) {
            this._writeBuffer.write(E, w);
          }
          writeSync(E, w) {
            this._logService.logLevel <= d.LogLevelEnum.WARN && !C && (this._logService.warn("writeSync is unreliable and will be removed soon."), C = !0), this._writeBuffer.writeSync(E, w);
          }
          input(E, w = !0) {
            this.coreService.triggerDataEvent(E, w);
          }
          resize(E, w) {
            isNaN(E) || isNaN(w) || (E = Math.max(E, a.MINIMUM_COLS), w = Math.max(w, a.MINIMUM_ROWS), this._bufferService.resize(E, w));
          }
          scroll(E, w = !1) {
            this._bufferService.scroll(E, w);
          }
          scrollLines(E, w, L) {
            this._bufferService.scrollLines(E, w, L);
          }
          scrollPages(E) {
            this.scrollLines(E * (this.rows - 1));
          }
          scrollToTop() {
            this.scrollLines(-this._bufferService.buffer.ydisp);
          }
          scrollToBottom() {
            this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          }
          scrollToLine(E) {
            const w = E - this._bufferService.buffer.ydisp;
            w !== 0 && this.scrollLines(w);
          }
          registerEscHandler(E, w) {
            return this._inputHandler.registerEscHandler(E, w);
          }
          registerDcsHandler(E, w) {
            return this._inputHandler.registerDcsHandler(E, w);
          }
          registerCsiHandler(E, w) {
            return this._inputHandler.registerCsiHandler(E, w);
          }
          registerOscHandler(E, w) {
            return this._inputHandler.registerOscHandler(E, w);
          }
          _setup() {
            this._handleWindowsPtyOptionChange();
          }
          reset() {
            this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
          }
          _handleWindowsPtyOptionChange() {
            let E = !1;
            const w = this.optionsService.rawOptions.windowsPty;
            w && w.buildNumber !== void 0 && w.buildNumber !== void 0 ? E = w.backend === "conpty" && w.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (E = !0), E ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
          }
          _enableWindowsWrappingHeuristics() {
            if (!this._windowsWrappingHeuristics.value) {
              const E = [];
              E.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), E.push(this.registerCsiHandler({ final: "H" }, () => ((0, f.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsWrappingHeuristics.value = (0, _.toDisposable)(() => {
                for (const w of E) w.dispose();
              });
            }
          }
        }
        i.CoreTerminal = T;
      }, 460: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.runAndSubscribe = i.forwardEvent = i.EventEmitter = void 0, i.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = !1;
          }
          get event() {
            return this._event || (this._event = (l) => (this._listeners.push(l), { dispose: () => {
              if (!this._disposed) {
                for (let d = 0; d < this._listeners.length; d++) if (this._listeners[d] === l) return void this._listeners.splice(d, 1);
              }
            } })), this._event;
          }
          fire(l, _) {
            const d = [];
            for (let n = 0; n < this._listeners.length; n++) d.push(this._listeners[n]);
            for (let n = 0; n < d.length; n++) d[n].call(void 0, l, _);
          }
          dispose() {
            this.clearListeners(), this._disposed = !0;
          }
          clearListeners() {
            this._listeners && (this._listeners.length = 0);
          }
        }, i.forwardEvent = function(l, _) {
          return l((d) => _.fire(d));
        }, i.runAndSubscribe = function(l, _) {
          return _(void 0), l((d) => _(d));
        };
      }, 435: function(B, i, l) {
        var _ = this && this.__decorate || function(x, o, b, g) {
          var S, A = arguments.length, D = A < 3 ? o : g === null ? g = Object.getOwnPropertyDescriptor(o, b) : g;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") D = Reflect.decorate(x, o, b, g);
          else for (var R = x.length - 1; R >= 0; R--) (S = x[R]) && (D = (A < 3 ? S(D) : A > 3 ? S(o, b, D) : S(o, b)) || D);
          return A > 3 && D && Object.defineProperty(o, b, D), D;
        }, d = this && this.__param || function(x, o) {
          return function(b, g) {
            o(b, g, x);
          };
        };
        Object.defineProperty(i, "__esModule", { value: !0 }), i.InputHandler = i.WindowsOptionsReportType = void 0;
        const n = l(584), c = l(116), a = l(15), h = l(844), u = l(482), e = l(437), s = l(460), r = l(643), t = l(511), f = l(734), p = l(585), m = l(480), y = l(242), C = l(351), T = l(941), F = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, E = 131072;
        function w(x, o) {
          if (x > 24) return o.setWinLines || !1;
          switch (x) {
            case 1:
              return !!o.restoreWin;
            case 2:
              return !!o.minimizeWin;
            case 3:
              return !!o.setWinPosition;
            case 4:
              return !!o.setWinSizePixels;
            case 5:
              return !!o.raiseWin;
            case 6:
              return !!o.lowerWin;
            case 7:
              return !!o.refreshWin;
            case 8:
              return !!o.setWinSizeChars;
            case 9:
              return !!o.maximizeWin;
            case 10:
              return !!o.fullscreenWin;
            case 11:
              return !!o.getWinState;
            case 13:
              return !!o.getWinPosition;
            case 14:
              return !!o.getWinSizePixels;
            case 15:
              return !!o.getScreenSizePixels;
            case 16:
              return !!o.getCellSizePixels;
            case 18:
              return !!o.getWinSizeChars;
            case 19:
              return !!o.getScreenSizeChars;
            case 20:
              return !!o.getIconTitle;
            case 21:
              return !!o.getWinTitle;
            case 22:
              return !!o.pushTitle;
            case 23:
              return !!o.popTitle;
            case 24:
              return !!o.setWinLines;
          }
          return !1;
        }
        var L;
        (function(x) {
          x[x.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", x[x.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
        })(L || (i.WindowsOptionsReportType = L = {}));
        let G = 0;
        class z extends h.Disposable {
          getAttrData() {
            return this._curAttrData;
          }
          constructor(o, b, g, S, A, D, R, I, $ = new a.EscapeSequenceParser()) {
            super(), this._bufferService = o, this._charsetService = b, this._coreService = g, this._logService = S, this._optionsService = A, this._oscLinkService = D, this._coreMouseService = R, this._unicodeService = I, this._parser = $, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new u.StringToUtf32(), this._utf8Decoder = new u.Utf8ToUtf32(), this._workCell = new t.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = e.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new s.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new s.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new s.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new s.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new s.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new s.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new s.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new s.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new s.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new s.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new s.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new s.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new s.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: !1, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new M(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((v) => this._activeBuffer = v.activeBuffer)), this._parser.setCsiHandlerFallback((v, H) => {
              this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(v), params: H.toArray() });
            }), this._parser.setEscHandlerFallback((v) => {
              this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(v) });
            }), this._parser.setExecuteHandlerFallback((v) => {
              this._logService.debug("Unknown EXECUTE code: ", { code: v });
            }), this._parser.setOscHandlerFallback((v, H, k) => {
              this._logService.debug("Unknown OSC code: ", { identifier: v, action: H, data: k });
            }), this._parser.setDcsHandlerFallback((v, H, k) => {
              H === "HOOK" && (k = k.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(v), action: H, payload: k });
            }), this._parser.setPrintHandler((v, H, k) => this.print(v, H, k)), this._parser.registerCsiHandler({ final: "@" }, (v) => this.insertChars(v)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (v) => this.scrollLeft(v)), this._parser.registerCsiHandler({ final: "A" }, (v) => this.cursorUp(v)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (v) => this.scrollRight(v)), this._parser.registerCsiHandler({ final: "B" }, (v) => this.cursorDown(v)), this._parser.registerCsiHandler({ final: "C" }, (v) => this.cursorForward(v)), this._parser.registerCsiHandler({ final: "D" }, (v) => this.cursorBackward(v)), this._parser.registerCsiHandler({ final: "E" }, (v) => this.cursorNextLine(v)), this._parser.registerCsiHandler({ final: "F" }, (v) => this.cursorPrecedingLine(v)), this._parser.registerCsiHandler({ final: "G" }, (v) => this.cursorCharAbsolute(v)), this._parser.registerCsiHandler({ final: "H" }, (v) => this.cursorPosition(v)), this._parser.registerCsiHandler({ final: "I" }, (v) => this.cursorForwardTab(v)), this._parser.registerCsiHandler({ final: "J" }, (v) => this.eraseInDisplay(v, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (v) => this.eraseInDisplay(v, !0)), this._parser.registerCsiHandler({ final: "K" }, (v) => this.eraseInLine(v, !1)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (v) => this.eraseInLine(v, !0)), this._parser.registerCsiHandler({ final: "L" }, (v) => this.insertLines(v)), this._parser.registerCsiHandler({ final: "M" }, (v) => this.deleteLines(v)), this._parser.registerCsiHandler({ final: "P" }, (v) => this.deleteChars(v)), this._parser.registerCsiHandler({ final: "S" }, (v) => this.scrollUp(v)), this._parser.registerCsiHandler({ final: "T" }, (v) => this.scrollDown(v)), this._parser.registerCsiHandler({ final: "X" }, (v) => this.eraseChars(v)), this._parser.registerCsiHandler({ final: "Z" }, (v) => this.cursorBackwardTab(v)), this._parser.registerCsiHandler({ final: "`" }, (v) => this.charPosAbsolute(v)), this._parser.registerCsiHandler({ final: "a" }, (v) => this.hPositionRelative(v)), this._parser.registerCsiHandler({ final: "b" }, (v) => this.repeatPrecedingCharacter(v)), this._parser.registerCsiHandler({ final: "c" }, (v) => this.sendDeviceAttributesPrimary(v)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (v) => this.sendDeviceAttributesSecondary(v)), this._parser.registerCsiHandler({ final: "d" }, (v) => this.linePosAbsolute(v)), this._parser.registerCsiHandler({ final: "e" }, (v) => this.vPositionRelative(v)), this._parser.registerCsiHandler({ final: "f" }, (v) => this.hVPosition(v)), this._parser.registerCsiHandler({ final: "g" }, (v) => this.tabClear(v)), this._parser.registerCsiHandler({ final: "h" }, (v) => this.setMode(v)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (v) => this.setModePrivate(v)), this._parser.registerCsiHandler({ final: "l" }, (v) => this.resetMode(v)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (v) => this.resetModePrivate(v)), this._parser.registerCsiHandler({ final: "m" }, (v) => this.charAttributes(v)), this._parser.registerCsiHandler({ final: "n" }, (v) => this.deviceStatus(v)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (v) => this.deviceStatusPrivate(v)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (v) => this.softReset(v)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (v) => this.setCursorStyle(v)), this._parser.registerCsiHandler({ final: "r" }, (v) => this.setScrollRegion(v)), this._parser.registerCsiHandler({ final: "s" }, (v) => this.saveCursor(v)), this._parser.registerCsiHandler({ final: "t" }, (v) => this.windowOptions(v)), this._parser.registerCsiHandler({ final: "u" }, (v) => this.restoreCursor(v)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (v) => this.insertColumns(v)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (v) => this.deleteColumns(v)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (v) => this.selectProtected(v)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (v) => this.requestMode(v, !0)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (v) => this.requestMode(v, !1)), this._parser.setExecuteHandler(n.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, () => this.index()), this._parser.setExecuteHandler(n.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new y.OscHandler((v) => (this.setTitle(v), this.setIconName(v), !0))), this._parser.registerOscHandler(1, new y.OscHandler((v) => this.setIconName(v))), this._parser.registerOscHandler(2, new y.OscHandler((v) => this.setTitle(v))), this._parser.registerOscHandler(4, new y.OscHandler((v) => this.setOrReportIndexedColor(v))), this._parser.registerOscHandler(8, new y.OscHandler((v) => this.setHyperlink(v))), this._parser.registerOscHandler(10, new y.OscHandler((v) => this.setOrReportFgColor(v))), this._parser.registerOscHandler(11, new y.OscHandler((v) => this.setOrReportBgColor(v))), this._parser.registerOscHandler(12, new y.OscHandler((v) => this.setOrReportCursorColor(v))), this._parser.registerOscHandler(104, new y.OscHandler((v) => this.restoreIndexedColor(v))), this._parser.registerOscHandler(110, new y.OscHandler((v) => this.restoreFgColor(v))), this._parser.registerOscHandler(111, new y.OscHandler((v) => this.restoreBgColor(v))), this._parser.registerOscHandler(112, new y.OscHandler((v) => this.restoreCursorColor(v))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
            for (const v in c.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: v }, () => this.selectCharset("(" + v)), this._parser.registerEscHandler({ intermediates: ")", final: v }, () => this.selectCharset(")" + v)), this._parser.registerEscHandler({ intermediates: "*", final: v }, () => this.selectCharset("*" + v)), this._parser.registerEscHandler({ intermediates: "+", final: v }, () => this.selectCharset("+" + v)), this._parser.registerEscHandler({ intermediates: "-", final: v }, () => this.selectCharset("-" + v)), this._parser.registerEscHandler({ intermediates: ".", final: v }, () => this.selectCharset("." + v)), this._parser.registerEscHandler({ intermediates: "/", final: v }, () => this.selectCharset("/" + v));
            this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((v) => (this._logService.error("Parsing error: ", v), v)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new C.DcsHandler((v, H) => this.requestStatusString(v, H)));
          }
          _preserveStack(o, b, g, S) {
            this._parseStack.paused = !0, this._parseStack.cursorStartX = o, this._parseStack.cursorStartY = b, this._parseStack.decodedLength = g, this._parseStack.position = S;
          }
          _logSlowResolvingAsync(o) {
            this._logService.logLevel <= p.LogLevelEnum.WARN && Promise.race([o, new Promise((b, g) => setTimeout(() => g("#SLOW_TIMEOUT"), 5e3))]).catch((b) => {
              if (b !== "#SLOW_TIMEOUT") throw b;
              console.warn("async parser handler taking longer than 5000 ms");
            });
          }
          _getCurrentLinkId() {
            return this._curAttrData.extended.urlId;
          }
          parse(o, b) {
            let g, S = this._activeBuffer.x, A = this._activeBuffer.y, D = 0;
            const R = this._parseStack.paused;
            if (R) {
              if (g = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, b)) return this._logSlowResolvingAsync(g), g;
              S = this._parseStack.cursorStartX, A = this._parseStack.cursorStartY, this._parseStack.paused = !1, o.length > E && (D = this._parseStack.position + E);
            }
            if (this._logService.logLevel <= p.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof o == "string" ? ` "${o}"` : ` "${Array.prototype.map.call(o, (v) => String.fromCharCode(v)).join("")}"`), typeof o == "string" ? o.split("").map((v) => v.charCodeAt(0)) : o), this._parseBuffer.length < o.length && this._parseBuffer.length < E && (this._parseBuffer = new Uint32Array(Math.min(o.length, E))), R || this._dirtyRowTracker.clearRange(), o.length > E) for (let v = D; v < o.length; v += E) {
              const H = v + E < o.length ? v + E : o.length, k = typeof o == "string" ? this._stringDecoder.decode(o.substring(v, H), this._parseBuffer) : this._utf8Decoder.decode(o.subarray(v, H), this._parseBuffer);
              if (g = this._parser.parse(this._parseBuffer, k)) return this._preserveStack(S, A, k, v), this._logSlowResolvingAsync(g), g;
            }
            else if (!R) {
              const v = typeof o == "string" ? this._stringDecoder.decode(o, this._parseBuffer) : this._utf8Decoder.decode(o, this._parseBuffer);
              if (g = this._parser.parse(this._parseBuffer, v)) return this._preserveStack(S, A, v, 0), this._logSlowResolvingAsync(g), g;
            }
            this._activeBuffer.x === S && this._activeBuffer.y === A || this._onCursorMove.fire();
            const I = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp), $ = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
            $ < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min($, this._bufferService.rows - 1), Math.min(I, this._bufferService.rows - 1));
          }
          print(o, b, g) {
            let S, A;
            const D = this._charsetService.charset, R = this._optionsService.rawOptions.screenReaderMode, I = this._bufferService.cols, $ = this._coreService.decPrivateModes.wraparound, v = this._coreService.modes.insertMode, H = this._curAttrData;
            let k = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && g - b > 0 && k.getWidth(this._activeBuffer.x - 1) === 2 && k.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, H);
            let P = this._parser.precedingJoinState;
            for (let J = b; J < g; ++J) {
              if (S = o[J], S < 127 && D) {
                const Y = D[String.fromCharCode(S)];
                Y && (S = Y.charCodeAt(0));
              }
              const Q = this._unicodeService.charProperties(S, P);
              A = m.UnicodeService.extractWidth(Q);
              const ee = m.UnicodeService.extractShouldJoin(Q), K = ee ? m.UnicodeService.extractWidth(P) : 0;
              if (P = Q, R && this._onA11yChar.fire((0, u.stringFromCodePoint)(S)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), this._activeBuffer.x + A - K > I) {
                if ($) {
                  const Y = k;
                  let Z = this._activeBuffer.x - K;
                  for (this._activeBuffer.x = K, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), k = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y), K > 0 && k instanceof e.BufferLine && k.copyCellsFrom(Y, Z, 0, K, !1); Z < I; ) Y.setCellFromCodepoint(Z++, 0, 1, H);
                } else if (this._activeBuffer.x = I - 1, A === 2) continue;
              }
              if (ee && this._activeBuffer.x) {
                const Y = k.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
                k.addCodepointToCell(this._activeBuffer.x - Y, S, A);
                for (let Z = A - K; --Z >= 0; ) k.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, H);
              } else if (v && (k.insertCells(this._activeBuffer.x, A - K, this._activeBuffer.getNullCell(H)), k.getWidth(I - 1) === 2 && k.setCellFromCodepoint(I - 1, r.NULL_CELL_CODE, r.NULL_CELL_WIDTH, H)), k.setCellFromCodepoint(this._activeBuffer.x++, S, A, H), A > 0) for (; --A; ) k.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, H);
            }
            this._parser.precedingJoinState = P, this._activeBuffer.x < I && g - b > 0 && k.getWidth(this._activeBuffer.x) === 0 && !k.hasContent(this._activeBuffer.x) && k.setCellFromCodepoint(this._activeBuffer.x, 0, 1, H), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          registerCsiHandler(o, b) {
            return o.final !== "t" || o.prefix || o.intermediates ? this._parser.registerCsiHandler(o, b) : this._parser.registerCsiHandler(o, (g) => !w(g.params[0], this._optionsService.rawOptions.windowOptions) || b(g));
          }
          registerDcsHandler(o, b) {
            return this._parser.registerDcsHandler(o, new C.DcsHandler(b));
          }
          registerEscHandler(o, b) {
            return this._parser.registerEscHandler(o, b);
          }
          registerOscHandler(o, b) {
            return this._parser.registerOscHandler(o, new y.OscHandler(b));
          }
          bell() {
            return this._onRequestBell.fire(), !0;
          }
          lineFeed() {
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;
          }
          carriageReturn() {
            return this._activeBuffer.x = 0, !0;
          }
          backspace() {
            if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;
            if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
            else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)?.isWrapped) {
              this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
              const o = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              o.hasWidth(this._activeBuffer.x) && !o.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
            }
            return this._restrictCursor(), !0;
          }
          tab() {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            const o = this._activeBuffer.x;
            return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - o), !0;
          }
          shiftOut() {
            return this._charsetService.setgLevel(1), !0;
          }
          shiftIn() {
            return this._charsetService.setgLevel(0), !0;
          }
          _restrictCursor(o = this._bufferService.cols - 1) {
            this._activeBuffer.x = Math.min(o, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _setCursor(o, b) {
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = o, this._activeBuffer.y = this._activeBuffer.scrollTop + b) : (this._activeBuffer.x = o, this._activeBuffer.y = b), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _moveCursor(o, b) {
            this._restrictCursor(), this._setCursor(this._activeBuffer.x + o, this._activeBuffer.y + b);
          }
          cursorUp(o) {
            const b = this._activeBuffer.y - this._activeBuffer.scrollTop;
            return b >= 0 ? this._moveCursor(0, -Math.min(b, o.params[0] || 1)) : this._moveCursor(0, -(o.params[0] || 1)), !0;
          }
          cursorDown(o) {
            const b = this._activeBuffer.scrollBottom - this._activeBuffer.y;
            return b >= 0 ? this._moveCursor(0, Math.min(b, o.params[0] || 1)) : this._moveCursor(0, o.params[0] || 1), !0;
          }
          cursorForward(o) {
            return this._moveCursor(o.params[0] || 1, 0), !0;
          }
          cursorBackward(o) {
            return this._moveCursor(-(o.params[0] || 1), 0), !0;
          }
          cursorNextLine(o) {
            return this.cursorDown(o), this._activeBuffer.x = 0, !0;
          }
          cursorPrecedingLine(o) {
            return this.cursorUp(o), this._activeBuffer.x = 0, !0;
          }
          cursorCharAbsolute(o) {
            return this._setCursor((o.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          cursorPosition(o) {
            return this._setCursor(o.length >= 2 ? (o.params[1] || 1) - 1 : 0, (o.params[0] || 1) - 1), !0;
          }
          charPosAbsolute(o) {
            return this._setCursor((o.params[0] || 1) - 1, this._activeBuffer.y), !0;
          }
          hPositionRelative(o) {
            return this._moveCursor(o.params[0] || 1, 0), !0;
          }
          linePosAbsolute(o) {
            return this._setCursor(this._activeBuffer.x, (o.params[0] || 1) - 1), !0;
          }
          vPositionRelative(o) {
            return this._moveCursor(0, o.params[0] || 1), !0;
          }
          hVPosition(o) {
            return this.cursorPosition(o), !0;
          }
          tabClear(o) {
            const b = o.params[0];
            return b === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : b === 3 && (this._activeBuffer.tabs = {}), !0;
          }
          cursorForwardTab(o) {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            let b = o.params[0] || 1;
            for (; b--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
            return !0;
          }
          cursorBackwardTab(o) {
            if (this._activeBuffer.x >= this._bufferService.cols) return !0;
            let b = o.params[0] || 1;
            for (; b--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
            return !0;
          }
          selectProtected(o) {
            const b = o.params[0];
            return b === 1 && (this._curAttrData.bg |= 536870912), b !== 2 && b !== 0 || (this._curAttrData.bg &= -536870913), !0;
          }
          _eraseInBufferLine(o, b, g, S = !1, A = !1) {
            const D = this._activeBuffer.lines.get(this._activeBuffer.ybase + o);
            D.replaceCells(b, g, this._activeBuffer.getNullCell(this._eraseAttrData()), A), S && (D.isWrapped = !1);
          }
          _resetBufferLine(o, b = !1) {
            const g = this._activeBuffer.lines.get(this._activeBuffer.ybase + o);
            g && (g.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), b), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + o), g.isWrapped = !1);
          }
          eraseInDisplay(o, b = !1) {
            let g;
            switch (this._restrictCursor(this._bufferService.cols), o.params[0]) {
              case 0:
                for (g = this._activeBuffer.y, this._dirtyRowTracker.markDirty(g), this._eraseInBufferLine(g++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, b); g < this._bufferService.rows; g++) this._resetBufferLine(g, b);
                this._dirtyRowTracker.markDirty(g);
                break;
              case 1:
                for (g = this._activeBuffer.y, this._dirtyRowTracker.markDirty(g), this._eraseInBufferLine(g, 0, this._activeBuffer.x + 1, !0, b), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(g + 1).isWrapped = !1); g--; ) this._resetBufferLine(g, b);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 2:
                for (g = this._bufferService.rows, this._dirtyRowTracker.markDirty(g - 1); g--; ) this._resetBufferLine(g, b);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 3:
                const S = this._activeBuffer.lines.length - this._bufferService.rows;
                S > 0 && (this._activeBuffer.lines.trimStart(S), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - S, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - S, 0), this._onScroll.fire(0));
            }
            return !0;
          }
          eraseInLine(o, b = !1) {
            switch (this._restrictCursor(this._bufferService.cols), o.params[0]) {
              case 0:
                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, b);
                break;
              case 1:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, b);
                break;
              case 2:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, b);
            }
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), !0;
          }
          insertLines(o) {
            this._restrictCursor();
            let b = o.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const g = this._activeBuffer.ybase + this._activeBuffer.y, S = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, A = this._bufferService.rows - 1 + this._activeBuffer.ybase - S + 1;
            for (; b--; ) this._activeBuffer.lines.splice(A - 1, 1), this._activeBuffer.lines.splice(g, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          deleteLines(o) {
            this._restrictCursor();
            let b = o.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const g = this._activeBuffer.ybase + this._activeBuffer.y;
            let S;
            for (S = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, S = this._bufferService.rows - 1 + this._activeBuffer.ybase - S; b--; ) this._activeBuffer.lines.splice(g, 1), this._activeBuffer.lines.splice(S, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;
          }
          insertChars(o) {
            this._restrictCursor();
            const b = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return b && (b.insertCells(this._activeBuffer.x, o.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          deleteChars(o) {
            this._restrictCursor();
            const b = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return b && (b.deleteCells(this._activeBuffer.x, o.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          scrollUp(o) {
            let b = o.params[0] || 1;
            for (; b--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollDown(o) {
            let b = o.params[0] || 1;
            for (; b--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(e.DEFAULT_ATTR_DATA));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollLeft(o) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const b = o.params[0] || 1;
            for (let g = this._activeBuffer.scrollTop; g <= this._activeBuffer.scrollBottom; ++g) {
              const S = this._activeBuffer.lines.get(this._activeBuffer.ybase + g);
              S.deleteCells(0, b, this._activeBuffer.getNullCell(this._eraseAttrData())), S.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          scrollRight(o) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const b = o.params[0] || 1;
            for (let g = this._activeBuffer.scrollTop; g <= this._activeBuffer.scrollBottom; ++g) {
              const S = this._activeBuffer.lines.get(this._activeBuffer.ybase + g);
              S.insertCells(0, b, this._activeBuffer.getNullCell(this._eraseAttrData())), S.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          insertColumns(o) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const b = o.params[0] || 1;
            for (let g = this._activeBuffer.scrollTop; g <= this._activeBuffer.scrollBottom; ++g) {
              const S = this._activeBuffer.lines.get(this._activeBuffer.ybase + g);
              S.insertCells(this._activeBuffer.x, b, this._activeBuffer.getNullCell(this._eraseAttrData())), S.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          deleteColumns(o) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;
            const b = o.params[0] || 1;
            for (let g = this._activeBuffer.scrollTop; g <= this._activeBuffer.scrollBottom; ++g) {
              const S = this._activeBuffer.lines.get(this._activeBuffer.ybase + g);
              S.deleteCells(this._activeBuffer.x, b, this._activeBuffer.getNullCell(this._eraseAttrData())), S.isWrapped = !1;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;
          }
          eraseChars(o) {
            this._restrictCursor();
            const b = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return b && (b.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (o.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), !0;
          }
          repeatPrecedingCharacter(o) {
            const b = this._parser.precedingJoinState;
            if (!b) return !0;
            const g = o.params[0] || 1, S = m.UnicodeService.extractWidth(b), A = this._activeBuffer.x - S, D = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(A), R = new Uint32Array(D.length * g);
            let I = 0;
            for (let v = 0; v < D.length; ) {
              const H = D.codePointAt(v) || 0;
              R[I++] = H, v += H > 65535 ? 2 : 1;
            }
            let $ = I;
            for (let v = 1; v < g; ++v) R.copyWithin($, 0, I), $ += I;
            return this.print(R, 0, $), !0;
          }
          sendDeviceAttributesPrimary(o) {
            return o.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), !0;
          }
          sendDeviceAttributesSecondary(o) {
            return o.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(o.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), !0;
          }
          _is(o) {
            return (this._optionsService.rawOptions.termName + "").indexOf(o) === 0;
          }
          setMode(o) {
            for (let b = 0; b < o.length; b++) switch (o.params[b]) {
              case 4:
                this._coreService.modes.insertMode = !0;
                break;
              case 20:
                this._optionsService.options.convertEol = !0;
            }
            return !0;
          }
          setModePrivate(o) {
            for (let b = 0; b < o.length; b++) switch (o.params[b]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = !0;
                break;
              case 2:
                this._charsetService.setgCharset(0, c.DEFAULT_CHARSET), this._charsetService.setgCharset(1, c.DEFAULT_CHARSET), this._charsetService.setgCharset(2, c.DEFAULT_CHARSET), this._charsetService.setgCharset(3, c.DEFAULT_CHARSET);
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = !0;
                break;
              case 12:
                this._optionsService.options.cursorBlink = !0;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = !0;
                break;
              case 66:
                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
                this._coreMouseService.activeProtocol = "X10";
                break;
              case 1e3:
                this._coreMouseService.activeProtocol = "VT200";
                break;
              case 1002:
                this._coreMouseService.activeProtocol = "DRAG";
                break;
              case 1003:
                this._coreMouseService.activeProtocol = "ANY";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();
                break;
              case 1005:
                this._logService.debug("DECSET 1005 not supported (see #2507)");
                break;
              case 1006:
                this._coreMouseService.activeEncoding = "SGR";
                break;
              case 1015:
                this._logService.debug("DECSET 1015 not supported (see #2507)");
                break;
              case 1016:
                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                break;
              case 25:
                this._coreService.isCursorHidden = !1;
                break;
              case 1048:
                this.saveCursor();
                break;
              case 1049:
                this.saveCursor();
              case 47:
              case 1047:
                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = !0;
            }
            return !0;
          }
          resetMode(o) {
            for (let b = 0; b < o.length; b++) switch (o.params[b]) {
              case 4:
                this._coreService.modes.insertMode = !1;
                break;
              case 20:
                this._optionsService.options.convertEol = !1;
            }
            return !0;
          }
          resetModePrivate(o) {
            for (let b = 0; b < o.length; b++) switch (o.params[b]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = !1;
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = !1;
                break;
              case 12:
                this._optionsService.options.cursorBlink = !1;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = !1;
                break;
              case 66:
                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
              case 1e3:
              case 1002:
              case 1003:
                this._coreMouseService.activeProtocol = "NONE";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = !1;
                break;
              case 1005:
                this._logService.debug("DECRST 1005 not supported (see #2507)");
                break;
              case 1006:
              case 1016:
                this._coreMouseService.activeEncoding = "DEFAULT";
                break;
              case 1015:
                this._logService.debug("DECRST 1015 not supported (see #2507)");
                break;
              case 25:
                this._coreService.isCursorHidden = !0;
                break;
              case 1048:
                this.restoreCursor();
                break;
              case 1049:
              case 47:
              case 1047:
                this._bufferService.buffers.activateNormalBuffer(), o.params[b] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = !1;
            }
            return !0;
          }
          requestMode(o, b) {
            const g = this._coreService.decPrivateModes, { activeProtocol: S, activeEncoding: A } = this._coreMouseService, D = this._coreService, { buffers: R, cols: I } = this._bufferService, { active: $, alt: v } = R, H = this._optionsService.rawOptions, k = (ee) => ee ? 1 : 2, P = o.params[0];
            return J = P, Q = b ? P === 2 ? 4 : P === 4 ? k(D.modes.insertMode) : P === 12 ? 3 : P === 20 ? k(H.convertEol) : 0 : P === 1 ? k(g.applicationCursorKeys) : P === 3 ? H.windowOptions.setWinLines ? I === 80 ? 2 : I === 132 ? 1 : 0 : 0 : P === 6 ? k(g.origin) : P === 7 ? k(g.wraparound) : P === 8 ? 3 : P === 9 ? k(S === "X10") : P === 12 ? k(H.cursorBlink) : P === 25 ? k(!D.isCursorHidden) : P === 45 ? k(g.reverseWraparound) : P === 66 ? k(g.applicationKeypad) : P === 67 ? 4 : P === 1e3 ? k(S === "VT200") : P === 1002 ? k(S === "DRAG") : P === 1003 ? k(S === "ANY") : P === 1004 ? k(g.sendFocus) : P === 1005 ? 4 : P === 1006 ? k(A === "SGR") : P === 1015 ? 4 : P === 1016 ? k(A === "SGR_PIXELS") : P === 1048 ? 1 : P === 47 || P === 1047 || P === 1049 ? k($ === v) : P === 2004 ? k(g.bracketedPasteMode) : 0, D.triggerDataEvent(`${n.C0.ESC}[${b ? "" : "?"}${J};${Q}$y`), !0;
            var J, Q;
          }
          _updateAttrColor(o, b, g, S, A) {
            return b === 2 ? (o |= 50331648, o &= -16777216, o |= f.AttributeData.fromColorRGB([g, S, A])) : b === 5 && (o &= -50331904, o |= 33554432 | 255 & g), o;
          }
          _extractColor(o, b, g) {
            const S = [0, 0, -1, 0, 0, 0];
            let A = 0, D = 0;
            do {
              if (S[D + A] = o.params[b + D], o.hasSubParams(b + D)) {
                const R = o.getSubParams(b + D);
                let I = 0;
                do
                  S[1] === 5 && (A = 1), S[D + I + 1 + A] = R[I];
                while (++I < R.length && I + D + 1 + A < S.length);
                break;
              }
              if (S[1] === 5 && D + A >= 2 || S[1] === 2 && D + A >= 5) break;
              S[1] && (A = 1);
            } while (++D + b < o.length && D + A < S.length);
            for (let R = 2; R < S.length; ++R) S[R] === -1 && (S[R] = 0);
            switch (S[0]) {
              case 38:
                g.fg = this._updateAttrColor(g.fg, S[1], S[3], S[4], S[5]);
                break;
              case 48:
                g.bg = this._updateAttrColor(g.bg, S[1], S[3], S[4], S[5]);
                break;
              case 58:
                g.extended = g.extended.clone(), g.extended.underlineColor = this._updateAttrColor(g.extended.underlineColor, S[1], S[3], S[4], S[5]);
            }
            return D;
          }
          _processUnderline(o, b) {
            b.extended = b.extended.clone(), (!~o || o > 5) && (o = 1), b.extended.underlineStyle = o, b.fg |= 268435456, o === 0 && (b.fg &= -268435457), b.updateExtended();
          }
          _processSGR0(o) {
            o.fg = e.DEFAULT_ATTR_DATA.fg, o.bg = e.DEFAULT_ATTR_DATA.bg, o.extended = o.extended.clone(), o.extended.underlineStyle = 0, o.extended.underlineColor &= -67108864, o.updateExtended();
          }
          charAttributes(o) {
            if (o.length === 1 && o.params[0] === 0) return this._processSGR0(this._curAttrData), !0;
            const b = o.length;
            let g;
            const S = this._curAttrData;
            for (let A = 0; A < b; A++) g = o.params[A], g >= 30 && g <= 37 ? (S.fg &= -50331904, S.fg |= 16777216 | g - 30) : g >= 40 && g <= 47 ? (S.bg &= -50331904, S.bg |= 16777216 | g - 40) : g >= 90 && g <= 97 ? (S.fg &= -50331904, S.fg |= 16777224 | g - 90) : g >= 100 && g <= 107 ? (S.bg &= -50331904, S.bg |= 16777224 | g - 100) : g === 0 ? this._processSGR0(S) : g === 1 ? S.fg |= 134217728 : g === 3 ? S.bg |= 67108864 : g === 4 ? (S.fg |= 268435456, this._processUnderline(o.hasSubParams(A) ? o.getSubParams(A)[0] : 1, S)) : g === 5 ? S.fg |= 536870912 : g === 7 ? S.fg |= 67108864 : g === 8 ? S.fg |= 1073741824 : g === 9 ? S.fg |= 2147483648 : g === 2 ? S.bg |= 134217728 : g === 21 ? this._processUnderline(2, S) : g === 22 ? (S.fg &= -134217729, S.bg &= -134217729) : g === 23 ? S.bg &= -67108865 : g === 24 ? (S.fg &= -268435457, this._processUnderline(0, S)) : g === 25 ? S.fg &= -536870913 : g === 27 ? S.fg &= -67108865 : g === 28 ? S.fg &= -1073741825 : g === 29 ? S.fg &= 2147483647 : g === 39 ? (S.fg &= -67108864, S.fg |= 16777215 & e.DEFAULT_ATTR_DATA.fg) : g === 49 ? (S.bg &= -67108864, S.bg |= 16777215 & e.DEFAULT_ATTR_DATA.bg) : g === 38 || g === 48 || g === 58 ? A += this._extractColor(o, A, S) : g === 53 ? S.bg |= 1073741824 : g === 55 ? S.bg &= -1073741825 : g === 59 ? (S.extended = S.extended.clone(), S.extended.underlineColor = -1, S.updateExtended()) : g === 100 ? (S.fg &= -67108864, S.fg |= 16777215 & e.DEFAULT_ATTR_DATA.fg, S.bg &= -67108864, S.bg |= 16777215 & e.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", g);
            return !0;
          }
          deviceStatus(o) {
            switch (o.params[0]) {
              case 5:
                this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
                break;
              case 6:
                const b = this._activeBuffer.y + 1, g = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${n.C0.ESC}[${b};${g}R`);
            }
            return !0;
          }
          deviceStatusPrivate(o) {
            if (o.params[0] === 6) {
              const b = this._activeBuffer.y + 1, g = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${n.C0.ESC}[?${b};${g}R`);
            }
            return !0;
          }
          softReset(o) {
            return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;
          }
          setCursorStyle(o) {
            const b = o.params[0] || 1;
            switch (b) {
              case 1:
              case 2:
                this._optionsService.options.cursorStyle = "block";
                break;
              case 3:
              case 4:
                this._optionsService.options.cursorStyle = "underline";
                break;
              case 5:
              case 6:
                this._optionsService.options.cursorStyle = "bar";
            }
            const g = b % 2 == 1;
            return this._optionsService.options.cursorBlink = g, !0;
          }
          setScrollRegion(o) {
            const b = o.params[0] || 1;
            let g;
            return (o.length < 2 || (g = o.params[1]) > this._bufferService.rows || g === 0) && (g = this._bufferService.rows), g > b && (this._activeBuffer.scrollTop = b - 1, this._activeBuffer.scrollBottom = g - 1, this._setCursor(0, 0)), !0;
          }
          windowOptions(o) {
            if (!w(o.params[0], this._optionsService.rawOptions.windowOptions)) return !0;
            const b = o.length > 1 ? o.params[1] : 0;
            switch (o.params[0]) {
              case 14:
                b !== 2 && this._onRequestWindowsOptionsReport.fire(L.GET_WIN_SIZE_PIXELS);
                break;
              case 16:
                this._onRequestWindowsOptionsReport.fire(L.GET_CELL_SIZE_PIXELS);
                break;
              case 18:
                this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                break;
              case 22:
                b !== 0 && b !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), b !== 0 && b !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                break;
              case 23:
                b !== 0 && b !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), b !== 0 && b !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
            }
            return !0;
          }
          saveCursor(o) {
            return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;
          }
          restoreCursor(o) {
            return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;
          }
          setTitle(o) {
            return this._windowTitle = o, this._onTitleChange.fire(o), !0;
          }
          setIconName(o) {
            return this._iconName = o, !0;
          }
          setOrReportIndexedColor(o) {
            const b = [], g = o.split(";");
            for (; g.length > 1; ) {
              const S = g.shift(), A = g.shift();
              if (/^\d+$/.exec(S)) {
                const D = parseInt(S);
                if (N(D)) if (A === "?") b.push({ type: 0, index: D });
                else {
                  const R = (0, T.parseColor)(A);
                  R && b.push({ type: 1, index: D, color: R });
                }
              }
            }
            return b.length && this._onColor.fire(b), !0;
          }
          setHyperlink(o) {
            const b = o.split(";");
            return !(b.length < 2) && (b[1] ? this._createHyperlink(b[0], b[1]) : !b[0] && this._finishHyperlink());
          }
          _createHyperlink(o, b) {
            this._getCurrentLinkId() && this._finishHyperlink();
            const g = o.split(":");
            let S;
            const A = g.findIndex((D) => D.startsWith("id="));
            return A !== -1 && (S = g[A].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: S, uri: b }), this._curAttrData.updateExtended(), !0;
          }
          _finishHyperlink() {
            return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), !0;
          }
          _setOrReportSpecialColor(o, b) {
            const g = o.split(";");
            for (let S = 0; S < g.length && !(b >= this._specialColors.length); ++S, ++b) if (g[S] === "?") this._onColor.fire([{ type: 0, index: this._specialColors[b] }]);
            else {
              const A = (0, T.parseColor)(g[S]);
              A && this._onColor.fire([{ type: 1, index: this._specialColors[b], color: A }]);
            }
            return !0;
          }
          setOrReportFgColor(o) {
            return this._setOrReportSpecialColor(o, 0);
          }
          setOrReportBgColor(o) {
            return this._setOrReportSpecialColor(o, 1);
          }
          setOrReportCursorColor(o) {
            return this._setOrReportSpecialColor(o, 2);
          }
          restoreIndexedColor(o) {
            if (!o) return this._onColor.fire([{ type: 2 }]), !0;
            const b = [], g = o.split(";");
            for (let S = 0; S < g.length; ++S) if (/^\d+$/.exec(g[S])) {
              const A = parseInt(g[S]);
              N(A) && b.push({ type: 2, index: A });
            }
            return b.length && this._onColor.fire(b), !0;
          }
          restoreFgColor(o) {
            return this._onColor.fire([{ type: 2, index: 256 }]), !0;
          }
          restoreBgColor(o) {
            return this._onColor.fire([{ type: 2, index: 257 }]), !0;
          }
          restoreCursorColor(o) {
            return this._onColor.fire([{ type: 2, index: 258 }]), !0;
          }
          nextLine() {
            return this._activeBuffer.x = 0, this.index(), !0;
          }
          keypadApplicationMode() {
            return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;
          }
          keypadNumericMode() {
            return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;
          }
          selectDefaultCharset() {
            return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, c.DEFAULT_CHARSET), !0;
          }
          selectCharset(o) {
            return o.length !== 2 ? (this.selectDefaultCharset(), !0) : (o[0] === "/" || this._charsetService.setgCharset(F[o[0]], c.CHARSETS[o[1]] || c.DEFAULT_CHARSET), !0);
          }
          index() {
            return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;
          }
          tabSet() {
            return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;
          }
          reverseIndex() {
            if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
              const o = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
              this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, o, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
            } else this._activeBuffer.y--, this._restrictCursor();
            return !0;
          }
          fullReset() {
            return this._parser.reset(), this._onRequestReset.fire(), !0;
          }
          reset() {
            this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = e.DEFAULT_ATTR_DATA.clone();
          }
          _eraseAttrData() {
            return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
          }
          setgLevel(o) {
            return this._charsetService.setgLevel(o), !0;
          }
          screenAlignmentPattern() {
            const o = new t.CellData();
            o.content = 4194373, o.fg = this._curAttrData.fg, o.bg = this._curAttrData.bg, this._setCursor(0, 0);
            for (let b = 0; b < this._bufferService.rows; ++b) {
              const g = this._activeBuffer.ybase + this._activeBuffer.y + b, S = this._activeBuffer.lines.get(g);
              S && (S.fill(o), S.isWrapped = !1);
            }
            return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), !0;
          }
          requestStatusString(o, b) {
            const g = this._bufferService.buffer, S = this._optionsService.rawOptions;
            return ((A) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${A}${n.C0.ESC}\\`), !0))(o === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : o === '"p' ? 'P1$r61;1"p' : o === "r" ? `P1$r${g.scrollTop + 1};${g.scrollBottom + 1}r` : o === "m" ? "P1$r0m" : o === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[S.cursorStyle] - (S.cursorBlink ? 1 : 0)} q` : "P0$r");
          }
          markRangeDirty(o, b) {
            this._dirtyRowTracker.markRangeDirty(o, b);
          }
        }
        i.InputHandler = z;
        let M = class {
          constructor(x) {
            this._bufferService = x, this.clearRange();
          }
          clearRange() {
            this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
          }
          markDirty(x) {
            x < this.start ? this.start = x : x > this.end && (this.end = x);
          }
          markRangeDirty(x, o) {
            x > o && (G = x, x = o, o = G), x < this.start && (this.start = x), o > this.end && (this.end = o);
          }
          markAllDirty() {
            this.markRangeDirty(0, this._bufferService.rows - 1);
          }
        };
        function N(x) {
          return 0 <= x && x < 256;
        }
        M = _([d(0, p.IBufferService)], M);
      }, 844: (B, i) => {
        function l(_) {
          for (const d of _) d.dispose();
          _.length = 0;
        }
        Object.defineProperty(i, "__esModule", { value: !0 }), i.getDisposeArrayDisposable = i.disposeArray = i.toDisposable = i.MutableDisposable = i.Disposable = void 0, i.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = !1;
          }
          dispose() {
            this._isDisposed = !0;
            for (const _ of this._disposables) _.dispose();
            this._disposables.length = 0;
          }
          register(_) {
            return this._disposables.push(_), _;
          }
          unregister(_) {
            const d = this._disposables.indexOf(_);
            d !== -1 && this._disposables.splice(d, 1);
          }
        }, i.MutableDisposable = class {
          constructor() {
            this._isDisposed = !1;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(_) {
            this._isDisposed || _ === this._value || (this._value?.dispose(), this._value = _);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            this._isDisposed = !0, this._value?.dispose(), this._value = void 0;
          }
        }, i.toDisposable = function(_) {
          return { dispose: _ };
        }, i.disposeArray = l, i.getDisposeArrayDisposable = function(_) {
          return { dispose: () => l(_) };
        };
      }, 114: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.isChromeOS = i.isLinux = i.isWindows = i.isIphone = i.isIpad = i.isMac = i.getSafariVersion = i.isSafari = i.isLegacyEdge = i.isFirefox = i.isNode = void 0, i.isNode = typeof process < "u" && "title" in process;
        const l = i.isNode ? "node" : navigator.userAgent, _ = i.isNode ? "node" : navigator.platform;
        i.isFirefox = l.includes("Firefox"), i.isLegacyEdge = l.includes("Edge"), i.isSafari = /^((?!chrome|android).)*safari/i.test(l), i.getSafariVersion = function() {
          if (!i.isSafari) return 0;
          const d = l.match(/Version\/(\d+)/);
          return d === null || d.length < 2 ? 0 : parseInt(d[1]);
        }, i.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(_), i.isIpad = _ === "iPad", i.isIphone = _ === "iPhone", i.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(_), i.isLinux = _.indexOf("Linux") >= 0, i.isChromeOS = /\bCrOS\b/.test(l);
      }, 226: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.DebouncedIdleTask = i.IdleTaskQueue = i.PriorityTaskQueue = void 0;
        const _ = l(114);
        class d {
          constructor() {
            this._tasks = [], this._i = 0;
          }
          enqueue(a) {
            this._tasks.push(a), this._start();
          }
          flush() {
            for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
            this.clear();
          }
          clear() {
            this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
          }
          _start() {
            this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
          }
          _process(a) {
            this._idleCallback = void 0;
            let h = 0, u = 0, e = a.timeRemaining(), s = 0;
            for (; this._i < this._tasks.length; ) {
              if (h = Date.now(), this._tasks[this._i]() || this._i++, h = Math.max(1, Date.now() - h), u = Math.max(h, u), s = a.timeRemaining(), 1.5 * u > s) return e - h < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(e - h))}ms`), void this._start();
              e = s;
            }
            this.clear();
          }
        }
        class n extends d {
          _requestCallback(a) {
            return setTimeout(() => a(this._createDeadline(16)));
          }
          _cancelCallback(a) {
            clearTimeout(a);
          }
          _createDeadline(a) {
            const h = Date.now() + a;
            return { timeRemaining: () => Math.max(0, h - Date.now()) };
          }
        }
        i.PriorityTaskQueue = n, i.IdleTaskQueue = !_.isNode && "requestIdleCallback" in window ? class extends d {
          _requestCallback(c) {
            return requestIdleCallback(c);
          }
          _cancelCallback(c) {
            cancelIdleCallback(c);
          }
        } : n, i.DebouncedIdleTask = class {
          constructor() {
            this._queue = new i.IdleTaskQueue();
          }
          set(c) {
            this._queue.clear(), this._queue.enqueue(c);
          }
          flush() {
            this._queue.flush();
          }
        };
      }, 282: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.updateWindowsModeWrappedState = void 0;
        const _ = l(643);
        i.updateWindowsModeWrappedState = function(d) {
          const n = d.buffer.lines.get(d.buffer.ybase + d.buffer.y - 1), c = n?.get(d.cols - 1), a = d.buffer.lines.get(d.buffer.ybase + d.buffer.y);
          a && c && (a.isWrapped = c[_.CHAR_DATA_CODE_INDEX] !== _.NULL_CELL_CODE && c[_.CHAR_DATA_CODE_INDEX] !== _.WHITESPACE_CELL_CODE);
        };
      }, 734: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.ExtendedAttrs = i.AttributeData = void 0;
        class l {
          constructor() {
            this.fg = 0, this.bg = 0, this.extended = new _();
          }
          static toColorRGB(n) {
            return [n >>> 16 & 255, n >>> 8 & 255, 255 & n];
          }
          static fromColorRGB(n) {
            return (255 & n[0]) << 16 | (255 & n[1]) << 8 | 255 & n[2];
          }
          clone() {
            const n = new l();
            return n.fg = this.fg, n.bg = this.bg, n.extended = this.extended.clone(), n;
          }
          isInverse() {
            return 67108864 & this.fg;
          }
          isBold() {
            return 134217728 & this.fg;
          }
          isUnderline() {
            return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
          }
          isBlink() {
            return 536870912 & this.fg;
          }
          isInvisible() {
            return 1073741824 & this.fg;
          }
          isItalic() {
            return 67108864 & this.bg;
          }
          isDim() {
            return 134217728 & this.bg;
          }
          isStrikethrough() {
            return 2147483648 & this.fg;
          }
          isProtected() {
            return 536870912 & this.bg;
          }
          isOverline() {
            return 1073741824 & this.bg;
          }
          getFgColorMode() {
            return 50331648 & this.fg;
          }
          getBgColorMode() {
            return 50331648 & this.bg;
          }
          isFgRGB() {
            return (50331648 & this.fg) == 50331648;
          }
          isBgRGB() {
            return (50331648 & this.bg) == 50331648;
          }
          isFgPalette() {
            return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
          }
          isBgPalette() {
            return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
          }
          isFgDefault() {
            return (50331648 & this.fg) == 0;
          }
          isBgDefault() {
            return (50331648 & this.bg) == 0;
          }
          isAttributeDefault() {
            return this.fg === 0 && this.bg === 0;
          }
          getFgColor() {
            switch (50331648 & this.fg) {
              case 16777216:
              case 33554432:
                return 255 & this.fg;
              case 50331648:
                return 16777215 & this.fg;
              default:
                return -1;
            }
          }
          getBgColor() {
            switch (50331648 & this.bg) {
              case 16777216:
              case 33554432:
                return 255 & this.bg;
              case 50331648:
                return 16777215 & this.bg;
              default:
                return -1;
            }
          }
          hasExtendedAttrs() {
            return 268435456 & this.bg;
          }
          updateExtended() {
            this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
          }
          getUnderlineColor() {
            if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
            return this.getFgColor();
          }
          getUnderlineColorMode() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
          }
          isUnderlineColorRGB() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
          }
          isUnderlineColorPalette() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
          }
          isUnderlineColorDefault() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
          }
          getUnderlineStyle() {
            return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
          }
          getUnderlineVariantOffset() {
            return this.extended.underlineVariantOffset;
          }
        }
        i.AttributeData = l;
        class _ {
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(n) {
            this._ext = n;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(n) {
            this._ext &= -469762049, this._ext |= n << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(n) {
            this._ext &= -67108864, this._ext |= 67108863 & n;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(n) {
            this._urlId = n;
          }
          get underlineVariantOffset() {
            const n = (3758096384 & this._ext) >> 29;
            return n < 0 ? 4294967288 ^ n : n;
          }
          set underlineVariantOffset(n) {
            this._ext &= 536870911, this._ext |= n << 29 & 3758096384;
          }
          constructor(n = 0, c = 0) {
            this._ext = 0, this._urlId = 0, this._ext = n, this._urlId = c;
          }
          clone() {
            return new _(this._ext, this._urlId);
          }
          isEmpty() {
            return this.underlineStyle === 0 && this._urlId === 0;
          }
        }
        i.ExtendedAttrs = _;
      }, 92: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.Buffer = i.MAX_BUFFER_SIZE = void 0;
        const _ = l(349), d = l(226), n = l(734), c = l(437), a = l(634), h = l(511), u = l(643), e = l(863), s = l(116);
        i.MAX_BUFFER_SIZE = 4294967295, i.Buffer = class {
          constructor(r, t, f) {
            this._hasScrollback = r, this._optionsService = t, this._bufferService = f, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = c.DEFAULT_ATTR_DATA.clone(), this.savedCharset = s.DEFAULT_CHARSET, this.markers = [], this._nullCell = h.CellData.fromCharData([0, u.NULL_CELL_CHAR, u.NULL_CELL_WIDTH, u.NULL_CELL_CODE]), this._whitespaceCell = h.CellData.fromCharData([0, u.WHITESPACE_CELL_CHAR, u.WHITESPACE_CELL_WIDTH, u.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._memoryCleanupQueue = new d.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new _.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          getNullCell(r) {
            return r ? (this._nullCell.fg = r.fg, this._nullCell.bg = r.bg, this._nullCell.extended = r.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs()), this._nullCell;
          }
          getWhitespaceCell(r) {
            return r ? (this._whitespaceCell.fg = r.fg, this._whitespaceCell.bg = r.bg, this._whitespaceCell.extended = r.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs()), this._whitespaceCell;
          }
          getBlankLine(r, t) {
            return new c.BufferLine(this._bufferService.cols, this.getNullCell(r), t);
          }
          get hasScrollback() {
            return this._hasScrollback && this.lines.maxLength > this._rows;
          }
          get isCursorInViewport() {
            const r = this.ybase + this.y - this.ydisp;
            return r >= 0 && r < this._rows;
          }
          _getCorrectBufferLength(r) {
            if (!this._hasScrollback) return r;
            const t = r + this._optionsService.rawOptions.scrollback;
            return t > i.MAX_BUFFER_SIZE ? i.MAX_BUFFER_SIZE : t;
          }
          fillViewportRows(r) {
            if (this.lines.length === 0) {
              r === void 0 && (r = c.DEFAULT_ATTR_DATA);
              let t = this._rows;
              for (; t--; ) this.lines.push(this.getBlankLine(r));
            }
          }
          clear() {
            this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new _.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          resize(r, t) {
            const f = this.getNullCell(c.DEFAULT_ATTR_DATA);
            let p = 0;
            const m = this._getCorrectBufferLength(t);
            if (m > this.lines.maxLength && (this.lines.maxLength = m), this.lines.length > 0) {
              if (this._cols < r) for (let C = 0; C < this.lines.length; C++) p += +this.lines.get(C).resize(r, f);
              let y = 0;
              if (this._rows < t) for (let C = this._rows; C < t; C++) this.lines.length < t + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new c.BufferLine(r, f)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + y + 1 ? (this.ybase--, y++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new c.BufferLine(r, f)));
              else for (let C = this._rows; C > t; C--) this.lines.length > t + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
              if (m < this.lines.maxLength) {
                const C = this.lines.length - m;
                C > 0 && (this.lines.trimStart(C), this.ybase = Math.max(this.ybase - C, 0), this.ydisp = Math.max(this.ydisp - C, 0), this.savedY = Math.max(this.savedY - C, 0)), this.lines.maxLength = m;
              }
              this.x = Math.min(this.x, r - 1), this.y = Math.min(this.y, t - 1), y && (this.y += y), this.savedX = Math.min(this.savedX, r - 1), this.scrollTop = 0;
            }
            if (this.scrollBottom = t - 1, this._isReflowEnabled && (this._reflow(r, t), this._cols > r)) for (let y = 0; y < this.lines.length; y++) p += +this.lines.get(y).resize(r, f);
            this._cols = r, this._rows = t, this._memoryCleanupQueue.clear(), p > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
          }
          _batchedMemoryCleanup() {
            let r = !0;
            this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, r = !1);
            let t = 0;
            for (; this._memoryCleanupPosition < this.lines.length; ) if (t += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t > 100) return !0;
            return r;
          }
          get _isReflowEnabled() {
            const r = this._optionsService.rawOptions.windowsPty;
            return r && r.buildNumber ? this._hasScrollback && r.backend === "conpty" && r.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
          }
          _reflow(r, t) {
            this._cols !== r && (r > this._cols ? this._reflowLarger(r, t) : this._reflowSmaller(r, t));
          }
          _reflowLarger(r, t) {
            const f = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, r, this.ybase + this.y, this.getNullCell(c.DEFAULT_ATTR_DATA));
            if (f.length > 0) {
              const p = (0, a.reflowLargerCreateNewLayout)(this.lines, f);
              (0, a.reflowLargerApplyNewLayout)(this.lines, p.layout), this._reflowLargerAdjustViewport(r, t, p.countRemoved);
            }
          }
          _reflowLargerAdjustViewport(r, t, f) {
            const p = this.getNullCell(c.DEFAULT_ATTR_DATA);
            let m = f;
            for (; m-- > 0; ) this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < t && this.lines.push(new c.BufferLine(r, p))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
            this.savedY = Math.max(this.savedY - f, 0);
          }
          _reflowSmaller(r, t) {
            const f = this.getNullCell(c.DEFAULT_ATTR_DATA), p = [];
            let m = 0;
            for (let y = this.lines.length - 1; y >= 0; y--) {
              let C = this.lines.get(y);
              if (!C || !C.isWrapped && C.getTrimmedLength() <= r) continue;
              const T = [C];
              for (; C.isWrapped && y > 0; ) C = this.lines.get(--y), T.unshift(C);
              const F = this.ybase + this.y;
              if (F >= y && F < y + T.length) continue;
              const E = T[T.length - 1].getTrimmedLength(), w = (0, a.reflowSmallerGetNewLineLengths)(T, this._cols, r), L = w.length - T.length;
              let G;
              G = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + L) : Math.max(0, this.lines.length - this.lines.maxLength + L);
              const z = [];
              for (let g = 0; g < L; g++) {
                const S = this.getBlankLine(c.DEFAULT_ATTR_DATA, !0);
                z.push(S);
              }
              z.length > 0 && (p.push({ start: y + T.length + m, newLines: z }), m += z.length), T.push(...z);
              let M = w.length - 1, N = w[M];
              N === 0 && (M--, N = w[M]);
              let x = T.length - L - 1, o = E;
              for (; x >= 0; ) {
                const g = Math.min(o, N);
                if (T[M] === void 0) break;
                if (T[M].copyCellsFrom(T[x], o - g, N - g, g, !0), N -= g, N === 0 && (M--, N = w[M]), o -= g, o === 0) {
                  x--;
                  const S = Math.max(x, 0);
                  o = (0, a.getWrappedLineTrimmedLength)(T, S, this._cols);
                }
              }
              for (let g = 0; g < T.length; g++) w[g] < r && T[g].setCell(w[g], f);
              let b = L - G;
              for (; b-- > 0; ) this.ybase === 0 ? this.y < t - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + m) - t && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
              this.savedY = Math.min(this.savedY + L, this.ybase + t - 1);
            }
            if (p.length > 0) {
              const y = [], C = [];
              for (let M = 0; M < this.lines.length; M++) C.push(this.lines.get(M));
              const T = this.lines.length;
              let F = T - 1, E = 0, w = p[E];
              this.lines.length = Math.min(this.lines.maxLength, this.lines.length + m);
              let L = 0;
              for (let M = Math.min(this.lines.maxLength - 1, T + m - 1); M >= 0; M--) if (w && w.start > F + L) {
                for (let N = w.newLines.length - 1; N >= 0; N--) this.lines.set(M--, w.newLines[N]);
                M++, y.push({ index: F + 1, amount: w.newLines.length }), L += w.newLines.length, w = p[++E];
              } else this.lines.set(M, C[F--]);
              let G = 0;
              for (let M = y.length - 1; M >= 0; M--) y[M].index += G, this.lines.onInsertEmitter.fire(y[M]), G += y[M].amount;
              const z = Math.max(0, T + m - this.lines.maxLength);
              z > 0 && this.lines.onTrimEmitter.fire(z);
            }
          }
          translateBufferLineToString(r, t, f = 0, p) {
            const m = this.lines.get(r);
            return m ? m.translateToString(t, f, p) : "";
          }
          getWrappedRangeForLine(r) {
            let t = r, f = r;
            for (; t > 0 && this.lines.get(t).isWrapped; ) t--;
            for (; f + 1 < this.lines.length && this.lines.get(f + 1).isWrapped; ) f++;
            return { first: t, last: f };
          }
          setupTabStops(r) {
            for (r != null ? this.tabs[r] || (r = this.prevStop(r)) : (this.tabs = {}, r = 0); r < this._cols; r += this._optionsService.rawOptions.tabStopWidth) this.tabs[r] = !0;
          }
          prevStop(r) {
            for (r == null && (r = this.x); !this.tabs[--r] && r > 0; ) ;
            return r >= this._cols ? this._cols - 1 : r < 0 ? 0 : r;
          }
          nextStop(r) {
            for (r == null && (r = this.x); !this.tabs[++r] && r < this._cols; ) ;
            return r >= this._cols ? this._cols - 1 : r < 0 ? 0 : r;
          }
          clearMarkers(r) {
            this._isClearing = !0;
            for (let t = 0; t < this.markers.length; t++) this.markers[t].line === r && (this.markers[t].dispose(), this.markers.splice(t--, 1));
            this._isClearing = !1;
          }
          clearAllMarkers() {
            this._isClearing = !0;
            for (let r = 0; r < this.markers.length; r++) this.markers[r].dispose(), this.markers.splice(r--, 1);
            this._isClearing = !1;
          }
          addMarker(r) {
            const t = new e.Marker(r);
            return this.markers.push(t), t.register(this.lines.onTrim((f) => {
              t.line -= f, t.line < 0 && t.dispose();
            })), t.register(this.lines.onInsert((f) => {
              t.line >= f.index && (t.line += f.amount);
            })), t.register(this.lines.onDelete((f) => {
              t.line >= f.index && t.line < f.index + f.amount && t.dispose(), t.line > f.index && (t.line -= f.amount);
            })), t.register(t.onDispose(() => this._removeMarker(t))), t;
          }
          _removeMarker(r) {
            this._isClearing || this.markers.splice(this.markers.indexOf(r), 1);
          }
        };
      }, 437: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.BufferLine = i.DEFAULT_ATTR_DATA = void 0;
        const _ = l(734), d = l(511), n = l(643), c = l(482);
        i.DEFAULT_ATTR_DATA = Object.freeze(new _.AttributeData());
        let a = 0;
        class h {
          constructor(e, s, r = !1) {
            this.isWrapped = r, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e);
            const t = s || d.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]);
            for (let f = 0; f < e; ++f) this.setCell(f, t);
            this.length = e;
          }
          get(e) {
            const s = this._data[3 * e + 0], r = 2097151 & s;
            return [this._data[3 * e + 1], 2097152 & s ? this._combined[e] : r ? (0, c.stringFromCodePoint)(r) : "", s >> 22, 2097152 & s ? this._combined[e].charCodeAt(this._combined[e].length - 1) : r];
          }
          set(e, s) {
            this._data[3 * e + 1] = s[n.CHAR_DATA_ATTR_INDEX], s[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e] = s[1], this._data[3 * e + 0] = 2097152 | e | s[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e + 0] = s[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | s[n.CHAR_DATA_WIDTH_INDEX] << 22;
          }
          getWidth(e) {
            return this._data[3 * e + 0] >> 22;
          }
          hasWidth(e) {
            return 12582912 & this._data[3 * e + 0];
          }
          getFg(e) {
            return this._data[3 * e + 1];
          }
          getBg(e) {
            return this._data[3 * e + 2];
          }
          hasContent(e) {
            return 4194303 & this._data[3 * e + 0];
          }
          getCodePoint(e) {
            const s = this._data[3 * e + 0];
            return 2097152 & s ? this._combined[e].charCodeAt(this._combined[e].length - 1) : 2097151 & s;
          }
          isCombined(e) {
            return 2097152 & this._data[3 * e + 0];
          }
          getString(e) {
            const s = this._data[3 * e + 0];
            return 2097152 & s ? this._combined[e] : 2097151 & s ? (0, c.stringFromCodePoint)(2097151 & s) : "";
          }
          isProtected(e) {
            return 536870912 & this._data[3 * e + 2];
          }
          loadCell(e, s) {
            return a = 3 * e, s.content = this._data[a + 0], s.fg = this._data[a + 1], s.bg = this._data[a + 2], 2097152 & s.content && (s.combinedData = this._combined[e]), 268435456 & s.bg && (s.extended = this._extendedAttrs[e]), s;
          }
          setCell(e, s) {
            2097152 & s.content && (this._combined[e] = s.combinedData), 268435456 & s.bg && (this._extendedAttrs[e] = s.extended), this._data[3 * e + 0] = s.content, this._data[3 * e + 1] = s.fg, this._data[3 * e + 2] = s.bg;
          }
          setCellFromCodepoint(e, s, r, t) {
            268435456 & t.bg && (this._extendedAttrs[e] = t.extended), this._data[3 * e + 0] = s | r << 22, this._data[3 * e + 1] = t.fg, this._data[3 * e + 2] = t.bg;
          }
          addCodepointToCell(e, s, r) {
            let t = this._data[3 * e + 0];
            2097152 & t ? this._combined[e] += (0, c.stringFromCodePoint)(s) : 2097151 & t ? (this._combined[e] = (0, c.stringFromCodePoint)(2097151 & t) + (0, c.stringFromCodePoint)(s), t &= -2097152, t |= 2097152) : t = s | 4194304, r && (t &= -12582913, t |= r << 22), this._data[3 * e + 0] = t;
          }
          insertCells(e, s, r) {
            if ((e %= this.length) && this.getWidth(e - 1) === 2 && this.setCellFromCodepoint(e - 1, 0, 1, r), s < this.length - e) {
              const t = new d.CellData();
              for (let f = this.length - e - s - 1; f >= 0; --f) this.setCell(e + s + f, this.loadCell(e + f, t));
              for (let f = 0; f < s; ++f) this.setCell(e + f, r);
            } else for (let t = e; t < this.length; ++t) this.setCell(t, r);
            this.getWidth(this.length - 1) === 2 && this.setCellFromCodepoint(this.length - 1, 0, 1, r);
          }
          deleteCells(e, s, r) {
            if (e %= this.length, s < this.length - e) {
              const t = new d.CellData();
              for (let f = 0; f < this.length - e - s; ++f) this.setCell(e + f, this.loadCell(e + s + f, t));
              for (let f = this.length - s; f < this.length; ++f) this.setCell(f, r);
            } else for (let t = e; t < this.length; ++t) this.setCell(t, r);
            e && this.getWidth(e - 1) === 2 && this.setCellFromCodepoint(e - 1, 0, 1, r), this.getWidth(e) !== 0 || this.hasContent(e) || this.setCellFromCodepoint(e, 0, 1, r);
          }
          replaceCells(e, s, r, t = !1) {
            if (t) for (e && this.getWidth(e - 1) === 2 && !this.isProtected(e - 1) && this.setCellFromCodepoint(e - 1, 0, 1, r), s < this.length && this.getWidth(s - 1) === 2 && !this.isProtected(s) && this.setCellFromCodepoint(s, 0, 1, r); e < s && e < this.length; ) this.isProtected(e) || this.setCell(e, r), e++;
            else for (e && this.getWidth(e - 1) === 2 && this.setCellFromCodepoint(e - 1, 0, 1, r), s < this.length && this.getWidth(s - 1) === 2 && this.setCellFromCodepoint(s, 0, 1, r); e < s && e < this.length; ) this.setCell(e++, r);
          }
          resize(e, s) {
            if (e === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
            const r = 3 * e;
            if (e > this.length) {
              if (this._data.buffer.byteLength >= 4 * r) this._data = new Uint32Array(this._data.buffer, 0, r);
              else {
                const t = new Uint32Array(r);
                t.set(this._data), this._data = t;
              }
              for (let t = this.length; t < e; ++t) this.setCell(t, s);
            } else {
              this._data = this._data.subarray(0, r);
              const t = Object.keys(this._combined);
              for (let p = 0; p < t.length; p++) {
                const m = parseInt(t[p], 10);
                m >= e && delete this._combined[m];
              }
              const f = Object.keys(this._extendedAttrs);
              for (let p = 0; p < f.length; p++) {
                const m = parseInt(f[p], 10);
                m >= e && delete this._extendedAttrs[m];
              }
            }
            return this.length = e, 4 * r * 2 < this._data.buffer.byteLength;
          }
          cleanupMemory() {
            if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
              const e = new Uint32Array(this._data.length);
              return e.set(this._data), this._data = e, 1;
            }
            return 0;
          }
          fill(e, s = !1) {
            if (s) for (let r = 0; r < this.length; ++r) this.isProtected(r) || this.setCell(r, e);
            else {
              this._combined = {}, this._extendedAttrs = {};
              for (let r = 0; r < this.length; ++r) this.setCell(r, e);
            }
          }
          copyFrom(e) {
            this.length !== e.length ? this._data = new Uint32Array(e._data) : this._data.set(e._data), this.length = e.length, this._combined = {};
            for (const s in e._combined) this._combined[s] = e._combined[s];
            this._extendedAttrs = {};
            for (const s in e._extendedAttrs) this._extendedAttrs[s] = e._extendedAttrs[s];
            this.isWrapped = e.isWrapped;
          }
          clone() {
            const e = new h(0);
            e._data = new Uint32Array(this._data), e.length = this.length;
            for (const s in this._combined) e._combined[s] = this._combined[s];
            for (const s in this._extendedAttrs) e._extendedAttrs[s] = this._extendedAttrs[s];
            return e.isWrapped = this.isWrapped, e;
          }
          getTrimmedLength() {
            for (let e = this.length - 1; e >= 0; --e) if (4194303 & this._data[3 * e + 0]) return e + (this._data[3 * e + 0] >> 22);
            return 0;
          }
          getNoBgTrimmedLength() {
            for (let e = this.length - 1; e >= 0; --e) if (4194303 & this._data[3 * e + 0] || 50331648 & this._data[3 * e + 2]) return e + (this._data[3 * e + 0] >> 22);
            return 0;
          }
          copyCellsFrom(e, s, r, t, f) {
            const p = e._data;
            if (f) for (let y = t - 1; y >= 0; y--) {
              for (let C = 0; C < 3; C++) this._data[3 * (r + y) + C] = p[3 * (s + y) + C];
              268435456 & p[3 * (s + y) + 2] && (this._extendedAttrs[r + y] = e._extendedAttrs[s + y]);
            }
            else for (let y = 0; y < t; y++) {
              for (let C = 0; C < 3; C++) this._data[3 * (r + y) + C] = p[3 * (s + y) + C];
              268435456 & p[3 * (s + y) + 2] && (this._extendedAttrs[r + y] = e._extendedAttrs[s + y]);
            }
            const m = Object.keys(e._combined);
            for (let y = 0; y < m.length; y++) {
              const C = parseInt(m[y], 10);
              C >= s && (this._combined[C - s + r] = e._combined[C]);
            }
          }
          translateToString(e, s, r, t) {
            s = s ?? 0, r = r ?? this.length, e && (r = Math.min(r, this.getTrimmedLength())), t && (t.length = 0);
            let f = "";
            for (; s < r; ) {
              const p = this._data[3 * s + 0], m = 2097151 & p, y = 2097152 & p ? this._combined[s] : m ? (0, c.stringFromCodePoint)(m) : n.WHITESPACE_CELL_CHAR;
              if (f += y, t) for (let C = 0; C < y.length; ++C) t.push(s);
              s += p >> 22 || 1;
            }
            return t && t.push(s), f;
          }
        }
        i.BufferLine = h;
      }, 634: (B, i) => {
        function l(_, d, n) {
          if (d === _.length - 1) return _[d].getTrimmedLength();
          const c = !_[d].hasContent(n - 1) && _[d].getWidth(n - 1) === 1, a = _[d + 1].getWidth(0) === 2;
          return c && a ? n - 1 : n;
        }
        Object.defineProperty(i, "__esModule", { value: !0 }), i.getWrappedLineTrimmedLength = i.reflowSmallerGetNewLineLengths = i.reflowLargerApplyNewLayout = i.reflowLargerCreateNewLayout = i.reflowLargerGetLinesToRemove = void 0, i.reflowLargerGetLinesToRemove = function(_, d, n, c, a) {
          const h = [];
          for (let u = 0; u < _.length - 1; u++) {
            let e = u, s = _.get(++e);
            if (!s.isWrapped) continue;
            const r = [_.get(u)];
            for (; e < _.length && s.isWrapped; ) r.push(s), s = _.get(++e);
            if (c >= u && c < e) {
              u += r.length - 1;
              continue;
            }
            let t = 0, f = l(r, t, d), p = 1, m = 0;
            for (; p < r.length; ) {
              const C = l(r, p, d), T = C - m, F = n - f, E = Math.min(T, F);
              r[t].copyCellsFrom(r[p], m, f, E, !1), f += E, f === n && (t++, f = 0), m += E, m === C && (p++, m = 0), f === 0 && t !== 0 && r[t - 1].getWidth(n - 1) === 2 && (r[t].copyCellsFrom(r[t - 1], n - 1, f++, 1, !1), r[t - 1].setCell(n - 1, a));
            }
            r[t].replaceCells(f, n, a);
            let y = 0;
            for (let C = r.length - 1; C > 0 && (C > t || r[C].getTrimmedLength() === 0); C--) y++;
            y > 0 && (h.push(u + r.length - y), h.push(y)), u += r.length - 1;
          }
          return h;
        }, i.reflowLargerCreateNewLayout = function(_, d) {
          const n = [];
          let c = 0, a = d[c], h = 0;
          for (let u = 0; u < _.length; u++) if (a === u) {
            const e = d[++c];
            _.onDeleteEmitter.fire({ index: u - h, amount: e }), u += e - 1, h += e, a = d[++c];
          } else n.push(u);
          return { layout: n, countRemoved: h };
        }, i.reflowLargerApplyNewLayout = function(_, d) {
          const n = [];
          for (let c = 0; c < d.length; c++) n.push(_.get(d[c]));
          for (let c = 0; c < n.length; c++) _.set(c, n[c]);
          _.length = d.length;
        }, i.reflowSmallerGetNewLineLengths = function(_, d, n) {
          const c = [], a = _.map((s, r) => l(_, r, d)).reduce((s, r) => s + r);
          let h = 0, u = 0, e = 0;
          for (; e < a; ) {
            if (a - e < n) {
              c.push(a - e);
              break;
            }
            h += n;
            const s = l(_, u, d);
            h > s && (h -= s, u++);
            const r = _[u].getWidth(h - 1) === 2;
            r && h--;
            const t = r ? n - 1 : n;
            c.push(t), e += t;
          }
          return c;
        }, i.getWrappedLineTrimmedLength = l;
      }, 295: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.BufferSet = void 0;
        const _ = l(460), d = l(844), n = l(92);
        class c extends d.Disposable {
          constructor(h, u) {
            super(), this._optionsService = h, this._bufferService = u, this._onBufferActivate = this.register(new _.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
          }
          reset() {
            this._normal = new n.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
          }
          get alt() {
            return this._alt;
          }
          get active() {
            return this._activeBuffer;
          }
          get normal() {
            return this._normal;
          }
          activateNormalBuffer() {
            this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
          }
          activateAltBuffer(h) {
            this._activeBuffer !== this._alt && (this._alt.fillViewportRows(h), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
          }
          resize(h, u) {
            this._normal.resize(h, u), this._alt.resize(h, u), this.setupTabStops(h);
          }
          setupTabStops(h) {
            this._normal.setupTabStops(h), this._alt.setupTabStops(h);
          }
        }
        i.BufferSet = c;
      }, 511: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.CellData = void 0;
        const _ = l(482), d = l(643), n = l(734);
        class c extends n.AttributeData {
          constructor() {
            super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = "";
          }
          static fromCharData(h) {
            const u = new c();
            return u.setFromCharData(h), u;
          }
          isCombined() {
            return 2097152 & this.content;
          }
          getWidth() {
            return this.content >> 22;
          }
          getChars() {
            return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, _.stringFromCodePoint)(2097151 & this.content) : "";
          }
          getCode() {
            return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
          }
          setFromCharData(h) {
            this.fg = h[d.CHAR_DATA_ATTR_INDEX], this.bg = 0;
            let u = !1;
            if (h[d.CHAR_DATA_CHAR_INDEX].length > 2) u = !0;
            else if (h[d.CHAR_DATA_CHAR_INDEX].length === 2) {
              const e = h[d.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
              if (55296 <= e && e <= 56319) {
                const s = h[d.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                56320 <= s && s <= 57343 ? this.content = 1024 * (e - 55296) + s - 56320 + 65536 | h[d.CHAR_DATA_WIDTH_INDEX] << 22 : u = !0;
              } else u = !0;
            } else this.content = h[d.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | h[d.CHAR_DATA_WIDTH_INDEX] << 22;
            u && (this.combinedData = h[d.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | h[d.CHAR_DATA_WIDTH_INDEX] << 22);
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        i.CellData = c;
      }, 643: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.WHITESPACE_CELL_CODE = i.WHITESPACE_CELL_WIDTH = i.WHITESPACE_CELL_CHAR = i.NULL_CELL_CODE = i.NULL_CELL_WIDTH = i.NULL_CELL_CHAR = i.CHAR_DATA_CODE_INDEX = i.CHAR_DATA_WIDTH_INDEX = i.CHAR_DATA_CHAR_INDEX = i.CHAR_DATA_ATTR_INDEX = i.DEFAULT_EXT = i.DEFAULT_ATTR = i.DEFAULT_COLOR = void 0, i.DEFAULT_COLOR = 0, i.DEFAULT_ATTR = 256 | i.DEFAULT_COLOR << 9, i.DEFAULT_EXT = 0, i.CHAR_DATA_ATTR_INDEX = 0, i.CHAR_DATA_CHAR_INDEX = 1, i.CHAR_DATA_WIDTH_INDEX = 2, i.CHAR_DATA_CODE_INDEX = 3, i.NULL_CELL_CHAR = "", i.NULL_CELL_WIDTH = 1, i.NULL_CELL_CODE = 0, i.WHITESPACE_CELL_CHAR = " ", i.WHITESPACE_CELL_WIDTH = 1, i.WHITESPACE_CELL_CODE = 32;
      }, 863: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.Marker = void 0;
        const _ = l(460), d = l(844);
        class n {
          get id() {
            return this._id;
          }
          constructor(a) {
            this.line = a, this.isDisposed = !1, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new _.EventEmitter()), this.onDispose = this._onDispose.event;
          }
          dispose() {
            this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), (0, d.disposeArray)(this._disposables), this._disposables.length = 0);
          }
          register(a) {
            return this._disposables.push(a), a;
          }
        }
        i.Marker = n, n._nextId = 1;
      }, 116: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.DEFAULT_CHARSET = i.CHARSETS = void 0, i.CHARSETS = {}, i.DEFAULT_CHARSET = i.CHARSETS.B, i.CHARSETS[0] = { "`": "", a: "", b: "", c: "", d: "", e: "", f: "", g: "", h: "", i: "", j: "", k: "", l: "", m: "", n: "", o: "", p: "", q: "", r: "", s: "", t: "", u: "", v: "", w: "", x: "", y: "", z: "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS.A = { "#": "" }, i.CHARSETS.B = void 0, i.CHARSETS[4] = { "#": "", "@": "", "[": "ij", "\\": "", "]": "|", "{": "", "|": "f", "}": "", "~": "" }, i.CHARSETS.C = i.CHARSETS[5] = { "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS.R = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS.Q = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS.K = { "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS.Y = { "#": "", "@": "", "[": "", "\\": "", "]": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS.E = i.CHARSETS[6] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS.Z = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "" }, i.CHARSETS.H = i.CHARSETS[7] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, i.CHARSETS["="] = { "#": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "" };
      }, 584: (B, i) => {
        var l, _, d;
        Object.defineProperty(i, "__esModule", { value: !0 }), i.C1_ESCAPED = i.C1 = i.C0 = void 0, function(n) {
          n.NUL = "\0", n.SOH = "", n.STX = "", n.ETX = "", n.EOT = "", n.ENQ = "", n.ACK = "", n.BEL = "\x07", n.BS = "\b", n.HT = "	", n.LF = `
`, n.VT = "\v", n.FF = "\f", n.CR = "\r", n.SO = "", n.SI = "", n.DLE = "", n.DC1 = "", n.DC2 = "", n.DC3 = "", n.DC4 = "", n.NAK = "", n.SYN = "", n.ETB = "", n.CAN = "", n.EM = "", n.SUB = "", n.ESC = "\x1B", n.FS = "", n.GS = "", n.RS = "", n.US = "", n.SP = " ", n.DEL = "";
        }(l || (i.C0 = l = {})), function(n) {
          n.PAD = "", n.HOP = "", n.BPH = "", n.NBH = "", n.IND = "", n.NEL = "", n.SSA = "", n.ESA = "", n.HTS = "", n.HTJ = "", n.VTS = "", n.PLD = "", n.PLU = "", n.RI = "", n.SS2 = "", n.SS3 = "", n.DCS = "", n.PU1 = "", n.PU2 = "", n.STS = "", n.CCH = "", n.MW = "", n.SPA = "", n.EPA = "", n.SOS = "", n.SGCI = "", n.SCI = "", n.CSI = "", n.ST = "", n.OSC = "", n.PM = "", n.APC = "";
        }(_ || (i.C1 = _ = {})), function(n) {
          n.ST = `${l.ESC}\\`;
        }(d || (i.C1_ESCAPED = d = {}));
      }, 482: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.Utf8ToUtf32 = i.StringToUtf32 = i.utf32ToString = i.stringFromCodePoint = void 0, i.stringFromCodePoint = function(l) {
          return l > 65535 ? (l -= 65536, String.fromCharCode(55296 + (l >> 10)) + String.fromCharCode(l % 1024 + 56320)) : String.fromCharCode(l);
        }, i.utf32ToString = function(l, _ = 0, d = l.length) {
          let n = "";
          for (let c = _; c < d; ++c) {
            let a = l[c];
            a > 65535 ? (a -= 65536, n += String.fromCharCode(55296 + (a >> 10)) + String.fromCharCode(a % 1024 + 56320)) : n += String.fromCharCode(a);
          }
          return n;
        }, i.StringToUtf32 = class {
          constructor() {
            this._interim = 0;
          }
          clear() {
            this._interim = 0;
          }
          decode(l, _) {
            const d = l.length;
            if (!d) return 0;
            let n = 0, c = 0;
            if (this._interim) {
              const a = l.charCodeAt(c++);
              56320 <= a && a <= 57343 ? _[n++] = 1024 * (this._interim - 55296) + a - 56320 + 65536 : (_[n++] = this._interim, _[n++] = a), this._interim = 0;
            }
            for (let a = c; a < d; ++a) {
              const h = l.charCodeAt(a);
              if (55296 <= h && h <= 56319) {
                if (++a >= d) return this._interim = h, n;
                const u = l.charCodeAt(a);
                56320 <= u && u <= 57343 ? _[n++] = 1024 * (h - 55296) + u - 56320 + 65536 : (_[n++] = h, _[n++] = u);
              } else h !== 65279 && (_[n++] = h);
            }
            return n;
          }
        }, i.Utf8ToUtf32 = class {
          constructor() {
            this.interim = new Uint8Array(3);
          }
          clear() {
            this.interim.fill(0);
          }
          decode(l, _) {
            const d = l.length;
            if (!d) return 0;
            let n, c, a, h, u = 0, e = 0, s = 0;
            if (this.interim[0]) {
              let f = !1, p = this.interim[0];
              p &= (224 & p) == 192 ? 31 : (240 & p) == 224 ? 15 : 7;
              let m, y = 0;
              for (; (m = 63 & this.interim[++y]) && y < 4; ) p <<= 6, p |= m;
              const C = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, T = C - y;
              for (; s < T; ) {
                if (s >= d) return 0;
                if (m = l[s++], (192 & m) != 128) {
                  s--, f = !0;
                  break;
                }
                this.interim[y++] = m, p <<= 6, p |= 63 & m;
              }
              f || (C === 2 ? p < 128 ? s-- : _[u++] = p : C === 3 ? p < 2048 || p >= 55296 && p <= 57343 || p === 65279 || (_[u++] = p) : p < 65536 || p > 1114111 || (_[u++] = p)), this.interim.fill(0);
            }
            const r = d - 4;
            let t = s;
            for (; t < d; ) {
              for (; !(!(t < r) || 128 & (n = l[t]) || 128 & (c = l[t + 1]) || 128 & (a = l[t + 2]) || 128 & (h = l[t + 3])); ) _[u++] = n, _[u++] = c, _[u++] = a, _[u++] = h, t += 4;
              if (n = l[t++], n < 128) _[u++] = n;
              else if ((224 & n) == 192) {
                if (t >= d) return this.interim[0] = n, u;
                if (c = l[t++], (192 & c) != 128) {
                  t--;
                  continue;
                }
                if (e = (31 & n) << 6 | 63 & c, e < 128) {
                  t--;
                  continue;
                }
                _[u++] = e;
              } else if ((240 & n) == 224) {
                if (t >= d) return this.interim[0] = n, u;
                if (c = l[t++], (192 & c) != 128) {
                  t--;
                  continue;
                }
                if (t >= d) return this.interim[0] = n, this.interim[1] = c, u;
                if (a = l[t++], (192 & a) != 128) {
                  t--;
                  continue;
                }
                if (e = (15 & n) << 12 | (63 & c) << 6 | 63 & a, e < 2048 || e >= 55296 && e <= 57343 || e === 65279) continue;
                _[u++] = e;
              } else if ((248 & n) == 240) {
                if (t >= d) return this.interim[0] = n, u;
                if (c = l[t++], (192 & c) != 128) {
                  t--;
                  continue;
                }
                if (t >= d) return this.interim[0] = n, this.interim[1] = c, u;
                if (a = l[t++], (192 & a) != 128) {
                  t--;
                  continue;
                }
                if (t >= d) return this.interim[0] = n, this.interim[1] = c, this.interim[2] = a, u;
                if (h = l[t++], (192 & h) != 128) {
                  t--;
                  continue;
                }
                if (e = (7 & n) << 18 | (63 & c) << 12 | (63 & a) << 6 | 63 & h, e < 65536 || e > 1114111) continue;
                _[u++] = e;
              }
            }
            return u;
          }
        };
      }, 225: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.UnicodeV6 = void 0;
        const _ = l(480), d = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], n = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
        let c;
        i.UnicodeV6 = class {
          constructor() {
            if (this.version = "6", !c) {
              c = new Uint8Array(65536), c.fill(1), c[0] = 0, c.fill(0, 1, 32), c.fill(0, 127, 160), c.fill(2, 4352, 4448), c[9001] = 2, c[9002] = 2, c.fill(2, 11904, 42192), c[12351] = 1, c.fill(2, 44032, 55204), c.fill(2, 63744, 64256), c.fill(2, 65040, 65050), c.fill(2, 65072, 65136), c.fill(2, 65280, 65377), c.fill(2, 65504, 65511);
              for (let a = 0; a < d.length; ++a) c.fill(0, d[a][0], d[a][1] + 1);
            }
          }
          wcwidth(a) {
            return a < 32 ? 0 : a < 127 ? 1 : a < 65536 ? c[a] : function(h, u) {
              let e, s = 0, r = u.length - 1;
              if (h < u[0][0] || h > u[r][1]) return !1;
              for (; r >= s; ) if (e = s + r >> 1, h > u[e][1]) s = e + 1;
              else {
                if (!(h < u[e][0])) return !0;
                r = e - 1;
              }
              return !1;
            }(a, n) ? 0 : a >= 131072 && a <= 196605 || a >= 196608 && a <= 262141 ? 2 : 1;
          }
          charProperties(a, h) {
            let u = this.wcwidth(a), e = u === 0 && h !== 0;
            if (e) {
              const s = _.UnicodeService.extractWidth(h);
              s === 0 ? e = !1 : s > u && (u = s);
            }
            return _.UnicodeService.createPropertyValue(0, u, e);
          }
        };
      }, 981: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.WriteBuffer = void 0;
        const _ = l(460), d = l(844);
        class n extends d.Disposable {
          constructor(a) {
            super(), this._action = a, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._didUserInput = !1, this._onWriteParsed = this.register(new _.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
          }
          handleUserInput() {
            this._didUserInput = !0;
          }
          writeSync(a, h) {
            if (h !== void 0 && this._syncCalls > h) return void (this._syncCalls = 0);
            if (this._pendingData += a.length, this._writeBuffer.push(a), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
            let u;
            for (this._isSyncWriting = !0; u = this._writeBuffer.shift(); ) {
              this._action(u);
              const e = this._callbacks.shift();
              e && e();
            }
            this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;
          }
          write(a, h) {
            if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
            if (!this._writeBuffer.length) {
              if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = !1, this._pendingData += a.length, this._writeBuffer.push(a), this._callbacks.push(h), void this._innerWrite();
              setTimeout(() => this._innerWrite());
            }
            this._pendingData += a.length, this._writeBuffer.push(a), this._callbacks.push(h);
          }
          _innerWrite(a = 0, h = !0) {
            const u = a || Date.now();
            for (; this._writeBuffer.length > this._bufferOffset; ) {
              const e = this._writeBuffer[this._bufferOffset], s = this._action(e, h);
              if (s) {
                const t = (f) => Date.now() - u >= 12 ? setTimeout(() => this._innerWrite(0, f)) : this._innerWrite(u, f);
                return void s.catch((f) => (queueMicrotask(() => {
                  throw f;
                }), Promise.resolve(!1))).then(t);
              }
              const r = this._callbacks[this._bufferOffset];
              if (r && r(), this._bufferOffset++, this._pendingData -= e.length, Date.now() - u >= 12) break;
            }
            this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
          }
        }
        i.WriteBuffer = n;
      }, 941: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.toRgbString = i.parseColor = void 0;
        const l = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, _ = /^[\da-f]+$/;
        function d(n, c) {
          const a = n.toString(16), h = a.length < 2 ? "0" + a : a;
          switch (c) {
            case 4:
              return a[0];
            case 8:
              return h;
            case 12:
              return (h + h).slice(0, 3);
            default:
              return h + h;
          }
        }
        i.parseColor = function(n) {
          if (!n) return;
          let c = n.toLowerCase();
          if (c.indexOf("rgb:") === 0) {
            c = c.slice(4);
            const a = l.exec(c);
            if (a) {
              const h = a[1] ? 15 : a[4] ? 255 : a[7] ? 4095 : 65535;
              return [Math.round(parseInt(a[1] || a[4] || a[7] || a[10], 16) / h * 255), Math.round(parseInt(a[2] || a[5] || a[8] || a[11], 16) / h * 255), Math.round(parseInt(a[3] || a[6] || a[9] || a[12], 16) / h * 255)];
            }
          } else if (c.indexOf("#") === 0 && (c = c.slice(1), _.exec(c) && [3, 6, 9, 12].includes(c.length))) {
            const a = c.length / 3, h = [0, 0, 0];
            for (let u = 0; u < 3; ++u) {
              const e = parseInt(c.slice(a * u, a * u + a), 16);
              h[u] = a === 1 ? e << 4 : a === 2 ? e : a === 3 ? e >> 4 : e >> 8;
            }
            return h;
          }
        }, i.toRgbString = function(n, c = 16) {
          const [a, h, u] = n;
          return `rgb:${d(a, c)}/${d(h, c)}/${d(u, c)}`;
        };
      }, 770: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.PAYLOAD_LIMIT = void 0, i.PAYLOAD_LIMIT = 1e7;
      }, 351: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.DcsHandler = i.DcsParser = void 0;
        const _ = l(482), d = l(742), n = l(770), c = [];
        i.DcsParser = class {
          constructor() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._active = c, this._ident = 0, this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = c;
          }
          registerHandler(h, u) {
            this._handlers[h] === void 0 && (this._handlers[h] = []);
            const e = this._handlers[h];
            return e.push(u), { dispose: () => {
              const s = e.indexOf(u);
              s !== -1 && e.splice(s, 1);
            } };
          }
          clearHandler(h) {
            this._handlers[h] && delete this._handlers[h];
          }
          setHandlerFallback(h) {
            this._handlerFb = h;
          }
          reset() {
            if (this._active.length) for (let h = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; h >= 0; --h) this._active[h].unhook(!1);
            this._stack.paused = !1, this._active = c, this._ident = 0;
          }
          hook(h, u) {
            if (this.reset(), this._ident = h, this._active = this._handlers[h] || c, this._active.length) for (let e = this._active.length - 1; e >= 0; e--) this._active[e].hook(u);
            else this._handlerFb(this._ident, "HOOK", u);
          }
          put(h, u, e) {
            if (this._active.length) for (let s = this._active.length - 1; s >= 0; s--) this._active[s].put(h, u, e);
            else this._handlerFb(this._ident, "PUT", (0, _.utf32ToString)(h, u, e));
          }
          unhook(h, u = !0) {
            if (this._active.length) {
              let e = !1, s = this._active.length - 1, r = !1;
              if (this._stack.paused && (s = this._stack.loopPosition - 1, e = u, r = this._stack.fallThrough, this._stack.paused = !1), !r && e === !1) {
                for (; s >= 0 && (e = this._active[s].unhook(h), e !== !0); s--) if (e instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !1, e;
                s--;
              }
              for (; s >= 0; s--) if (e = this._active[s].unhook(!1), e instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !0, e;
            } else this._handlerFb(this._ident, "UNHOOK", h);
            this._active = c, this._ident = 0;
          }
        };
        const a = new d.Params();
        a.addParam(0), i.DcsHandler = class {
          constructor(h) {
            this._handler = h, this._data = "", this._params = a, this._hitLimit = !1;
          }
          hook(h) {
            this._params = h.length > 1 || h.params[0] ? h.clone() : a, this._data = "", this._hitLimit = !1;
          }
          put(h, u, e) {
            this._hitLimit || (this._data += (0, _.utf32ToString)(h, u, e), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          unhook(h) {
            let u = !1;
            if (this._hitLimit) u = !1;
            else if (h && (u = this._handler(this._data, this._params), u instanceof Promise)) return u.then((e) => (this._params = a, this._data = "", this._hitLimit = !1, e));
            return this._params = a, this._data = "", this._hitLimit = !1, u;
          }
        };
      }, 15: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.EscapeSequenceParser = i.VT500_TRANSITION_TABLE = i.TransitionTable = void 0;
        const _ = l(844), d = l(742), n = l(242), c = l(351);
        class a {
          constructor(s) {
            this.table = new Uint8Array(s);
          }
          setDefault(s, r) {
            this.table.fill(s << 4 | r);
          }
          add(s, r, t, f) {
            this.table[r << 8 | s] = t << 4 | f;
          }
          addMany(s, r, t, f) {
            for (let p = 0; p < s.length; p++) this.table[r << 8 | s[p]] = t << 4 | f;
          }
        }
        i.TransitionTable = a;
        const h = 160;
        i.VT500_TRANSITION_TABLE = function() {
          const e = new a(4095), s = Array.apply(null, Array(256)).map((y, C) => C), r = (y, C) => s.slice(y, C), t = r(32, 127), f = r(0, 24);
          f.push(25), f.push.apply(f, r(28, 32));
          const p = r(0, 14);
          let m;
          for (m in e.setDefault(1, 0), e.addMany(t, 0, 2, 0), p) e.addMany([24, 26, 153, 154], m, 3, 0), e.addMany(r(128, 144), m, 3, 0), e.addMany(r(144, 152), m, 3, 0), e.add(156, m, 0, 0), e.add(27, m, 11, 1), e.add(157, m, 4, 8), e.addMany([152, 158, 159], m, 0, 7), e.add(155, m, 11, 3), e.add(144, m, 11, 9);
          return e.addMany(f, 0, 3, 0), e.addMany(f, 1, 3, 1), e.add(127, 1, 0, 1), e.addMany(f, 8, 0, 8), e.addMany(f, 3, 3, 3), e.add(127, 3, 0, 3), e.addMany(f, 4, 3, 4), e.add(127, 4, 0, 4), e.addMany(f, 6, 3, 6), e.addMany(f, 5, 3, 5), e.add(127, 5, 0, 5), e.addMany(f, 2, 3, 2), e.add(127, 2, 0, 2), e.add(93, 1, 4, 8), e.addMany(t, 8, 5, 8), e.add(127, 8, 5, 8), e.addMany([156, 27, 24, 26, 7], 8, 6, 0), e.addMany(r(28, 32), 8, 0, 8), e.addMany([88, 94, 95], 1, 0, 7), e.addMany(t, 7, 0, 7), e.addMany(f, 7, 0, 7), e.add(156, 7, 0, 0), e.add(127, 7, 0, 7), e.add(91, 1, 11, 3), e.addMany(r(64, 127), 3, 7, 0), e.addMany(r(48, 60), 3, 8, 4), e.addMany([60, 61, 62, 63], 3, 9, 4), e.addMany(r(48, 60), 4, 8, 4), e.addMany(r(64, 127), 4, 7, 0), e.addMany([60, 61, 62, 63], 4, 0, 6), e.addMany(r(32, 64), 6, 0, 6), e.add(127, 6, 0, 6), e.addMany(r(64, 127), 6, 0, 0), e.addMany(r(32, 48), 3, 9, 5), e.addMany(r(32, 48), 5, 9, 5), e.addMany(r(48, 64), 5, 0, 6), e.addMany(r(64, 127), 5, 7, 0), e.addMany(r(32, 48), 4, 9, 5), e.addMany(r(32, 48), 1, 9, 2), e.addMany(r(32, 48), 2, 9, 2), e.addMany(r(48, 127), 2, 10, 0), e.addMany(r(48, 80), 1, 10, 0), e.addMany(r(81, 88), 1, 10, 0), e.addMany([89, 90, 92], 1, 10, 0), e.addMany(r(96, 127), 1, 10, 0), e.add(80, 1, 11, 9), e.addMany(f, 9, 0, 9), e.add(127, 9, 0, 9), e.addMany(r(28, 32), 9, 0, 9), e.addMany(r(32, 48), 9, 9, 12), e.addMany(r(48, 60), 9, 8, 10), e.addMany([60, 61, 62, 63], 9, 9, 10), e.addMany(f, 11, 0, 11), e.addMany(r(32, 128), 11, 0, 11), e.addMany(r(28, 32), 11, 0, 11), e.addMany(f, 10, 0, 10), e.add(127, 10, 0, 10), e.addMany(r(28, 32), 10, 0, 10), e.addMany(r(48, 60), 10, 8, 10), e.addMany([60, 61, 62, 63], 10, 0, 11), e.addMany(r(32, 48), 10, 9, 12), e.addMany(f, 12, 0, 12), e.add(127, 12, 0, 12), e.addMany(r(28, 32), 12, 0, 12), e.addMany(r(32, 48), 12, 9, 12), e.addMany(r(48, 64), 12, 0, 11), e.addMany(r(64, 127), 12, 12, 13), e.addMany(r(64, 127), 10, 12, 13), e.addMany(r(64, 127), 9, 12, 13), e.addMany(f, 13, 13, 13), e.addMany(t, 13, 13, 13), e.add(127, 13, 0, 13), e.addMany([27, 156, 24, 26], 13, 14, 0), e.add(h, 0, 2, 0), e.add(h, 8, 5, 8), e.add(h, 6, 0, 6), e.add(h, 11, 0, 11), e.add(h, 13, 13, 13), e;
        }();
        class u extends _.Disposable {
          constructor(s = i.VT500_TRANSITION_TABLE) {
            super(), this._transitions = s, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new d.Params(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._printHandlerFb = (r, t, f) => {
            }, this._executeHandlerFb = (r) => {
            }, this._csiHandlerFb = (r, t) => {
            }, this._escHandlerFb = (r) => {
            }, this._errorHandlerFb = (r) => r, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, _.toDisposable)(() => {
              this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
            })), this._oscParser = this.register(new n.OscParser()), this._dcsParser = this.register(new c.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => !0);
          }
          _identifier(s, r = [64, 126]) {
            let t = 0;
            if (s.prefix) {
              if (s.prefix.length > 1) throw new Error("only one byte as prefix supported");
              if (t = s.prefix.charCodeAt(0), t && 60 > t || t > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
            }
            if (s.intermediates) {
              if (s.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
              for (let p = 0; p < s.intermediates.length; ++p) {
                const m = s.intermediates.charCodeAt(p);
                if (32 > m || m > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
                t <<= 8, t |= m;
              }
            }
            if (s.final.length !== 1) throw new Error("final must be a single byte");
            const f = s.final.charCodeAt(0);
            if (r[0] > f || f > r[1]) throw new Error(`final must be in range ${r[0]} .. ${r[1]}`);
            return t <<= 8, t |= f, t;
          }
          identToString(s) {
            const r = [];
            for (; s; ) r.push(String.fromCharCode(255 & s)), s >>= 8;
            return r.reverse().join("");
          }
          setPrintHandler(s) {
            this._printHandler = s;
          }
          clearPrintHandler() {
            this._printHandler = this._printHandlerFb;
          }
          registerEscHandler(s, r) {
            const t = this._identifier(s, [48, 126]);
            this._escHandlers[t] === void 0 && (this._escHandlers[t] = []);
            const f = this._escHandlers[t];
            return f.push(r), { dispose: () => {
              const p = f.indexOf(r);
              p !== -1 && f.splice(p, 1);
            } };
          }
          clearEscHandler(s) {
            this._escHandlers[this._identifier(s, [48, 126])] && delete this._escHandlers[this._identifier(s, [48, 126])];
          }
          setEscHandlerFallback(s) {
            this._escHandlerFb = s;
          }
          setExecuteHandler(s, r) {
            this._executeHandlers[s.charCodeAt(0)] = r;
          }
          clearExecuteHandler(s) {
            this._executeHandlers[s.charCodeAt(0)] && delete this._executeHandlers[s.charCodeAt(0)];
          }
          setExecuteHandlerFallback(s) {
            this._executeHandlerFb = s;
          }
          registerCsiHandler(s, r) {
            const t = this._identifier(s);
            this._csiHandlers[t] === void 0 && (this._csiHandlers[t] = []);
            const f = this._csiHandlers[t];
            return f.push(r), { dispose: () => {
              const p = f.indexOf(r);
              p !== -1 && f.splice(p, 1);
            } };
          }
          clearCsiHandler(s) {
            this._csiHandlers[this._identifier(s)] && delete this._csiHandlers[this._identifier(s)];
          }
          setCsiHandlerFallback(s) {
            this._csiHandlerFb = s;
          }
          registerDcsHandler(s, r) {
            return this._dcsParser.registerHandler(this._identifier(s), r);
          }
          clearDcsHandler(s) {
            this._dcsParser.clearHandler(this._identifier(s));
          }
          setDcsHandlerFallback(s) {
            this._dcsParser.setHandlerFallback(s);
          }
          registerOscHandler(s, r) {
            return this._oscParser.registerHandler(s, r);
          }
          clearOscHandler(s) {
            this._oscParser.clearHandler(s);
          }
          setOscHandlerFallback(s) {
            this._oscParser.setHandlerFallback(s);
          }
          setErrorHandler(s) {
            this._errorHandler = s;
          }
          clearErrorHandler() {
            this._errorHandler = this._errorHandlerFb;
          }
          reset() {
            this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
          }
          _preserveStack(s, r, t, f, p) {
            this._parseStack.state = s, this._parseStack.handlers = r, this._parseStack.handlerPos = t, this._parseStack.transition = f, this._parseStack.chunkPos = p;
          }
          parse(s, r, t) {
            let f, p = 0, m = 0, y = 0;
            if (this._parseStack.state) if (this._parseStack.state === 2) this._parseStack.state = 0, y = this._parseStack.chunkPos + 1;
            else {
              if (t === void 0 || this._parseStack.state === 1) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
              const C = this._parseStack.handlers;
              let T = this._parseStack.handlerPos - 1;
              switch (this._parseStack.state) {
                case 3:
                  if (t === !1 && T > -1) {
                    for (; T >= 0 && (f = C[T](this._params), f !== !0); T--) if (f instanceof Promise) return this._parseStack.handlerPos = T, f;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 4:
                  if (t === !1 && T > -1) {
                    for (; T >= 0 && (f = C[T](), f !== !0); T--) if (f instanceof Promise) return this._parseStack.handlerPos = T, f;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 6:
                  if (p = s[this._parseStack.chunkPos], f = this._dcsParser.unhook(p !== 24 && p !== 26, t), f) return f;
                  p === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 5:
                  if (p = s[this._parseStack.chunkPos], f = this._oscParser.end(p !== 24 && p !== 26, t), f) return f;
                  p === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
              }
              this._parseStack.state = 0, y = this._parseStack.chunkPos + 1, this.precedingJoinState = 0, this.currentState = 15 & this._parseStack.transition;
            }
            for (let C = y; C < r; ++C) {
              switch (p = s[C], m = this._transitions.table[this.currentState << 8 | (p < 160 ? p : h)], m >> 4) {
                case 2:
                  for (let L = C + 1; ; ++L) {
                    if (L >= r || (p = s[L]) < 32 || p > 126 && p < h) {
                      this._printHandler(s, C, L), C = L - 1;
                      break;
                    }
                    if (++L >= r || (p = s[L]) < 32 || p > 126 && p < h) {
                      this._printHandler(s, C, L), C = L - 1;
                      break;
                    }
                    if (++L >= r || (p = s[L]) < 32 || p > 126 && p < h) {
                      this._printHandler(s, C, L), C = L - 1;
                      break;
                    }
                    if (++L >= r || (p = s[L]) < 32 || p > 126 && p < h) {
                      this._printHandler(s, C, L), C = L - 1;
                      break;
                    }
                  }
                  break;
                case 3:
                  this._executeHandlers[p] ? this._executeHandlers[p]() : this._executeHandlerFb(p), this.precedingJoinState = 0;
                  break;
                case 0:
                  break;
                case 1:
                  if (this._errorHandler({ position: C, code: p, currentState: this.currentState, collect: this._collect, params: this._params, abort: !1 }).abort) return;
                  break;
                case 7:
                  const T = this._csiHandlers[this._collect << 8 | p];
                  let F = T ? T.length - 1 : -1;
                  for (; F >= 0 && (f = T[F](this._params), f !== !0); F--) if (f instanceof Promise) return this._preserveStack(3, T, F, m, C), f;
                  F < 0 && this._csiHandlerFb(this._collect << 8 | p, this._params), this.precedingJoinState = 0;
                  break;
                case 8:
                  do
                    switch (p) {
                      case 59:
                        this._params.addParam(0);
                        break;
                      case 58:
                        this._params.addSubParam(-1);
                        break;
                      default:
                        this._params.addDigit(p - 48);
                    }
                  while (++C < r && (p = s[C]) > 47 && p < 60);
                  C--;
                  break;
                case 9:
                  this._collect <<= 8, this._collect |= p;
                  break;
                case 10:
                  const E = this._escHandlers[this._collect << 8 | p];
                  let w = E ? E.length - 1 : -1;
                  for (; w >= 0 && (f = E[w](), f !== !0); w--) if (f instanceof Promise) return this._preserveStack(4, E, w, m, C), f;
                  w < 0 && this._escHandlerFb(this._collect << 8 | p), this.precedingJoinState = 0;
                  break;
                case 11:
                  this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 12:
                  this._dcsParser.hook(this._collect << 8 | p, this._params);
                  break;
                case 13:
                  for (let L = C + 1; ; ++L) if (L >= r || (p = s[L]) === 24 || p === 26 || p === 27 || p > 127 && p < h) {
                    this._dcsParser.put(s, C, L), C = L - 1;
                    break;
                  }
                  break;
                case 14:
                  if (f = this._dcsParser.unhook(p !== 24 && p !== 26), f) return this._preserveStack(6, [], 0, m, C), f;
                  p === 27 && (m |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                  break;
                case 4:
                  this._oscParser.start();
                  break;
                case 5:
                  for (let L = C + 1; ; L++) if (L >= r || (p = s[L]) < 32 || p > 127 && p < h) {
                    this._oscParser.put(s, C, L), C = L - 1;
                    break;
                  }
                  break;
                case 6:
                  if (f = this._oscParser.end(p !== 24 && p !== 26), f) return this._preserveStack(5, [], 0, m, C), f;
                  p === 27 && (m |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
              }
              this.currentState = 15 & m;
            }
          }
        }
        i.EscapeSequenceParser = u;
      }, 242: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.OscHandler = i.OscParser = void 0;
        const _ = l(770), d = l(482), n = [];
        i.OscParser = class {
          constructor() {
            this._state = 0, this._active = n, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._stack = { paused: !1, loopPosition: 0, fallThrough: !1 };
          }
          registerHandler(c, a) {
            this._handlers[c] === void 0 && (this._handlers[c] = []);
            const h = this._handlers[c];
            return h.push(a), { dispose: () => {
              const u = h.indexOf(a);
              u !== -1 && h.splice(u, 1);
            } };
          }
          clearHandler(c) {
            this._handlers[c] && delete this._handlers[c];
          }
          setHandlerFallback(c) {
            this._handlerFb = c;
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = n;
          }
          reset() {
            if (this._state === 2) for (let c = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; c >= 0; --c) this._active[c].end(!1);
            this._stack.paused = !1, this._active = n, this._id = -1, this._state = 0;
          }
          _start() {
            if (this._active = this._handlers[this._id] || n, this._active.length) for (let c = this._active.length - 1; c >= 0; c--) this._active[c].start();
            else this._handlerFb(this._id, "START");
          }
          _put(c, a, h) {
            if (this._active.length) for (let u = this._active.length - 1; u >= 0; u--) this._active[u].put(c, a, h);
            else this._handlerFb(this._id, "PUT", (0, d.utf32ToString)(c, a, h));
          }
          start() {
            this.reset(), this._state = 1;
          }
          put(c, a, h) {
            if (this._state !== 3) {
              if (this._state === 1) for (; a < h; ) {
                const u = c[a++];
                if (u === 59) {
                  this._state = 2, this._start();
                  break;
                }
                if (u < 48 || 57 < u) return void (this._state = 3);
                this._id === -1 && (this._id = 0), this._id = 10 * this._id + u - 48;
              }
              this._state === 2 && h - a > 0 && this._put(c, a, h);
            }
          }
          end(c, a = !0) {
            if (this._state !== 0) {
              if (this._state !== 3) if (this._state === 1 && this._start(), this._active.length) {
                let h = !1, u = this._active.length - 1, e = !1;
                if (this._stack.paused && (u = this._stack.loopPosition - 1, h = a, e = this._stack.fallThrough, this._stack.paused = !1), !e && h === !1) {
                  for (; u >= 0 && (h = this._active[u].end(c), h !== !0); u--) if (h instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = u, this._stack.fallThrough = !1, h;
                  u--;
                }
                for (; u >= 0; u--) if (h = this._active[u].end(!1), h instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = u, this._stack.fallThrough = !0, h;
              } else this._handlerFb(this._id, "END", c);
              this._active = n, this._id = -1, this._state = 0;
            }
          }
        }, i.OscHandler = class {
          constructor(c) {
            this._handler = c, this._data = "", this._hitLimit = !1;
          }
          start() {
            this._data = "", this._hitLimit = !1;
          }
          put(c, a, h) {
            this._hitLimit || (this._data += (0, d.utf32ToString)(c, a, h), this._data.length > _.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = !0));
          }
          end(c) {
            let a = !1;
            if (this._hitLimit) a = !1;
            else if (c && (a = this._handler(this._data), a instanceof Promise)) return a.then((h) => (this._data = "", this._hitLimit = !1, h));
            return this._data = "", this._hitLimit = !1, a;
          }
        };
      }, 742: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.Params = void 0;
        const l = 2147483647;
        class _ {
          static fromArray(n) {
            const c = new _();
            if (!n.length) return c;
            for (let a = Array.isArray(n[0]) ? 1 : 0; a < n.length; ++a) {
              const h = n[a];
              if (Array.isArray(h)) for (let u = 0; u < h.length; ++u) c.addSubParam(h[u]);
              else c.addParam(h);
            }
            return c;
          }
          constructor(n = 32, c = 32) {
            if (this.maxLength = n, this.maxSubParamsLength = c, c > 256) throw new Error("maxSubParamsLength must not be greater than 256");
            this.params = new Int32Array(n), this.length = 0, this._subParams = new Int32Array(c), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(n), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          clone() {
            const n = new _(this.maxLength, this.maxSubParamsLength);
            return n.params.set(this.params), n.length = this.length, n._subParams.set(this._subParams), n._subParamsLength = this._subParamsLength, n._subParamsIdx.set(this._subParamsIdx), n._rejectDigits = this._rejectDigits, n._rejectSubDigits = this._rejectSubDigits, n._digitIsSub = this._digitIsSub, n;
          }
          toArray() {
            const n = [];
            for (let c = 0; c < this.length; ++c) {
              n.push(this.params[c]);
              const a = this._subParamsIdx[c] >> 8, h = 255 & this._subParamsIdx[c];
              h - a > 0 && n.push(Array.prototype.slice.call(this._subParams, a, h));
            }
            return n;
          }
          reset() {
            this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;
          }
          addParam(n) {
            if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0;
            else {
              if (n < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = n > l ? l : n;
            }
          }
          addSubParam(n) {
            if (this._digitIsSub = !0, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0;
            else {
              if (n < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParams[this._subParamsLength++] = n > l ? l : n, this._subParamsIdx[this.length - 1]++;
            }
          }
          hasSubParams(n) {
            return (255 & this._subParamsIdx[n]) - (this._subParamsIdx[n] >> 8) > 0;
          }
          getSubParams(n) {
            const c = this._subParamsIdx[n] >> 8, a = 255 & this._subParamsIdx[n];
            return a - c > 0 ? this._subParams.subarray(c, a) : null;
          }
          getSubParamsAll() {
            const n = {};
            for (let c = 0; c < this.length; ++c) {
              const a = this._subParamsIdx[c] >> 8, h = 255 & this._subParamsIdx[c];
              h - a > 0 && (n[c] = this._subParams.slice(a, h));
            }
            return n;
          }
          addDigit(n) {
            let c;
            if (this._rejectDigits || !(c = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
            const a = this._digitIsSub ? this._subParams : this.params, h = a[c - 1];
            a[c - 1] = ~h ? Math.min(10 * h + n, l) : n;
          }
        }
        i.Params = _;
      }, 741: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.AddonManager = void 0, i.AddonManager = class {
          constructor() {
            this._addons = [];
          }
          dispose() {
            for (let l = this._addons.length - 1; l >= 0; l--) this._addons[l].instance.dispose();
          }
          loadAddon(l, _) {
            const d = { instance: _, dispose: _.dispose, isDisposed: !1 };
            this._addons.push(d), _.dispose = () => this._wrappedAddonDispose(d), _.activate(l);
          }
          _wrappedAddonDispose(l) {
            if (l.isDisposed) return;
            let _ = -1;
            for (let d = 0; d < this._addons.length; d++) if (this._addons[d] === l) {
              _ = d;
              break;
            }
            if (_ === -1) throw new Error("Could not dispose an addon that has not been loaded");
            l.isDisposed = !0, l.dispose.apply(l.instance), this._addons.splice(_, 1);
          }
        };
      }, 771: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.BufferApiView = void 0;
        const _ = l(785), d = l(511);
        i.BufferApiView = class {
          constructor(n, c) {
            this._buffer = n, this.type = c;
          }
          init(n) {
            return this._buffer = n, this;
          }
          get cursorY() {
            return this._buffer.y;
          }
          get cursorX() {
            return this._buffer.x;
          }
          get viewportY() {
            return this._buffer.ydisp;
          }
          get baseY() {
            return this._buffer.ybase;
          }
          get length() {
            return this._buffer.lines.length;
          }
          getLine(n) {
            const c = this._buffer.lines.get(n);
            if (c) return new _.BufferLineApiView(c);
          }
          getNullCell() {
            return new d.CellData();
          }
        };
      }, 785: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.BufferLineApiView = void 0;
        const _ = l(511);
        i.BufferLineApiView = class {
          constructor(d) {
            this._line = d;
          }
          get isWrapped() {
            return this._line.isWrapped;
          }
          get length() {
            return this._line.length;
          }
          getCell(d, n) {
            if (!(d < 0 || d >= this._line.length)) return n ? (this._line.loadCell(d, n), n) : this._line.loadCell(d, new _.CellData());
          }
          translateToString(d, n, c) {
            return this._line.translateToString(d, n, c);
          }
        };
      }, 285: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.BufferNamespaceApi = void 0;
        const _ = l(771), d = l(460), n = l(844);
        class c extends n.Disposable {
          constructor(h) {
            super(), this._core = h, this._onBufferChange = this.register(new d.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new _.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new _.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
          }
          get active() {
            if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
            if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
            throw new Error("Active buffer is neither normal nor alternate");
          }
          get normal() {
            return this._normal.init(this._core.buffers.normal);
          }
          get alternate() {
            return this._alternate.init(this._core.buffers.alt);
          }
        }
        i.BufferNamespaceApi = c;
      }, 975: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.ParserApi = void 0, i.ParserApi = class {
          constructor(l) {
            this._core = l;
          }
          registerCsiHandler(l, _) {
            return this._core.registerCsiHandler(l, (d) => _(d.toArray()));
          }
          addCsiHandler(l, _) {
            return this.registerCsiHandler(l, _);
          }
          registerDcsHandler(l, _) {
            return this._core.registerDcsHandler(l, (d, n) => _(d, n.toArray()));
          }
          addDcsHandler(l, _) {
            return this.registerDcsHandler(l, _);
          }
          registerEscHandler(l, _) {
            return this._core.registerEscHandler(l, _);
          }
          addEscHandler(l, _) {
            return this.registerEscHandler(l, _);
          }
          registerOscHandler(l, _) {
            return this._core.registerOscHandler(l, _);
          }
          addOscHandler(l, _) {
            return this.registerOscHandler(l, _);
          }
        };
      }, 90: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.UnicodeApi = void 0, i.UnicodeApi = class {
          constructor(l) {
            this._core = l;
          }
          register(l) {
            this._core.unicodeService.register(l);
          }
          get versions() {
            return this._core.unicodeService.versions;
          }
          get activeVersion() {
            return this._core.unicodeService.activeVersion;
          }
          set activeVersion(l) {
            this._core.unicodeService.activeVersion = l;
          }
        };
      }, 744: function(B, i, l) {
        var _ = this && this.__decorate || function(e, s, r, t) {
          var f, p = arguments.length, m = p < 3 ? s : t === null ? t = Object.getOwnPropertyDescriptor(s, r) : t;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") m = Reflect.decorate(e, s, r, t);
          else for (var y = e.length - 1; y >= 0; y--) (f = e[y]) && (m = (p < 3 ? f(m) : p > 3 ? f(s, r, m) : f(s, r)) || m);
          return p > 3 && m && Object.defineProperty(s, r, m), m;
        }, d = this && this.__param || function(e, s) {
          return function(r, t) {
            s(r, t, e);
          };
        };
        Object.defineProperty(i, "__esModule", { value: !0 }), i.BufferService = i.MINIMUM_ROWS = i.MINIMUM_COLS = void 0;
        const n = l(460), c = l(844), a = l(295), h = l(585);
        i.MINIMUM_COLS = 2, i.MINIMUM_ROWS = 1;
        let u = i.BufferService = class extends c.Disposable {
          get buffer() {
            return this.buffers.active;
          }
          constructor(e) {
            super(), this.isUserScrolling = !1, this._onResize = this.register(new n.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e.rawOptions.cols || 0, i.MINIMUM_COLS), this.rows = Math.max(e.rawOptions.rows || 0, i.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e, this));
          }
          resize(e, s) {
            this.cols = e, this.rows = s, this.buffers.resize(e, s), this._onResize.fire({ cols: e, rows: s });
          }
          reset() {
            this.buffers.reset(), this.isUserScrolling = !1;
          }
          scroll(e, s = !1) {
            const r = this.buffer;
            let t;
            t = this._cachedBlankLine, t && t.length === this.cols && t.getFg(0) === e.fg && t.getBg(0) === e.bg || (t = r.getBlankLine(e, s), this._cachedBlankLine = t), t.isWrapped = s;
            const f = r.ybase + r.scrollTop, p = r.ybase + r.scrollBottom;
            if (r.scrollTop === 0) {
              const m = r.lines.isFull;
              p === r.lines.length - 1 ? m ? r.lines.recycle().copyFrom(t) : r.lines.push(t.clone()) : r.lines.splice(p + 1, 0, t.clone()), m ? this.isUserScrolling && (r.ydisp = Math.max(r.ydisp - 1, 0)) : (r.ybase++, this.isUserScrolling || r.ydisp++);
            } else {
              const m = p - f + 1;
              r.lines.shiftElements(f + 1, m - 1, -1), r.lines.set(p, t.clone());
            }
            this.isUserScrolling || (r.ydisp = r.ybase), this._onScroll.fire(r.ydisp);
          }
          scrollLines(e, s, r) {
            const t = this.buffer;
            if (e < 0) {
              if (t.ydisp === 0) return;
              this.isUserScrolling = !0;
            } else e + t.ydisp >= t.ybase && (this.isUserScrolling = !1);
            const f = t.ydisp;
            t.ydisp = Math.max(Math.min(t.ydisp + e, t.ybase), 0), f !== t.ydisp && (s || this._onScroll.fire(t.ydisp));
          }
        };
        i.BufferService = u = _([d(0, h.IOptionsService)], u);
      }, 994: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.CharsetService = void 0, i.CharsetService = class {
          constructor() {
            this.glevel = 0, this._charsets = [];
          }
          reset() {
            this.charset = void 0, this._charsets = [], this.glevel = 0;
          }
          setgLevel(l) {
            this.glevel = l, this.charset = this._charsets[l];
          }
          setgCharset(l, _) {
            this._charsets[l] = _, this.glevel === l && (this.charset = _);
          }
        };
      }, 753: function(B, i, l) {
        var _ = this && this.__decorate || function(t, f, p, m) {
          var y, C = arguments.length, T = C < 3 ? f : m === null ? m = Object.getOwnPropertyDescriptor(f, p) : m;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") T = Reflect.decorate(t, f, p, m);
          else for (var F = t.length - 1; F >= 0; F--) (y = t[F]) && (T = (C < 3 ? y(T) : C > 3 ? y(f, p, T) : y(f, p)) || T);
          return C > 3 && T && Object.defineProperty(f, p, T), T;
        }, d = this && this.__param || function(t, f) {
          return function(p, m) {
            f(p, m, t);
          };
        };
        Object.defineProperty(i, "__esModule", { value: !0 }), i.CoreMouseService = void 0;
        const n = l(585), c = l(460), a = l(844), h = { NONE: { events: 0, restrict: () => !1 }, X10: { events: 1, restrict: (t) => t.button !== 4 && t.action === 1 && (t.ctrl = !1, t.alt = !1, t.shift = !1, !0) }, VT200: { events: 19, restrict: (t) => t.action !== 32 }, DRAG: { events: 23, restrict: (t) => t.action !== 32 || t.button !== 3 }, ANY: { events: 31, restrict: (t) => !0 } };
        function u(t, f) {
          let p = (t.ctrl ? 16 : 0) | (t.shift ? 4 : 0) | (t.alt ? 8 : 0);
          return t.button === 4 ? (p |= 64, p |= t.action) : (p |= 3 & t.button, 4 & t.button && (p |= 64), 8 & t.button && (p |= 128), t.action === 32 ? p |= 32 : t.action !== 0 || f || (p |= 3)), p;
        }
        const e = String.fromCharCode, s = { DEFAULT: (t) => {
          const f = [u(t, !1) + 32, t.col + 32, t.row + 32];
          return f[0] > 255 || f[1] > 255 || f[2] > 255 ? "" : `\x1B[M${e(f[0])}${e(f[1])}${e(f[2])}`;
        }, SGR: (t) => {
          const f = t.action === 0 && t.button !== 4 ? "m" : "M";
          return `\x1B[<${u(t, !0)};${t.col};${t.row}${f}`;
        }, SGR_PIXELS: (t) => {
          const f = t.action === 0 && t.button !== 4 ? "m" : "M";
          return `\x1B[<${u(t, !0)};${t.x};${t.y}${f}`;
        } };
        let r = i.CoreMouseService = class extends a.Disposable {
          constructor(t, f) {
            super(), this._bufferService = t, this._coreService = f, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new c.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
            for (const p of Object.keys(h)) this.addProtocol(p, h[p]);
            for (const p of Object.keys(s)) this.addEncoding(p, s[p]);
            this.reset();
          }
          addProtocol(t, f) {
            this._protocols[t] = f;
          }
          addEncoding(t, f) {
            this._encodings[t] = f;
          }
          get activeProtocol() {
            return this._activeProtocol;
          }
          get areMouseEventsActive() {
            return this._protocols[this._activeProtocol].events !== 0;
          }
          set activeProtocol(t) {
            if (!this._protocols[t]) throw new Error(`unknown protocol "${t}"`);
            this._activeProtocol = t, this._onProtocolChange.fire(this._protocols[t].events);
          }
          get activeEncoding() {
            return this._activeEncoding;
          }
          set activeEncoding(t) {
            if (!this._encodings[t]) throw new Error(`unknown encoding "${t}"`);
            this._activeEncoding = t;
          }
          reset() {
            this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
          }
          triggerMouseEvent(t) {
            if (t.col < 0 || t.col >= this._bufferService.cols || t.row < 0 || t.row >= this._bufferService.rows || t.button === 4 && t.action === 32 || t.button === 3 && t.action !== 32 || t.button !== 4 && (t.action === 2 || t.action === 3) || (t.col++, t.row++, t.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, t, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(t)) return !1;
            const f = this._encodings[this._activeEncoding](t);
            return f && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(f) : this._coreService.triggerDataEvent(f, !0)), this._lastEvent = t, !0;
          }
          explainEvents(t) {
            return { down: !!(1 & t), up: !!(2 & t), drag: !!(4 & t), move: !!(8 & t), wheel: !!(16 & t) };
          }
          _equalEvents(t, f, p) {
            if (p) {
              if (t.x !== f.x || t.y !== f.y) return !1;
            } else if (t.col !== f.col || t.row !== f.row) return !1;
            return t.button === f.button && t.action === f.action && t.ctrl === f.ctrl && t.alt === f.alt && t.shift === f.shift;
          }
        };
        i.CoreMouseService = r = _([d(0, n.IBufferService), d(1, n.ICoreService)], r);
      }, 83: function(B, i, l) {
        var _ = this && this.__decorate || function(r, t, f, p) {
          var m, y = arguments.length, C = y < 3 ? t : p === null ? p = Object.getOwnPropertyDescriptor(t, f) : p;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") C = Reflect.decorate(r, t, f, p);
          else for (var T = r.length - 1; T >= 0; T--) (m = r[T]) && (C = (y < 3 ? m(C) : y > 3 ? m(t, f, C) : m(t, f)) || C);
          return y > 3 && C && Object.defineProperty(t, f, C), C;
        }, d = this && this.__param || function(r, t) {
          return function(f, p) {
            t(f, p, r);
          };
        };
        Object.defineProperty(i, "__esModule", { value: !0 }), i.CoreService = void 0;
        const n = l(439), c = l(460), a = l(844), h = l(585), u = Object.freeze({ insertMode: !1 }), e = Object.freeze({ applicationCursorKeys: !1, applicationKeypad: !1, bracketedPasteMode: !1, origin: !1, reverseWraparound: !1, sendFocus: !1, wraparound: !0 });
        let s = i.CoreService = class extends a.Disposable {
          constructor(r, t, f) {
            super(), this._bufferService = r, this._logService = t, this._optionsService = f, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new c.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new c.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new c.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new c.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(u), this.decPrivateModes = (0, n.clone)(e);
          }
          reset() {
            this.modes = (0, n.clone)(u), this.decPrivateModes = (0, n.clone)(e);
          }
          triggerDataEvent(r, t = !1) {
            if (this._optionsService.rawOptions.disableStdin) return;
            const f = this._bufferService.buffer;
            t && this._optionsService.rawOptions.scrollOnUserInput && f.ybase !== f.ydisp && this._onRequestScrollToBottom.fire(), t && this._onUserInput.fire(), this._logService.debug(`sending data "${r}"`, () => r.split("").map((p) => p.charCodeAt(0))), this._onData.fire(r);
          }
          triggerBinaryEvent(r) {
            this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${r}"`, () => r.split("").map((t) => t.charCodeAt(0))), this._onBinary.fire(r));
          }
        };
        i.CoreService = s = _([d(0, h.IBufferService), d(1, h.ILogService), d(2, h.IOptionsService)], s);
      }, 348: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.InstantiationService = i.ServiceCollection = void 0;
        const _ = l(585), d = l(343);
        class n {
          constructor(...a) {
            this._entries = /* @__PURE__ */ new Map();
            for (const [h, u] of a) this.set(h, u);
          }
          set(a, h) {
            const u = this._entries.get(a);
            return this._entries.set(a, h), u;
          }
          forEach(a) {
            for (const [h, u] of this._entries.entries()) a(h, u);
          }
          has(a) {
            return this._entries.has(a);
          }
          get(a) {
            return this._entries.get(a);
          }
        }
        i.ServiceCollection = n, i.InstantiationService = class {
          constructor() {
            this._services = new n(), this._services.set(_.IInstantiationService, this);
          }
          setService(c, a) {
            this._services.set(c, a);
          }
          getService(c) {
            return this._services.get(c);
          }
          createInstance(c, ...a) {
            const h = (0, d.getServiceDependencies)(c).sort((s, r) => s.index - r.index), u = [];
            for (const s of h) {
              const r = this._services.get(s.id);
              if (!r) throw new Error(`[createInstance] ${c.name} depends on UNKNOWN service ${s.id}.`);
              u.push(r);
            }
            const e = h.length > 0 ? h[0].index : a.length;
            if (a.length !== e) throw new Error(`[createInstance] First service dependency of ${c.name} at position ${e + 1} conflicts with ${a.length} static arguments`);
            return new c(...a, ...u);
          }
        };
      }, 866: function(B, i, l) {
        var _ = this && this.__decorate || function(e, s, r, t) {
          var f, p = arguments.length, m = p < 3 ? s : t === null ? t = Object.getOwnPropertyDescriptor(s, r) : t;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") m = Reflect.decorate(e, s, r, t);
          else for (var y = e.length - 1; y >= 0; y--) (f = e[y]) && (m = (p < 3 ? f(m) : p > 3 ? f(s, r, m) : f(s, r)) || m);
          return p > 3 && m && Object.defineProperty(s, r, m), m;
        }, d = this && this.__param || function(e, s) {
          return function(r, t) {
            s(r, t, e);
          };
        };
        Object.defineProperty(i, "__esModule", { value: !0 }), i.traceCall = i.setTraceLogger = i.LogService = void 0;
        const n = l(844), c = l(585), a = { trace: c.LogLevelEnum.TRACE, debug: c.LogLevelEnum.DEBUG, info: c.LogLevelEnum.INFO, warn: c.LogLevelEnum.WARN, error: c.LogLevelEnum.ERROR, off: c.LogLevelEnum.OFF };
        let h, u = i.LogService = class extends n.Disposable {
          get logLevel() {
            return this._logLevel;
          }
          constructor(e) {
            super(), this._optionsService = e, this._logLevel = c.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), h = this;
          }
          _updateLogLevel() {
            this._logLevel = a[this._optionsService.rawOptions.logLevel];
          }
          _evalLazyOptionalParams(e) {
            for (let s = 0; s < e.length; s++) typeof e[s] == "function" && (e[s] = e[s]());
          }
          _log(e, s, r) {
            this._evalLazyOptionalParams(r), e.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + s, ...r);
          }
          trace(e, ...s) {
            this._logLevel <= c.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, e, s);
          }
          debug(e, ...s) {
            this._logLevel <= c.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, e, s);
          }
          info(e, ...s) {
            this._logLevel <= c.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, e, s);
          }
          warn(e, ...s) {
            this._logLevel <= c.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, e, s);
          }
          error(e, ...s) {
            this._logLevel <= c.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, e, s);
          }
        };
        i.LogService = u = _([d(0, c.IOptionsService)], u), i.setTraceLogger = function(e) {
          h = e;
        }, i.traceCall = function(e, s, r) {
          if (typeof r.value != "function") throw new Error("not supported");
          const t = r.value;
          r.value = function(...f) {
            if (h.logLevel !== c.LogLevelEnum.TRACE) return t.apply(this, f);
            h.trace(`GlyphRenderer#${t.name}(${f.map((m) => JSON.stringify(m)).join(", ")})`);
            const p = t.apply(this, f);
            return h.trace(`GlyphRenderer#${t.name} return`, p), p;
          };
        };
      }, 302: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.OptionsService = i.DEFAULT_OPTIONS = void 0;
        const _ = l(460), d = l(844), n = l(114);
        i.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: !1, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: !0, drawBoldTextInBrightColors: !0, documentOverride: null, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: !1, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: !0, scrollSensitivity: 1, screenReaderMode: !1, smoothScrollDuration: 0, macOptionIsMeta: !1, macOptionClickForcesSelection: !1, minimumContrastRatio: 1, disableStdin: !1, allowProposedApi: !1, allowTransparency: !1, tabStopWidth: 8, theme: {}, rescaleOverlappingGlyphs: !1, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: !1, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: !0, convertEol: !1, termName: "xterm", cancelEvents: !1, overviewRulerWidth: 0 };
        const c = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
        class a extends d.Disposable {
          constructor(u) {
            super(), this._onOptionChange = this.register(new _.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
            const e = { ...i.DEFAULT_OPTIONS };
            for (const s in u) if (s in e) try {
              const r = u[s];
              e[s] = this._sanitizeAndValidateOption(s, r);
            } catch (r) {
              console.error(r);
            }
            this.rawOptions = e, this.options = { ...e }, this._setupOptions(), this.register((0, d.toDisposable)(() => {
              this.rawOptions.linkHandler = null, this.rawOptions.documentOverride = null;
            }));
          }
          onSpecificOptionChange(u, e) {
            return this.onOptionChange((s) => {
              s === u && e(this.rawOptions[u]);
            });
          }
          onMultipleOptionChange(u, e) {
            return this.onOptionChange((s) => {
              u.indexOf(s) !== -1 && e();
            });
          }
          _setupOptions() {
            const u = (s) => {
              if (!(s in i.DEFAULT_OPTIONS)) throw new Error(`No option with key "${s}"`);
              return this.rawOptions[s];
            }, e = (s, r) => {
              if (!(s in i.DEFAULT_OPTIONS)) throw new Error(`No option with key "${s}"`);
              r = this._sanitizeAndValidateOption(s, r), this.rawOptions[s] !== r && (this.rawOptions[s] = r, this._onOptionChange.fire(s));
            };
            for (const s in this.rawOptions) {
              const r = { get: u.bind(this, s), set: e.bind(this, s) };
              Object.defineProperty(this.options, s, r);
            }
          }
          _sanitizeAndValidateOption(u, e) {
            switch (u) {
              case "cursorStyle":
                if (e || (e = i.DEFAULT_OPTIONS[u]), !/* @__PURE__ */ function(s) {
                  return s === "block" || s === "underline" || s === "bar";
                }(e)) throw new Error(`"${e}" is not a valid value for ${u}`);
                break;
              case "wordSeparator":
                e || (e = i.DEFAULT_OPTIONS[u]);
                break;
              case "fontWeight":
              case "fontWeightBold":
                if (typeof e == "number" && 1 <= e && e <= 1e3) break;
                e = c.includes(e) ? e : i.DEFAULT_OPTIONS[u];
                break;
              case "cursorWidth":
                e = Math.floor(e);
              case "lineHeight":
              case "tabStopWidth":
                if (e < 1) throw new Error(`${u} cannot be less than 1, value: ${e}`);
                break;
              case "minimumContrastRatio":
                e = Math.max(1, Math.min(21, Math.round(10 * e) / 10));
                break;
              case "scrollback":
                if ((e = Math.min(e, 4294967295)) < 0) throw new Error(`${u} cannot be less than 0, value: ${e}`);
                break;
              case "fastScrollSensitivity":
              case "scrollSensitivity":
                if (e <= 0) throw new Error(`${u} cannot be less than or equal to 0, value: ${e}`);
                break;
              case "rows":
              case "cols":
                if (!e && e !== 0) throw new Error(`${u} must be numeric, value: ${e}`);
                break;
              case "windowsPty":
                e = e ?? {};
            }
            return e;
          }
        }
        i.OptionsService = a;
      }, 660: function(B, i, l) {
        var _ = this && this.__decorate || function(a, h, u, e) {
          var s, r = arguments.length, t = r < 3 ? h : e === null ? e = Object.getOwnPropertyDescriptor(h, u) : e;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function") t = Reflect.decorate(a, h, u, e);
          else for (var f = a.length - 1; f >= 0; f--) (s = a[f]) && (t = (r < 3 ? s(t) : r > 3 ? s(h, u, t) : s(h, u)) || t);
          return r > 3 && t && Object.defineProperty(h, u, t), t;
        }, d = this && this.__param || function(a, h) {
          return function(u, e) {
            h(u, e, a);
          };
        };
        Object.defineProperty(i, "__esModule", { value: !0 }), i.OscLinkService = void 0;
        const n = l(585);
        let c = i.OscLinkService = class {
          constructor(a) {
            this._bufferService = a, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
          }
          registerLink(a) {
            const h = this._bufferService.buffer;
            if (a.id === void 0) {
              const f = h.addMarker(h.ybase + h.y), p = { data: a, id: this._nextId++, lines: [f] };
              return f.onDispose(() => this._removeMarkerFromLink(p, f)), this._dataByLinkId.set(p.id, p), p.id;
            }
            const u = a, e = this._getEntryIdKey(u), s = this._entriesWithId.get(e);
            if (s) return this.addLineToLink(s.id, h.ybase + h.y), s.id;
            const r = h.addMarker(h.ybase + h.y), t = { id: this._nextId++, key: this._getEntryIdKey(u), data: u, lines: [r] };
            return r.onDispose(() => this._removeMarkerFromLink(t, r)), this._entriesWithId.set(t.key, t), this._dataByLinkId.set(t.id, t), t.id;
          }
          addLineToLink(a, h) {
            const u = this._dataByLinkId.get(a);
            if (u && u.lines.every((e) => e.line !== h)) {
              const e = this._bufferService.buffer.addMarker(h);
              u.lines.push(e), e.onDispose(() => this._removeMarkerFromLink(u, e));
            }
          }
          getLinkData(a) {
            return this._dataByLinkId.get(a)?.data;
          }
          _getEntryIdKey(a) {
            return `${a.id};;${a.uri}`;
          }
          _removeMarkerFromLink(a, h) {
            const u = a.lines.indexOf(h);
            u !== -1 && (a.lines.splice(u, 1), a.lines.length === 0 && (a.data.id !== void 0 && this._entriesWithId.delete(a.key), this._dataByLinkId.delete(a.id)));
          }
        };
        i.OscLinkService = c = _([d(0, n.IBufferService)], c);
      }, 343: (B, i) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.createDecorator = i.getServiceDependencies = i.serviceRegistry = void 0;
        const l = "di$target", _ = "di$dependencies";
        i.serviceRegistry = /* @__PURE__ */ new Map(), i.getServiceDependencies = function(d) {
          return d[_] || [];
        }, i.createDecorator = function(d) {
          if (i.serviceRegistry.has(d)) return i.serviceRegistry.get(d);
          const n = function(c, a, h) {
            if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            (function(u, e, s) {
              e[l] === e ? e[_].push({ id: u, index: s }) : (e[_] = [{ id: u, index: s }], e[l] = e);
            })(n, c, h);
          };
          return n.toString = () => d, i.serviceRegistry.set(d, n), n;
        };
      }, 585: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.IDecorationService = i.IUnicodeService = i.IOscLinkService = i.IOptionsService = i.ILogService = i.LogLevelEnum = i.IInstantiationService = i.ICharsetService = i.ICoreService = i.ICoreMouseService = i.IBufferService = void 0;
        const _ = l(343);
        var d;
        i.IBufferService = (0, _.createDecorator)("BufferService"), i.ICoreMouseService = (0, _.createDecorator)("CoreMouseService"), i.ICoreService = (0, _.createDecorator)("CoreService"), i.ICharsetService = (0, _.createDecorator)("CharsetService"), i.IInstantiationService = (0, _.createDecorator)("InstantiationService"), function(n) {
          n[n.TRACE = 0] = "TRACE", n[n.DEBUG = 1] = "DEBUG", n[n.INFO = 2] = "INFO", n[n.WARN = 3] = "WARN", n[n.ERROR = 4] = "ERROR", n[n.OFF = 5] = "OFF";
        }(d || (i.LogLevelEnum = d = {})), i.ILogService = (0, _.createDecorator)("LogService"), i.IOptionsService = (0, _.createDecorator)("OptionsService"), i.IOscLinkService = (0, _.createDecorator)("OscLinkService"), i.IUnicodeService = (0, _.createDecorator)("UnicodeService"), i.IDecorationService = (0, _.createDecorator)("DecorationService");
      }, 480: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.UnicodeService = void 0;
        const _ = l(460), d = l(225);
        class n {
          static extractShouldJoin(a) {
            return (1 & a) != 0;
          }
          static extractWidth(a) {
            return a >> 1 & 3;
          }
          static extractCharKind(a) {
            return a >> 3;
          }
          static createPropertyValue(a, h, u = !1) {
            return (16777215 & a) << 3 | (3 & h) << 1 | (u ? 1 : 0);
          }
          constructor() {
            this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new _.EventEmitter(), this.onChange = this._onChange.event;
            const a = new d.UnicodeV6();
            this.register(a), this._active = a.version, this._activeProvider = a;
          }
          dispose() {
            this._onChange.dispose();
          }
          get versions() {
            return Object.keys(this._providers);
          }
          get activeVersion() {
            return this._active;
          }
          set activeVersion(a) {
            if (!this._providers[a]) throw new Error(`unknown Unicode version "${a}"`);
            this._active = a, this._activeProvider = this._providers[a], this._onChange.fire(a);
          }
          register(a) {
            this._providers[a.version] = a;
          }
          wcwidth(a) {
            return this._activeProvider.wcwidth(a);
          }
          getStringCellWidth(a) {
            let h = 0, u = 0;
            const e = a.length;
            for (let s = 0; s < e; ++s) {
              let r = a.charCodeAt(s);
              if (55296 <= r && r <= 56319) {
                if (++s >= e) return h + this.wcwidth(r);
                const p = a.charCodeAt(s);
                56320 <= p && p <= 57343 ? r = 1024 * (r - 55296) + p - 56320 + 65536 : h += this.wcwidth(p);
              }
              const t = this.charProperties(r, u);
              let f = n.extractWidth(t);
              n.extractShouldJoin(t) && (f -= n.extractWidth(u)), h += f, u = t;
            }
            return h;
          }
          charProperties(a, h) {
            return this._activeProvider.charProperties(a, h);
          }
        }
        i.UnicodeService = n;
      }, 781: (B, i, l) => {
        Object.defineProperty(i, "__esModule", { value: !0 }), i.Terminal = void 0;
        const _ = l(437), d = l(969), n = l(460);
        class c extends d.CoreTerminal {
          constructor(h = {}) {
            super(h), this._onBell = this.register(new n.EventEmitter()), this.onBell = this._onBell.event, this._onCursorMove = this.register(new n.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onTitleChange = this.register(new n.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onA11yCharEmitter = this.register(new n.EventEmitter()), this.onA11yChar = this._onA11yCharEmitter.event, this._onA11yTabEmitter = this.register(new n.EventEmitter()), this.onA11yTab = this._onA11yTabEmitter.event, this._setup(), this.register(this._inputHandler.onRequestBell(() => this.bell())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register((0, n.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, n.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, n.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, n.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter));
          }
          get buffer() {
            return this.buffers.active;
          }
          get markers() {
            return this.buffer.markers;
          }
          addMarker(h) {
            if (this.buffer === this.buffers.normal) return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + h);
          }
          bell() {
            this._onBell.fire();
          }
          input(h, u = !0) {
            this.coreService.triggerDataEvent(h, u);
          }
          resize(h, u) {
            h === this.cols && u === this.rows || super.resize(h, u);
          }
          clear() {
            if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
              this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
              for (let h = 1; h < this.rows; h++) this.buffer.lines.push(this.buffer.getBlankLine(_.DEFAULT_ATTR_DATA));
              this._onScroll.fire({ position: this.buffer.ydisp, source: 0 });
            }
          }
          reset() {
            this.options.rows = this.rows, this.options.cols = this.cols, this._setup(), super.reset();
          }
        }
        i.Terminal = c;
      } }, X = {};
      function O(B) {
        var i = X[B];
        if (i !== void 0) return i.exports;
        var l = X[B] = { exports: {} };
        return V[B].call(l.exports, l, l.exports, O), l.exports;
      }
      var q = {};
      (() => {
        var B = q;
        Object.defineProperty(B, "__esModule", { value: !0 }), B.Terminal = void 0;
        const i = O(285), l = O(975), _ = O(90), d = O(781), n = O(741), c = O(844), a = ["cols", "rows"];
        class h extends c.Disposable {
          constructor(e) {
            super(), this._core = this.register(new d.Terminal(e)), this._addonManager = this.register(new n.AddonManager()), this._publicOptions = { ...this._core.options };
            const s = (t) => this._core.options[t], r = (t, f) => {
              this._checkReadonlyOptions(t), this._core.options[t] = f;
            };
            for (const t in this._core.options) {
              Object.defineProperty(this._publicOptions, t, { get: () => this._core.options[t], set: (p) => {
                this._checkReadonlyOptions(t), this._core.options[t] = p;
              } });
              const f = { get: s.bind(this, t), set: r.bind(this, t) };
              Object.defineProperty(this._publicOptions, t, f);
            }
          }
          _checkReadonlyOptions(e) {
            if (a.includes(e)) throw new Error(`Option "${e}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.options.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get parser() {
            return this._checkProposedApi(), this._parser || (this._parser = new l.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new _.UnicodeApi(this._core);
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._checkProposedApi(), this._buffer || (this._buffer = this.register(new i.BufferNamespaceApi(this._core))), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const e = this._core.coreService.decPrivateModes;
            let s = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                s = "x10";
                break;
              case "VT200":
                s = "vt200";
                break;
              case "DRAG":
                s = "drag";
                break;
              case "ANY":
                s = "any";
            }
            return { applicationCursorKeysMode: e.applicationCursorKeys, applicationKeypadMode: e.applicationKeypad, bracketedPasteMode: e.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: s, originMode: e.origin, reverseWraparoundMode: e.reverseWraparound, sendFocusMode: e.sendFocus, wraparoundMode: e.wraparound };
          }
          get options() {
            return this._publicOptions;
          }
          set options(e) {
            for (const s in e) this._publicOptions[s] = e[s];
          }
          input(e, s = !0) {
            this._core.input(e, s);
          }
          resize(e, s) {
            this._verifyIntegers(e, s), this._core.resize(e, s);
          }
          registerMarker(e = 0) {
            return this._checkProposedApi(), this._verifyIntegers(e), this._core.addMarker(e);
          }
          addMarker(e) {
            return this.registerMarker(e);
          }
          dispose() {
            super.dispose();
          }
          scrollLines(e) {
            this._verifyIntegers(e), this._core.scrollLines(e);
          }
          scrollPages(e) {
            this._verifyIntegers(e), this._core.scrollPages(e);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(e) {
            this._verifyIntegers(e), this._core.scrollToLine(e);
          }
          clear() {
            this._core.clear();
          }
          write(e, s) {
            this._core.write(e, s);
          }
          writeln(e, s) {
            this._core.write(e), this._core.write(`\r
`, s);
          }
          reset() {
            this._core.reset();
          }
          loadAddon(e) {
            this._addonManager.loadAddon(this, e);
          }
          _verifyIntegers(...e) {
            for (const s of e) if (s === 1 / 0 || isNaN(s) || s % 1 != 0) throw new Error("This API only accepts integers");
          }
        }
        B.Terminal = h;
      })();
      var j = W;
      for (var U in q) j[U] = q[U];
      q.__esModule && Object.defineProperty(j, "__esModule", { value: !0 });
    })();
  }(se)), se;
}
var be = ve();
function Se() {
  return new be.Terminal({
    cols: 1e3,
    rows: 500,
    allowProposedApi: !0,
    convertEol: !0,
    scrollback: 1e4,
    cursorBlink: !1
  });
}
const me = {
  maxCharacterLength: ce
};
function Ce(W, V = me) {
  const X = W.buffer.active, O = [], q = Math.max(0, V.maxCharacterLength);
  for (let U = 0; U < X.length; U++) {
    const B = X.getLine(U);
    if (!B)
      continue;
    const i = B.translateToString(!1).trimEnd();
    i.trim().length === 0 && O.at(-1)?.trim().length === 0 || O.push(i);
  }
  let j = 0;
  for (let U = O.length - 1; U > 0; U--) {
    const B = O[U];
    if (j += B.length, j > q) {
      const l = U, _ = `Truncated ${l} ${le(l, "line")} above this point`, d = O.length - U - 1, n = d === 1 ? "Below is the last line of the output" : `Below are the last ${d} lines of the output`;
      return {
        output: [
          `--- ${_}. ${n}. ---`,
          ...O.slice(U)
        ].join(`
`),
        hidden_truncatedOutput: O.slice(0, U).join(`
`)
      };
    }
  }
  return {
    output: O.join(`
`)
  };
}
function ye(W, V, X) {
  const O = Se();
  return ge(
    W,
    V.settings["terminal.commands.node-spawn.load-profile"]
  ).pipe(
    re(
      (q) => ue(X.cmd, [], {
        shell: oe.userInfo().shell || !0,
        cwd: W,
        stdio: ["ignore", null, null],
        env: q
      })
    ),
    re(({ lastData: q, exitCode: j, exited: U }) => fe(
      new Promise((B) => {
        const i = q?.subarray() ?? new Uint8Array();
        O.write(i, () => {
          const { output: l } = Ce(O);
          U || B({
            status: "in-progress",
            progress: { output: l }
          }), B({
            status: "done",
            result: { output: l, exitCode: j ?? -1 }
          });
        });
      })
    ))
  );
}
const ke = ({ args: W, userInput: V }, { dir: X, config: O, toolMessages: q }) => {
  _e(X);
  const j = he(X.fsPath, W.cwd ? we(W.cwd) : "."), U = (d) => ({
    status: "done",
    result: {
      output: `Error: ${d}`,
      exitCode: 1
    }
  }), B = Be(W.cmd);
  if (B)
    return te.of(U(B));
  const i = Ee(j);
  if (i)
    return te.of(U(i));
  const l = de(W.cmd, j, O.settings), _ = l.parts.flatMap(
    (d) => (
      // Only offer adding to allowlist when parsable, non-dynamic, and within cwd.
      d.requiresConfirmation ? typeof d.command == "string" || d.command.program === ie || d.command.arguments.some((n) => n === ie || pe(n, j)) ? [] : [d.command.program] : []
    )
  );
  if (l.requiresConfirmation) {
    if (V && !V.accepted)
      return te.of({ status: "rejected-by-user", toAllow: _ });
    if (!V?.accepted)
      return te.of({ status: "blocked-on-user", toAllow: _ });
  }
  return O.settings["terminal.commands.environment"], ye(j, O, W);
}, ae = oe.homedir();
function we(W) {
  return ae ? W.replace(/^~(?=$|\/|\\)/, ae) : W;
}
function Be(W) {
  if (typeof W != "string")
    return "`cmd` must be a string representing a command.";
}
function Ee(W) {
  if (W !== void 0 && typeof W != "string")
    return "`cwd` must be a string representing a relative path within the workspace.";
}
export {
  ke as nodeBashTool
};
//# sourceMappingURL=node-DSPACSAV.js.map
