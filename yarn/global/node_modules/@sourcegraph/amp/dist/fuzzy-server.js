#!/usr/bin/env node
import * as he from "node:readline";
function D(s) {
  return Array.isArray ? Array.isArray(s) : se(s) === "[object Array]";
}
function le(s) {
  if (typeof s == "string")
    return s;
  let e = s + "";
  return e == "0" && 1 / s == -1 / 0 ? "-0" : e;
}
function fe(s) {
  return s == null ? "" : le(s);
}
function M(s) {
  return typeof s == "string";
}
function ee(s) {
  return typeof s == "number";
}
function de(s) {
  return s === !0 || s === !1 || ge(s) && se(s) == "[object Boolean]";
}
function te(s) {
  return typeof s == "object";
}
function ge(s) {
  return te(s) && s !== null;
}
function E(s) {
  return s != null;
}
function P(s) {
  return !s.trim().length;
}
function se(s) {
  return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
const Ae = "Incorrect 'index' type", pe = (s) => `Invalid value for key ${s}`, Ee = (s) => `Pattern length exceeds max of ${s}.`, Ce = (s) => `Missing ${s} property in key`, Fe = (s) => `Property 'weight' in key '${s}' must be a positive integer`, Q = Object.prototype.hasOwnProperty;
class me {
  constructor(e) {
    this._keys = [], this._keyMap = {};
    let t = 0;
    e.forEach((r) => {
      let n = re(r);
      this._keys.push(n), this._keyMap[n.id] = n, t += n.weight;
    }), this._keys.forEach((r) => {
      r.weight /= t;
    });
  }
  get(e) {
    return this._keyMap[e];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function re(s) {
  let e = null, t = null, r = null, n = 1, i = null;
  if (M(s) || D(s))
    r = s, e = U(s), t = j(s);
  else {
    if (!Q.call(s, "name"))
      throw new Error(Ce("name"));
    const u = s.name;
    if (r = u, Q.call(s, "weight") && (n = s.weight, n <= 0))
      throw new Error(Fe(u));
    e = U(u), t = j(u), i = s.getFn;
  }
  return { path: e, id: t, weight: n, src: r, getFn: i };
}
function U(s) {
  return D(s) ? s : s.split(".");
}
function j(s) {
  return D(s) ? s.join(".") : s;
}
function Me(s, e) {
  let t = [], r = !1;
  const n = (i, u, c) => {
    if (E(i))
      if (!u[c])
        t.push(i);
      else {
        let o = u[c];
        const a = i[o];
        if (!E(a))
          return;
        if (c === u.length - 1 && (M(a) || ee(a) || de(a)))
          t.push(fe(a));
        else if (D(a)) {
          r = !0;
          for (let h = 0, f = a.length; h < f; h += 1)
            n(a[h], u, c + 1);
        } else u.length && n(a, u, c + 1);
      }
  };
  return n(s, M(e) ? e.split(".") : e, 0), r ? t : t[0];
}
const Be = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: !1,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: !1,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
}, De = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: !1,
  // When `true`, the algorithm will ignore diacritics (accents) in comparisons
  ignoreDiacritics: !1,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: !1,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: !0,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (s, e) => s.score === e.score ? s.idx < e.idx ? -1 : 1 : s.score < e.score ? -1 : 1
}, ye = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
}, xe = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: !1,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: Me,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: !1,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: !1,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var l = {
  ...De,
  ...Be,
  ...ye,
  ...xe
};
const _e = /[^ ]+/g;
function Se(s = 1, e = 3) {
  const t = /* @__PURE__ */ new Map(), r = Math.pow(10, e);
  return {
    get(n) {
      const i = n.match(_e).length;
      if (t.has(i))
        return t.get(i);
      const u = 1 / Math.pow(i, 0.5 * s), c = parseFloat(Math.round(u * r) / r);
      return t.set(i, c), c;
    },
    clear() {
      t.clear();
    }
  };
}
class J {
  constructor({
    getFn: e = l.getFn,
    fieldNormWeight: t = l.fieldNormWeight
  } = {}) {
    this.norm = Se(t, 3), this.getFn = e, this.isCreated = !1, this.setIndexRecords();
  }
  setSources(e = []) {
    this.docs = e;
  }
  setIndexRecords(e = []) {
    this.records = e;
  }
  setKeys(e = []) {
    this.keys = e, this._keysMap = {}, e.forEach((t, r) => {
      this._keysMap[t.id] = r;
    });
  }
  create() {
    this.isCreated || !this.docs.length || (this.isCreated = !0, M(this.docs[0]) ? this.docs.forEach((e, t) => {
      this._addString(e, t);
    }) : this.docs.forEach((e, t) => {
      this._addObject(e, t);
    }), this.norm.clear());
  }
  // Adds a doc to the end of the index
  add(e) {
    const t = this.size();
    M(e) ? this._addString(e, t) : this._addObject(e, t);
  }
  // Removes the doc at the specified index of the index
  removeAt(e) {
    this.records.splice(e, 1);
    for (let t = e, r = this.size(); t < r; t += 1)
      this.records[t].i -= 1;
  }
  getValueForItemAtKeyId(e, t) {
    return e[this._keysMap[t]];
  }
  size() {
    return this.records.length;
  }
  _addString(e, t) {
    if (!E(e) || P(e))
      return;
    let r = {
      v: e,
      i: t,
      n: this.norm.get(e)
    };
    this.records.push(r);
  }
  _addObject(e, t) {
    let r = { i: t, $: {} };
    this.keys.forEach((n, i) => {
      let u = n.getFn ? n.getFn(e) : this.getFn(e, n.path);
      if (E(u)) {
        if (D(u)) {
          let c = [];
          const o = [{ nestedArrIndex: -1, value: u }];
          for (; o.length; ) {
            const { nestedArrIndex: a, value: h } = o.pop();
            if (E(h))
              if (M(h) && !P(h)) {
                let f = {
                  v: h,
                  i: a,
                  n: this.norm.get(h)
                };
                c.push(f);
              } else D(h) && h.forEach((f, d) => {
                o.push({
                  nestedArrIndex: d,
                  value: f
                });
              });
          }
          r.$[i] = c;
        } else if (M(u) && !P(u)) {
          let c = {
            v: u,
            n: this.norm.get(u)
          };
          r.$[i] = c;
        }
      }
    }), this.records.push(r);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function ne(s, e, { getFn: t = l.getFn, fieldNormWeight: r = l.fieldNormWeight } = {}) {
  const n = new J({ getFn: t, fieldNormWeight: r });
  return n.setKeys(s.map(re)), n.setSources(e), n.create(), n;
}
function Ie(s, { getFn: e = l.getFn, fieldNormWeight: t = l.fieldNormWeight } = {}) {
  const { keys: r, records: n } = s, i = new J({ getFn: e, fieldNormWeight: t });
  return i.setKeys(r), i.setIndexRecords(n), i;
}
function v(s, {
  errors: e = 0,
  currentLocation: t = 0,
  expectedLocation: r = 0,
  distance: n = l.distance,
  ignoreLocation: i = l.ignoreLocation
} = {}) {
  const u = e / s.length;
  if (i)
    return u;
  const c = Math.abs(r - t);
  return n ? u + c / n : c ? 1 : u;
}
function we(s = [], e = l.minMatchCharLength) {
  let t = [], r = -1, n = -1, i = 0;
  for (let u = s.length; i < u; i += 1) {
    let c = s[i];
    c && r === -1 ? r = i : !c && r !== -1 && (n = i - 1, n - r + 1 >= e && t.push([r, n]), r = -1);
  }
  return s[i - 1] && i - r >= e && t.push([r, i - 1]), t;
}
const w = 32;
function Le(s, e, t, {
  location: r = l.location,
  distance: n = l.distance,
  threshold: i = l.threshold,
  findAllMatches: u = l.findAllMatches,
  minMatchCharLength: c = l.minMatchCharLength,
  includeMatches: o = l.includeMatches,
  ignoreLocation: a = l.ignoreLocation
} = {}) {
  if (e.length > w)
    throw new Error(Ee(w));
  const h = e.length, f = s.length, d = Math.max(0, Math.min(r, f));
  let g = i, A = d;
  const p = c > 1 || o, F = p ? Array(f) : [];
  let y;
  for (; (y = s.indexOf(e, A)) > -1; ) {
    let C = v(e, {
      currentLocation: y,
      expectedLocation: d,
      distance: n,
      ignoreLocation: a
    });
    if (g = Math.min(C, g), A = y + h, p) {
      let x = 0;
      for (; x < h; )
        F[y + x] = 1, x += 1;
    }
  }
  A = -1;
  let B = [], L = 1, I = h + f;
  const ae = 1 << h - 1;
  for (let C = 0; C < h; C += 1) {
    let x = 0, _ = I;
    for (; x < _; )
      v(e, {
        errors: C,
        currentLocation: d + _,
        expectedLocation: d,
        distance: n,
        ignoreLocation: a
      }) <= g ? x = _ : I = _, _ = Math.floor((I - x) / 2 + x);
    I = _;
    let Y = Math.max(1, d - _ + 1), T = u ? f : Math.min(d + _, f) + h, b = Array(T + 2);
    b[T + 1] = (1 << C) - 1;
    for (let m = T; m >= Y; m -= 1) {
      let k = m - 1, V = t[s.charAt(k)];
      if (p && (F[k] = +!!V), b[m] = (b[m + 1] << 1 | 1) & V, C && (b[m] |= (B[m + 1] | B[m]) << 1 | 1 | B[m + 1]), b[m] & ae && (L = v(e, {
        errors: C,
        currentLocation: k,
        expectedLocation: d,
        distance: n,
        ignoreLocation: a
      }), L <= g)) {
        if (g = L, A = k, A <= d)
          break;
        Y = Math.max(1, 2 * d - A);
      }
    }
    if (v(e, {
      errors: C + 1,
      currentLocation: d,
      expectedLocation: d,
      distance: n,
      ignoreLocation: a
    }) > g)
      break;
    B = b;
  }
  const N = {
    isMatch: A >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, L)
  };
  if (p) {
    const C = we(F, c);
    C.length ? o && (N.indices = C) : N.isMatch = !1;
  }
  return N;
}
function be(s) {
  let e = {};
  for (let t = 0, r = s.length; t < r; t += 1) {
    const n = s.charAt(t);
    e[n] = (e[n] || 0) | 1 << r - t - 1;
  }
  return e;
}
const O = String.prototype.normalize ? (s) => s.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, "") : (s) => s;
class ie {
  constructor(e, {
    location: t = l.location,
    threshold: r = l.threshold,
    distance: n = l.distance,
    includeMatches: i = l.includeMatches,
    findAllMatches: u = l.findAllMatches,
    minMatchCharLength: c = l.minMatchCharLength,
    isCaseSensitive: o = l.isCaseSensitive,
    ignoreDiacritics: a = l.ignoreDiacritics,
    ignoreLocation: h = l.ignoreLocation
  } = {}) {
    if (this.options = {
      location: t,
      threshold: r,
      distance: n,
      includeMatches: i,
      findAllMatches: u,
      minMatchCharLength: c,
      isCaseSensitive: o,
      ignoreDiacritics: a,
      ignoreLocation: h
    }, e = o ? e : e.toLowerCase(), e = a ? O(e) : e, this.pattern = e, this.chunks = [], !this.pattern.length)
      return;
    const f = (g, A) => {
      this.chunks.push({
        pattern: g,
        alphabet: be(g),
        startIndex: A
      });
    }, d = this.pattern.length;
    if (d > w) {
      let g = 0;
      const A = d % w, p = d - A;
      for (; g < p; )
        f(this.pattern.substr(g, w), g), g += w;
      if (A) {
        const F = d - w;
        f(this.pattern.substr(F), F);
      }
    } else
      f(this.pattern, 0);
  }
  searchIn(e) {
    const { isCaseSensitive: t, ignoreDiacritics: r, includeMatches: n } = this.options;
    if (e = t ? e : e.toLowerCase(), e = r ? O(e) : e, this.pattern === e) {
      let p = {
        isMatch: !0,
        score: 0
      };
      return n && (p.indices = [[0, e.length - 1]]), p;
    }
    const {
      location: i,
      distance: u,
      threshold: c,
      findAllMatches: o,
      minMatchCharLength: a,
      ignoreLocation: h
    } = this.options;
    let f = [], d = 0, g = !1;
    this.chunks.forEach(({ pattern: p, alphabet: F, startIndex: y }) => {
      const { isMatch: B, score: L, indices: I } = Le(e, p, F, {
        location: i + y,
        distance: u,
        threshold: c,
        findAllMatches: o,
        minMatchCharLength: a,
        includeMatches: n,
        ignoreLocation: h
      });
      B && (g = !0), d += L, B && I && (f = [...f, ...I]);
    });
    let A = {
      isMatch: g,
      score: g ? d / this.chunks.length : 1
    };
    return g && n && (A.indices = f), A;
  }
}
class S {
  constructor(e) {
    this.pattern = e;
  }
  static isMultiMatch(e) {
    return X(e, this.multiRegex);
  }
  static isSingleMatch(e) {
    return X(e, this.singleRegex);
  }
  search() {
  }
}
function X(s, e) {
  const t = s.match(e);
  return t ? t[1] : null;
}
class Re extends S {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(e) {
    const t = e === this.pattern;
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class ke extends S {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(e) {
    const r = e.indexOf(this.pattern) === -1;
    return {
      isMatch: r,
      score: r ? 0 : 1,
      indices: [0, e.length - 1]
    };
  }
}
class ve extends S {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(e) {
    const t = e.startsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class Oe extends S {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(e) {
    const t = !e.startsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, e.length - 1]
    };
  }
}
class $e extends S {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(e) {
    const t = e.endsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [e.length - this.pattern.length, e.length - 1]
    };
  }
}
class Ne extends S {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(e) {
    const t = !e.endsWith(this.pattern);
    return {
      isMatch: t,
      score: t ? 0 : 1,
      indices: [0, e.length - 1]
    };
  }
}
class ue extends S {
  constructor(e, {
    location: t = l.location,
    threshold: r = l.threshold,
    distance: n = l.distance,
    includeMatches: i = l.includeMatches,
    findAllMatches: u = l.findAllMatches,
    minMatchCharLength: c = l.minMatchCharLength,
    isCaseSensitive: o = l.isCaseSensitive,
    ignoreDiacritics: a = l.ignoreDiacritics,
    ignoreLocation: h = l.ignoreLocation
  } = {}) {
    super(e), this._bitapSearch = new ie(e, {
      location: t,
      threshold: r,
      distance: n,
      includeMatches: i,
      findAllMatches: u,
      minMatchCharLength: c,
      isCaseSensitive: o,
      ignoreDiacritics: a,
      ignoreLocation: h
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(e) {
    return this._bitapSearch.searchIn(e);
  }
}
class ce extends S {
  constructor(e) {
    super(e);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(e) {
    let t = 0, r;
    const n = [], i = this.pattern.length;
    for (; (r = e.indexOf(this.pattern, t)) > -1; )
      t = r + i, n.push([r, t - 1]);
    const u = !!n.length;
    return {
      isMatch: u,
      score: u ? 0 : 1,
      indices: n
    };
  }
}
const K = [
  Re,
  ce,
  ve,
  Oe,
  Ne,
  $e,
  ke,
  ue
], Z = K.length, Te = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, Pe = "|";
function je(s, e = {}) {
  return s.split(Pe).map((t) => {
    let r = t.trim().split(Te).filter((i) => i && !!i.trim()), n = [];
    for (let i = 0, u = r.length; i < u; i += 1) {
      const c = r[i];
      let o = !1, a = -1;
      for (; !o && ++a < Z; ) {
        const h = K[a];
        let f = h.isMultiMatch(c);
        f && (n.push(new h(f, e)), o = !0);
      }
      if (!o)
        for (a = -1; ++a < Z; ) {
          const h = K[a];
          let f = h.isSingleMatch(c);
          if (f) {
            n.push(new h(f, e));
            break;
          }
        }
    }
    return n;
  });
}
const Ke = /* @__PURE__ */ new Set([ue.type, ce.type]);
class ze {
  constructor(e, {
    isCaseSensitive: t = l.isCaseSensitive,
    ignoreDiacritics: r = l.ignoreDiacritics,
    includeMatches: n = l.includeMatches,
    minMatchCharLength: i = l.minMatchCharLength,
    ignoreLocation: u = l.ignoreLocation,
    findAllMatches: c = l.findAllMatches,
    location: o = l.location,
    threshold: a = l.threshold,
    distance: h = l.distance
  } = {}) {
    this.query = null, this.options = {
      isCaseSensitive: t,
      ignoreDiacritics: r,
      includeMatches: n,
      minMatchCharLength: i,
      findAllMatches: c,
      ignoreLocation: u,
      location: o,
      threshold: a,
      distance: h
    }, e = t ? e : e.toLowerCase(), e = r ? O(e) : e, this.pattern = e, this.query = je(this.pattern, this.options);
  }
  static condition(e, t) {
    return t.useExtendedSearch;
  }
  searchIn(e) {
    const t = this.query;
    if (!t)
      return {
        isMatch: !1,
        score: 1
      };
    const { includeMatches: r, isCaseSensitive: n, ignoreDiacritics: i } = this.options;
    e = n ? e : e.toLowerCase(), e = i ? O(e) : e;
    let u = 0, c = [], o = 0;
    for (let a = 0, h = t.length; a < h; a += 1) {
      const f = t[a];
      c.length = 0, u = 0;
      for (let d = 0, g = f.length; d < g; d += 1) {
        const A = f[d], { isMatch: p, indices: F, score: y } = A.search(e);
        if (p) {
          if (u += 1, o += y, r) {
            const B = A.constructor.type;
            Ke.has(B) ? c = [...c, ...F] : c.push(F);
          }
        } else {
          o = 0, u = 0, c.length = 0;
          break;
        }
      }
      if (u) {
        let d = {
          isMatch: !0,
          score: o / u
        };
        return r && (d.indices = c), d;
      }
    }
    return {
      isMatch: !1,
      score: 1
    };
  }
}
const z = [];
function We(...s) {
  z.push(...s);
}
function W(s, e) {
  for (let t = 0, r = z.length; t < r; t += 1) {
    let n = z[t];
    if (n.condition(s, e))
      return new n(s, e);
  }
  return new ie(s, e);
}
const $ = {
  AND: "$and",
  OR: "$or"
}, G = {
  PATH: "$path",
  PATTERN: "$val"
}, H = (s) => !!(s[$.AND] || s[$.OR]), Ge = (s) => !!s[G.PATH], He = (s) => !D(s) && te(s) && !H(s), q = (s) => ({
  [$.AND]: Object.keys(s).map((e) => ({
    [e]: s[e]
  }))
});
function oe(s, e, { auto: t = !0 } = {}) {
  const r = (n) => {
    let i = Object.keys(n);
    const u = Ge(n);
    if (!u && i.length > 1 && !H(n))
      return r(q(n));
    if (He(n)) {
      const o = u ? n[G.PATH] : i[0], a = u ? n[G.PATTERN] : n[o];
      if (!M(a))
        throw new Error(pe(o));
      const h = {
        keyId: j(o),
        pattern: a
      };
      return t && (h.searcher = W(a, e)), h;
    }
    let c = {
      children: [],
      operator: i[0]
    };
    return i.forEach((o) => {
      const a = n[o];
      D(a) && a.forEach((h) => {
        c.children.push(r(h));
      });
    }), c;
  };
  return H(s) || (s = q(s)), r(s);
}
function Je(s, { ignoreFieldNorm: e = l.ignoreFieldNorm }) {
  s.forEach((t) => {
    let r = 1;
    t.matches.forEach(({ key: n, norm: i, score: u }) => {
      const c = n ? n.weight : null;
      r *= Math.pow(
        u === 0 && c ? Number.EPSILON : u,
        (c || 1) * (e ? 1 : i)
      );
    }), t.score = r;
  });
}
function Ye(s, e) {
  const t = s.matches;
  e.matches = [], E(t) && t.forEach((r) => {
    if (!E(r.indices) || !r.indices.length)
      return;
    const { indices: n, value: i } = r;
    let u = {
      indices: n,
      value: i
    };
    r.key && (u.key = r.key.src), r.idx > -1 && (u.refIndex = r.idx), e.matches.push(u);
  });
}
function Ve(s, e) {
  e.score = s.score;
}
function Qe(s, e, {
  includeMatches: t = l.includeMatches,
  includeScore: r = l.includeScore
} = {}) {
  const n = [];
  return t && n.push(Ye), r && n.push(Ve), s.map((i) => {
    const { idx: u } = i, c = {
      item: e[u],
      refIndex: u
    };
    return n.length && n.forEach((o) => {
      o(i, c);
    }), c;
  });
}
class R {
  constructor(e, t = {}, r) {
    this.options = { ...l, ...t }, this.options.useExtendedSearch, this._keyStore = new me(this.options.keys), this.setCollection(e, r);
  }
  setCollection(e, t) {
    if (this._docs = e, t && !(t instanceof J))
      throw new Error(Ae);
    this._myIndex = t || ne(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(e) {
    E(e) && (this._docs.push(e), this._myIndex.add(e));
  }
  remove(e = () => !1) {
    const t = [];
    for (let r = 0, n = this._docs.length; r < n; r += 1) {
      const i = this._docs[r];
      e(i, r) && (this.removeAt(r), r -= 1, n -= 1, t.push(i));
    }
    return t;
  }
  removeAt(e) {
    this._docs.splice(e, 1), this._myIndex.removeAt(e);
  }
  getIndex() {
    return this._myIndex;
  }
  search(e, { limit: t = -1 } = {}) {
    const {
      includeMatches: r,
      includeScore: n,
      shouldSort: i,
      sortFn: u,
      ignoreFieldNorm: c
    } = this.options;
    let o = M(e) ? M(this._docs[0]) ? this._searchStringList(e) : this._searchObjectList(e) : this._searchLogical(e);
    return Je(o, { ignoreFieldNorm: c }), i && o.sort(u), ee(t) && t > -1 && (o = o.slice(0, t)), Qe(o, this._docs, {
      includeMatches: r,
      includeScore: n
    });
  }
  _searchStringList(e) {
    const t = W(e, this.options), { records: r } = this._myIndex, n = [];
    return r.forEach(({ v: i, i: u, n: c }) => {
      if (!E(i))
        return;
      const { isMatch: o, score: a, indices: h } = t.searchIn(i);
      o && n.push({
        item: i,
        idx: u,
        matches: [{ score: a, value: i, norm: c, indices: h }]
      });
    }), n;
  }
  _searchLogical(e) {
    const t = oe(e, this.options), r = (c, o, a) => {
      if (!c.children) {
        const { keyId: f, searcher: d } = c, g = this._findMatches({
          key: this._keyStore.get(f),
          value: this._myIndex.getValueForItemAtKeyId(o, f),
          searcher: d
        });
        return g && g.length ? [
          {
            idx: a,
            item: o,
            matches: g
          }
        ] : [];
      }
      const h = [];
      for (let f = 0, d = c.children.length; f < d; f += 1) {
        const g = c.children[f], A = r(g, o, a);
        if (A.length)
          h.push(...A);
        else if (c.operator === $.AND)
          return [];
      }
      return h;
    }, n = this._myIndex.records, i = {}, u = [];
    return n.forEach(({ $: c, i: o }) => {
      if (E(c)) {
        let a = r(t, c, o);
        a.length && (i[o] || (i[o] = { idx: o, item: c, matches: [] }, u.push(i[o])), a.forEach(({ matches: h }) => {
          i[o].matches.push(...h);
        }));
      }
    }), u;
  }
  _searchObjectList(e) {
    const t = W(e, this.options), { keys: r, records: n } = this._myIndex, i = [];
    return n.forEach(({ $: u, i: c }) => {
      if (!E(u))
        return;
      let o = [];
      r.forEach((a, h) => {
        o.push(
          ...this._findMatches({
            key: a,
            value: u[h],
            searcher: t
          })
        );
      }), o.length && i.push({
        idx: c,
        item: u,
        matches: o
      });
    }), i;
  }
  _findMatches({ key: e, value: t, searcher: r }) {
    if (!E(t))
      return [];
    let n = [];
    if (D(t))
      t.forEach(({ v: i, i: u, n: c }) => {
        if (!E(i))
          return;
        const { isMatch: o, score: a, indices: h } = r.searchIn(i);
        o && n.push({
          score: a,
          key: e,
          value: i,
          idx: u,
          norm: c,
          indices: h
        });
      });
    else {
      const { v: i, n: u } = t, { isMatch: c, score: o, indices: a } = r.searchIn(i);
      c && n.push({ score: o, key: e, value: i, norm: u, indices: a });
    }
    return n;
  }
}
R.version = "7.1.0";
R.createIndex = ne;
R.parseIndex = Ie;
R.config = l;
R.parseQuery = oe;
We(ze);
class Ue {
  fuse;
  constructor() {
    this.fuse = new R([], {
      keys: ["value"],
      includeScore: !0,
      location: 0,
      threshold: 0.7,
      distance: 256,
      ignoreLocation: !0,
      findAllMatches: !0,
      isCaseSensitive: !1
    });
  }
  addFiles(e) {
    for (const t of e)
      this.fuse.add({ value: t.toLowerCase(), original: t });
  }
  removeFiles(e) {
    for (const t of e)
      this.fuse.remove((r) => r.value === t);
  }
  query(e, t = 50) {
    return this.fuse.search(e, { limit: t }).map((n) => n.item.original);
  }
  handleMessage(e) {
    try {
      const { id: t, type: r } = e;
      switch (r) {
        case "index:add":
          return this.addFiles(e.files || []), { id: t, type: "response", status: "ok" };
        case "index:remove":
          return this.removeFiles(e.files || []), { id: t, type: "response", status: "ok" };
        case "query": {
          const n = this.query(e.text || "");
          return { id: t, type: "response", results: n };
        }
        default:
          return { id: t, type: "error", message: `Unknown type: ${r}` };
      }
    } catch (t) {
      return {
        id: e.id,
        type: "error",
        message: t instanceof Error ? t.message : String(t)
      };
    }
  }
  start() {
    const e = he.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: !1
    });
    e.on("line", (t) => {
      try {
        const r = JSON.parse(t), n = this.handleMessage(r);
        console.log(JSON.stringify(n));
      } catch (r) {
        console.log(
          JSON.stringify({
            id: -1,
            type: "error",
            message: `Parse error: ${r instanceof Error ? r.message : String(r)}`
          })
        );
      }
    }), e.on("close", () => {
      process.exit(0);
    });
  }
}
const Xe = new Ue();
Xe.start();
//# sourceMappingURL=fuzzy-server.js.map
