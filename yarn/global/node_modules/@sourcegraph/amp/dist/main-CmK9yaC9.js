#!/usr/bin/env node
import { B as Nr, O as It, s as Gn, c as ub, a as ur, b as eu, f as it, d as is, p as ms, m as at, e as gs, g as kn, h as ys, i as BM, j as cb, M as pr, l as VM, k as oe, N as gl, n as zh, r as wn, o as Yh, t as HM, q as GM, u as Zh, v as WM, w as gy, x as Rl, y as KM, z as qn, A as XG, C as os, D as JM, E as zM, H as YM, F as lo, G as fb, I as ZM, J as no, K as db, L as hb, P as jM, Q as QM, R as sh, S as XM, T as ek, U as tk, V as nk, W as rk, X as tf, Y as ik, Z as pb, _ as yy, $ as ok, a0 as sk, a1 as ak, a2 as lk, a3 as uk, a4 as mb, a5 as ck, a6 as fk, a7 as dk, a8 as hk, a9 as vy, aa as pk, ab as mk, ac as gk, ad as yk, ae as vk, af as _k, ag as wk, ah as bk, ai as Tk, aj as Ck, ak as Sk, al as Ek, am as Ak, an as xk, ao as Rk, ap as Ik, aq as Mk, ar as kk, as as Pk, at as jh, au as Il, av as Ok, aw as Lk, ax as Nk, ay as Dk, az as gb, aA as ah, aB as st, aC as Fk, aD as $k, aE as Uk, aF as qk, aG as yb, aH as vb, aI as Bk, aJ as Vk, aK as Hk, aL as Gk, aM as Wk, aN as Kk } from "./color-Bf2jGwiV.js";
import * as Jk from "node:fs/promises";
import ro, { readdir as zk, stat as Yk, readFile as li, mkdir as Qh, writeFile as Xh, unlink as Zk } from "node:fs/promises";
import * as jk from "node:path";
import Je, { join as Qk } from "node:path";
import { f as Dr, i as Xk } from "./client-DfrJv231.js";
import * as eP from "node:child_process";
import tP, { exec as ii, spawn as tu } from "node:child_process";
import ep from "node:events";
import uo, { fstatSync as nP, readlinkSync as rP } from "node:fs";
import iP, { stderr as Ge, stdout as tt } from "node:process";
import { randomBytes as oP } from "node:crypto";
import gr, { homedir as nu, platform as sP } from "node:os";
import Jn, { promisify as _b, isDeepStrictEqual as aP } from "node:util";
import ru from "node:buffer";
import lP from "node:zlib";
import uP from "node:string_decoder";
import cP, { createServer as wb } from "node:http";
import fP from "node:https";
function dP() {
  const r = /* @__PURE__ */ new Set(), t = new Nr(r);
  return {
    add(e) {
      r.add(e), t.next(r);
    },
    delete(e) {
      r.delete(e), t.next(r);
    },
    set: r,
    observable: t
  };
}
function hP() {
  const r = /* @__PURE__ */ new Map(), t = new Nr(r);
  return {
    get(e) {
      return r.get(e);
    },
    set(e, n) {
      r.set(e, n), t.next(r);
    },
    delete(e) {
      r.delete(e), t.next(r);
    },
    map: r,
    observable: t
  };
}
const $r = Symbol.for("@@pendingOperation");
function _y(r, t) {
  return (e) => It.from(e).pipe(
    Gn(
      (n) => n === $r ? It.of($r) : r(n).pipe(
        ub(
          (i) => It.of(i instanceof Error ? i : new Error(i))
        ),
        ur($r)
      )
    ),
    eu(t)
  );
}
function pP() {
  return (r) => It.from(r).pipe(is((t) => t !== $r));
}
async function mP(r, t) {
  const e = await it(
    It.from(r).pipe(pP()),
    t
  );
  if (e instanceof Error)
    throw e;
  return e;
}
const gP = new URL("https://ampcode.com/"), qr = gP.toString(), yP = new URL("https://api.anthropic.com/");
yP.toString();
function vP(r) {
  const t = typeof r == "string" ? r : r.toString();
  return t === qr || t === qr.slice(0, -1);
}
const _P = ["apiKey"];
function wP({
  storage: r,
  secretStorage: t,
  workspaceRoots: e,
  defaultAmpURL: n = qr
}) {
  const i = ms(async () => {
    const s = await r.keys();
    return Object.fromEntries(
      await Promise.all(s.map(async (l) => [l, await r.get(l)]))
    );
  }).pipe(
    Gn(
      (s) => cb(
        It.of(s),
        r.changes.pipe(
          ys(async (u) => (await Promise.all(
            u.map(async (l) => {
              const c = await r.get(l);
              s[l] = c;
            })
          ), s))
        )
      )
    ),
    at((s) => ({
      ...s,
      url: s.url || n
    })),
    eu(),
    gs()
  ), o = kn(
    t.changes.pipe(ur(void 0)),
    i.pipe(
      at(({ url: s }) => s),
      gs()
    )
  ).pipe(
    ys(
      async ([, s]) => ({
        getToken: async (u, l) => t.get(u, l),
        isSet: {
          [s]: Object.fromEntries(
            await Promise.all(
              _P.map(async (u) => [
                u,
                !!await t.get(u, s)
              ])
            )
          )
        }
      })
    )
  );
  return BM(
    kn(i, o).pipe(
      at(
        ([s, u]) => ({
          settings: s,
          secrets: u
        })
      )
    )
  ), {
    updateSettings(s, u, l) {
      return r.set(s, u, l);
    },
    async appendSettings(s, u, l) {
      const c = await r.get(s, l);
      if (c === void 0)
        return r.set(s, u, l);
      if (Array.isArray(c)) {
        if (c.length === 0)
          return r.set(s, u, l);
        {
          const d = [...c, ...u];
          return r.set(s, d, l);
        }
      } else throw new Error(`Cannot append to non-array setting: ${s}`);
    },
    updateSecret(s, u, l) {
      return t.set(s, u, l);
    },
    workspaceRoots: e
  };
}
function bP(r) {
  const t = ["prompt is too long", "exceed context limit"], e = r.error?.type === "invalid_request_error" && t.some((i) => r.error?.message?.includes(i)), n = t.some(
    (i) => r.message?.includes(i)
  );
  return e || n;
}
var Xe;
(function(r) {
  r.assertEqual = (i) => {
  };
  function t(i) {
  }
  r.assertIs = t;
  function e(i) {
    throw new Error();
  }
  r.assertNever = e, r.arrayToEnum = (i) => {
    const o = {};
    for (const s of i)
      o[s] = s;
    return o;
  }, r.getValidEnumValues = (i) => {
    const o = r.objectKeys(i).filter((u) => typeof i[i[u]] != "number"), s = {};
    for (const u of o)
      s[u] = i[u];
    return r.objectValues(s);
  }, r.objectValues = (i) => r.objectKeys(i).map(function(o) {
    return i[o];
  }), r.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
    return o;
  }, r.find = (i, o) => {
    for (const s of i)
      if (o(s))
        return s;
  }, r.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && Number.isFinite(i) && Math.floor(i) === i;
  function n(i, o = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(o);
  }
  r.joinValues = n, r.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
})(Xe || (Xe = {}));
var wy;
(function(r) {
  r.mergeShapes = (t, e) => ({
    ...t,
    ...e
    // second overwrites first
  });
})(wy || (wy = {}));
const be = Xe.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), kr = (r) => {
  switch (typeof r) {
    case "undefined":
      return be.undefined;
    case "string":
      return be.string;
    case "number":
      return Number.isNaN(r) ? be.nan : be.number;
    case "boolean":
      return be.boolean;
    case "function":
      return be.function;
    case "bigint":
      return be.bigint;
    case "symbol":
      return be.symbol;
    case "object":
      return Array.isArray(r) ? be.array : r === null ? be.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? be.promise : typeof Map < "u" && r instanceof Map ? be.map : typeof Set < "u" && r instanceof Set ? be.set : typeof Date < "u" && r instanceof Date ? be.date : be.object;
    default:
      return be.unknown;
  }
}, pe = Xe.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class mr extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const e = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, e) : this.__proto__ = e, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const e = t || function(o) {
      return o.message;
    }, n = { _errors: [] }, i = (o) => {
      for (const s of o.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          n._errors.push(e(s));
        else {
          let u = n, l = 0;
          for (; l < s.path.length; ) {
            const c = s.path[l];
            l === s.path.length - 1 ? (u[c] = u[c] || { _errors: [] }, u[c]._errors.push(e(s))) : u[c] = u[c] || { _errors: [] }, u = u[c], l++;
          }
        }
    };
    return i(this), n;
  }
  static assert(t) {
    if (!(t instanceof mr))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Xe.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (e) => e.message) {
    const e = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (e[i.path[0]] = e[i.path[0]] || [], e[i.path[0]].push(t(i))) : n.push(t(i));
    return { formErrors: n, fieldErrors: e };
  }
  get formErrors() {
    return this.flatten();
  }
}
mr.create = (r) => new mr(r);
const lh = (r, t) => {
  let e;
  switch (r.code) {
    case pe.invalid_type:
      r.received === be.undefined ? e = "Required" : e = `Expected ${r.expected}, received ${r.received}`;
      break;
    case pe.invalid_literal:
      e = `Invalid literal value, expected ${JSON.stringify(r.expected, Xe.jsonStringifyReplacer)}`;
      break;
    case pe.unrecognized_keys:
      e = `Unrecognized key(s) in object: ${Xe.joinValues(r.keys, ", ")}`;
      break;
    case pe.invalid_union:
      e = "Invalid input";
      break;
    case pe.invalid_union_discriminator:
      e = `Invalid discriminator value. Expected ${Xe.joinValues(r.options)}`;
      break;
    case pe.invalid_enum_value:
      e = `Invalid enum value. Expected ${Xe.joinValues(r.options)}, received '${r.received}'`;
      break;
    case pe.invalid_arguments:
      e = "Invalid function arguments";
      break;
    case pe.invalid_return_type:
      e = "Invalid function return type";
      break;
    case pe.invalid_date:
      e = "Invalid date";
      break;
    case pe.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (e = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (e = `${e} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? e = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? e = `Invalid input: must end with "${r.validation.endsWith}"` : Xe.assertNever(r.validation) : r.validation !== "regex" ? e = `Invalid ${r.validation}` : e = "Invalid";
      break;
    case pe.too_small:
      r.type === "array" ? e = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? e = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? e = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? e = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : e = "Invalid input";
      break;
    case pe.too_big:
      r.type === "array" ? e = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? e = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? e = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? e = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? e = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : e = "Invalid input";
      break;
    case pe.custom:
      e = "Invalid input";
      break;
    case pe.invalid_intersection_types:
      e = "Intersection results could not be merged";
      break;
    case pe.not_multiple_of:
      e = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case pe.not_finite:
      e = "Number must be finite";
      break;
    default:
      e = t.defaultError, Xe.assertNever(r);
  }
  return { message: e };
};
let TP = lh;
function CP() {
  return TP;
}
const SP = (r) => {
  const { data: t, path: e, errorMaps: n, issueData: i } = r, o = [...e, ...i.path || []], s = {
    ...i,
    path: o
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: o,
      message: i.message
    };
  let u = "";
  const l = n.filter((c) => !!c).slice().reverse();
  for (const c of l)
    u = c(s, { data: t, defaultError: u }).message;
  return {
    ...i,
    path: o,
    message: u
  };
};
function _e(r, t) {
  const e = CP(), n = SP({
    issueData: t,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      // contextual error map is first priority
      r.schemaErrorMap,
      // then schema-bound map if available
      e,
      // then global override map
      e === lh ? void 0 : lh
      // then global default map
    ].filter((i) => !!i)
  });
  r.common.issues.push(n);
}
class Vt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, e) {
    const n = [];
    for (const i of e) {
      if (i.status === "aborted")
        return Oe;
      i.status === "dirty" && t.dirty(), n.push(i.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, e) {
    const n = [];
    for (const i of e) {
      const o = await i.key, s = await i.value;
      n.push({
        key: o,
        value: s
      });
    }
    return Vt.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, e) {
    const n = {};
    for (const i of e) {
      const { key: o, value: s } = i;
      if (o.status === "aborted" || s.status === "aborted")
        return Oe;
      o.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), o.value !== "__proto__" && (typeof s.value < "u" || i.alwaysSet) && (n[o.value] = s.value);
    }
    return { status: t.value, value: n };
  }
}
const Oe = Object.freeze({
  status: "aborted"
}), jo = (r) => ({ status: "dirty", value: r }), Cn = (r) => ({ status: "valid", value: r }), by = (r) => r.status === "aborted", Ty = (r) => r.status === "dirty", co = (r) => r.status === "valid", Ml = (r) => typeof Promise < "u" && r instanceof Promise;
var Ee;
(function(r) {
  r.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, r.toString = (t) => typeof t == "string" ? t : t?.message;
})(Ee || (Ee = {}));
var kl = function(r, t, e, n) {
  if (e === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? r !== t || !n : !t.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return e === "m" ? n : e === "a" ? n.call(r) : n ? n.value : t.get(r);
}, bb = function(r, t, e, n, i) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? r !== t || !i : !t.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? i.call(r, e) : i ? i.value = e : t.set(r, e), e;
}, Qo, Xo;
class Wn {
  constructor(t, e, n, i) {
    this._cachedPath = [], this.parent = t, this.data = e, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Cy = (r, t) => {
  if (co(t))
    return { success: !0, data: t.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const e = new mr(r.common.issues);
      return this._error = e, this._error;
    }
  };
};
function qe(r) {
  if (!r)
    return {};
  const { errorMap: t, invalid_type_error: e, required_error: n, description: i } = r;
  if (t && (e || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (s, u) => {
    const { message: l } = r;
    return s.code === "invalid_enum_value" ? { message: l ?? u.defaultError } : typeof u.data > "u" ? { message: l ?? n ?? u.defaultError } : s.code !== "invalid_type" ? { message: u.defaultError } : { message: l ?? e ?? u.defaultError };
  }, description: i };
}
class Ye {
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return kr(t.data);
  }
  _getOrReturnCtx(t, e) {
    return e || {
      common: t.parent.common,
      data: t.data,
      parsedType: kr(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Vt(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: kr(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const e = this._parse(t);
    if (Ml(e))
      throw new Error("Synchronous parse encountered promise.");
    return e;
  }
  _parseAsync(t) {
    const e = this._parse(t);
    return Promise.resolve(e);
  }
  parse(t, e) {
    const n = this.safeParse(t, e);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, e) {
    const n = {
      common: {
        issues: [],
        async: e?.async ?? !1,
        contextualErrorMap: e?.errorMap
      },
      path: e?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: kr(t)
    }, i = this._parseSync({ data: t, path: n.path, parent: n });
    return Cy(n, i);
  }
  "~validate"(t) {
    const e = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: kr(t)
    };
    if (!this["~standard"].async)
      try {
        const n = this._parseSync({ data: t, path: [], parent: e });
        return co(n) ? {
          value: n.value
        } : {
          issues: e.common.issues
        };
      } catch (n) {
        n?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), e.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: t, path: [], parent: e }).then((n) => co(n) ? {
      value: n.value
    } : {
      issues: e.common.issues
    });
  }
  async parseAsync(t, e) {
    const n = await this.safeParseAsync(t, e);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, e) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: e?.errorMap,
        async: !0
      },
      path: e?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: kr(t)
    }, i = this._parse({ data: t, path: n.path, parent: n }), o = await (Ml(i) ? i : Promise.resolve(i));
    return Cy(n, o);
  }
  refine(t, e) {
    const n = (i) => typeof e == "string" || typeof e > "u" ? { message: e } : typeof e == "function" ? e(i) : e;
    return this._refinement((i, o) => {
      const s = t(i), u = () => o.addIssue({
        code: pe.custom,
        ...n(i)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((l) => l ? !0 : (u(), !1)) : s ? !0 : (u(), !1);
    });
  }
  refinement(t, e) {
    return this._refinement((n, i) => t(n) ? !0 : (i.addIssue(typeof e == "function" ? e(n, i) : e), !1));
  }
  _refinement(t) {
    return new gi({
      schema: this,
      typeName: Pe.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (e) => this["~validate"](e)
    };
  }
  optional() {
    return fr.create(this, this._def);
  }
  nullable() {
    return yi.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Vn.create(this);
  }
  promise() {
    return $l.create(this, this._def);
  }
  or(t) {
    return Ol.create([this, t], this._def);
  }
  and(t) {
    return Ll.create(this, t, this._def);
  }
  transform(t) {
    return new gi({
      ...qe(this._def),
      schema: this,
      typeName: Pe.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const e = typeof t == "function" ? t : () => t;
    return new Ul({
      ...qe(this._def),
      innerType: this,
      defaultValue: e,
      typeName: Pe.ZodDefault
    });
  }
  brand() {
    return new Eb({
      typeName: Pe.ZodBranded,
      type: this,
      ...qe(this._def)
    });
  }
  catch(t) {
    const e = typeof t == "function" ? t : () => t;
    return new ql({
      ...qe(this._def),
      innerType: this,
      catchValue: e,
      typeName: Pe.ZodCatch
    });
  }
  describe(t) {
    const e = this.constructor;
    return new e({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return np.create(this, t);
  }
  readonly() {
    return Bl.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const EP = /^c[^\s-]{8,}$/i, AP = /^[0-9a-z]+$/, xP = /^[0-9A-HJKMNP-TV-Z]{26}$/i, RP = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, IP = /^[a-z0-9_-]{21}$/i, MP = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, kP = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, PP = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, OP = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let nf;
const LP = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, NP = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, DP = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, FP = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, $P = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, UP = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Tb = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", qP = new RegExp(`^${Tb}$`);
function Cb(r) {
  let t = "[0-5]\\d";
  r.precision ? t = `${t}\\.\\d{${r.precision}}` : r.precision == null && (t = `${t}(\\.\\d+)?`);
  const e = r.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${t})${e}`;
}
function BP(r) {
  return new RegExp(`^${Cb(r)}$`);
}
function VP(r) {
  let t = `${Tb}T${Cb(r)}`;
  const e = [];
  return e.push(r.local ? "Z?" : "Z"), r.offset && e.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${e.join("|")})`, new RegExp(`^${t}$`);
}
function HP(r, t) {
  return !!((t === "v4" || !t) && LP.test(r) || (t === "v6" || !t) && DP.test(r));
}
function GP(r, t) {
  if (!MP.test(r))
    return !1;
  try {
    const [e] = r.split("."), n = e.replace(/-/g, "+").replace(/_/g, "/").padEnd(e.length + (4 - e.length % 4) % 4, "="), i = JSON.parse(atob(n));
    return !(typeof i != "object" || i === null || "typ" in i && i?.typ !== "JWT" || !i.alg || t && i.alg !== t);
  } catch {
    return !1;
  }
}
function WP(r, t) {
  return !!((t === "v4" || !t) && NP.test(r) || (t === "v6" || !t) && FP.test(r));
}
class Bn extends Ye {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== be.string) {
      const o = this._getOrReturnCtx(t);
      return _e(o, {
        code: pe.invalid_type,
        expected: be.string,
        received: o.parsedType
      }), Oe;
    }
    const n = new Vt();
    let i;
    for (const o of this._def.checks)
      if (o.kind === "min")
        t.data.length < o.value && (i = this._getOrReturnCtx(t, i), _e(i, {
          code: pe.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), n.dirty());
      else if (o.kind === "max")
        t.data.length > o.value && (i = this._getOrReturnCtx(t, i), _e(i, {
          code: pe.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), n.dirty());
      else if (o.kind === "length") {
        const s = t.data.length > o.value, u = t.data.length < o.value;
        (s || u) && (i = this._getOrReturnCtx(t, i), s ? _e(i, {
          code: pe.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }) : u && _e(i, {
          code: pe.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }), n.dirty());
      } else if (o.kind === "email")
        PP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
          validation: "email",
          code: pe.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "emoji")
        nf || (nf = new RegExp(OP, "u")), nf.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
          validation: "emoji",
          code: pe.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "uuid")
        RP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
          validation: "uuid",
          code: pe.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "nanoid")
        IP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
          validation: "nanoid",
          code: pe.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "cuid")
        EP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
          validation: "cuid",
          code: pe.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "cuid2")
        AP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
          validation: "cuid2",
          code: pe.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "ulid")
        xP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
          validation: "ulid",
          code: pe.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), _e(i, {
            validation: "url",
            code: pe.invalid_string,
            message: o.message
          }), n.dirty();
        }
      else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
        validation: "regex",
        code: pe.invalid_string,
        message: o.message
      }), n.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.invalid_string,
        validation: { includes: o.value, position: o.position },
        message: o.message
      }), n.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.invalid_string,
        validation: { startsWith: o.value },
        message: o.message
      }), n.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.invalid_string,
        validation: { endsWith: o.value },
        message: o.message
      }), n.dirty()) : o.kind === "datetime" ? VP(o).test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.invalid_string,
        validation: "datetime",
        message: o.message
      }), n.dirty()) : o.kind === "date" ? qP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.invalid_string,
        validation: "date",
        message: o.message
      }), n.dirty()) : o.kind === "time" ? BP(o).test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.invalid_string,
        validation: "time",
        message: o.message
      }), n.dirty()) : o.kind === "duration" ? kP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
        validation: "duration",
        code: pe.invalid_string,
        message: o.message
      }), n.dirty()) : o.kind === "ip" ? HP(t.data, o.version) || (i = this._getOrReturnCtx(t, i), _e(i, {
        validation: "ip",
        code: pe.invalid_string,
        message: o.message
      }), n.dirty()) : o.kind === "jwt" ? GP(t.data, o.alg) || (i = this._getOrReturnCtx(t, i), _e(i, {
        validation: "jwt",
        code: pe.invalid_string,
        message: o.message
      }), n.dirty()) : o.kind === "cidr" ? WP(t.data, o.version) || (i = this._getOrReturnCtx(t, i), _e(i, {
        validation: "cidr",
        code: pe.invalid_string,
        message: o.message
      }), n.dirty()) : o.kind === "base64" ? $P.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
        validation: "base64",
        code: pe.invalid_string,
        message: o.message
      }), n.dirty()) : o.kind === "base64url" ? UP.test(t.data) || (i = this._getOrReturnCtx(t, i), _e(i, {
        validation: "base64url",
        code: pe.invalid_string,
        message: o.message
      }), n.dirty()) : Xe.assertNever(o);
    return { status: n.value, value: t.data };
  }
  _regex(t, e, n) {
    return this.refinement((i) => t.test(i), {
      validation: e,
      code: pe.invalid_string,
      ...Ee.errToObj(n)
    });
  }
  _addCheck(t) {
    return new Bn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Ee.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Ee.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Ee.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Ee.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...Ee.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Ee.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Ee.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Ee.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...Ee.errToObj(t) });
  }
  base64url(t) {
    return this._addCheck({
      kind: "base64url",
      ...Ee.errToObj(t)
    });
  }
  jwt(t) {
    return this._addCheck({ kind: "jwt", ...Ee.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Ee.errToObj(t) });
  }
  cidr(t) {
    return this._addCheck({ kind: "cidr", ...Ee.errToObj(t) });
  }
  datetime(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      offset: t?.offset ?? !1,
      local: t?.local ?? !1,
      ...Ee.errToObj(t?.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof t?.precision > "u" ? null : t?.precision,
      ...Ee.errToObj(t?.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...Ee.errToObj(t) });
  }
  regex(t, e) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Ee.errToObj(e)
    });
  }
  includes(t, e) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: e?.position,
      ...Ee.errToObj(e?.message)
    });
  }
  startsWith(t, e) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Ee.errToObj(e)
    });
  }
  endsWith(t, e) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Ee.errToObj(e)
    });
  }
  min(t, e) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Ee.errToObj(e)
    });
  }
  max(t, e) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Ee.errToObj(e)
    });
  }
  length(t, e) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Ee.errToObj(e)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(t) {
    return this.min(1, Ee.errToObj(t));
  }
  trim() {
    return new Bn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Bn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Bn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url");
  }
  get minLength() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
}
Bn.create = (r) => new Bn({
  checks: [],
  typeName: Pe.ZodString,
  coerce: r?.coerce ?? !1,
  ...qe(r)
});
function KP(r, t) {
  const e = (r.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = e > n ? e : n, o = Number.parseInt(r.toFixed(i).replace(".", "")), s = Number.parseInt(t.toFixed(i).replace(".", ""));
  return o % s / 10 ** i;
}
class di extends Ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== be.number) {
      const o = this._getOrReturnCtx(t);
      return _e(o, {
        code: pe.invalid_type,
        expected: be.number,
        received: o.parsedType
      }), Oe;
    }
    let n;
    const i = new Vt();
    for (const o of this._def.checks)
      o.kind === "int" ? Xe.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? KP(t.data, o.value) !== 0 && (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.not_finite,
        message: o.message
      }), i.dirty()) : Xe.assertNever(o);
    return { status: i.value, value: t.data };
  }
  gte(t, e) {
    return this.setLimit("min", t, !0, Ee.toString(e));
  }
  gt(t, e) {
    return this.setLimit("min", t, !1, Ee.toString(e));
  }
  lte(t, e) {
    return this.setLimit("max", t, !0, Ee.toString(e));
  }
  lt(t, e) {
    return this.setLimit("max", t, !1, Ee.toString(e));
  }
  setLimit(t, e, n, i) {
    return new di({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: e,
          inclusive: n,
          message: Ee.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new di({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Ee.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Ee.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Ee.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Ee.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Ee.toString(t)
    });
  }
  multipleOf(t, e) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ee.toString(e)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Ee.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ee.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Ee.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Xe.isInteger(t.value));
  }
  get isFinite() {
    let t = null, e = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (e === null || n.value > e) && (e = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(e) && Number.isFinite(t);
  }
}
di.create = (r) => new di({
  checks: [],
  typeName: Pe.ZodNumber,
  coerce: r?.coerce || !1,
  ...qe(r)
});
class hi extends Ye {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data);
      } catch {
        return this._getInvalidInput(t);
      }
    if (this._getType(t) !== be.bigint)
      return this._getInvalidInput(t);
    let n;
    const i = new Vt();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), _e(n, {
        code: pe.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : Xe.assertNever(o);
    return { status: i.value, value: t.data };
  }
  _getInvalidInput(t) {
    const e = this._getOrReturnCtx(t);
    return _e(e, {
      code: pe.invalid_type,
      expected: be.bigint,
      received: e.parsedType
    }), Oe;
  }
  gte(t, e) {
    return this.setLimit("min", t, !0, Ee.toString(e));
  }
  gt(t, e) {
    return this.setLimit("min", t, !1, Ee.toString(e));
  }
  lte(t, e) {
    return this.setLimit("max", t, !0, Ee.toString(e));
  }
  lt(t, e) {
    return this.setLimit("max", t, !1, Ee.toString(e));
  }
  setLimit(t, e, n, i) {
    return new hi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: e,
          inclusive: n,
          message: Ee.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new hi({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Ee.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Ee.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Ee.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Ee.toString(t)
    });
  }
  multipleOf(t, e) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ee.toString(e)
    });
  }
  get minValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t;
  }
}
hi.create = (r) => new hi({
  checks: [],
  typeName: Pe.ZodBigInt,
  coerce: r?.coerce ?? !1,
  ...qe(r)
});
class Pl extends Ye {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== be.boolean) {
      const n = this._getOrReturnCtx(t);
      return _e(n, {
        code: pe.invalid_type,
        expected: be.boolean,
        received: n.parsedType
      }), Oe;
    }
    return Cn(t.data);
  }
}
Pl.create = (r) => new Pl({
  typeName: Pe.ZodBoolean,
  coerce: r?.coerce || !1,
  ...qe(r)
});
class fo extends Ye {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== be.date) {
      const o = this._getOrReturnCtx(t);
      return _e(o, {
        code: pe.invalid_type,
        expected: be.date,
        received: o.parsedType
      }), Oe;
    }
    if (Number.isNaN(t.data.getTime())) {
      const o = this._getOrReturnCtx(t);
      return _e(o, {
        code: pe.invalid_date
      }), Oe;
    }
    const n = new Vt();
    let i;
    for (const o of this._def.checks)
      o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.too_small,
        message: o.message,
        inclusive: !0,
        exact: !1,
        minimum: o.value,
        type: "date"
      }), n.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), _e(i, {
        code: pe.too_big,
        message: o.message,
        inclusive: !0,
        exact: !1,
        maximum: o.value,
        type: "date"
      }), n.dirty()) : Xe.assertNever(o);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new fo({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, e) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Ee.toString(e)
    });
  }
  max(t, e) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Ee.toString(e)
    });
  }
  get minDate() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "min" && (t === null || e.value > t) && (t = e.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const e of this._def.checks)
      e.kind === "max" && (t === null || e.value < t) && (t = e.value);
    return t != null ? new Date(t) : null;
  }
}
fo.create = (r) => new fo({
  checks: [],
  coerce: r?.coerce || !1,
  typeName: Pe.ZodDate,
  ...qe(r)
});
class Sy extends Ye {
  _parse(t) {
    if (this._getType(t) !== be.symbol) {
      const n = this._getOrReturnCtx(t);
      return _e(n, {
        code: pe.invalid_type,
        expected: be.symbol,
        received: n.parsedType
      }), Oe;
    }
    return Cn(t.data);
  }
}
Sy.create = (r) => new Sy({
  typeName: Pe.ZodSymbol,
  ...qe(r)
});
class uh extends Ye {
  _parse(t) {
    if (this._getType(t) !== be.undefined) {
      const n = this._getOrReturnCtx(t);
      return _e(n, {
        code: pe.invalid_type,
        expected: be.undefined,
        received: n.parsedType
      }), Oe;
    }
    return Cn(t.data);
  }
}
uh.create = (r) => new uh({
  typeName: Pe.ZodUndefined,
  ...qe(r)
});
class ch extends Ye {
  _parse(t) {
    if (this._getType(t) !== be.null) {
      const n = this._getOrReturnCtx(t);
      return _e(n, {
        code: pe.invalid_type,
        expected: be.null,
        received: n.parsedType
      }), Oe;
    }
    return Cn(t.data);
  }
}
ch.create = (r) => new ch({
  typeName: Pe.ZodNull,
  ...qe(r)
});
class fh extends Ye {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Cn(t.data);
  }
}
fh.create = (r) => new fh({
  typeName: Pe.ZodAny,
  ...qe(r)
});
class dh extends Ye {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Cn(t.data);
  }
}
dh.create = (r) => new dh({
  typeName: Pe.ZodUnknown,
  ...qe(r)
});
class Br extends Ye {
  _parse(t) {
    const e = this._getOrReturnCtx(t);
    return _e(e, {
      code: pe.invalid_type,
      expected: be.never,
      received: e.parsedType
    }), Oe;
  }
}
Br.create = (r) => new Br({
  typeName: Pe.ZodNever,
  ...qe(r)
});
class Ey extends Ye {
  _parse(t) {
    if (this._getType(t) !== be.undefined) {
      const n = this._getOrReturnCtx(t);
      return _e(n, {
        code: pe.invalid_type,
        expected: be.void,
        received: n.parsedType
      }), Oe;
    }
    return Cn(t.data);
  }
}
Ey.create = (r) => new Ey({
  typeName: Pe.ZodVoid,
  ...qe(r)
});
class Vn extends Ye {
  _parse(t) {
    const { ctx: e, status: n } = this._processInputParams(t), i = this._def;
    if (e.parsedType !== be.array)
      return _e(e, {
        code: pe.invalid_type,
        expected: be.array,
        received: e.parsedType
      }), Oe;
    if (i.exactLength !== null) {
      const s = e.data.length > i.exactLength.value, u = e.data.length < i.exactLength.value;
      (s || u) && (_e(e, {
        code: s ? pe.too_big : pe.too_small,
        minimum: u ? i.exactLength.value : void 0,
        maximum: s ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && e.data.length < i.minLength.value && (_e(e, {
      code: pe.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && e.data.length > i.maxLength.value && (_e(e, {
      code: pe.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), e.common.async)
      return Promise.all([...e.data].map((s, u) => i.type._parseAsync(new Wn(e, s, e.path, u)))).then((s) => Vt.mergeArray(n, s));
    const o = [...e.data].map((s, u) => i.type._parseSync(new Wn(e, s, e.path, u)));
    return Vt.mergeArray(n, o);
  }
  get element() {
    return this._def.type;
  }
  min(t, e) {
    return new Vn({
      ...this._def,
      minLength: { value: t, message: Ee.toString(e) }
    });
  }
  max(t, e) {
    return new Vn({
      ...this._def,
      maxLength: { value: t, message: Ee.toString(e) }
    });
  }
  length(t, e) {
    return new Vn({
      ...this._def,
      exactLength: { value: t, message: Ee.toString(e) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Vn.create = (r, t) => new Vn({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Pe.ZodArray,
  ...qe(t)
});
function Gi(r) {
  if (r instanceof St) {
    const t = {};
    for (const e in r.shape) {
      const n = r.shape[e];
      t[e] = fr.create(Gi(n));
    }
    return new St({
      ...r._def,
      shape: () => t
    });
  } else return r instanceof Vn ? new Vn({
    ...r._def,
    type: Gi(r.element)
  }) : r instanceof fr ? fr.create(Gi(r.unwrap())) : r instanceof yi ? yi.create(Gi(r.unwrap())) : r instanceof pi ? pi.create(r.items.map((t) => Gi(t))) : r;
}
class St extends Ye {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), e = Xe.objectKeys(t);
    return this._cached = { shape: t, keys: e }, this._cached;
  }
  _parse(t) {
    if (this._getType(t) !== be.object) {
      const c = this._getOrReturnCtx(t);
      return _e(c, {
        code: pe.invalid_type,
        expected: be.object,
        received: c.parsedType
      }), Oe;
    }
    const { status: n, ctx: i } = this._processInputParams(t), { shape: o, keys: s } = this._getCached(), u = [];
    if (!(this._def.catchall instanceof Br && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        s.includes(c) || u.push(c);
    const l = [];
    for (const c of s) {
      const d = o[c], g = i.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: d._parse(new Wn(i, g, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof Br) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const d of u)
          l.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: i.data[d] }
          });
      else if (c === "strict")
        u.length > 0 && (_e(i, {
          code: pe.unrecognized_keys,
          keys: u
        }), n.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const d of u) {
        const g = i.data[d];
        l.push({
          key: { status: "valid", value: d },
          value: c._parse(
            new Wn(i, g, i.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const d of l) {
        const g = await d.key, y = await d.value;
        c.push({
          key: g,
          value: y,
          alwaysSet: d.alwaysSet
        });
      }
      return c;
    }).then((c) => Vt.mergeObjectSync(n, c)) : Vt.mergeObjectSync(n, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Ee.errToObj, new St({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (e, n) => {
          const i = this._def.errorMap?.(e, n).message ?? n.defaultError;
          return e.code === "unrecognized_keys" ? {
            message: Ee.errToObj(t).message ?? i
          } : {
            message: i
          };
        }
      } : {}
    });
  }
  strip() {
    return new St({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new St({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new St({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new St({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Pe.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, e) {
    return this.augment({ [t]: e });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new St({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const e = {};
    for (const n of Xe.objectKeys(t))
      t[n] && this.shape[n] && (e[n] = this.shape[n]);
    return new St({
      ...this._def,
      shape: () => e
    });
  }
  omit(t) {
    const e = {};
    for (const n of Xe.objectKeys(this.shape))
      t[n] || (e[n] = this.shape[n]);
    return new St({
      ...this._def,
      shape: () => e
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Gi(this);
  }
  partial(t) {
    const e = {};
    for (const n of Xe.objectKeys(this.shape)) {
      const i = this.shape[n];
      t && !t[n] ? e[n] = i : e[n] = i.optional();
    }
    return new St({
      ...this._def,
      shape: () => e
    });
  }
  required(t) {
    const e = {};
    for (const n of Xe.objectKeys(this.shape))
      if (t && !t[n])
        e[n] = this.shape[n];
      else {
        let o = this.shape[n];
        for (; o instanceof fr; )
          o = o._def.innerType;
        e[n] = o;
      }
    return new St({
      ...this._def,
      shape: () => e
    });
  }
  keyof() {
    return Sb(Xe.objectKeys(this.shape));
  }
}
St.create = (r, t) => new St({
  shape: () => r,
  unknownKeys: "strip",
  catchall: Br.create(),
  typeName: Pe.ZodObject,
  ...qe(t)
});
St.strictCreate = (r, t) => new St({
  shape: () => r,
  unknownKeys: "strict",
  catchall: Br.create(),
  typeName: Pe.ZodObject,
  ...qe(t)
});
St.lazycreate = (r, t) => new St({
  shape: r,
  unknownKeys: "strip",
  catchall: Br.create(),
  typeName: Pe.ZodObject,
  ...qe(t)
});
class Ol extends Ye {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t), n = this._def.options;
    function i(o) {
      for (const u of o)
        if (u.result.status === "valid")
          return u.result;
      for (const u of o)
        if (u.result.status === "dirty")
          return e.common.issues.push(...u.ctx.common.issues), u.result;
      const s = o.map((u) => new mr(u.ctx.common.issues));
      return _e(e, {
        code: pe.invalid_union,
        unionErrors: s
      }), Oe;
    }
    if (e.common.async)
      return Promise.all(n.map(async (o) => {
        const s = {
          ...e,
          common: {
            ...e.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await o._parseAsync({
            data: e.data,
            path: e.path,
            parent: s
          }),
          ctx: s
        };
      })).then(i);
    {
      let o;
      const s = [];
      for (const l of n) {
        const c = {
          ...e,
          common: {
            ...e.common,
            issues: []
          },
          parent: null
        }, d = l._parseSync({
          data: e.data,
          path: e.path,
          parent: c
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !o && (o = { result: d, ctx: c }), c.common.issues.length && s.push(c.common.issues);
      }
      if (o)
        return e.common.issues.push(...o.ctx.common.issues), o.result;
      const u = s.map((l) => new mr(l));
      return _e(e, {
        code: pe.invalid_union,
        unionErrors: u
      }), Oe;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ol.create = (r, t) => new Ol({
  options: r,
  typeName: Pe.ZodUnion,
  ...qe(t)
});
const sr = (r) => r instanceof Dl ? sr(r.schema) : r instanceof gi ? sr(r.innerType()) : r instanceof Fl ? [r.value] : r instanceof mi ? r.options : r instanceof ph ? Xe.objectValues(r.enum) : r instanceof Ul ? sr(r._def.innerType) : r instanceof uh ? [void 0] : r instanceof ch ? [null] : r instanceof fr ? [void 0, ...sr(r.unwrap())] : r instanceof yi ? [null, ...sr(r.unwrap())] : r instanceof Eb || r instanceof Bl ? sr(r.unwrap()) : r instanceof ql ? sr(r._def.innerType) : [];
class tp extends Ye {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== be.object)
      return _e(e, {
        code: pe.invalid_type,
        expected: be.object,
        received: e.parsedType
      }), Oe;
    const n = this.discriminator, i = e.data[n], o = this.optionsMap.get(i);
    return o ? e.common.async ? o._parseAsync({
      data: e.data,
      path: e.path,
      parent: e
    }) : o._parseSync({
      data: e.data,
      path: e.path,
      parent: e
    }) : (_e(e, {
      code: pe.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), Oe);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, e, n) {
    const i = /* @__PURE__ */ new Map();
    for (const o of e) {
      const s = sr(o.shape[t]);
      if (!s.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const u of s) {
        if (i.has(u))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(u)}`);
        i.set(u, o);
      }
    }
    return new tp({
      typeName: Pe.ZodDiscriminatedUnion,
      discriminator: t,
      options: e,
      optionsMap: i,
      ...qe(n)
    });
  }
}
function hh(r, t) {
  const e = kr(r), n = kr(t);
  if (r === t)
    return { valid: !0, data: r };
  if (e === be.object && n === be.object) {
    const i = Xe.objectKeys(t), o = Xe.objectKeys(r).filter((u) => i.indexOf(u) !== -1), s = { ...r, ...t };
    for (const u of o) {
      const l = hh(r[u], t[u]);
      if (!l.valid)
        return { valid: !1 };
      s[u] = l.data;
    }
    return { valid: !0, data: s };
  } else if (e === be.array && n === be.array) {
    if (r.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let o = 0; o < r.length; o++) {
      const s = r[o], u = t[o], l = hh(s, u);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else return e === be.date && n === be.date && +r == +t ? { valid: !0, data: r } : { valid: !1 };
}
class Ll extends Ye {
  _parse(t) {
    const { status: e, ctx: n } = this._processInputParams(t), i = (o, s) => {
      if (by(o) || by(s))
        return Oe;
      const u = hh(o.value, s.value);
      return u.valid ? ((Ty(o) || Ty(s)) && e.dirty(), { status: e.value, value: u.data }) : (_e(n, {
        code: pe.invalid_intersection_types
      }), Oe);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([o, s]) => i(o, s)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Ll.create = (r, t, e) => new Ll({
  left: r,
  right: t,
  typeName: Pe.ZodIntersection,
  ...qe(e)
});
class pi extends Ye {
  _parse(t) {
    const { status: e, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== be.array)
      return _e(n, {
        code: pe.invalid_type,
        expected: be.array,
        received: n.parsedType
      }), Oe;
    if (n.data.length < this._def.items.length)
      return _e(n, {
        code: pe.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Oe;
    !this._def.rest && n.data.length > this._def.items.length && (_e(n, {
      code: pe.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), e.dirty());
    const o = [...n.data].map((s, u) => {
      const l = this._def.items[u] || this._def.rest;
      return l ? l._parse(new Wn(n, s, n.path, u)) : null;
    }).filter((s) => !!s);
    return n.common.async ? Promise.all(o).then((s) => Vt.mergeArray(e, s)) : Vt.mergeArray(e, o);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new pi({
      ...this._def,
      rest: t
    });
  }
}
pi.create = (r, t) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new pi({
    items: r,
    typeName: Pe.ZodTuple,
    rest: null,
    ...qe(t)
  });
};
class Nl extends Ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: e, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== be.object)
      return _e(n, {
        code: pe.invalid_type,
        expected: be.object,
        received: n.parsedType
      }), Oe;
    const i = [], o = this._def.keyType, s = this._def.valueType;
    for (const u in n.data)
      i.push({
        key: o._parse(new Wn(n, u, n.path, u)),
        value: s._parse(new Wn(n, n.data[u], n.path, u)),
        alwaysSet: u in n.data
      });
    return n.common.async ? Vt.mergeObjectAsync(e, i) : Vt.mergeObjectSync(e, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, e, n) {
    return e instanceof Ye ? new Nl({
      keyType: t,
      valueType: e,
      typeName: Pe.ZodRecord,
      ...qe(n)
    }) : new Nl({
      keyType: Bn.create(),
      valueType: t,
      typeName: Pe.ZodRecord,
      ...qe(e)
    });
  }
}
class Ay extends Ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: e, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== be.map)
      return _e(n, {
        code: pe.invalid_type,
        expected: be.map,
        received: n.parsedType
      }), Oe;
    const i = this._def.keyType, o = this._def.valueType, s = [...n.data.entries()].map(([u, l], c) => ({
      key: i._parse(new Wn(n, u, n.path, [c, "key"])),
      value: o._parse(new Wn(n, l, n.path, [c, "value"]))
    }));
    if (n.common.async) {
      const u = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of s) {
          const c = await l.key, d = await l.value;
          if (c.status === "aborted" || d.status === "aborted")
            return Oe;
          (c.status === "dirty" || d.status === "dirty") && e.dirty(), u.set(c.value, d.value);
        }
        return { status: e.value, value: u };
      });
    } else {
      const u = /* @__PURE__ */ new Map();
      for (const l of s) {
        const c = l.key, d = l.value;
        if (c.status === "aborted" || d.status === "aborted")
          return Oe;
        (c.status === "dirty" || d.status === "dirty") && e.dirty(), u.set(c.value, d.value);
      }
      return { status: e.value, value: u };
    }
  }
}
Ay.create = (r, t, e) => new Ay({
  valueType: t,
  keyType: r,
  typeName: Pe.ZodMap,
  ...qe(e)
});
class vs extends Ye {
  _parse(t) {
    const { status: e, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== be.set)
      return _e(n, {
        code: pe.invalid_type,
        expected: be.set,
        received: n.parsedType
      }), Oe;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (_e(n, {
      code: pe.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), e.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (_e(n, {
      code: pe.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), e.dirty());
    const o = this._def.valueType;
    function s(l) {
      const c = /* @__PURE__ */ new Set();
      for (const d of l) {
        if (d.status === "aborted")
          return Oe;
        d.status === "dirty" && e.dirty(), c.add(d.value);
      }
      return { status: e.value, value: c };
    }
    const u = [...n.data.values()].map((l, c) => o._parse(new Wn(n, l, n.path, c)));
    return n.common.async ? Promise.all(u).then((l) => s(l)) : s(u);
  }
  min(t, e) {
    return new vs({
      ...this._def,
      minSize: { value: t, message: Ee.toString(e) }
    });
  }
  max(t, e) {
    return new vs({
      ...this._def,
      maxSize: { value: t, message: Ee.toString(e) }
    });
  }
  size(t, e) {
    return this.min(t, e).max(t, e);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
vs.create = (r, t) => new vs({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: Pe.ZodSet,
  ...qe(t)
});
class Dl extends Ye {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    return this._def.getter()._parse({ data: e.data, path: e.path, parent: e });
  }
}
Dl.create = (r, t) => new Dl({
  getter: r,
  typeName: Pe.ZodLazy,
  ...qe(t)
});
class Fl extends Ye {
  _parse(t) {
    if (t.data !== this._def.value) {
      const e = this._getOrReturnCtx(t);
      return _e(e, {
        received: e.data,
        code: pe.invalid_literal,
        expected: this._def.value
      }), Oe;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Fl.create = (r, t) => new Fl({
  value: r,
  typeName: Pe.ZodLiteral,
  ...qe(t)
});
function Sb(r, t) {
  return new mi({
    values: r,
    typeName: Pe.ZodEnum,
    ...qe(t)
  });
}
class mi extends Ye {
  constructor() {
    super(...arguments), Qo.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const e = this._getOrReturnCtx(t), n = this._def.values;
      return _e(e, {
        expected: Xe.joinValues(n),
        received: e.parsedType,
        code: pe.invalid_type
      }), Oe;
    }
    if (kl(this, Qo, "f") || bb(this, Qo, new Set(this._def.values), "f"), !kl(this, Qo, "f").has(t.data)) {
      const e = this._getOrReturnCtx(t), n = this._def.values;
      return _e(e, {
        received: e.data,
        code: pe.invalid_enum_value,
        options: n
      }), Oe;
    }
    return Cn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const e of this._def.values)
      t[e] = e;
    return t;
  }
  get Values() {
    const t = {};
    for (const e of this._def.values)
      t[e] = e;
    return t;
  }
  get Enum() {
    const t = {};
    for (const e of this._def.values)
      t[e] = e;
    return t;
  }
  extract(t, e = this._def) {
    return mi.create(t, {
      ...this._def,
      ...e
    });
  }
  exclude(t, e = this._def) {
    return mi.create(this.options.filter((n) => !t.includes(n)), {
      ...this._def,
      ...e
    });
  }
}
Qo = /* @__PURE__ */ new WeakMap();
mi.create = Sb;
class ph extends Ye {
  constructor() {
    super(...arguments), Xo.set(this, void 0);
  }
  _parse(t) {
    const e = Xe.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== be.string && n.parsedType !== be.number) {
      const i = Xe.objectValues(e);
      return _e(n, {
        expected: Xe.joinValues(i),
        received: n.parsedType,
        code: pe.invalid_type
      }), Oe;
    }
    if (kl(this, Xo, "f") || bb(this, Xo, new Set(Xe.getValidEnumValues(this._def.values)), "f"), !kl(this, Xo, "f").has(t.data)) {
      const i = Xe.objectValues(e);
      return _e(n, {
        received: n.data,
        code: pe.invalid_enum_value,
        options: i
      }), Oe;
    }
    return Cn(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Xo = /* @__PURE__ */ new WeakMap();
ph.create = (r, t) => new ph({
  values: r,
  typeName: Pe.ZodNativeEnum,
  ...qe(t)
});
class $l extends Ye {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    if (e.parsedType !== be.promise && e.common.async === !1)
      return _e(e, {
        code: pe.invalid_type,
        expected: be.promise,
        received: e.parsedType
      }), Oe;
    const n = e.parsedType === be.promise ? e.data : Promise.resolve(e.data);
    return Cn(n.then((i) => this._def.type.parseAsync(i, {
      path: e.path,
      errorMap: e.common.contextualErrorMap
    })));
  }
}
$l.create = (r, t) => new $l({
  type: r,
  typeName: Pe.ZodPromise,
  ...qe(t)
});
class gi extends Ye {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Pe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: e, ctx: n } = this._processInputParams(t), i = this._def.effect || null, o = {
      addIssue: (s) => {
        _e(n, s), s.fatal ? e.abort() : e.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (o.addIssue = o.addIssue.bind(o), i.type === "preprocess") {
      const s = i.transform(n.data, o);
      if (n.common.async)
        return Promise.resolve(s).then(async (u) => {
          if (e.value === "aborted")
            return Oe;
          const l = await this._def.schema._parseAsync({
            data: u,
            path: n.path,
            parent: n
          });
          return l.status === "aborted" ? Oe : l.status === "dirty" || e.value === "dirty" ? jo(l.value) : l;
        });
      {
        if (e.value === "aborted")
          return Oe;
        const u = this._def.schema._parseSync({
          data: s,
          path: n.path,
          parent: n
        });
        return u.status === "aborted" ? Oe : u.status === "dirty" || e.value === "dirty" ? jo(u.value) : u;
      }
    }
    if (i.type === "refinement") {
      const s = (u) => {
        const l = i.refinement(u, o);
        if (n.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return u;
      };
      if (n.common.async === !1) {
        const u = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return u.status === "aborted" ? Oe : (u.status === "dirty" && e.dirty(), s(u.value), { status: e.value, value: u.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((u) => u.status === "aborted" ? Oe : (u.status === "dirty" && e.dirty(), s(u.value).then(() => ({ status: e.value, value: u.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!co(s))
          return s;
        const u = i.transform(s.value, o);
        if (u instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: e.value, value: u };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => co(s) ? Promise.resolve(i.transform(s.value, o)).then((u) => ({
          status: e.value,
          value: u
        })) : s);
    Xe.assertNever(i);
  }
}
gi.create = (r, t, e) => new gi({
  schema: r,
  typeName: Pe.ZodEffects,
  effect: t,
  ...qe(e)
});
gi.createWithPreprocess = (r, t, e) => new gi({
  schema: t,
  effect: { type: "preprocess", transform: r },
  typeName: Pe.ZodEffects,
  ...qe(e)
});
class fr extends Ye {
  _parse(t) {
    return this._getType(t) === be.undefined ? Cn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
fr.create = (r, t) => new fr({
  innerType: r,
  typeName: Pe.ZodOptional,
  ...qe(t)
});
class yi extends Ye {
  _parse(t) {
    return this._getType(t) === be.null ? Cn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
yi.create = (r, t) => new yi({
  innerType: r,
  typeName: Pe.ZodNullable,
  ...qe(t)
});
class Ul extends Ye {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t);
    let n = e.data;
    return e.parsedType === be.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: e.path,
      parent: e
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ul.create = (r, t) => new Ul({
  innerType: r,
  typeName: Pe.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...qe(t)
});
class ql extends Ye {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t), n = {
      ...e,
      common: {
        ...e.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Ml(i) ? i.then((o) => ({
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new mr(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new mr(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ql.create = (r, t) => new ql({
  innerType: r,
  typeName: Pe.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...qe(t)
});
class xy extends Ye {
  _parse(t) {
    if (this._getType(t) !== be.nan) {
      const n = this._getOrReturnCtx(t);
      return _e(n, {
        code: pe.invalid_type,
        expected: be.nan,
        received: n.parsedType
      }), Oe;
    }
    return { status: "valid", value: t.data };
  }
}
xy.create = (r) => new xy({
  typeName: Pe.ZodNaN,
  ...qe(r)
});
class Eb extends Ye {
  _parse(t) {
    const { ctx: e } = this._processInputParams(t), n = e.data;
    return this._def.type._parse({
      data: n,
      path: e.path,
      parent: e
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class np extends Ye {
  _parse(t) {
    const { status: e, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const o = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? Oe : o.status === "dirty" ? (e.dirty(), jo(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? Oe : i.status === "dirty" ? (e.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, e) {
    return new np({
      in: t,
      out: e,
      typeName: Pe.ZodPipeline
    });
  }
}
class Bl extends Ye {
  _parse(t) {
    const e = this._def.innerType._parse(t), n = (i) => (co(i) && (i.value = Object.freeze(i.value)), i);
    return Ml(e) ? e.then((i) => n(i)) : n(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Bl.create = (r, t) => new Bl({
  innerType: r,
  typeName: Pe.ZodReadonly,
  ...qe(t)
});
var Pe;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline", r.ZodReadonly = "ZodReadonly";
})(Pe || (Pe = {}));
const ue = Bn.create, Nt = di.create;
hi.create;
const ln = Pl.create;
fo.create;
const JP = fh.create, ho = dh.create;
Br.create;
const Qe = Vn.create, xe = St.create, Ft = Ol.create, zP = tp.create;
Ll.create;
pi.create;
const rp = Nl.create, YP = Dl.create, je = Fl.create, vi = mi.create;
$l.create;
const Ae = fr.create;
yi.create;
const Ui = {
  string: (r) => Bn.create({ ...r, coerce: !0 }),
  number: (r) => di.create({ ...r, coerce: !0 }),
  boolean: (r) => Pl.create({
    ...r,
    coerce: !0
  }),
  bigint: (r) => hi.create({ ...r, coerce: !0 }),
  date: (r) => fo.create({ ...r, coerce: !0 })
}, ip = "2025-03-26", ZP = [
  ip,
  "2024-11-05",
  "2024-10-07"
], iu = "2.0", Ab = Ft([ue(), Nt().int()]), xb = ue(), jP = xe({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: Ae(Ab)
}).passthrough(), On = xe({
  _meta: Ae(jP)
}).passthrough(), un = xe({
  method: ue(),
  params: Ae(On)
}), Ts = xe({
  /**
   * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
   */
  _meta: Ae(xe({}).passthrough())
}).passthrough(), zn = xe({
  method: ue(),
  params: Ae(Ts)
}), Ln = xe({
  /**
   * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
   */
  _meta: Ae(xe({}).passthrough())
}).passthrough(), ou = Ft([ue(), Nt().int()]), Rb = xe({
  jsonrpc: je(iu),
  id: ou
}).merge(un).strict(), QP = (r) => Rb.safeParse(r).success, Ib = xe({
  jsonrpc: je(iu)
}).merge(zn).strict(), XP = (r) => Ib.safeParse(r).success, Mb = xe({
  jsonrpc: je(iu),
  id: ou,
  result: Ln
}).strict(), Ry = (r) => Mb.safeParse(r).success;
var oi;
(function(r) {
  r[r.ConnectionClosed = -32e3] = "ConnectionClosed", r[r.RequestTimeout = -32001] = "RequestTimeout", r[r.ParseError = -32700] = "ParseError", r[r.InvalidRequest = -32600] = "InvalidRequest", r[r.MethodNotFound = -32601] = "MethodNotFound", r[r.InvalidParams = -32602] = "InvalidParams", r[r.InternalError = -32603] = "InternalError";
})(oi || (oi = {}));
const kb = xe({
  jsonrpc: je(iu),
  id: ou,
  error: xe({
    /**
     * The error type that occurred.
     */
    code: Nt().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: ue(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: Ae(ho())
  })
}).strict(), eO = (r) => kb.safeParse(r).success, tO = Ft([
  Rb,
  Ib,
  Mb,
  kb
]), zi = Ln.strict(), op = zn.extend({
  method: je("notifications/cancelled"),
  params: Ts.extend({
    /**
     * The ID of the request to cancel.
     *
     * This MUST correspond to the ID of a request previously issued in the same direction.
     */
    requestId: ou,
    /**
     * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
     */
    reason: ue().optional()
  })
}), Pb = xe({
  name: ue(),
  version: ue()
}).passthrough(), nO = xe({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: Ae(xe({}).passthrough()),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: Ae(xe({}).passthrough()),
  /**
   * Present if the client supports listing roots.
   */
  roots: Ae(xe({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: Ae(ln())
  }).passthrough())
}).passthrough(), rO = un.extend({
  method: je("initialize"),
  params: On.extend({
    /**
     * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
     */
    protocolVersion: ue(),
    capabilities: nO,
    clientInfo: Pb
  })
}), iO = xe({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: Ae(xe({}).passthrough()),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: Ae(xe({}).passthrough()),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: Ae(xe({}).passthrough()),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: Ae(xe({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: Ae(ln())
  }).passthrough()),
  /**
   * Present if the server offers any resources to read.
   */
  resources: Ae(xe({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: Ae(ln()),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: Ae(ln())
  }).passthrough()),
  /**
   * Present if the server offers any tools to call.
   */
  tools: Ae(xe({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: Ae(ln())
  }).passthrough())
}).passthrough(), Ob = Ln.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: ue(),
  capabilities: iO,
  serverInfo: Pb,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: Ae(ue())
}), oO = zn.extend({
  method: je("notifications/initialized")
}), sp = un.extend({
  method: je("ping")
}), sO = xe({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: Nt(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: Ae(Nt())
}).passthrough(), ap = zn.extend({
  method: je("notifications/progress"),
  params: Ts.merge(sO).extend({
    /**
     * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
     */
    progressToken: Ab
  })
}), su = un.extend({
  params: On.extend({
    /**
     * An opaque token representing the current pagination position.
     * If provided, the server should return results starting after this cursor.
     */
    cursor: Ae(xb)
  }).optional()
}), au = Ln.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: Ae(xb)
}), Lb = xe({
  /**
   * The URI of this resource.
   */
  uri: ue(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: Ae(ue())
}).passthrough(), Nb = Lb.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: ue()
}), Db = Lb.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: ue().base64()
}), aO = xe({
  /**
   * The URI of this resource.
   */
  uri: ue(),
  /**
   * A human-readable name for this resource.
   *
   * This can be used by clients to populate UI elements.
   */
  name: ue(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: Ae(ue()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: Ae(ue())
}).passthrough(), lO = xe({
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: ue(),
  /**
   * A human-readable name for the type of resource this template refers to.
   *
   * This can be used by clients to populate UI elements.
   */
  name: ue(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: Ae(ue()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: Ae(ue())
}).passthrough(), uO = su.extend({
  method: je("resources/list")
}), Fb = au.extend({
  resources: Qe(aO)
}), cO = su.extend({
  method: je("resources/templates/list")
}), $b = au.extend({
  resourceTemplates: Qe(lO)
}), fO = un.extend({
  method: je("resources/read"),
  params: On.extend({
    /**
     * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
     */
    uri: ue()
  })
}), Ub = Ln.extend({
  contents: Qe(Ft([Nb, Db]))
}), dO = zn.extend({
  method: je("notifications/resources/list_changed")
}), hO = un.extend({
  method: je("resources/subscribe"),
  params: On.extend({
    /**
     * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.
     */
    uri: ue()
  })
}), pO = un.extend({
  method: je("resources/unsubscribe"),
  params: On.extend({
    /**
     * The URI of the resource to unsubscribe from.
     */
    uri: ue()
  })
}), mO = zn.extend({
  method: je("notifications/resources/updated"),
  params: Ts.extend({
    /**
     * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
     */
    uri: ue()
  })
}), gO = xe({
  /**
   * The name of the argument.
   */
  name: ue(),
  /**
   * A human-readable description of the argument.
   */
  description: Ae(ue()),
  /**
   * Whether this argument must be provided.
   */
  required: Ae(ln())
}).passthrough(), yO = xe({
  /**
   * The name of the prompt or prompt template.
   */
  name: ue(),
  /**
   * An optional description of what this prompt provides
   */
  description: Ae(ue()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: Ae(Qe(gO))
}).passthrough(), vO = su.extend({
  method: je("prompts/list")
}), qb = au.extend({
  prompts: Qe(yO)
}), _O = un.extend({
  method: je("prompts/get"),
  params: On.extend({
    /**
     * The name of the prompt or prompt template.
     */
    name: ue(),
    /**
     * Arguments to use for templating the prompt.
     */
    arguments: Ae(rp(ue()))
  })
}), lu = xe({
  type: je("text"),
  /**
   * The text content of the message.
   */
  text: ue()
}).passthrough(), uu = xe({
  type: je("image"),
  /**
   * The base64-encoded image data.
   */
  data: ue().base64(),
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: ue()
}).passthrough(), cu = xe({
  type: je("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: ue().base64(),
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: ue()
}).passthrough(), Bb = xe({
  type: je("resource"),
  resource: Ft([Nb, Db])
}).passthrough(), wO = xe({
  role: vi(["user", "assistant"]),
  content: Ft([
    lu,
    uu,
    cu,
    Bb
  ])
}).passthrough(), Vb = Ln.extend({
  /**
   * An optional description for the prompt.
   */
  description: Ae(ue()),
  messages: Qe(wO)
}), bO = zn.extend({
  method: je("notifications/prompts/list_changed")
}), TO = xe({
  /**
   * A human-readable title for the tool.
   */
  title: Ae(ue()),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: Ae(ln()),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: Ae(ln()),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: Ae(ln()),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: Ae(ln())
}).passthrough(), CO = xe({
  /**
   * The name of the tool.
   */
  name: ue(),
  /**
   * A human-readable description of the tool.
   */
  description: Ae(ue()),
  /**
   * A JSON Schema object defining the expected parameters for the tool.
   */
  inputSchema: xe({
    type: je("object"),
    properties: Ae(xe({}).passthrough())
  }).passthrough(),
  /**
   * Optional additional tool information.
   */
  annotations: Ae(TO)
}).passthrough(), SO = su.extend({
  method: je("tools/list")
}), Hb = au.extend({
  tools: Qe(CO)
}), lp = Ln.extend({
  content: Qe(Ft([lu, uu, cu, Bb])),
  isError: ln().default(!1).optional()
});
lp.or(Ln.extend({
  toolResult: ho()
}));
const EO = un.extend({
  method: je("tools/call"),
  params: On.extend({
    name: ue(),
    arguments: Ae(rp(ho()))
  })
}), Gb = zn.extend({
  method: je("notifications/tools/list_changed")
}), Wb = vi([
  "debug",
  "info",
  "notice",
  "warning",
  "error",
  "critical",
  "alert",
  "emergency"
]), AO = un.extend({
  method: je("logging/setLevel"),
  params: On.extend({
    /**
     * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
     */
    level: Wb
  })
}), xO = zn.extend({
  method: je("notifications/message"),
  params: Ts.extend({
    /**
     * The severity of this log message.
     */
    level: Wb,
    /**
     * An optional name of the logger issuing this message.
     */
    logger: Ae(ue()),
    /**
     * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
     */
    data: ho()
  })
}), RO = xe({
  /**
   * A hint for a model name.
   */
  name: ue().optional()
}).passthrough(), IO = xe({
  /**
   * Optional hints to use for model selection.
   */
  hints: Ae(Qe(RO)),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: Ae(Nt().min(0).max(1)),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: Ae(Nt().min(0).max(1)),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: Ae(Nt().min(0).max(1))
}).passthrough(), MO = xe({
  role: vi(["user", "assistant"]),
  content: Ft([lu, uu, cu])
}).passthrough(), kO = un.extend({
  method: je("sampling/createMessage"),
  params: On.extend({
    messages: Qe(MO),
    /**
     * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
     */
    systemPrompt: Ae(ue()),
    /**
     * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.
     */
    includeContext: Ae(vi(["none", "thisServer", "allServers"])),
    temperature: Ae(Nt()),
    /**
     * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.
     */
    maxTokens: Nt().int(),
    stopSequences: Ae(Qe(ue())),
    /**
     * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
     */
    metadata: Ae(xe({}).passthrough()),
    /**
     * The server's preferences for which model to select.
     */
    modelPreferences: Ae(IO)
  })
}), PO = Ln.extend({
  /**
   * The name of the model that generated the message.
   */
  model: ue(),
  /**
   * The reason why sampling stopped.
   */
  stopReason: Ae(vi(["endTurn", "stopSequence", "maxTokens"]).or(ue())),
  role: vi(["user", "assistant"]),
  content: zP("type", [
    lu,
    uu,
    cu
  ])
}), OO = xe({
  type: je("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: ue()
}).passthrough(), LO = xe({
  type: je("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: ue()
}).passthrough(), NO = un.extend({
  method: je("completion/complete"),
  params: On.extend({
    ref: Ft([LO, OO]),
    /**
     * The argument's information
     */
    argument: xe({
      /**
       * The name of the argument
       */
      name: ue(),
      /**
       * The value of the argument to use for completion matching.
       */
      value: ue()
    }).passthrough()
  })
}), Kb = Ln.extend({
  completion: xe({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: Qe(ue()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: Ae(Nt().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: Ae(ln())
  }).passthrough()
}), DO = xe({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: ue().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: Ae(ue())
}).passthrough(), FO = un.extend({
  method: je("roots/list")
}), $O = Ln.extend({
  roots: Qe(DO)
}), UO = zn.extend({
  method: je("notifications/roots/list_changed")
});
Ft([
  sp,
  rO,
  NO,
  AO,
  _O,
  vO,
  uO,
  cO,
  fO,
  hO,
  pO,
  EO,
  SO
]);
Ft([
  op,
  ap,
  oO,
  UO
]);
Ft([
  zi,
  PO,
  $O
]);
Ft([
  sp,
  kO,
  FO
]);
Ft([
  op,
  ap,
  xO,
  mO,
  dO,
  Gb,
  bO
]);
Ft([
  zi,
  Ob,
  Kb,
  Vb,
  qb,
  Fb,
  $b,
  Ub,
  lp,
  Hb
]);
class wa extends Error {
  constructor(t, e, n) {
    super(`MCP error ${t}: ${e}`), this.code = t, this.data = n, this.name = "McpError";
  }
}
const qO = 6e4;
class BO {
  constructor(t) {
    this._options = t, this._requestMessageId = 0, this._requestHandlers = /* @__PURE__ */ new Map(), this._requestHandlerAbortControllers = /* @__PURE__ */ new Map(), this._notificationHandlers = /* @__PURE__ */ new Map(), this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers = /* @__PURE__ */ new Map(), this._timeoutInfo = /* @__PURE__ */ new Map(), this.setNotificationHandler(op, (e) => {
      const n = this._requestHandlerAbortControllers.get(e.params.requestId);
      n?.abort(e.params.reason);
    }), this.setNotificationHandler(ap, (e) => {
      this._onprogress(e);
    }), this.setRequestHandler(
      sp,
      // Automatic pong by default.
      (e) => ({})
    );
  }
  _setupTimeout(t, e, n, i, o = !1) {
    this._timeoutInfo.set(t, {
      timeoutId: setTimeout(i, e),
      startTime: Date.now(),
      timeout: e,
      maxTotalTimeout: n,
      resetTimeoutOnProgress: o,
      onTimeout: i
    });
  }
  _resetTimeout(t) {
    const e = this._timeoutInfo.get(t);
    if (!e)
      return !1;
    const n = Date.now() - e.startTime;
    if (e.maxTotalTimeout && n >= e.maxTotalTimeout)
      throw this._timeoutInfo.delete(t), new wa(oi.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: e.maxTotalTimeout, totalElapsed: n });
    return clearTimeout(e.timeoutId), e.timeoutId = setTimeout(e.onTimeout, e.timeout), !0;
  }
  _cleanupTimeout(t) {
    const e = this._timeoutInfo.get(t);
    e && (clearTimeout(e.timeoutId), this._timeoutInfo.delete(t));
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(t) {
    this._transport = t, this._transport.onclose = () => {
      this._onclose();
    }, this._transport.onerror = (e) => {
      this._onerror(e);
    }, this._transport.onmessage = (e, n) => {
      Ry(e) || eO(e) ? this._onresponse(e) : QP(e) ? this._onrequest(e, n) : XP(e) ? this._onnotification(e) : this._onerror(new Error(`Unknown message type: ${JSON.stringify(e)}`));
    }, await this._transport.start();
  }
  _onclose() {
    var t;
    const e = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers.clear(), this._transport = void 0, (t = this.onclose) === null || t === void 0 || t.call(this);
    const n = new wa(oi.ConnectionClosed, "Connection closed");
    for (const i of e.values())
      i(n);
  }
  _onerror(t) {
    var e;
    (e = this.onerror) === null || e === void 0 || e.call(this, t);
  }
  _onnotification(t) {
    var e;
    const n = (e = this._notificationHandlers.get(t.method)) !== null && e !== void 0 ? e : this.fallbackNotificationHandler;
    n !== void 0 && Promise.resolve().then(() => n(t)).catch((i) => this._onerror(new Error(`Uncaught error in notification handler: ${i}`)));
  }
  _onrequest(t, e) {
    var n, i, o, s;
    const u = (n = this._requestHandlers.get(t.method)) !== null && n !== void 0 ? n : this.fallbackRequestHandler;
    if (u === void 0) {
      (i = this._transport) === null || i === void 0 || i.send({
        jsonrpc: "2.0",
        id: t.id,
        error: {
          code: oi.MethodNotFound,
          message: "Method not found"
        }
      }).catch((d) => this._onerror(new Error(`Failed to send an error response: ${d}`)));
      return;
    }
    const l = new AbortController();
    this._requestHandlerAbortControllers.set(t.id, l);
    const c = {
      signal: l.signal,
      sessionId: (o = this._transport) === null || o === void 0 ? void 0 : o.sessionId,
      _meta: (s = t.params) === null || s === void 0 ? void 0 : s._meta,
      sendNotification: (d) => this.notification(d, { relatedRequestId: t.id }),
      sendRequest: (d, g, y) => this.request(d, g, { ...y, relatedRequestId: t.id }),
      authInfo: e?.authInfo,
      requestId: t.id
    };
    Promise.resolve().then(() => u(t, c)).then((d) => {
      var g;
      if (!l.signal.aborted)
        return (g = this._transport) === null || g === void 0 ? void 0 : g.send({
          result: d,
          jsonrpc: "2.0",
          id: t.id
        });
    }, (d) => {
      var g, y;
      if (!l.signal.aborted)
        return (g = this._transport) === null || g === void 0 ? void 0 : g.send({
          jsonrpc: "2.0",
          id: t.id,
          error: {
            code: Number.isSafeInteger(d.code) ? d.code : oi.InternalError,
            message: (y = d.message) !== null && y !== void 0 ? y : "Internal error"
          }
        });
    }).catch((d) => this._onerror(new Error(`Failed to send response: ${d}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(t.id);
    });
  }
  _onprogress(t) {
    const { progressToken: e, ...n } = t.params, i = Number(e), o = this._progressHandlers.get(i);
    if (!o) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(t)}`));
      return;
    }
    const s = this._responseHandlers.get(i), u = this._timeoutInfo.get(i);
    if (u && s && u.resetTimeoutOnProgress)
      try {
        this._resetTimeout(i);
      } catch (l) {
        s(l);
        return;
      }
    o(n);
  }
  _onresponse(t) {
    const e = Number(t.id), n = this._responseHandlers.get(e);
    if (n === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(t)}`));
      return;
    }
    if (this._responseHandlers.delete(e), this._progressHandlers.delete(e), this._cleanupTimeout(e), Ry(t))
      n(t);
    else {
      const i = new wa(t.error.code, t.error.message, t.error.data);
      n(i);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    var t;
    await ((t = this._transport) === null || t === void 0 ? void 0 : t.close());
  }
  /**
   * Sends a request and wait for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(t, e, n) {
    const { relatedRequestId: i, resumptionToken: o, onresumptiontoken: s } = n ?? {};
    return new Promise((u, l) => {
      var c, d, g, y, w;
      if (!this._transport) {
        l(new Error("Not connected"));
        return;
      }
      ((c = this._options) === null || c === void 0 ? void 0 : c.enforceStrictCapabilities) === !0 && this.assertCapabilityForMethod(t.method), (d = n?.signal) === null || d === void 0 || d.throwIfAborted();
      const b = this._requestMessageId++, _ = {
        ...t,
        jsonrpc: "2.0",
        id: b
      };
      n?.onprogress && (this._progressHandlers.set(b, n.onprogress), _.params = {
        ...t.params,
        _meta: { progressToken: b }
      });
      const C = (S) => {
        var A;
        this._responseHandlers.delete(b), this._progressHandlers.delete(b), this._cleanupTimeout(b), (A = this._transport) === null || A === void 0 || A.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: b,
            reason: String(S)
          }
        }, { relatedRequestId: i, resumptionToken: o, onresumptiontoken: s }).catch((x) => this._onerror(new Error(`Failed to send cancellation: ${x}`))), l(S);
      };
      this._responseHandlers.set(b, (S) => {
        var A;
        if (!(!((A = n?.signal) === null || A === void 0) && A.aborted)) {
          if (S instanceof Error)
            return l(S);
          try {
            const x = e.parse(S.result);
            u(x);
          } catch (x) {
            l(x);
          }
        }
      }), (g = n?.signal) === null || g === void 0 || g.addEventListener("abort", () => {
        var S;
        C((S = n?.signal) === null || S === void 0 ? void 0 : S.reason);
      });
      const m = (y = n?.timeout) !== null && y !== void 0 ? y : qO, T = () => C(new wa(oi.RequestTimeout, "Request timed out", { timeout: m }));
      this._setupTimeout(b, m, n?.maxTotalTimeout, T, (w = n?.resetTimeoutOnProgress) !== null && w !== void 0 ? w : !1), this._transport.send(_, { relatedRequestId: i, resumptionToken: o, onresumptiontoken: s }).catch((S) => {
        this._cleanupTimeout(b), l(S);
      });
    });
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(t, e) {
    if (!this._transport)
      throw new Error("Not connected");
    this.assertNotificationCapability(t.method);
    const n = {
      ...t,
      jsonrpc: "2.0"
    };
    await this._transport.send(n, e);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(t, e) {
    const n = t.shape.method.value;
    this.assertRequestHandlerCapability(n), this._requestHandlers.set(n, (i, o) => Promise.resolve(e(t.parse(i), o)));
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(t) {
    this._requestHandlers.delete(t);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(t) {
    if (this._requestHandlers.has(t))
      throw new Error(`A request handler for ${t} already exists, which would be overridden`);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(t, e) {
    this._notificationHandlers.set(t.shape.method.value, (n) => Promise.resolve(e(t.parse(n))));
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(t) {
    this._notificationHandlers.delete(t);
  }
}
function VO(r, t) {
  return Object.entries(t).reduce((e, [n, i]) => (i && typeof i == "object" ? e[n] = e[n] ? { ...e[n], ...i } : i : e[n] = i, e), { ...r });
}
class Iy extends BO {
  /**
   * Initializes this client with the given name and version information.
   */
  constructor(t, e) {
    var n;
    super(e), this._clientInfo = t, this._capabilities = (n = e?.capabilities) !== null && n !== void 0 ? n : {};
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(t) {
    if (this.transport)
      throw new Error("Cannot register capabilities after connecting to transport");
    this._capabilities = VO(this._capabilities, t);
  }
  assertCapability(t, e) {
    var n;
    if (!(!((n = this._serverCapabilities) === null || n === void 0) && n[t]))
      throw new Error(`Server does not support ${t} (required for ${e})`);
  }
  async connect(t, e) {
    if (await super.connect(t), t.sessionId === void 0)
      try {
        const n = await this.request({
          method: "initialize",
          params: {
            protocolVersion: ip,
            capabilities: this._capabilities,
            clientInfo: this._clientInfo
          }
        }, Ob, e);
        if (n === void 0)
          throw new Error(`Server sent invalid initialize result: ${n}`);
        if (!ZP.includes(n.protocolVersion))
          throw new Error(`Server's protocol version is not supported: ${n.protocolVersion}`);
        this._serverCapabilities = n.capabilities, this._serverVersion = n.serverInfo, this._instructions = n.instructions, await this.notification({
          method: "notifications/initialized"
        });
      } catch (n) {
        throw this.close(), n;
      }
  }
  /**
   * After initialization has completed, this will be populated with the server's reported capabilities.
   */
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the server's name and version.
   */
  getServerVersion() {
    return this._serverVersion;
  }
  /**
   * After initialization has completed, this may be populated with information about the server's instructions.
   */
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(t) {
    var e, n, i, o, s;
    switch (t) {
      case "logging/setLevel":
        if (!(!((e = this._serverCapabilities) === null || e === void 0) && e.logging))
          throw new Error(`Server does not support logging (required for ${t})`);
        break;
      case "prompts/get":
      case "prompts/list":
        if (!(!((n = this._serverCapabilities) === null || n === void 0) && n.prompts))
          throw new Error(`Server does not support prompts (required for ${t})`);
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!(!((i = this._serverCapabilities) === null || i === void 0) && i.resources))
          throw new Error(`Server does not support resources (required for ${t})`);
        if (t === "resources/subscribe" && !this._serverCapabilities.resources.subscribe)
          throw new Error(`Server does not support resource subscriptions (required for ${t})`);
        break;
      case "tools/call":
      case "tools/list":
        if (!(!((o = this._serverCapabilities) === null || o === void 0) && o.tools))
          throw new Error(`Server does not support tools (required for ${t})`);
        break;
      case "completion/complete":
        if (!(!((s = this._serverCapabilities) === null || s === void 0) && s.completions))
          throw new Error(`Server does not support completions (required for ${t})`);
        break;
    }
  }
  assertNotificationCapability(t) {
    var e;
    switch (t) {
      case "notifications/roots/list_changed":
        if (!(!((e = this._capabilities.roots) === null || e === void 0) && e.listChanged))
          throw new Error(`Client does not support roots list changed notifications (required for ${t})`);
        break;
    }
  }
  assertRequestHandlerCapability(t) {
    switch (t) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling)
          throw new Error(`Client does not support sampling capability (required for ${t})`);
        break;
      case "roots/list":
        if (!this._capabilities.roots)
          throw new Error(`Client does not support roots capability (required for ${t})`);
        break;
    }
  }
  async ping(t) {
    return this.request({ method: "ping" }, zi, t);
  }
  async complete(t, e) {
    return this.request({ method: "completion/complete", params: t }, Kb, e);
  }
  async setLoggingLevel(t, e) {
    return this.request({ method: "logging/setLevel", params: { level: t } }, zi, e);
  }
  async getPrompt(t, e) {
    return this.request({ method: "prompts/get", params: t }, Vb, e);
  }
  async listPrompts(t, e) {
    return this.request({ method: "prompts/list", params: t }, qb, e);
  }
  async listResources(t, e) {
    return this.request({ method: "resources/list", params: t }, Fb, e);
  }
  async listResourceTemplates(t, e) {
    return this.request({ method: "resources/templates/list", params: t }, $b, e);
  }
  async readResource(t, e) {
    return this.request({ method: "resources/read", params: t }, Ub, e);
  }
  async subscribeResource(t, e) {
    return this.request({ method: "resources/subscribe", params: t }, zi, e);
  }
  async unsubscribeResource(t, e) {
    return this.request({ method: "resources/unsubscribe", params: t }, zi, e);
  }
  async callTool(t, e = lp, n) {
    return this.request({ method: "tools/call", params: t }, e, n);
  }
  async listTools(t, e) {
    return this.request({ method: "tools/list", params: t }, Hb, e);
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
}
var HO = Object.defineProperty, GO = (r, t, e) => t in r ? HO(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e, ba = (r, t, e) => GO(r, typeof t != "symbol" ? t + "" : t, e);
class My extends Error {
  constructor(t, e) {
    super(t), ba(this, "type"), ba(this, "field"), ba(this, "value"), ba(this, "line"), this.name = "ParseError", this.type = e.type, this.field = e.field, this.value = e.value, this.line = e.line;
  }
}
function rf(r) {
}
function WO(r) {
  const { onEvent: t = rf, onError: e = rf, onRetry: n = rf, onComment: i } = r;
  let o = "", s = !0, u, l = "", c = "";
  function d(_) {
    const C = s ? _.replace(/^\xEF\xBB\xBF/, "") : _, [m, T] = KO(`${o}${C}`);
    for (const S of m)
      g(S);
    o = T, s = !1;
  }
  function g(_) {
    if (_ === "") {
      w();
      return;
    }
    if (_.startsWith(":")) {
      i && i(_.slice(_.startsWith(": ") ? 2 : 1));
      return;
    }
    const C = _.indexOf(":");
    if (C !== -1) {
      const m = _.slice(0, C), T = _[C + 1] === " " ? 2 : 1, S = _.slice(C + T);
      y(m, S, _);
      return;
    }
    y(_, "", _);
  }
  function y(_, C, m) {
    switch (_) {
      case "event":
        c = C;
        break;
      case "data":
        l = `${l}${C}
`;
        break;
      case "id":
        u = C.includes("\0") ? void 0 : C;
        break;
      case "retry":
        /^\d+$/.test(C) ? n(parseInt(C, 10)) : e(
          new My(`Invalid \`retry\` value: "${C}"`, {
            type: "invalid-retry",
            value: C,
            line: m
          })
        );
        break;
      default:
        e(
          new My(
            `Unknown field "${_.length > 20 ? `${_.slice(0, 20)}` : _}"`,
            { type: "unknown-field", field: _, value: C, line: m }
          )
        );
        break;
    }
  }
  function w() {
    l.length > 0 && t({
      id: u,
      event: c || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: l.endsWith(`
`) ? l.slice(0, -1) : l
    }), u = void 0, l = "", c = "";
  }
  function b(_ = {}) {
    o && _.consume && g(o), u = void 0, l = "", c = "", o = "";
  }
  return { feed: d, reset: b };
}
function KO(r) {
  const t = [];
  let e = "";
  const n = r.length;
  for (let i = 0; i < n; i++) {
    const o = r[i];
    o === "\r" && r[i + 1] === `
` ? (t.push(e), e = "", i++) : o === "\r" || o === `
` ? (t.push(e), e = "") : e += o;
  }
  return [t, e];
}
class ky extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(t, e) {
    var n, i;
    super(t), this.code = (n = e?.code) != null ? n : void 0, this.message = (i = e?.message) != null ? i : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](t, e, n) {
    return n(Py(this), e);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](t, e) {
    return t(Py(this), e);
  }
}
function JO(r) {
  const t = globalThis.DOMException;
  return typeof t == "function" ? new t(r, "SyntaxError") : new SyntaxError(r);
}
function mh(r) {
  return r instanceof Error ? "errors" in r && Array.isArray(r.errors) ? r.errors.map(mh).join(", ") : "cause" in r && r.cause instanceof Error ? `${r}: ${mh(r.cause)}` : r.message : `${r}`;
}
function Py(r) {
  return {
    type: r.type,
    message: r.message,
    code: r.code,
    defaultPrevented: r.defaultPrevented,
    cancelable: r.cancelable,
    timeStamp: r.timeStamp
  };
}
var Jb = (r) => {
  throw TypeError(r);
}, up = (r, t, e) => t.has(r) || Jb("Cannot " + e), Ke = (r, t, e) => (up(r, t, "read from private field"), e ? e.call(r) : t.get(r)), xt = (r, t, e) => t.has(r) ? Jb("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(r) : t.set(r, e), pt = (r, t, e, n) => (up(r, t, "write to private field"), t.set(r, e), e), ar = (r, t, e) => (up(r, t, "access private method"), e), zt, si, Wi, yl, Vl, ss, Yi, as, Lr, Ki, io, Ji, es, Mn, gh, yh, vh, Oy, _h, wh, ts, bh, Th;
class vl extends EventTarget {
  constructor(t, e) {
    var n, i;
    super(), xt(this, Mn), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, xt(this, zt), xt(this, si), xt(this, Wi), xt(this, yl), xt(this, Vl), xt(this, ss), xt(this, Yi), xt(this, as, null), xt(this, Lr), xt(this, Ki), xt(this, io, null), xt(this, Ji, null), xt(this, es, null), xt(this, yh, async (o) => {
      var s;
      Ke(this, Ki).reset();
      const { body: u, redirected: l, status: c, headers: d } = o;
      if (c === 204) {
        ar(this, Mn, ts).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (l ? pt(this, Wi, new URL(o.url)) : pt(this, Wi, void 0), c !== 200) {
        ar(this, Mn, ts).call(this, `Non-200 status code (${c})`, c);
        return;
      }
      if (!(d.get("content-type") || "").startsWith("text/event-stream")) {
        ar(this, Mn, ts).call(this, 'Invalid content type, expected "text/event-stream"', c);
        return;
      }
      if (Ke(this, zt) === this.CLOSED)
        return;
      pt(this, zt, this.OPEN);
      const g = new Event("open");
      if ((s = Ke(this, es)) == null || s.call(this, g), this.dispatchEvent(g), typeof u != "object" || !u || !("getReader" in u)) {
        ar(this, Mn, ts).call(this, "Invalid response body, expected a web ReadableStream", c), this.close();
        return;
      }
      const y = new TextDecoder(), w = u.getReader();
      let b = !0;
      do {
        const { done: _, value: C } = await w.read();
        C && Ke(this, Ki).feed(y.decode(C, { stream: !_ })), _ && (b = !1, Ke(this, Ki).reset(), ar(this, Mn, bh).call(this));
      } while (b);
    }), xt(this, vh, (o) => {
      pt(this, Lr, void 0), !(o.name === "AbortError" || o.type === "aborted") && ar(this, Mn, bh).call(this, mh(o));
    }), xt(this, _h, (o) => {
      typeof o.id == "string" && pt(this, as, o.id);
      const s = new MessageEvent(o.event || "message", {
        data: o.data,
        origin: Ke(this, Wi) ? Ke(this, Wi).origin : Ke(this, si).origin,
        lastEventId: o.id || ""
      });
      Ke(this, Ji) && (!o.event || o.event === "message") && Ke(this, Ji).call(this, s), this.dispatchEvent(s);
    }), xt(this, wh, (o) => {
      pt(this, ss, o);
    }), xt(this, Th, () => {
      pt(this, Yi, void 0), Ke(this, zt) === this.CONNECTING && ar(this, Mn, gh).call(this);
    });
    try {
      if (t instanceof URL)
        pt(this, si, t);
      else if (typeof t == "string")
        pt(this, si, new URL(t, zO()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw JO("An invalid or illegal string was specified");
    }
    pt(this, Ki, WO({
      onEvent: Ke(this, _h),
      onRetry: Ke(this, wh)
    })), pt(this, zt, this.CONNECTING), pt(this, ss, 3e3), pt(this, Vl, (n = e?.fetch) != null ? n : globalThis.fetch), pt(this, yl, (i = e?.withCredentials) != null ? i : !1), ar(this, Mn, gh).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return Ke(this, zt);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return Ke(this, si).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return Ke(this, yl);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return Ke(this, io);
  }
  set onerror(t) {
    pt(this, io, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return Ke(this, Ji);
  }
  set onmessage(t) {
    pt(this, Ji, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return Ke(this, es);
  }
  set onopen(t) {
    pt(this, es, t);
  }
  addEventListener(t, e, n) {
    const i = e;
    super.addEventListener(t, i, n);
  }
  removeEventListener(t, e, n) {
    const i = e;
    super.removeEventListener(t, i, n);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    Ke(this, Yi) && clearTimeout(Ke(this, Yi)), Ke(this, zt) !== this.CLOSED && (Ke(this, Lr) && Ke(this, Lr).abort(), pt(this, zt, this.CLOSED), pt(this, Lr, void 0));
  }
}
zt = /* @__PURE__ */ new WeakMap(), si = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakMap(), yl = /* @__PURE__ */ new WeakMap(), Vl = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakMap(), as = /* @__PURE__ */ new WeakMap(), Lr = /* @__PURE__ */ new WeakMap(), Ki = /* @__PURE__ */ new WeakMap(), io = /* @__PURE__ */ new WeakMap(), Ji = /* @__PURE__ */ new WeakMap(), es = /* @__PURE__ */ new WeakMap(), Mn = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
gh = function() {
  pt(this, zt, this.CONNECTING), pt(this, Lr, new AbortController()), Ke(this, Vl)(Ke(this, si), ar(this, Mn, Oy).call(this)).then(Ke(this, yh)).catch(Ke(this, vh));
}, yh = /* @__PURE__ */ new WeakMap(), vh = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
Oy = function() {
  var r;
  const t = {
    // [spec] Let `corsAttributeState` be `Anonymous`
    // [spec] will have their mode set to "cors"
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...Ke(this, as) ? { "Last-Event-ID": Ke(this, as) } : void 0 },
    cache: "no-store",
    signal: (r = Ke(this, Lr)) == null ? void 0 : r.signal
  };
  return "window" in globalThis && (t.credentials = this.withCredentials ? "include" : "same-origin"), t;
}, _h = /* @__PURE__ */ new WeakMap(), wh = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
ts = function(r, t) {
  var e;
  Ke(this, zt) !== this.CLOSED && pt(this, zt, this.CLOSED);
  const n = new ky("error", { code: t, message: r });
  (e = Ke(this, io)) == null || e.call(this, n), this.dispatchEvent(n);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
bh = function(r, t) {
  var e;
  if (Ke(this, zt) === this.CLOSED)
    return;
  pt(this, zt, this.CONNECTING);
  const n = new ky("error", { code: t, message: r });
  (e = Ke(this, io)) == null || e.call(this, n), this.dispatchEvent(n), pt(this, Yi, setTimeout(Ke(this, Th), Ke(this, ss)));
}, Th = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
vl.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
vl.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
vl.CLOSED = 2;
function zO() {
  const r = "document" in globalThis ? globalThis.document : void 0;
  return r && typeof r == "object" && "baseURI" in r && typeof r.baseURI == "string" ? r.baseURI : void 0;
}
let cp;
cp = globalThis.crypto;
async function YO(r) {
  return (await cp).getRandomValues(new Uint8Array(r));
}
async function ZO(r) {
  const t = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
  let e = "";
  const n = await YO(r);
  for (let i = 0; i < r; i++) {
    const o = n[i] % t.length;
    e += t[o];
  }
  return e;
}
async function jO(r) {
  return await ZO(r);
}
async function QO(r) {
  const t = await (await cp).subtle.digest("SHA-256", new TextEncoder().encode(r));
  return btoa(String.fromCharCode(...new Uint8Array(t))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
async function XO(r) {
  if (r || (r = 43), r < 43 || r > 128)
    throw `Expected a length between 43 and 128. Received ${r}.`;
  const t = await jO(r), e = await QO(t);
  return {
    code_verifier: t,
    code_challenge: e
  };
}
const eL = xe({
  issuer: ue(),
  authorization_endpoint: ue(),
  token_endpoint: ue(),
  registration_endpoint: ue().optional(),
  scopes_supported: Qe(ue()).optional(),
  response_types_supported: Qe(ue()),
  response_modes_supported: Qe(ue()).optional(),
  grant_types_supported: Qe(ue()).optional(),
  token_endpoint_auth_methods_supported: Qe(ue()).optional(),
  token_endpoint_auth_signing_alg_values_supported: Qe(ue()).optional(),
  service_documentation: ue().optional(),
  revocation_endpoint: ue().optional(),
  revocation_endpoint_auth_methods_supported: Qe(ue()).optional(),
  revocation_endpoint_auth_signing_alg_values_supported: Qe(ue()).optional(),
  introspection_endpoint: ue().optional(),
  introspection_endpoint_auth_methods_supported: Qe(ue()).optional(),
  introspection_endpoint_auth_signing_alg_values_supported: Qe(ue()).optional(),
  code_challenge_methods_supported: Qe(ue()).optional()
}).passthrough(), zb = xe({
  access_token: ue(),
  token_type: ue(),
  expires_in: Nt().optional(),
  scope: ue().optional(),
  refresh_token: ue().optional()
}).strip();
xe({
  error: ue(),
  error_description: ue().optional(),
  error_uri: ue().optional()
});
const tL = xe({
  redirect_uris: Qe(ue()).refine((r) => r.every((t) => URL.canParse(t)), { message: "redirect_uris must contain valid URLs" }),
  token_endpoint_auth_method: ue().optional(),
  grant_types: Qe(ue()).optional(),
  response_types: Qe(ue()).optional(),
  client_name: ue().optional(),
  client_uri: ue().optional(),
  logo_uri: ue().optional(),
  scope: ue().optional(),
  contacts: Qe(ue()).optional(),
  tos_uri: ue().optional(),
  policy_uri: ue().optional(),
  jwks_uri: ue().optional(),
  jwks: JP().optional(),
  software_id: ue().optional(),
  software_version: ue().optional()
}).strip(), nL = xe({
  client_id: ue(),
  client_secret: ue().optional(),
  client_id_issued_at: Nt().optional(),
  client_secret_expires_at: Nt().optional()
}).strip(), rL = tL.merge(nL);
xe({
  error: ue(),
  error_description: ue().optional()
}).strip();
xe({
  token: ue(),
  token_type_hint: ue().optional()
}).strip();
class Go extends Error {
  constructor(t) {
    super(t ?? "Unauthorized");
  }
}
async function of(r, { serverUrl: t, authorizationCode: e }) {
  const n = await iL(t);
  let i = await Promise.resolve(r.clientInformation());
  if (!i) {
    if (e !== void 0)
      throw new Error("Existing OAuth client information is required when exchanging an authorization code");
    if (!r.saveClientInformation)
      throw new Error("OAuth client information must be saveable for dynamic registration");
    const l = await lL(t, {
      metadata: n,
      clientMetadata: r.clientMetadata
    });
    await r.saveClientInformation(l), i = l;
  }
  if (e !== void 0) {
    const l = await r.codeVerifier(), c = await sL(t, {
      metadata: n,
      clientInformation: i,
      authorizationCode: e,
      codeVerifier: l,
      redirectUri: r.redirectUrl
    });
    return await r.saveTokens(c), "AUTHORIZED";
  }
  const o = await r.tokens();
  if (o?.refresh_token)
    try {
      const l = await aL(t, {
        metadata: n,
        clientInformation: i,
        refreshToken: o.refresh_token
      });
      return await r.saveTokens(l), "AUTHORIZED";
    } catch (l) {
      console.error("Could not refresh OAuth tokens:", l);
    }
  const { authorizationUrl: s, codeVerifier: u } = await oL(t, {
    metadata: n,
    clientInformation: i,
    redirectUrl: r.redirectUrl,
    scope: r.clientMetadata.scope
  });
  return await r.saveCodeVerifier(u), await r.redirectToAuthorization(s), "REDIRECT";
}
async function iL(r, t) {
  var e;
  const n = new URL("/.well-known/oauth-authorization-server", r);
  let i;
  try {
    i = await fetch(n, {
      headers: {
        "MCP-Protocol-Version": (e = t?.protocolVersion) !== null && e !== void 0 ? e : ip
      }
    });
  } catch (o) {
    if (o instanceof TypeError)
      i = await fetch(n);
    else
      throw o;
  }
  if (i.status !== 404) {
    if (!i.ok)
      throw new Error(`HTTP ${i.status} trying to load well-known OAuth metadata`);
    return eL.parse(await i.json());
  }
}
async function oL(r, { metadata: t, clientInformation: e, redirectUrl: n, scope: i }) {
  const o = "code", s = "S256";
  let u;
  if (t) {
    if (u = new URL(t.authorization_endpoint), !t.response_types_supported.includes(o))
      throw new Error(`Incompatible auth server: does not support response type ${o}`);
    if (!t.code_challenge_methods_supported || !t.code_challenge_methods_supported.includes(s))
      throw new Error(`Incompatible auth server: does not support code challenge method ${s}`);
  } else
    u = new URL("/authorize", r);
  const l = await XO(), c = l.code_verifier, d = l.code_challenge;
  return u.searchParams.set("response_type", o), u.searchParams.set("client_id", e.client_id), u.searchParams.set("code_challenge", d), u.searchParams.set("code_challenge_method", s), u.searchParams.set("redirect_uri", String(n)), i && u.searchParams.set("scope", i), { authorizationUrl: u, codeVerifier: c };
}
async function sL(r, { metadata: t, clientInformation: e, authorizationCode: n, codeVerifier: i, redirectUri: o }) {
  const s = "authorization_code";
  let u;
  if (t) {
    if (u = new URL(t.token_endpoint), t.grant_types_supported && !t.grant_types_supported.includes(s))
      throw new Error(`Incompatible auth server: does not support grant type ${s}`);
  } else
    u = new URL("/token", r);
  const l = new URLSearchParams({
    grant_type: s,
    client_id: e.client_id,
    code: n,
    code_verifier: i,
    redirect_uri: String(o)
  });
  e.client_secret && l.set("client_secret", e.client_secret);
  const c = await fetch(u, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: l
  });
  if (!c.ok)
    throw new Error(`Token exchange failed: HTTP ${c.status}`);
  return zb.parse(await c.json());
}
async function aL(r, { metadata: t, clientInformation: e, refreshToken: n }) {
  const i = "refresh_token";
  let o;
  if (t) {
    if (o = new URL(t.token_endpoint), t.grant_types_supported && !t.grant_types_supported.includes(i))
      throw new Error(`Incompatible auth server: does not support grant type ${i}`);
  } else
    o = new URL("/token", r);
  const s = new URLSearchParams({
    grant_type: i,
    client_id: e.client_id,
    refresh_token: n
  });
  e.client_secret && s.set("client_secret", e.client_secret);
  const u = await fetch(o, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: s
  });
  if (!u.ok)
    throw new Error(`Token refresh failed: HTTP ${u.status}`);
  return zb.parse(await u.json());
}
async function lL(r, { metadata: t, clientMetadata: e }) {
  let n;
  if (t) {
    if (!t.registration_endpoint)
      throw new Error("Incompatible auth server: does not support dynamic client registration");
    n = new URL(t.registration_endpoint);
  } else
    n = new URL("/register", r);
  const i = await fetch(n, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(e)
  });
  if (!i.ok)
    throw new Error(`Dynamic client registration failed: HTTP ${i.status}`);
  return rL.parse(await i.json());
}
class uL extends Error {
  constructor(t, e, n) {
    super(`SSE error: ${e}`), this.code = t, this.event = n;
  }
}
class cL {
  constructor(t, e) {
    this._url = t, this._eventSourceInit = e?.eventSourceInit, this._requestInit = e?.requestInit, this._authProvider = e?.authProvider;
  }
  async _authThenStart() {
    var t;
    if (!this._authProvider)
      throw new Go("No auth provider");
    let e;
    try {
      e = await of(this._authProvider, { serverUrl: this._url });
    } catch (n) {
      throw (t = this.onerror) === null || t === void 0 || t.call(this, n), n;
    }
    if (e !== "AUTHORIZED")
      throw new Go();
    return await this._startOrAuth();
  }
  async _commonHeaders() {
    const t = {};
    if (this._authProvider) {
      const e = await this._authProvider.tokens();
      e && (t.Authorization = `Bearer ${e.access_token}`);
    }
    return t;
  }
  _startOrAuth() {
    return new Promise((t, e) => {
      var n;
      this._eventSource = new vl(this._url.href, (n = this._eventSourceInit) !== null && n !== void 0 ? n : {
        fetch: (i, o) => this._commonHeaders().then((s) => fetch(i, {
          ...o,
          headers: {
            ...s,
            Accept: "text/event-stream"
          }
        }))
      }), this._abortController = new AbortController(), this._eventSource.onerror = (i) => {
        var o;
        if (i.code === 401 && this._authProvider) {
          this._authThenStart().then(t, e);
          return;
        }
        const s = new uL(i.code, i.message, i);
        e(s), (o = this.onerror) === null || o === void 0 || o.call(this, s);
      }, this._eventSource.onopen = () => {
      }, this._eventSource.addEventListener("endpoint", (i) => {
        var o;
        const s = i;
        try {
          if (this._endpoint = new URL(s.data, this._url), this._endpoint.origin !== this._url.origin)
            throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
        } catch (u) {
          e(u), (o = this.onerror) === null || o === void 0 || o.call(this, u), this.close();
          return;
        }
        t();
      }), this._eventSource.onmessage = (i) => {
        var o, s;
        const u = i;
        let l;
        try {
          l = tO.parse(JSON.parse(u.data));
        } catch (c) {
          (o = this.onerror) === null || o === void 0 || o.call(this, c);
          return;
        }
        (s = this.onmessage) === null || s === void 0 || s.call(this, l);
      };
    });
  }
  async start() {
    if (this._eventSource)
      throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    return await this._startOrAuth();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(t) {
    if (!this._authProvider)
      throw new Go("No auth provider");
    if (await of(this._authProvider, { serverUrl: this._url, authorizationCode: t }) !== "AUTHORIZED")
      throw new Go("Failed to authorize");
  }
  async close() {
    var t, e, n;
    (t = this._abortController) === null || t === void 0 || t.abort(), (e = this._eventSource) === null || e === void 0 || e.close(), (n = this.onclose) === null || n === void 0 || n.call(this);
  }
  async send(t) {
    var e, n, i;
    if (!this._endpoint)
      throw new Error("Not connected");
    try {
      const o = await this._commonHeaders(), s = new Headers({ ...o, ...(e = this._requestInit) === null || e === void 0 ? void 0 : e.headers });
      s.set("content-type", "application/json");
      const u = {
        ...this._requestInit,
        method: "POST",
        headers: s,
        body: JSON.stringify(t),
        signal: (n = this._abortController) === null || n === void 0 ? void 0 : n.signal
      }, l = await fetch(this._endpoint, u);
      if (!l.ok) {
        if (l.status === 401 && this._authProvider) {
          if (await of(this._authProvider, { serverUrl: this._url }) !== "AUTHORIZED")
            throw new Go();
          return this.send(t);
        }
        const c = await l.text().catch(() => null);
        throw new Error(`Error POSTing to endpoint (HTTP ${l.status}): ${c}`);
      }
    } catch (o) {
      throw (i = this.onerror) === null || i === void 0 || i.call(this, o), o;
    }
  }
}
const ai = Symbol.for("disabled-client");
function fL(r, t, e) {
  const n = new Iy({ name: "amp-mcp-client", version: "0.0.0-dev" }), i = It.of(void 0).pipe(
    _y(
      () => cb(
        ms(async () => (await n.close(), await new Promise((c) => setTimeout(c, 100)), e ? ai : dL(r, n, t))),
        gl
      ).pipe(
        zh((c) => {
          c instanceof Iy && c?.close();
        })
      ),
      {
        shouldCountRefs: !1
      }
    )
  ), o = i.subscribe({}), s = i.pipe(
    at((c) => c === ai ? { type: "disabled" } : c === $r ? { type: "connecting" } : c instanceof Error ? {
      type: "connection-failed",
      error: {
        message: c.message
      }
    } : {
      type: "connected",
      capabilities: c.getServerCapabilities(),
      serverInfo: c.getServerVersion()
    })
  ), l = i.pipe(
    Gn(
      (c) => {
        if (c === $r || c instanceof Error || c === ai)
          return It.of(c);
        const d = new pr();
        return c.setNotificationHandler(Gb, () => {
          d.next();
        }), d.pipe(
          VM({
            onUnsubscribe: () => c.removeNotificationHandler("notifications/tools/list_changed")
          }),
          ur(void 0),
          at(() => c)
        );
      }
    )
  ).pipe(
    _y((c) => c instanceof Error ? It.of(c) : c === ai ? It.of([]) : ms(async (d) => (await c.listTools({ signal: d })).tools))
  );
  return {
    status: s,
    tools: l,
    async callTool(c, d) {
      const g = await mP(i);
      if (g === ai)
        throw new Error("cannot call tools for disabled client");
      const y = await g.callTool(c, void 0, {
        signal: d,
        // TODO(sqs): hacky, but avoid having the MCP lib's default timeout (60 seconds)
        // apply here because we have our own timeout imposed by `signal`.
        timeout: 999999 * 1e3
      });
      if (!("content" in y))
        throw new Error("unexpected response");
      return y.content;
    },
    async dispose() {
      o.unsubscribe();
      try {
        await n.close();
      } catch (c) {
        oe.error("Error closing MCP client:", c);
      }
    }
  };
}
async function dL(r, t, e) {
  let n;
  if ("url" in r)
    n = new cL(new URL(r.url));
  else {
    const { loadProfileEnvironmentVariables: i } = await import("./load-profile-Bu7wgoOq.js"), o = e.loadProfile === "never" || !e.workingDirectory ? process.env : await it(
      i(e.workingDirectory, e.loadProfile)
    );
    n = await import("./stdio-CNkqPrBz.js").then(
      ({ StdioClientTransport: s }) => new s({
        ...r,
        stderr: "pipe",
        cwd: e.workingDirectory,
        env: { ...o, ...r.env }
      })
    );
  }
  "stderr" in n && n.stderr && typeof n.stderr == "object" && n.stderr !== null && "on" in n.stderr && typeof n.stderr.on == "function" && n.stderr.on("data", (i) => {
    const o = i.toString().trim();
    o && oe.info("mcp-server-stderr", { stderr: o, spec: r });
  });
  try {
    const i = t.connect(n), o = new Promise((s, u) => {
      const l = setTimeout(() => {
        clearTimeout(l), u(
          new Error("Connection timeout: MCP server did not respond within 10 seconds")
        );
      }, 1e4);
    });
    return await Promise.race([i, o]), t;
  } catch (i) {
    if (i instanceof Error) {
      if (i.message.includes("Connection closed"))
        throw new Error(
          "MCP server connection was closed unexpectedly. Check if the server is running and try refreshing the connection."
        );
      if (i.message.includes("Invalid content type"))
        throw new Error(
          'SSE error: Invalid content type, expected "text/event-stream". Check that the URL is correct and points to a valid MCP SSE endpoint. The server must respond with Content-Type: text/event-stream header.'
        );
      if ("url" in r && i.message.includes("fetch failed"))
        throw new Error(
          `Could not connect to MCP server at ${r.url}. Check that the server is running and accessible.`
        );
    }
    throw i;
  }
}
function hL({
  configService: r,
  toolService: t
}) {
  const e = wn.pipe(
    at(
      ({
        settings: {
          mcpServers: d,
          "terminal.commands.node-spawn.load-profile": g,
          "mcp.disable": y
        }
      }) => ({ mcpServers: d, loadProfile: g, disabledMCPServers: y })
    ),
    gs()
  ), n = r.workspaceRoots.pipe(at((d) => d.at(0)?.fsPath)), i = /* @__PURE__ */ new Map(), o = kn(e, n).pipe(
    Yh(300),
    at(async ([{ mcpServers: d, loadProfile: g, disabledMCPServers: y }, w]) => {
      for (const [b, _] of Object.entries(d ?? {})) {
        const C = y?.includes(b) ?? !1, m = i.get(b);
        m && pL(m.spec, { ..._, disabled: C }) || (i.set(b, {
          spec: { ..._, disabled: C },
          client: fL(_, { workingDirectory: w, loadProfile: g }, C)
        }), m && await m.client.dispose());
      }
      for (const [b, { client: _ }] of i.entries())
        (!d || !(b in d)) && (await _.dispose(), i.delete(b));
      return Array.from(i.entries());
    })
  ), s = o.subscribe({}), u = o.pipe(
    Gn(
      (d) => d.length === 0 ? It.of([]) : kn(
        ...d.map(
          ([g, { spec: y, client: w }]) => w.tools.pipe(
            at((b) => ({
              name: g,
              spec: y,
              tools: b === $r || b instanceof Error || b === ai ? [] : b,
              client: w
            }))
          )
        )
      )
    )
  );
  let l;
  const c = u.subscribe(
    (d) => {
      if (l)
        for (const g of l)
          g.dispose();
      l = [];
      for (const { name: g, tools: y, client: w } of d)
        for (const b of y)
          l.push(
            t.registerTool({
              spec: {
                name: b.name,
                description: b.description ?? "",
                inputSchema: b.inputSchema,
                source: { mcp: g }
              },
              fn: ({ args: _ }, C) => ms(
                (m) => w.callTool(
                  { name: b.name, arguments: _ ?? void 0 },
                  m
                ).then(
                  (T) => ({
                    status: "done",
                    result: T.map((S) => {
                      if (S.type === "text" || S.type === "image")
                        return S;
                      throw new Error(
                        `unsupported content type: ${S.type}`
                      );
                    })
                  })
                )
              )
            })
          );
    },
    (d) => {
      oe.error("MCP toolRegisterer error", d);
    }
  );
  return {
    servers: kn(wn, o).pipe(
      Gn(
        ([d, g]) => g.length === 0 ? It.of([]) : kn(
          ...g.map(
            ([y, { spec: w, client: b }]) => kn(b.status, b.tools).pipe(
              at(
                ([_, C]) => ({
                  name: y,
                  spec: w,
                  status: _,
                  tools: C instanceof Error ? C : C === $r || C === ai ? [] : C.map(
                    (m) => ({
                      spec: {
                        name: m.name,
                        description: m.description,
                        inputSchema: m.inputSchema,
                        source: { mcp: y }
                      },
                      ...HM(
                        {
                          name: m.name
                        },
                        d
                      )
                    })
                  )
                })
              )
            )
          )
        )
      )
    ),
    async addServer(d, g) {
      const y = (await it(wn)).settings.mcpServers;
      if (y && d in y)
        throw new Error(`MCP server already exists with name ${JSON.stringify(d)}`);
      if ("command" in g && typeof g.command != "string")
        throw new Error("Command must be a string");
      if ("url" in g)
        try {
          new URL(g.url);
        } catch {
          throw new Error(`Invalid URL: ${g.url}`);
        }
      await r.updateSettings("mcpServers", { ...y, [d]: g }, "global");
    },
    async removeServer(d) {
      const g = (await it(wn)).settings.mcpServers;
      if (!g || !(d in g))
        throw new Error(`MCP server does not exist with name ${JSON.stringify(d)}`);
      const y = { ...g };
      delete y[d], await r.updateSettings("mcpServers", y, "global");
    },
    async updateServer(d, g) {
      const y = (await it(wn)).settings.mcpServers;
      if (!y || !(d in y))
        throw new Error(`MCP server does not exist with name ${JSON.stringify(d)}`);
      await r.updateSettings("mcpServers", { ...y, [d]: g }, "global");
    },
    async dispose() {
      c.unsubscribe(), s.unsubscribe();
      const d = Array.from(i.values()).map(async ({ client: g }) => {
        try {
          await g.dispose();
        } catch (y) {
          oe.error("Error disposing MCP client:", y);
        }
      });
      await Promise.all(d), i.clear();
    }
  };
}
function pL(r, t) {
  return JSON.stringify(r) === JSON.stringify(t);
}
const mL = "Out of credits";
function gL(r) {
  let t = {}, e = !0;
  return r.changes.pipe(
    ur(void 0),
    ys(async (n, i) => {
      if (n === void 0 || e) {
        const o = await r.keys();
        i?.throwIfAborted(), t = Object.fromEntries(
          await Promise.all(o.map(async (s) => [s, await r.get(s)]))
        ), i?.throwIfAborted(), e = !1;
      } else {
        const o = await r.get(n);
        i?.throwIfAborted(), o === void 0 ? (t = { ...t, [n]: void 0 }, delete t[n]) : t = { ...t, [n]: o };
      }
      return t;
    })
  );
}
function yL(r) {
  const t = {}, e = new pr();
  return {
    async get(n) {
      return Promise.resolve(t[n]);
    },
    async set(n, i) {
      t[n] = i, e.next(n);
    },
    async delete(n) {
      delete t[n], e.next(n);
    },
    async keys() {
      return Promise.resolve(Object.keys(t));
    },
    async path(n) {
      return Promise.resolve(void 0);
    },
    changes: e.pipe(ur(void 0))
  };
}
function vL(r) {
  const { interval: t, fn: e, cacheKey: n } = r, i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  return (...s) => {
    const u = n ? n(...s) : "default", l = Date.now(), c = o.get(u) || 0;
    if (i.has(u) && l - c < t)
      return i.get(u);
    o.set(u, l);
    const d = e(...s);
    return i.set(u, d), d;
  };
}
const _L = vL({
  interval: 20 * 1e3,
  fn: wL,
  cacheKey: (r) => r.toString()
});
async function wL(r, t) {
  const e = t?.workingDirectory?.fsPath === r.fsPath ? " (your working directory)" : "", n = [t?.testing ? "./" : r.fsPath + e], i = await zk(r.fsPath), o = await Promise.all(
    i.filter((s) => !GM(s)).map(async (s) => {
      try {
        const u = await Yk(Qk(r.fsPath, s));
        return { name: s, isDirectory: u.isDirectory() };
      } catch {
        return { name: s, isDirectory: !1 };
      }
    })
  );
  o.sort((s, u) => s.isDirectory === u.isDirectory ? s.name.localeCompare(u.name) : s.isDirectory ? -1 : 1);
  for (let s = 0; s < o.length; s++) {
    const { name: u, isDirectory: l } = o[s], g = `${s === o.length - 1 ? " " : " "}${u}${l ? "/" : ""}`;
    n.push(g);
  }
  return n.join(`
`);
}
class bL {
  constructor(t) {
    this.storage = t, this._observeHistory = Zh(
      gL(this.storage).pipe(
        at((e) => {
          const n = Object.values(e).filter((o) => o && "messages" in o).toSorted((o, s) => s.created - o.created), i = [];
          for (const o of n)
            o.messages.length === 0 || i.push(o);
          return i.map(
            (o) => ({
              id: o.id,
              v: o.v,
              created: o.created,
              title: o.title ?? null,
              userLastInteractedAt: TL(o),
              env: o.env,
              originThreadID: o.originThreadID
            })
          ).toSorted((o, s) => s.userLastInteractedAt - o.userLastInteractedAt);
        }),
        eu()
      )
    );
  }
  /**
   * Delete a thread.
   */
  async delete(t) {
    await this.storage.delete(t);
  }
  /**
   * Observe the history of all threads.
   */
  observeHistory() {
    return this._observeHistory.observable;
  }
  _observeHistory;
  dispose() {
    this._observeHistory.subscription.unsubscribe();
  }
}
function TL(r) {
  return Math.max(
    r.created,
    ...r.messages.map((t) => t.role === "user" ? t.meta?.sentAt : void 0).filter((t) => t !== void 0)
  );
}
function Yb() {
  return new Promise((r) => setTimeout(r, 0));
}
class CL {
  constructor(t) {
    this.storage = t;
  }
  /** Keeps track of threads that have exclusive read-writers, along with their BehaviorSubjects. */
  exclusiveThreads = /* @__PURE__ */ new Map();
  /** Emits whenever the set of exclusive threads changes. */
  exclusiveThreadsChanged = new pr();
  /**
   * Observable that emits whenever the set of exclusive threads (the threads that are writable by
   * this process) changes. Observers should listen to the individual BehaviorSubjects for each
   * thread to listen for changes to the content of a thread.
   *
   * Observers MUST NOT mutate the returned Map, as it is shared with other observers.
   */
  exclusiveThreadsChanges = this.exclusiveThreadsChanged.pipe(
    ur(void 0),
    at(() => this.exclusiveThreads)
  );
  flushRequests = new pr();
  /** Periodically flush threads to storage. */
  flusher = this.exclusiveThreadsChanged.pipe(
    at(() => Array.from(this.exclusiveThreads.keys())),
    Gn(
      (t) => t.length > 0 ? kn(
        ...t.map((e) => {
          const n = this.exclusiveThreads.get(e);
          return n ? kn(
            n.pipe(Yh(0), ur(void 0)),
            this.flushRequests.pipe(ur(void 0))
          ).pipe(
            ys(async () => {
              const i = n.getValue();
              await this.storage.set(e, i);
            }),
            ub((i) => (oe.error("Error flushing thread to storage:", i, {
              name: "ThreadService",
              threadID: e
            }), gl))
          ) : gl;
        })
      ) : gl
    )
  ).subscribe({});
  /**
   * Observe the chat thread with the given {@link id}. The returned {@link Observable} emits
   * whenever there are any changes to the chat thread by an
   * {@link ThreadService.exclusiveSyncReadWriter} in this execution context.
   */
  observe(t) {
    return this.exclusiveThreadsChanged.pipe(
      ur(void 0),
      at(() => this.exclusiveThreads.has(t)),
      gs(),
      Gn((e) => e ? this.exclusiveThreads.get(t) : ms(async (n) => {
        let i = await this.storage.get(t);
        return n?.throwIfAborted(), i || (i = Ly(t), await this.storage.set(t, i), n?.throwIfAborted()), i;
      })),
      // Throttle to avoid passing very large objects (~1MB+ often) across the RPC boundary,
      // which causes GC pressure.
      WM(100)
    );
  }
  /**
   * Get exclusive synchronous read/write access to a thread. Only one caller can hold this access
   * at a time, and this is the only way to update a thread. It returns an object that supports
   * synchronous reading and writing of the {@link Thread} value.
   *
   * @throws Error if someone already has exclusive access to this thread
   */
  async exclusiveSyncReadWriter(t) {
    if (this.exclusiveThreads.has(t))
      throw new Error(`Thread ${t} already has an exclusive read-writer`);
    let e = this.exclusiveThreads.get(t);
    if (!e) {
      let o = await this.storage.get(t);
      o || (o = Ly(t), await this.storage.set(t, o)), e = new Nr(o), this.exclusiveThreads.set(t, e), this.exclusiveThreadsChanged.next(), await Yb();
    }
    let n = !1;
    return {
      read: () => {
        if (n)
          throw new Error("thread exclusive read-writer was disposed");
        return e.getValue();
      },
      write: (o) => {
        if (n)
          throw new Error("thread exclusive read-writer was disposed");
        const s = JSON.parse(JSON.stringify(o));
        e.next(s);
      },
      dispose: () => {
        n || (n = !0, this.exclusiveThreads.delete(t), this.exclusiveThreadsChanged.next());
      }
    };
  }
  flush() {
    this.flushRequests.next();
  }
  /**
   * Flush a thread to storage and wait until the storage has been updated with at least the specified version.
   * This is useful for ensuring that changes to a thread are persisted before continuing.
   *
   * The caller MUST ensure that they've written a thread with that version before.
   *
   * @param id The ID of the thread to flush
   * @param version The minimum version number to wait for
   * @param timeout Optional timeout in milliseconds (defaults to 5000ms)
   * @returns A promise that resolves when the thread has been flushed with the specified version
   */
  async flushVersion(t, e, n = 5e3) {
    this.flush();
    const i = Date.now();
    for (; ; ) {
      if (Date.now() - i > n)
        throw new Error(`Timed out waiting for thread ${t} to reach version ${e}`);
      const o = await this.storage.get(t);
      if (o && o.v >= e)
        return;
      await new Promise((s) => setTimeout(s, 10));
    }
  }
  /**
   * Delete a thread from exclusive access tracking.
   * Note: This does not delete the thread from storage. Use ThreadHistoryService.delete for that.
   */
  deleteFromExclusiveAccess(t) {
    this.exclusiveThreads.delete(t), this.exclusiveThreadsChanged.next();
  }
  dispose() {
    this.flusher.unsubscribe(), this.exclusiveThreads.clear();
  }
}
function Ly(r) {
  return {
    v: 0,
    id: r,
    created: Date.now(),
    messages: []
  };
}
function SL({
  threadService: r,
  threadHistoryService: t,
  isExtensionDevelopment: e = !1
}) {
  let n = !1;
  const i = [], o = dP(), s = new Nr(/* @__PURE__ */ new Map()), u = async () => {
    if (n || !await it(Xk))
      return !1;
    const _ = await it(wn);
    return e && vP(_.settings.url) ? (oe.debug(
      `Skipping sync to ${qr} in extension development mode to avoid polluting the production server`,
      { name: "ThreadSyncService" }
    ), !1) : !0;
  }, l = async (_) => {
    if (!g(_))
      return;
    const C = await it(r.observe(_));
    if (C && !C.messages.length || !await u())
      return;
    const m = new AbortController();
    i.push({
      dispose: () => m.abort()
    });
    const T = await Dr(`/api/threads/${_}`, {
      method: "POST",
      body: JSON.stringify(C),
      signal: m.signal
    });
    if (!T.ok) {
      const S = await T.text().catch(() => "Unable to read response body");
      throw new Error(
        `Thread sync API (for thread ${_}) responded with status: ${T.status}${S ? `: ${S}` : ""}`
      );
    }
  }, c = /* @__PURE__ */ new Map(), d = 6e4, g = (_) => {
    const C = c.get(_);
    if (!C)
      return !0;
    const m = Date.now() - C, T = m >= d;
    return T || oe.debug(
      `Skipping thread ${_} sync due to backoff (${Math.round(m / 1e3)}s elapsed of ${d / 1e3}s backoff)`,
      { name: "ThreadSyncService" }
    ), T;
  }, y = async () => {
    for (const _ of o.set)
      if (g(_))
        try {
          await l(_), o.delete(_), c.delete(_);
        } catch (C) {
          c.set(_, Date.now()), oe.error(`Error syncing thread ${_} (will retry after backoff)`, C, {
            name: "ThreadSyncService"
          });
        }
  }, w = async (_, C = !1) => {
    if (!await u())
      return;
    let m;
    if (_)
      m = (await Promise.all(
        _.map(
          (O) => it(
            r.observe(O).pipe(at((k) => k ? { id: k.id, v: k.v } : null))
          )
        )
      )).filter((O) => O !== null);
    else {
      const O = await it(
        t.observeHistory().pipe(
          at(
            (H) => H.map((V) => ({ id: V.id, v: V.v }))
          )
        )
      ), k = await it(
        r.exclusiveThreadsChanges.pipe(
          at(
            (H) => Object.values(H).map(
              (V) => ({ id: V.id, v: V.v })
            )
          )
        )
      );
      m = O.concat(k);
    }
    const T = {
      threadVersions: [],
      threadMetas: []
    }, S = /* @__PURE__ */ new Set();
    for (const O of m) {
      if (S.has(O.id))
        continue;
      S.add(O.id), C || T.threadVersions.push({ id: O.id, v: O.v });
      const k = s.getValue().get(O.id);
      T.threadMetas.push({
        id: O.id,
        meta: k && k.status === "synced" ? k.info?.meta : void 0
      });
    }
    if (T.threadVersions.length === 0 && T.threadMetas.length === 0 || !await u())
      return;
    const A = new AbortController();
    i.push({
      dispose: () => A.abort()
    }), oe.debug("Sending threads sync request", { name: "ThreadSyncService" });
    const x = await Dr("/api/threads/sync", {
      method: "POST",
      body: JSON.stringify(T),
      signal: A.signal
    });
    if (!x.ok) {
      const O = await x.text().catch(() => "Unable to read response body");
      throw oe.warn("Threads sync request failed", {
        name: "ThreadSyncService",
        status: x.status,
        text: O
      }), new Error(
        `Threads sync API responded with status: ${x.status}${O ? `: ${O}` : ""}`
      );
    }
    oe.debug("Got response for threads sync request", {
      name: "ThreadSyncService",
      status: x.status
    });
    const D = await x.json();
    let U = 0;
    for (const O of D.threadActions)
      if ("action" in O && typeof O.action == "string")
        switch (O.action) {
          case "upload": {
            o.add(O.id), U++;
            break;
          }
          case "meta": {
            s.getValue().set(O.id, { status: "synced", info: { meta: O.meta } });
            break;
          }
          default:
            continue;
        }
    if (_)
      for (const O of _)
        s.getValue().get(O)?.status === "unknown" && s.getValue().set(O, { status: "synced", info: null });
    s.next(s.getValue()), await y(), oe.debug(
      `Sync completed (${_ ? _.length : "all"} threads checked, ${U} threads needed sync)`,
      { name: "ThreadSyncService" }
    );
  }, b = w().catch(
    (_) => oe.error("Failed to perform initial sync:", _, { name: "ThreadSyncService" })
  );
  return i.push(
    gy(
      o.observable.pipe(
        is((_) => _.size > 0),
        Yh(3e3),
        // Debounce to batch closely-timed changes
        ys(
          () => y().catch(
            (_) => oe.error("Error processing sync queue:", _, {
              name: "ThreadSyncService"
            })
          )
        )
      ).subscribe({})
    )
  ), i.push(
    gy(
      r.exclusiveThreadsChanges.pipe(
        Gn(
          (_) => Rl(
            ...Array.from(_.entries()).map(
              ([, C]) => C.pipe(KM((m) => o.add(m.id)))
            )
          )
        )
      ).subscribe({})
    )
  ), {
    async sync() {
      return w();
    },
    initialSyncComplete: b,
    async updateThreadMeta(_, C) {
      const m = s.getValue().get(_);
      try {
        s.getValue().set(_, { status: "synced", info: { meta: C } }), s.next(s.getValue());
        const T = new AbortController();
        i.push({
          dispose: () => T.abort()
        });
        const S = await Dr(`/api/threads/${_}/meta`, {
          method: "PUT",
          body: JSON.stringify({ private: C.private, public: C.public }),
          signal: T.signal
        });
        if (!S.ok)
          throw new Error(`Failed to update sharing status: ${S.status}`);
      } catch (T) {
        throw m ? s.getValue().set(_, m) : s.getValue().delete(_), T;
      }
    },
    threadSyncInfo(_) {
      for (const C of _)
        s.getValue().has(C) || s.getValue().set(C, { status: "unknown" });
      return w(_, !0).catch(
        (C) => oe.error("Error syncing thread metadata:", C, {
          name: "ThreadSyncService"
        })
      ), s.pipe(
        at((C) => {
          const m = {};
          for (const T of _)
            m[T] = C.get(T) ?? {
              status: "synced",
              info: null
            };
          return m;
        })
      );
    },
    dispose() {
      if (!n) {
        n = !0;
        for (const _ of i)
          _.dispose();
      }
    }
  };
}
function EL(r) {
  if (r === 59999) return "59.99s";
  if (r === 3599999) return "59m 59.99s";
  const t = r / 1e3, e = t / 60, n = e / 60, i = n / 24, o = Math.floor(i), s = Math.floor(n) % 24, u = Math.floor(e) % 60, l = Math.floor(t) % 60, c = (t - Math.floor(t)).toFixed(2).substring(1);
  return o > 0 ? `${o}d ${s}h` : s > 0 ? `${s}h ${u}m` : u > 0 ? `${u}m ${l}${c}s` : `${Math.floor(t)}${c}s`;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let AL, xL;
function RL() {
  return {
    geminiUrl: AL,
    vertexUrl: xL
  };
}
function IL(r, t, e) {
  var n, i, o;
  if (!(!((n = r.httpOptions) === null || n === void 0) && n.baseUrl)) {
    const s = RL();
    return r.vertexai ? (i = s.vertexUrl) !== null && i !== void 0 ? i : t : (o = s.geminiUrl) !== null && o !== void 0 ? o : e;
  }
  return r.httpOptions.baseUrl;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Cs {
}
function ke(r, t) {
  const e = /\{([^}]+)\}/g;
  return r.replace(e, (n, i) => {
    if (Object.prototype.hasOwnProperty.call(t, i)) {
      const o = t[i];
      return o != null ? String(o) : "";
    } else
      throw new Error(`Key '${i}' not found in valueMap.`);
  });
}
function p(r, t, e) {
  for (let o = 0; o < t.length - 1; o++) {
    const s = t[o];
    if (s.endsWith("[]")) {
      const u = s.slice(0, -2);
      if (!(u in r))
        if (Array.isArray(e))
          r[u] = Array.from({ length: e.length }, () => ({}));
        else
          throw new Error(`Value must be a list given an array path ${s}`);
      if (Array.isArray(r[u])) {
        const l = r[u];
        if (Array.isArray(e))
          for (let c = 0; c < l.length; c++) {
            const d = l[c];
            p(d, t.slice(o + 1), e[c]);
          }
        else
          for (const c of l)
            p(c, t.slice(o + 1), e);
      }
      return;
    } else if (s.endsWith("[0]")) {
      const u = s.slice(0, -3);
      u in r || (r[u] = [{}]);
      const l = r[u];
      p(l[0], t.slice(o + 1), e);
      return;
    }
    (!r[s] || typeof r[s] != "object") && (r[s] = {}), r = r[s];
  }
  const n = t[t.length - 1], i = r[n];
  if (i !== void 0) {
    if (!e || typeof e == "object" && Object.keys(e).length === 0 || e === i)
      return;
    if (typeof i == "object" && typeof e == "object" && i !== null && e !== null)
      Object.assign(i, e);
    else
      throw new Error(`Cannot set value for an existing key. Key: ${n}`);
  } else
    r[n] = e;
}
function h(r, t) {
  try {
    if (t.length === 1 && t[0] === "_self")
      return r;
    for (let e = 0; e < t.length; e++) {
      if (typeof r != "object" || r === null)
        return;
      const n = t[e];
      if (n.endsWith("[]")) {
        const i = n.slice(0, -2);
        if (i in r) {
          const o = r[i];
          return Array.isArray(o) ? o.map((s) => h(s, t.slice(e + 1))) : void 0;
        } else
          return;
      } else
        r = r[n];
    }
    return r;
  } catch (e) {
    if (e instanceof TypeError)
      return;
    throw e;
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Ny;
(function(r) {
  r.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED", r.OUTCOME_OK = "OUTCOME_OK", r.OUTCOME_FAILED = "OUTCOME_FAILED", r.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED";
})(Ny || (Ny = {}));
var Dy;
(function(r) {
  r.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED", r.PYTHON = "PYTHON";
})(Dy || (Dy = {}));
var Fy;
(function(r) {
  r.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", r.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", r.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT", r.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", r.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", r.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY";
})(Fy || (Fy = {}));
var $y;
(function(r) {
  r.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED", r.SEVERITY = "SEVERITY", r.PROBABILITY = "PROBABILITY";
})($y || ($y = {}));
var Uy;
(function(r) {
  r.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", r.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", r.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", r.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", r.BLOCK_NONE = "BLOCK_NONE", r.OFF = "OFF";
})(Uy || (Uy = {}));
var Lt;
(function(r) {
  r.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED", r.STRING = "STRING", r.NUMBER = "NUMBER", r.INTEGER = "INTEGER", r.BOOLEAN = "BOOLEAN", r.ARRAY = "ARRAY", r.OBJECT = "OBJECT";
})(Lt || (Lt = {}));
var qy;
(function(r) {
  r.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", r.MODE_DYNAMIC = "MODE_DYNAMIC";
})(qy || (qy = {}));
var By;
(function(r) {
  r.AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED", r.NO_AUTH = "NO_AUTH", r.API_KEY_AUTH = "API_KEY_AUTH", r.HTTP_BASIC_AUTH = "HTTP_BASIC_AUTH", r.GOOGLE_SERVICE_ACCOUNT_AUTH = "GOOGLE_SERVICE_ACCOUNT_AUTH", r.OAUTH = "OAUTH", r.OIDC_AUTH = "OIDC_AUTH";
})(By || (By = {}));
var Vy;
(function(r) {
  r.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", r.STOP = "STOP", r.MAX_TOKENS = "MAX_TOKENS", r.SAFETY = "SAFETY", r.RECITATION = "RECITATION", r.LANGUAGE = "LANGUAGE", r.OTHER = "OTHER", r.BLOCKLIST = "BLOCKLIST", r.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", r.SPII = "SPII", r.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", r.IMAGE_SAFETY = "IMAGE_SAFETY";
})(Vy || (Vy = {}));
var Hy;
(function(r) {
  r.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", r.NEGLIGIBLE = "NEGLIGIBLE", r.LOW = "LOW", r.MEDIUM = "MEDIUM", r.HIGH = "HIGH";
})(Hy || (Hy = {}));
var Gy;
(function(r) {
  r.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED", r.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE", r.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW", r.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM", r.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH";
})(Gy || (Gy = {}));
var Wy;
(function(r) {
  r.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", r.SAFETY = "SAFETY", r.OTHER = "OTHER", r.BLOCKLIST = "BLOCKLIST", r.PROHIBITED_CONTENT = "PROHIBITED_CONTENT";
})(Wy || (Wy = {}));
var Ky;
(function(r) {
  r.TRAFFIC_TYPE_UNSPECIFIED = "TRAFFIC_TYPE_UNSPECIFIED", r.ON_DEMAND = "ON_DEMAND", r.PROVISIONED_THROUGHPUT = "PROVISIONED_THROUGHPUT";
})(Ky || (Ky = {}));
var Hl;
(function(r) {
  r.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", r.TEXT = "TEXT", r.IMAGE = "IMAGE", r.AUDIO = "AUDIO";
})(Hl || (Hl = {}));
var Jy;
(function(r) {
  r.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", r.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", r.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", r.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH";
})(Jy || (Jy = {}));
var Ch;
(function(r) {
  r.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED", r.JOB_STATE_QUEUED = "JOB_STATE_QUEUED", r.JOB_STATE_PENDING = "JOB_STATE_PENDING", r.JOB_STATE_RUNNING = "JOB_STATE_RUNNING", r.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED", r.JOB_STATE_FAILED = "JOB_STATE_FAILED", r.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING", r.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED", r.JOB_STATE_PAUSED = "JOB_STATE_PAUSED", r.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED", r.JOB_STATE_UPDATING = "JOB_STATE_UPDATING", r.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED";
})(Ch || (Ch = {}));
var zy;
(function(r) {
  r.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED", r.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE", r.ADAPTER_SIZE_TWO = "ADAPTER_SIZE_TWO", r.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR", r.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT", r.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN", r.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO";
})(zy || (zy = {}));
var Yy;
(function(r) {
  r.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED", r.PRIORITIZE_QUALITY = "PRIORITIZE_QUALITY", r.BALANCED = "BALANCED", r.PRIORITIZE_COST = "PRIORITIZE_COST";
})(Yy || (Yy = {}));
var Zy;
(function(r) {
  r.UNSPECIFIED = "UNSPECIFIED", r.BLOCKING = "BLOCKING", r.NON_BLOCKING = "NON_BLOCKING";
})(Zy || (Zy = {}));
var jy;
(function(r) {
  r.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", r.MODE_DYNAMIC = "MODE_DYNAMIC";
})(jy || (jy = {}));
var Qy;
(function(r) {
  r.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", r.AUTO = "AUTO", r.ANY = "ANY", r.NONE = "NONE";
})(Qy || (Qy = {}));
var Xy;
(function(r) {
  r.URL_RETRIEVAL_STATUS_UNSPECIFIED = "URL_RETRIEVAL_STATUS_UNSPECIFIED", r.URL_RETRIEVAL_STATUS_SUCCESS = "URL_RETRIEVAL_STATUS_SUCCESS", r.URL_RETRIEVAL_STATUS_ERROR = "URL_RETRIEVAL_STATUS_ERROR";
})(Xy || (Xy = {}));
var ev;
(function(r) {
  r.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", r.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", r.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", r.BLOCK_NONE = "BLOCK_NONE";
})(ev || (ev = {}));
var tv;
(function(r) {
  r.DONT_ALLOW = "DONT_ALLOW", r.ALLOW_ADULT = "ALLOW_ADULT", r.ALLOW_ALL = "ALLOW_ALL";
})(tv || (tv = {}));
var nv;
(function(r) {
  r.auto = "auto", r.en = "en", r.ja = "ja", r.ko = "ko", r.hi = "hi";
})(nv || (nv = {}));
var rv;
(function(r) {
  r.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT", r.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED", r.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND", r.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND", r.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC";
})(rv || (rv = {}));
var iv;
(function(r) {
  r.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT", r.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY", r.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE", r.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH";
})(iv || (iv = {}));
var ov;
(function(r) {
  r.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT", r.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON", r.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL", r.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT";
})(ov || (ov = {}));
var sv;
(function(r) {
  r.EDIT_MODE_DEFAULT = "EDIT_MODE_DEFAULT", r.EDIT_MODE_INPAINT_REMOVAL = "EDIT_MODE_INPAINT_REMOVAL", r.EDIT_MODE_INPAINT_INSERTION = "EDIT_MODE_INPAINT_INSERTION", r.EDIT_MODE_OUTPAINT = "EDIT_MODE_OUTPAINT", r.EDIT_MODE_CONTROLLED_EDITING = "EDIT_MODE_CONTROLLED_EDITING", r.EDIT_MODE_STYLE = "EDIT_MODE_STYLE", r.EDIT_MODE_BGSWAP = "EDIT_MODE_BGSWAP", r.EDIT_MODE_PRODUCT_IMAGE = "EDIT_MODE_PRODUCT_IMAGE";
})(sv || (sv = {}));
var av;
(function(r) {
  r.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", r.PROCESSING = "PROCESSING", r.ACTIVE = "ACTIVE", r.FAILED = "FAILED";
})(av || (av = {}));
var lv;
(function(r) {
  r.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED", r.UPLOADED = "UPLOADED", r.GENERATED = "GENERATED";
})(lv || (lv = {}));
var uv;
(function(r) {
  r.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", r.TEXT = "TEXT", r.IMAGE = "IMAGE", r.VIDEO = "VIDEO", r.AUDIO = "AUDIO", r.DOCUMENT = "DOCUMENT";
})(uv || (uv = {}));
var cv;
(function(r) {
  r.START_SENSITIVITY_UNSPECIFIED = "START_SENSITIVITY_UNSPECIFIED", r.START_SENSITIVITY_HIGH = "START_SENSITIVITY_HIGH", r.START_SENSITIVITY_LOW = "START_SENSITIVITY_LOW";
})(cv || (cv = {}));
var fv;
(function(r) {
  r.END_SENSITIVITY_UNSPECIFIED = "END_SENSITIVITY_UNSPECIFIED", r.END_SENSITIVITY_HIGH = "END_SENSITIVITY_HIGH", r.END_SENSITIVITY_LOW = "END_SENSITIVITY_LOW";
})(fv || (fv = {}));
var dv;
(function(r) {
  r.ACTIVITY_HANDLING_UNSPECIFIED = "ACTIVITY_HANDLING_UNSPECIFIED", r.START_OF_ACTIVITY_INTERRUPTS = "START_OF_ACTIVITY_INTERRUPTS", r.NO_INTERRUPTION = "NO_INTERRUPTION";
})(dv || (dv = {}));
var hv;
(function(r) {
  r.TURN_COVERAGE_UNSPECIFIED = "TURN_COVERAGE_UNSPECIFIED", r.TURN_INCLUDES_ONLY_ACTIVITY = "TURN_INCLUDES_ONLY_ACTIVITY", r.TURN_INCLUDES_ALL_INPUT = "TURN_INCLUDES_ALL_INPUT";
})(hv || (hv = {}));
var pv;
(function(r) {
  r.SCHEDULING_UNSPECIFIED = "SCHEDULING_UNSPECIFIED", r.SILENT = "SILENT", r.WHEN_IDLE = "WHEN_IDLE", r.INTERRUPT = "INTERRUPT";
})(pv || (pv = {}));
var mv;
(function(r) {
  r.SCALE_UNSPECIFIED = "SCALE_UNSPECIFIED", r.C_MAJOR_A_MINOR = "C_MAJOR_A_MINOR", r.D_FLAT_MAJOR_B_FLAT_MINOR = "D_FLAT_MAJOR_B_FLAT_MINOR", r.D_MAJOR_B_MINOR = "D_MAJOR_B_MINOR", r.E_FLAT_MAJOR_C_MINOR = "E_FLAT_MAJOR_C_MINOR", r.E_MAJOR_D_FLAT_MINOR = "E_MAJOR_D_FLAT_MINOR", r.F_MAJOR_D_MINOR = "F_MAJOR_D_MINOR", r.G_FLAT_MAJOR_E_FLAT_MINOR = "G_FLAT_MAJOR_E_FLAT_MINOR", r.G_MAJOR_E_MINOR = "G_MAJOR_E_MINOR", r.A_FLAT_MAJOR_F_MINOR = "A_FLAT_MAJOR_F_MINOR", r.A_MAJOR_G_FLAT_MINOR = "A_MAJOR_G_FLAT_MINOR", r.B_FLAT_MAJOR_G_MINOR = "B_FLAT_MAJOR_G_MINOR", r.B_MAJOR_A_FLAT_MINOR = "B_MAJOR_A_FLAT_MINOR";
})(mv || (mv = {}));
var gv;
(function(r) {
  r.MUSIC_GENERATION_MODE_UNSPECIFIED = "MUSIC_GENERATION_MODE_UNSPECIFIED", r.QUALITY = "QUALITY", r.DIVERSITY = "DIVERSITY";
})(gv || (gv = {}));
var Zi;
(function(r) {
  r.PLAYBACK_CONTROL_UNSPECIFIED = "PLAYBACK_CONTROL_UNSPECIFIED", r.PLAY = "PLAY", r.PAUSE = "PAUSE", r.STOP = "STOP", r.RESET_CONTEXT = "RESET_CONTEXT";
})(Zi || (Zi = {}));
class Wo {
  /**
   * Returns the concatenation of all text parts from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the text from the first
   * one will be returned.
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   * If there are thought parts in the response, the concatenation of all text
   * parts excluding the thought parts will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'Why is the sky blue?',
   * });
   *
   * console.debug(response.text);
   * ```
   */
  get text() {
    var t, e, n, i, o, s, u, l;
    if (((i = (n = (e = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || e === void 0 ? void 0 : e.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning text from the first one.");
    let c = "", d = !1;
    const g = [];
    for (const y of (l = (u = (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) !== null && l !== void 0 ? l : []) {
      for (const [w, b] of Object.entries(y))
        w !== "text" && w !== "thought" && (b !== null || b !== void 0) && g.push(w);
      if (typeof y.text == "string") {
        if (typeof y.thought == "boolean" && y.thought)
          continue;
        d = !0, c += y.text;
      }
    }
    return g.length > 0 && console.warn(`there are non-text parts ${g} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), d ? c : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the first candidate
   * in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the inline data from the
   * first one will be returned. If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var t, e, n, i, o, s, u, l;
    if (((i = (n = (e = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || e === void 0 ? void 0 : e.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning data from the first one.");
    let c = "";
    const d = [];
    for (const g of (l = (u = (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) !== null && l !== void 0 ? l : []) {
      for (const [y, w] of Object.entries(g))
        y !== "inlineData" && (w !== null || w !== void 0) && d.push(y);
      g.inlineData && typeof g.inlineData.data == "string" && (c += atob(g.inlineData.data));
    }
    return d.length > 0 && console.warn(`there are non-data parts ${d} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), c.length > 0 ? btoa(c) : void 0;
  }
  /**
   * Returns the function calls from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the function calls from
   * the first one will be returned.
   * If there are no function calls in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const controlLightFunctionDeclaration: FunctionDeclaration = {
   *   name: 'controlLight',
   *   parameters: {
   *   type: Type.OBJECT,
   *   description: 'Set the brightness and color temperature of a room light.',
   *   properties: {
   *     brightness: {
   *       type: Type.NUMBER,
   *       description:
   *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
   *     },
   *     colorTemperature: {
   *       type: Type.STRING,
   *       description:
   *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
   *     },
   *   },
   *   required: ['brightness', 'colorTemperature'],
   *  };
   *  const response = await ai.models.generateContent({
   *     model: 'gemini-2.0-flash',
   *     contents: 'Dim the lights so the room feels cozy and warm.',
   *     config: {
   *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
   *       toolConfig: {
   *         functionCallingConfig: {
   *           mode: FunctionCallingConfigMode.ANY,
   *           allowedFunctionNames: ['controlLight'],
   *         },
   *       },
   *     },
   *   });
   *  console.debug(JSON.stringify(response.functionCalls));
   * ```
   */
  get functionCalls() {
    var t, e, n, i, o, s, u, l;
    if (((i = (n = (e = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || e === void 0 ? void 0 : e.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning function calls from the first one.");
    const c = (l = (u = (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) === null || l === void 0 ? void 0 : l.filter((d) => d.functionCall).map((d) => d.functionCall).filter((d) => d !== void 0);
    if (c?.length !== 0)
      return c;
  }
  /**
   * Returns the first executable code from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the executable code from
   * the first one will be returned.
   * If there are no executable code in the response, undefined will be
   * returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.executableCode);
   * ```
   */
  get executableCode() {
    var t, e, n, i, o, s, u, l, c;
    if (((i = (n = (e = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || e === void 0 ? void 0 : e.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning executable code from the first one.");
    const d = (l = (u = (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) === null || l === void 0 ? void 0 : l.filter((g) => g.executableCode).map((g) => g.executableCode).filter((g) => g !== void 0);
    if (d?.length !== 0)
      return (c = d?.[0]) === null || c === void 0 ? void 0 : c.code;
  }
  /**
   * Returns the first code execution result from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the code execution result from
   * the first one will be returned.
   * If there are no code execution result in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.codeExecutionResult);
   * ```
   */
  get codeExecutionResult() {
    var t, e, n, i, o, s, u, l, c;
    if (((i = (n = (e = (t = this.candidates) === null || t === void 0 ? void 0 : t[0]) === null || e === void 0 ? void 0 : e.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0)
      return;
    this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
    const d = (l = (u = (s = (o = this.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) === null || l === void 0 ? void 0 : l.filter((g) => g.codeExecutionResult).map((g) => g.codeExecutionResult).filter((g) => g !== void 0);
    if (d?.length !== 0)
      return (c = d?.[0]) === null || c === void 0 ? void 0 : c.output;
  }
}
class yv {
}
class vv {
}
class ML {
}
class kL {
}
class _v {
}
class wv {
}
class bv {
}
class PL {
}
class Tv {
}
class Cv {
}
class Sv {
}
class OL {
}
class Sh {
  constructor(t) {
    const e = {};
    for (const n of t.headers.entries())
      e[n[0]] = n[1];
    this.headers = e, this.responseInternal = t;
  }
  json() {
    return this.responseInternal.json();
  }
}
class LL {
}
class NL {
}
class DL {
  /**
   * Returns the concatenation of all text parts from the server content if present.
   *
   * @remarks
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   */
  get text() {
    var t, e, n;
    let i = "", o = !1;
    const s = [];
    for (const u of (n = (e = (t = this.serverContent) === null || t === void 0 ? void 0 : t.modelTurn) === null || e === void 0 ? void 0 : e.parts) !== null && n !== void 0 ? n : []) {
      for (const [l, c] of Object.entries(u))
        l !== "text" && l !== "thought" && c !== null && s.push(l);
      if (typeof u.text == "string") {
        if (typeof u.thought == "boolean" && u.thought)
          continue;
        o = !0, i += u.text;
      }
    }
    return s.length > 0 && console.warn(`there are non-text parts ${s} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), o ? i : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the server content if present.
   *
   * @remarks
   * If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var t, e, n;
    let i = "";
    const o = [];
    for (const s of (n = (e = (t = this.serverContent) === null || t === void 0 ? void 0 : t.modelTurn) === null || e === void 0 ? void 0 : e.parts) !== null && n !== void 0 ? n : []) {
      for (const [u, l] of Object.entries(s))
        u !== "inlineData" && l !== null && o.push(u);
      s.inlineData && typeof s.inlineData.data == "string" && (i += atob(s.inlineData.data));
    }
    return o.length > 0 && console.warn(`there are non-data parts ${o} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), i.length > 0 ? btoa(i) : void 0;
  }
}
class FL {
  /**
   * Returns the first audio chunk from the server content, if present.
   *
   * @remarks
   * If there are no audio chunks in the response, undefined will be returned.
   */
  get audioChunk() {
    if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0)
      return this.serverContent.audioChunks[0];
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function dt(r, t) {
  if (!t || typeof t != "string")
    throw new Error("model is required and must be a string");
  if (r.isVertexAI()) {
    if (t.startsWith("publishers/") || t.startsWith("projects/") || t.startsWith("models/"))
      return t;
    if (t.indexOf("/") >= 0) {
      const e = t.split("/", 2);
      return `publishers/${e[0]}/models/${e[1]}`;
    } else
      return `publishers/google/models/${t}`;
  } else
    return t.startsWith("models/") || t.startsWith("tunedModels/") ? t : `models/${t}`;
}
function Zb(r, t) {
  const e = dt(r, t);
  return e ? e.startsWith("publishers/") && r.isVertexAI() ? `projects/${r.getProject()}/locations/${r.getLocation()}/${e}` : e.startsWith("models/") && r.isVertexAI() ? `projects/${r.getProject()}/locations/${r.getLocation()}/publishers/google/${e}` : e : "";
}
function jb(r, t) {
  return Array.isArray(t) ? t.map((e) => Gl(r, e)) : [Gl(r, t)];
}
function Gl(r, t) {
  if (typeof t == "object" && t !== null)
    return t;
  throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof t}`);
}
function $L(r, t) {
  const e = Gl(r, t);
  if (e.mimeType && e.mimeType.startsWith("image/"))
    return e;
  throw new Error(`Unsupported mime type: ${e.mimeType}`);
}
function UL(r, t) {
  const e = Gl(r, t);
  if (e.mimeType && e.mimeType.startsWith("audio/"))
    return e;
  throw new Error(`Unsupported mime type: ${e.mimeType}`);
}
function Ev(r, t) {
  if (t == null)
    throw new Error("PartUnion is required");
  if (typeof t == "object")
    return t;
  if (typeof t == "string")
    return { text: t };
  throw new Error(`Unsupported part type: ${typeof t}`);
}
function Qb(r, t) {
  if (t == null || Array.isArray(t) && t.length === 0)
    throw new Error("PartListUnion is required");
  return Array.isArray(t) ? t.map((e) => Ev(r, e)) : [Ev(r, t)];
}
function Eh(r) {
  return r != null && typeof r == "object" && "parts" in r && Array.isArray(r.parts);
}
function Av(r) {
  return r != null && typeof r == "object" && "functionCall" in r;
}
function xv(r) {
  return r != null && typeof r == "object" && "functionResponse" in r;
}
function Zt(r, t) {
  if (t == null)
    throw new Error("ContentUnion is required");
  return Eh(t) ? t : {
    role: "user",
    parts: Qb(r, t)
  };
}
function Xb(r, t) {
  if (!t)
    return [];
  if (r.isVertexAI() && Array.isArray(t))
    return t.flatMap((e) => {
      const n = Zt(r, e);
      return n.parts && n.parts.length > 0 && n.parts[0].text !== void 0 ? [n.parts[0].text] : [];
    });
  if (r.isVertexAI()) {
    const e = Zt(r, t);
    return e.parts && e.parts.length > 0 && e.parts[0].text !== void 0 ? [e.parts[0].text] : [];
  }
  return Array.isArray(t) ? t.map((e) => Zt(r, e)) : [Zt(r, t)];
}
function Pn(r, t) {
  if (t == null || Array.isArray(t) && t.length === 0)
    throw new Error("contents are required");
  if (!Array.isArray(t)) {
    if (Av(t) || xv(t))
      throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
    return [Zt(r, t)];
  }
  const e = [], n = [], i = Eh(t[0]);
  for (const o of t) {
    const s = Eh(o);
    if (s != i)
      throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
    if (s)
      e.push(o);
    else {
      if (Av(o) || xv(o))
        throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
      n.push(o);
    }
  }
  return i || e.push({ role: "user", parts: Qb(r, n) }), e;
}
const Rv = vi([
  "string",
  "number",
  "integer",
  "object",
  "array",
  "boolean",
  "null"
]), qL = Ft([
  Rv,
  Qe(Rv)
]);
function BL(r = !0) {
  const t = YP(() => {
    const e = xe({
      // --- Type ---
      type: qL.optional(),
      // --- Annotations ---
      format: ue().optional(),
      title: ue().optional(),
      description: ue().optional(),
      default: ho().optional(),
      // --- Array Validations ---
      items: t.optional(),
      minItems: Ui.string().optional(),
      maxItems: Ui.string().optional(),
      // --- Generic Validations ---
      enum: Qe(ho()).optional(),
      // --- Object Validations ---
      properties: rp(ue(), t).optional(),
      required: Qe(ue()).optional(),
      minProperties: Ui.string().optional(),
      maxProperties: Ui.string().optional(),
      propertyOrdering: Qe(ue()).optional(),
      // --- Numeric Validations ---
      minimum: Nt().optional(),
      maximum: Nt().optional(),
      // --- String Validations ---
      minLength: Ui.string().optional(),
      maxLength: Ui.string().optional(),
      pattern: ue().optional(),
      // --- Schema Composition ---
      anyOf: Qe(t).optional(),
      // --- Additional Properties --- This field is not included in the
      // JSONSchema, will not be communicated to the model, it is here purely
      // for enabling the zod validation strict mode.
      additionalProperties: ln().optional()
    });
    return r ? e.strict() : e;
  });
  return t;
}
function VL(r, t) {
  r.includes("null") && (t.nullable = !0);
  const e = r.filter((n) => n !== "null");
  if (e.length === 1)
    t.type = Object.keys(Lt).includes(e[0].toUpperCase()) ? Lt[e[0].toUpperCase()] : Lt.TYPE_UNSPECIFIED;
  else {
    t.anyOf = [];
    for (const n of e)
      t.anyOf.push({
        type: Object.keys(Lt).includes(n.toUpperCase()) ? Lt[n.toUpperCase()] : Lt.TYPE_UNSPECIFIED
      });
  }
}
function ls(r) {
  const t = {}, e = ["items"], n = ["anyOf"], i = ["properties"];
  if (r.type && r.anyOf)
    throw new Error("type and anyOf cannot be both populated.");
  const o = r.anyOf;
  o != null && o.length == 2 && (o[0].type === "null" ? (t.nullable = !0, r = o[1]) : o[1].type === "null" && (t.nullable = !0, r = o[0])), r.type instanceof Array && VL(r.type, t);
  for (const [s, u] of Object.entries(r))
    if (u != null)
      if (s == "type") {
        if (u === "null")
          throw new Error("type: null can not be the only possible type for the field.");
        if (u instanceof Array)
          continue;
        t.type = Object.keys(Lt).includes(u.toUpperCase()) ? u.toUpperCase() : Lt.TYPE_UNSPECIFIED;
      } else if (e.includes(s))
        t[s] = ls(u);
      else if (n.includes(s)) {
        const l = [];
        for (const c of u) {
          if (c.type == "null") {
            t.nullable = !0;
            continue;
          }
          l.push(ls(c));
        }
        t[s] = l;
      } else if (i.includes(s)) {
        const l = {};
        for (const [c, d] of Object.entries(u))
          l[c] = ls(d);
        t[s] = l;
      } else {
        if (s === "additionalProperties")
          continue;
        t[s] = u;
      }
  return t;
}
function Wl(r, t) {
  if (Object.keys(t).includes("$schema")) {
    delete t.$schema;
    const e = BL().parse(t);
    return ls(e);
  } else
    return ls(t);
}
function eT(r, t) {
  if (typeof t == "object")
    return t;
  if (typeof t == "string")
    return {
      voiceConfig: {
        prebuiltVoiceConfig: {
          voiceName: t
        }
      }
    };
  throw new Error(`Unsupported speechConfig type: ${typeof t}`);
}
function tT(r, t) {
  if ("multiSpeakerVoiceConfig" in t)
    throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
  return t;
}
function fu(r, t) {
  if (t.functionDeclarations)
    for (const e of t.functionDeclarations)
      e.parameters && (e.parameters = Wl(r, e.parameters)), e.response && (e.response = Wl(r, e.response));
  return t;
}
function du(r, t) {
  if (t == null)
    throw new Error("tools is required");
  if (!Array.isArray(t))
    throw new Error("tools is required and must be an array of Tools");
  const e = [];
  for (const n of t)
    e.push(n);
  return e;
}
function HL(r, t, e, n = 1) {
  const i = !t.startsWith(`${e}/`) && t.split("/").length === n;
  return r.isVertexAI() ? t.startsWith("projects/") ? t : t.startsWith("locations/") ? `projects/${r.getProject()}/${t}` : t.startsWith(`${e}/`) ? `projects/${r.getProject()}/locations/${r.getLocation()}/${t}` : i ? `projects/${r.getProject()}/locations/${r.getLocation()}/${e}/${t}` : t : i ? `${e}/${t}` : t;
}
function Kr(r, t) {
  if (typeof t != "string")
    throw new Error("name must be a string");
  return HL(r, t, "cachedContents");
}
function nT(r, t) {
  switch (t) {
    case "STATE_UNSPECIFIED":
      return "JOB_STATE_UNSPECIFIED";
    case "CREATING":
      return "JOB_STATE_RUNNING";
    case "ACTIVE":
      return "JOB_STATE_SUCCEEDED";
    case "FAILED":
      return "JOB_STATE_FAILED";
    default:
      return t;
  }
}
function Jr(r, t) {
  if (typeof t != "string")
    throw new Error("fromImageBytes must be a string");
  return t;
}
function GL(r) {
  return r != null && typeof r == "object" && "name" in r;
}
function WL(r) {
  return r != null && typeof r == "object" && "video" in r;
}
function KL(r) {
  return r != null && typeof r == "object" && "uri" in r;
}
function rT(r, t) {
  var e;
  let n;
  if (GL(t) && (n = t.name), !(KL(t) && (n = t.uri, n === void 0)) && !(WL(t) && (n = (e = t.video) === null || e === void 0 ? void 0 : e.uri, n === void 0))) {
    if (typeof t == "string" && (n = t), n === void 0)
      throw new Error("Could not extract file name from the provided input.");
    if (n.startsWith("https://")) {
      const o = n.split("files/")[1].match(/[a-z0-9]+/);
      if (o === null)
        throw new Error(`Could not extract file name from URI ${n}`);
      n = o[0];
    } else n.startsWith("files/") && (n = n.split("files/")[1]);
    return n;
  }
}
function iT(r, t) {
  let e;
  return r.isVertexAI() ? e = t ? "publishers/google/models" : "models" : e = t ? "models" : "tunedModels", e;
}
function oT(r, t) {
  for (const e of ["models", "tunedModels", "publisherModels"])
    if (JL(t, e))
      return t[e];
  return [];
}
function JL(r, t) {
  return r !== null && typeof r == "object" && t in r;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function zL(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function YL(r, t) {
  const e = {};
  if (h(t, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const n = h(t, ["data"]);
  n != null && p(e, ["data"], n);
  const i = h(t, ["mimeType"]);
  return i != null && p(e, ["mimeType"], i), e;
}
function ZL(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], zL(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], YL(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function Iv(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => ZL(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function jL(r, t) {
  const e = {}, n = h(t, ["behavior"]);
  n != null && p(e, ["behavior"], n);
  const i = h(t, ["description"]);
  i != null && p(e, ["description"], i);
  const o = h(t, ["name"]);
  o != null && p(e, ["name"], o);
  const s = h(t, ["parameters"]);
  s != null && p(e, ["parameters"], s);
  const u = h(t, ["response"]);
  return u != null && p(e, ["response"], u), e;
}
function QL(r, t) {
  const e = {}, n = h(t, ["startTime"]);
  n != null && p(e, ["startTime"], n);
  const i = h(t, ["endTime"]);
  return i != null && p(e, ["endTime"], i), e;
}
function XL(r, t) {
  const e = {}, n = h(t, [
    "timeRangeFilter"
  ]);
  return n != null && p(e, ["timeRangeFilter"], QL(r, n)), e;
}
function eN(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "dynamicThreshold"
  ]);
  return i != null && p(e, ["dynamicThreshold"], i), e;
}
function tN(r, t) {
  const e = {}, n = h(t, [
    "dynamicRetrievalConfig"
  ]);
  return n != null && p(e, ["dynamicRetrievalConfig"], eN(r, n)), e;
}
function nN() {
  return {};
}
function rN(r, t) {
  const e = {}, n = h(t, [
    "functionDeclarations"
  ]);
  if (n != null) {
    let l = n;
    Array.isArray(l) && (l = l.map((c) => jL(r, c))), p(e, ["functionDeclarations"], l);
  }
  if (h(t, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const i = h(t, ["googleSearch"]);
  i != null && p(e, ["googleSearch"], XL(r, i));
  const o = h(t, [
    "googleSearchRetrieval"
  ]);
  if (o != null && p(e, ["googleSearchRetrieval"], tN(r, o)), h(t, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  if (h(t, ["googleMaps"]) !== void 0)
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  h(t, ["urlContext"]) != null && p(e, ["urlContext"], nN());
  const u = h(t, [
    "codeExecution"
  ]);
  return u != null && p(e, ["codeExecution"], u), e;
}
function iN(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "allowedFunctionNames"
  ]);
  return i != null && p(e, ["allowedFunctionNames"], i), e;
}
function oN(r, t) {
  const e = {}, n = h(t, ["latitude"]);
  n != null && p(e, ["latitude"], n);
  const i = h(t, ["longitude"]);
  return i != null && p(e, ["longitude"], i), e;
}
function sN(r, t) {
  const e = {}, n = h(t, ["latLng"]);
  return n != null && p(e, ["latLng"], oN(r, n)), e;
}
function aN(r, t) {
  const e = {}, n = h(t, [
    "functionCallingConfig"
  ]);
  n != null && p(e, ["functionCallingConfig"], iN(r, n));
  const i = h(t, [
    "retrievalConfig"
  ]);
  return i != null && p(e, ["retrievalConfig"], sN(r, i)), e;
}
function lN(r, t, e) {
  const n = {}, i = h(t, ["ttl"]);
  e !== void 0 && i != null && p(e, ["ttl"], i);
  const o = h(t, ["expireTime"]);
  e !== void 0 && o != null && p(e, ["expireTime"], o);
  const s = h(t, ["displayName"]);
  e !== void 0 && s != null && p(e, ["displayName"], s);
  const u = h(t, ["contents"]);
  if (e !== void 0 && u != null) {
    let g = Pn(r, u);
    Array.isArray(g) && (g = g.map((y) => Iv(r, y))), p(e, ["contents"], g);
  }
  const l = h(t, [
    "systemInstruction"
  ]);
  e !== void 0 && l != null && p(e, ["systemInstruction"], Iv(r, Zt(r, l)));
  const c = h(t, ["tools"]);
  if (e !== void 0 && c != null) {
    let g = c;
    Array.isArray(g) && (g = g.map((y) => rN(r, y))), p(e, ["tools"], g);
  }
  const d = h(t, ["toolConfig"]);
  if (e !== void 0 && d != null && p(e, ["toolConfig"], aN(r, d)), h(t, ["kmsKeyName"]) !== void 0)
    throw new Error("kmsKeyName parameter is not supported in Gemini API.");
  return n;
}
function uN(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["model"], Zb(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], lN(r, i, e)), e;
}
function cN(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], Kr(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function fN(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], Kr(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function dN(r, t, e) {
  const n = {}, i = h(t, ["ttl"]);
  e !== void 0 && i != null && p(e, ["ttl"], i);
  const o = h(t, ["expireTime"]);
  return e !== void 0 && o != null && p(e, ["expireTime"], o), n;
}
function hN(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], Kr(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], dN(r, i, e)), e;
}
function pN(r, t, e) {
  const n = {}, i = h(t, ["pageSize"]);
  e !== void 0 && i != null && p(e, ["_query", "pageSize"], i);
  const o = h(t, ["pageToken"]);
  return e !== void 0 && o != null && p(e, ["_query", "pageToken"], o), n;
}
function mN(r, t) {
  const e = {}, n = h(t, ["config"]);
  return n != null && p(e, ["config"], pN(r, n, e)), e;
}
function gN(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function yN(r, t) {
  const e = {}, n = h(t, ["displayName"]);
  n != null && p(e, ["displayName"], n);
  const i = h(t, ["data"]);
  i != null && p(e, ["data"], i);
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function vN(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], gN(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], yN(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function Mv(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => vN(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function _N(r, t) {
  const e = {};
  if (h(t, ["behavior"]) !== void 0)
    throw new Error("behavior parameter is not supported in Vertex AI.");
  const n = h(t, ["description"]);
  n != null && p(e, ["description"], n);
  const i = h(t, ["name"]);
  i != null && p(e, ["name"], i);
  const o = h(t, ["parameters"]);
  o != null && p(e, ["parameters"], o);
  const s = h(t, ["response"]);
  return s != null && p(e, ["response"], s), e;
}
function wN(r, t) {
  const e = {}, n = h(t, ["startTime"]);
  n != null && p(e, ["startTime"], n);
  const i = h(t, ["endTime"]);
  return i != null && p(e, ["endTime"], i), e;
}
function bN(r, t) {
  const e = {}, n = h(t, [
    "timeRangeFilter"
  ]);
  return n != null && p(e, ["timeRangeFilter"], wN(r, n)), e;
}
function TN(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "dynamicThreshold"
  ]);
  return i != null && p(e, ["dynamicThreshold"], i), e;
}
function CN(r, t) {
  const e = {}, n = h(t, [
    "dynamicRetrievalConfig"
  ]);
  return n != null && p(e, ["dynamicRetrievalConfig"], TN(r, n)), e;
}
function SN() {
  return {};
}
function EN(r, t) {
  const e = {}, n = h(t, ["apiKeyString"]);
  return n != null && p(e, ["apiKeyString"], n), e;
}
function AN(r, t) {
  const e = {}, n = h(t, ["apiKeyConfig"]);
  n != null && p(e, ["apiKeyConfig"], EN(r, n));
  const i = h(t, ["authType"]);
  i != null && p(e, ["authType"], i);
  const o = h(t, [
    "googleServiceAccountConfig"
  ]);
  o != null && p(e, ["googleServiceAccountConfig"], o);
  const s = h(t, [
    "httpBasicAuthConfig"
  ]);
  s != null && p(e, ["httpBasicAuthConfig"], s);
  const u = h(t, ["oauthConfig"]);
  u != null && p(e, ["oauthConfig"], u);
  const l = h(t, ["oidcConfig"]);
  return l != null && p(e, ["oidcConfig"], l), e;
}
function xN(r, t) {
  const e = {}, n = h(t, ["authConfig"]);
  return n != null && p(e, ["authConfig"], AN(r, n)), e;
}
function RN(r, t) {
  const e = {}, n = h(t, [
    "functionDeclarations"
  ]);
  if (n != null) {
    let d = n;
    Array.isArray(d) && (d = d.map((g) => _N(r, g))), p(e, ["functionDeclarations"], d);
  }
  const i = h(t, ["retrieval"]);
  i != null && p(e, ["retrieval"], i);
  const o = h(t, ["googleSearch"]);
  o != null && p(e, ["googleSearch"], bN(r, o));
  const s = h(t, [
    "googleSearchRetrieval"
  ]);
  s != null && p(e, ["googleSearchRetrieval"], CN(r, s)), h(t, [
    "enterpriseWebSearch"
  ]) != null && p(e, ["enterpriseWebSearch"], SN());
  const l = h(t, ["googleMaps"]);
  if (l != null && p(e, ["googleMaps"], xN(r, l)), h(t, ["urlContext"]) !== void 0)
    throw new Error("urlContext parameter is not supported in Vertex AI.");
  const c = h(t, [
    "codeExecution"
  ]);
  return c != null && p(e, ["codeExecution"], c), e;
}
function IN(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "allowedFunctionNames"
  ]);
  return i != null && p(e, ["allowedFunctionNames"], i), e;
}
function MN(r, t) {
  const e = {}, n = h(t, ["latitude"]);
  n != null && p(e, ["latitude"], n);
  const i = h(t, ["longitude"]);
  return i != null && p(e, ["longitude"], i), e;
}
function kN(r, t) {
  const e = {}, n = h(t, ["latLng"]);
  return n != null && p(e, ["latLng"], MN(r, n)), e;
}
function PN(r, t) {
  const e = {}, n = h(t, [
    "functionCallingConfig"
  ]);
  n != null && p(e, ["functionCallingConfig"], IN(r, n));
  const i = h(t, [
    "retrievalConfig"
  ]);
  return i != null && p(e, ["retrievalConfig"], kN(r, i)), e;
}
function ON(r, t, e) {
  const n = {}, i = h(t, ["ttl"]);
  e !== void 0 && i != null && p(e, ["ttl"], i);
  const o = h(t, ["expireTime"]);
  e !== void 0 && o != null && p(e, ["expireTime"], o);
  const s = h(t, ["displayName"]);
  e !== void 0 && s != null && p(e, ["displayName"], s);
  const u = h(t, ["contents"]);
  if (e !== void 0 && u != null) {
    let y = Pn(r, u);
    Array.isArray(y) && (y = y.map((w) => Mv(r, w))), p(e, ["contents"], y);
  }
  const l = h(t, [
    "systemInstruction"
  ]);
  e !== void 0 && l != null && p(e, ["systemInstruction"], Mv(r, Zt(r, l)));
  const c = h(t, ["tools"]);
  if (e !== void 0 && c != null) {
    let y = c;
    Array.isArray(y) && (y = y.map((w) => RN(r, w))), p(e, ["tools"], y);
  }
  const d = h(t, ["toolConfig"]);
  e !== void 0 && d != null && p(e, ["toolConfig"], PN(r, d));
  const g = h(t, ["kmsKeyName"]);
  return e !== void 0 && g != null && p(e, ["encryption_spec", "kmsKeyName"], g), n;
}
function LN(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["model"], Zb(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], ON(r, i, e)), e;
}
function NN(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], Kr(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function DN(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], Kr(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function FN(r, t, e) {
  const n = {}, i = h(t, ["ttl"]);
  e !== void 0 && i != null && p(e, ["ttl"], i);
  const o = h(t, ["expireTime"]);
  return e !== void 0 && o != null && p(e, ["expireTime"], o), n;
}
function $N(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], Kr(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], FN(r, i, e)), e;
}
function UN(r, t, e) {
  const n = {}, i = h(t, ["pageSize"]);
  e !== void 0 && i != null && p(e, ["_query", "pageSize"], i);
  const o = h(t, ["pageToken"]);
  return e !== void 0 && o != null && p(e, ["_query", "pageToken"], o), n;
}
function qN(r, t) {
  const e = {}, n = h(t, ["config"]);
  return n != null && p(e, ["config"], UN(r, n, e)), e;
}
function _l(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["displayName"]);
  i != null && p(e, ["displayName"], i);
  const o = h(t, ["model"]);
  o != null && p(e, ["model"], o);
  const s = h(t, ["createTime"]);
  s != null && p(e, ["createTime"], s);
  const u = h(t, ["updateTime"]);
  u != null && p(e, ["updateTime"], u);
  const l = h(t, ["expireTime"]);
  l != null && p(e, ["expireTime"], l);
  const c = h(t, [
    "usageMetadata"
  ]);
  return c != null && p(e, ["usageMetadata"], c), e;
}
function BN() {
  return {};
}
function VN(r, t) {
  const e = {}, n = h(t, [
    "nextPageToken"
  ]);
  n != null && p(e, ["nextPageToken"], n);
  const i = h(t, [
    "cachedContents"
  ]);
  if (i != null) {
    let o = i;
    Array.isArray(o) && (o = o.map((s) => _l(r, s))), p(e, ["cachedContents"], o);
  }
  return e;
}
function wl(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["displayName"]);
  i != null && p(e, ["displayName"], i);
  const o = h(t, ["model"]);
  o != null && p(e, ["model"], o);
  const s = h(t, ["createTime"]);
  s != null && p(e, ["createTime"], s);
  const u = h(t, ["updateTime"]);
  u != null && p(e, ["updateTime"], u);
  const l = h(t, ["expireTime"]);
  l != null && p(e, ["expireTime"], l);
  const c = h(t, [
    "usageMetadata"
  ]);
  return c != null && p(e, ["usageMetadata"], c), e;
}
function HN() {
  return {};
}
function GN(r, t) {
  const e = {}, n = h(t, [
    "nextPageToken"
  ]);
  n != null && p(e, ["nextPageToken"], n);
  const i = h(t, [
    "cachedContents"
  ]);
  if (i != null) {
    let o = i;
    Array.isArray(o) && (o = o.map((s) => wl(r, s))), p(e, ["cachedContents"], o);
  }
  return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var po;
(function(r) {
  r.PAGED_ITEM_BATCH_JOBS = "batchJobs", r.PAGED_ITEM_MODELS = "models", r.PAGED_ITEM_TUNING_JOBS = "tuningJobs", r.PAGED_ITEM_FILES = "files", r.PAGED_ITEM_CACHED_CONTENTS = "cachedContents";
})(po || (po = {}));
class hu {
  constructor(t, e, n, i) {
    this.pageInternal = [], this.paramsInternal = {}, this.requestInternal = e, this.init(t, n, i);
  }
  init(t, e, n) {
    var i, o;
    this.nameInternal = t, this.pageInternal = e[this.nameInternal] || [], this.idxInternal = 0;
    let s = { config: {} };
    n ? typeof n == "object" ? s = Object.assign({}, n) : s = n : s = { config: {} }, s.config && (s.config.pageToken = e.nextPageToken), this.paramsInternal = s, this.pageInternalSize = (o = (i = s.config) === null || i === void 0 ? void 0 : i.pageSize) !== null && o !== void 0 ? o : this.pageInternal.length;
  }
  initNextPage(t) {
    this.init(this.nameInternal, t, this.paramsInternal);
  }
  /**
   * Returns the current page, which is a list of items.
   *
   * @remarks
   * The first page is retrieved when the pager is created. The returned list of
   * items could be a subset of the entire list.
   */
  get page() {
    return this.pageInternal;
  }
  /**
   * Returns the type of paged item (for example, ``batch_jobs``).
   */
  get name() {
    return this.nameInternal;
  }
  /**
   * Returns the length of the page fetched each time by this pager.
   *
   * @remarks
   * The number of items in the page is less than or equal to the page length.
   */
  get pageSize() {
    return this.pageInternalSize;
  }
  /**
   * Returns the parameters when making the API request for the next page.
   *
   * @remarks
   * Parameters contain a set of optional configs that can be
   * used to customize the API request. For example, the `pageToken` parameter
   * contains the token to request the next page.
   */
  get params() {
    return this.paramsInternal;
  }
  /**
   * Returns the total number of items in the current page.
   */
  get pageLength() {
    return this.pageInternal.length;
  }
  /**
   * Returns the item at the given index.
   */
  getItem(t) {
    return this.pageInternal[t];
  }
  /**
   * Returns an async iterator that support iterating through all items
   * retrieved from the API.
   *
   * @remarks
   * The iterator will automatically fetch the next page if there are more items
   * to fetch from the API.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * for await (const file of pager) {
   *   console.log(file.name);
   * }
   * ```
   */
  [Symbol.asyncIterator]() {
    return {
      next: async () => {
        if (this.idxInternal >= this.pageLength)
          if (this.hasNextPage())
            await this.nextPage();
          else
            return { value: void 0, done: !0 };
        const t = this.getItem(this.idxInternal);
        return this.idxInternal += 1, { value: t, done: !1 };
      },
      return: async () => ({ value: void 0, done: !0 })
    };
  }
  /**
   * Fetches the next page of items. This makes a new API request.
   *
   * @throws {Error} If there are no more pages to fetch.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * let page = pager.page;
   * while (true) {
   *   for (const file of page) {
   *     console.log(file.name);
   *   }
   *   if (!pager.hasNextPage()) {
   *     break;
   *   }
   *   page = await pager.nextPage();
   * }
   * ```
   */
  async nextPage() {
    if (!this.hasNextPage())
      throw new Error("No more pages to fetch.");
    const t = await this.requestInternal(this.params);
    return this.initNextPage(t), this.page;
  }
  /**
   * Returns true if there are more pages to fetch from the API.
   */
  hasNextPage() {
    var t;
    return ((t = this.params.config) === null || t === void 0 ? void 0 : t.pageToken) !== void 0;
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class WN extends Cs {
  constructor(t) {
    super(), this.apiClient = t, this.list = async (e = {}) => new hu(po.PAGED_ITEM_CACHED_CONTENTS, (n) => this.listInternal(n), await this.listInternal(e), e);
  }
  /**
   * Creates a cached contents resource.
   *
   * @remarks
   * Context caching is only supported for specific models. See [Gemini
   * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
   * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
   * for more information.
   *
   * @param params - The parameters for the create request.
   * @return The created cached content.
   *
   * @example
   * ```ts
   * const contents = ...; // Initialize the content to cache.
   * const response = await ai.caches.create({
   *   model: 'gemini-2.0-flash-001',
   *   config: {
   *    'contents': contents,
   *    'displayName': 'test cache',
   *    'systemInstruction': 'What is the sum of the two pdfs?',
   *    'ttl': '86400s',
   *  }
   * });
   * ```
   */
  async create(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = LN(this.apiClient, t);
      return u = ke("cachedContents", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => wl(this.apiClient, d));
    } else {
      const c = uN(this.apiClient, t);
      return u = ke("cachedContents", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => _l(this.apiClient, d));
    }
  }
  /**
   * Gets cached content configurations.
   *
   * @param params - The parameters for the get request.
   * @return The cached content.
   *
   * @example
   * ```ts
   * await ai.caches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = NN(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => wl(this.apiClient, d));
    } else {
      const c = cN(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => _l(this.apiClient, d));
    }
  }
  /**
   * Deletes cached content.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.caches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = DN(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "DELETE",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then(() => {
        const d = HN(), g = new Cv();
        return Object.assign(g, d), g;
      });
    } else {
      const c = fN(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "DELETE",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then(() => {
        const d = BN(), g = new Cv();
        return Object.assign(g, d), g;
      });
    }
  }
  /**
   * Updates cached content configurations.
   *
   * @param params - The parameters for the update request.
   * @return The updated cached content.
   *
   * @example
   * ```ts
   * const response = await ai.caches.update({
   *   name: '...',  // The server-generated resource name.
   *   config: {'ttl': '7600s'}
   * });
   * ```
   */
  async update(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = $N(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "PATCH",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => wl(this.apiClient, d));
    } else {
      const c = hN(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "PATCH",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => _l(this.apiClient, d));
    }
  }
  async listInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = qN(this.apiClient, t);
      return u = ke("cachedContents", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = GN(this.apiClient, d), y = new Sv();
        return Object.assign(y, g), y;
      });
    } else {
      const c = mN(this.apiClient, t);
      return u = ke("cachedContents", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = VN(this.apiClient, d), y = new Sv();
        return Object.assign(y, g), y;
      });
    }
  }
}
function kv(r) {
  var t = typeof Symbol == "function" && Symbol.iterator, e = t && r[t], n = 0;
  if (e) return e.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function yt(r) {
  return this instanceof yt ? (this.v = r, this) : new yt(r);
}
function us(r, t, e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = e.apply(r, t || []), i, o = [];
  return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), u("next"), u("throw"), u("return", s), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(w) {
    return function(b) {
      return Promise.resolve(b).then(w, g);
    };
  }
  function u(w, b) {
    n[w] && (i[w] = function(_) {
      return new Promise(function(C, m) {
        o.push([w, _, C, m]) > 1 || l(w, _);
      });
    }, b && (i[w] = b(i[w])));
  }
  function l(w, b) {
    try {
      c(n[w](b));
    } catch (_) {
      y(o[0][3], _);
    }
  }
  function c(w) {
    w.value instanceof yt ? Promise.resolve(w.value.v).then(d, g) : y(o[0][2], w);
  }
  function d(w) {
    l("next", w);
  }
  function g(w) {
    l("throw", w);
  }
  function y(w, b) {
    w(b), o.shift(), o.length && l(o[0][0], o[0][1]);
  }
}
function bl(r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = r[Symbol.asyncIterator], e;
  return t ? t.call(r) : (r = typeof kv == "function" ? kv(r) : r[Symbol.iterator](), e = {}, n("next"), n("throw"), n("return"), e[Symbol.asyncIterator] = function() {
    return this;
  }, e);
  function n(o) {
    e[o] = r[o] && function(s) {
      return new Promise(function(u, l) {
        s = r[o](s), i(u, l, s.done, s.value);
      });
    };
  }
  function i(o, s, u, l) {
    Promise.resolve(l).then(function(c) {
      o({ value: c, done: u });
    }, s);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function KN(r) {
  var t;
  if (r.candidates == null || r.candidates.length === 0)
    return !1;
  const e = (t = r.candidates[0]) === null || t === void 0 ? void 0 : t.content;
  return e === void 0 ? !1 : sT(e);
}
function sT(r) {
  if (r.parts === void 0 || r.parts.length === 0)
    return !1;
  for (const t of r.parts)
    if (t === void 0 || Object.keys(t).length === 0 || !t.thought && t.text !== void 0 && t.text === "")
      return !1;
  return !0;
}
function JN(r) {
  if (r.length !== 0) {
    for (const t of r)
      if (t.role !== "user" && t.role !== "model")
        throw new Error(`Role must be user or model, but got ${t.role}.`);
  }
}
function Pv(r) {
  if (r === void 0 || r.length === 0)
    return [];
  const t = [], e = r.length;
  let n = 0;
  for (; n < e; )
    if (r[n].role === "user")
      t.push(r[n]), n++;
    else {
      const i = [];
      let o = !0;
      for (; n < e && r[n].role === "model"; )
        i.push(r[n]), o && !sT(r[n]) && (o = !1), n++;
      o ? t.push(...i) : t.pop();
    }
  return t;
}
class zN {
  constructor(t, e) {
    this.modelsModule = t, this.apiClient = e;
  }
  /**
   * Creates a new chat session.
   *
   * @remarks
   * The config in the params will be used for all requests within the chat
   * session unless overridden by a per-request `config` in
   * @see {@link types.SendMessageParameters#config}.
   *
   * @param params - Parameters for creating a chat session.
   * @returns A new chat session.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({
   *   model: 'gemini-2.0-flash'
   *   config: {
   *     temperature: 0.5,
   *     maxOutputTokens: 1024,
   *   }
   * });
   * ```
   */
  create(t) {
    return new YN(
      this.apiClient,
      this.modelsModule,
      t.model,
      t.config,
      // Deep copy the history to avoid mutating the history outside of the
      // chat session.
      structuredClone(t.history)
    );
  }
}
class YN {
  constructor(t, e, n, i = {}, o = []) {
    this.apiClient = t, this.modelsModule = e, this.model = n, this.config = i, this.history = o, this.sendPromise = Promise.resolve(), JN(o);
  }
  /**
   * Sends a message to the model and returns the response.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessageStream} for streaming method.
   * @param params - parameters for sending messages within a chat session.
   * @returns The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessage({
   *   message: 'Why is the sky blue?'
   * });
   * console.log(response.text);
   * ```
   */
  async sendMessage(t) {
    var e;
    await this.sendPromise;
    const n = Zt(this.apiClient, t.message), i = this.modelsModule.generateContent({
      model: this.model,
      contents: this.getHistory(!0).concat(n),
      config: (e = t.config) !== null && e !== void 0 ? e : this.config
    });
    return this.sendPromise = (async () => {
      var o, s, u;
      const l = await i, c = (s = (o = l.candidates) === null || o === void 0 ? void 0 : o[0]) === null || s === void 0 ? void 0 : s.content, d = l.automaticFunctionCallingHistory, g = this.getHistory(!0).length;
      let y = [];
      d != null && (y = (u = d.slice(g)) !== null && u !== void 0 ? u : []);
      const w = c ? [c] : [];
      this.recordHistory(n, w, y);
    })(), await this.sendPromise, i;
  }
  /**
   * Sends a message to the model and returns the response in chunks.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessage} for non-streaming method.
   * @param params - parameters for sending the message.
   * @return The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessageStream({
   *   message: 'Why is the sky blue?'
   * });
   * for await (const chunk of response) {
   *   console.log(chunk.text);
   * }
   * ```
   */
  async sendMessageStream(t) {
    var e;
    await this.sendPromise;
    const n = Zt(this.apiClient, t.message), i = this.modelsModule.generateContentStream({
      model: this.model,
      contents: this.getHistory(!0).concat(n),
      config: (e = t.config) !== null && e !== void 0 ? e : this.config
    });
    this.sendPromise = i.then(() => {
    }).catch(() => {
    });
    const o = await i;
    return this.processStreamResponse(o, n);
  }
  /**
   * Returns the chat history.
   *
   * @remarks
   * The history is a list of contents alternating between user and model.
   *
   * There are two types of history:
   * - The `curated history` contains only the valid turns between user and
   * model, which will be included in the subsequent requests sent to the model.
   * - The `comprehensive history` contains all turns, including invalid or
   *   empty model outputs, providing a complete record of the history.
   *
   * The history is updated after receiving the response from the model,
   * for streaming response, it means receiving the last chunk of the response.
   *
   * The `comprehensive history` is returned by default. To get the `curated
   * history`, set the `curated` parameter to `true`.
   *
   * @param curated - whether to return the curated history or the comprehensive
   *     history.
   * @return History contents alternating between user and model for the entire
   *     chat session.
   */
  getHistory(t = !1) {
    const e = t ? Pv(this.history) : this.history;
    return structuredClone(e);
  }
  processStreamResponse(t, e) {
    var n, i;
    return us(this, arguments, function* () {
      var s, u, l, c;
      const d = [];
      try {
        for (var g = !0, y = bl(t), w; w = yield yt(y.next()), s = w.done, !s; g = !0) {
          c = w.value, g = !1;
          const b = c;
          if (KN(b)) {
            const _ = (i = (n = b.candidates) === null || n === void 0 ? void 0 : n[0]) === null || i === void 0 ? void 0 : i.content;
            _ !== void 0 && d.push(_);
          }
          yield yield yt(b);
        }
      } catch (b) {
        u = { error: b };
      } finally {
        try {
          !g && !s && (l = y.return) && (yield yt(l.call(y)));
        } finally {
          if (u) throw u.error;
        }
      }
      this.recordHistory(e, d);
    });
  }
  recordHistory(t, e, n) {
    let i = [];
    e.length > 0 && e.every((o) => o.role !== void 0) ? i = e : i.push({
      role: "model",
      parts: []
    }), n && n.length > 0 ? this.history.push(...Pv(n)) : this.history.push(t), this.history.push(...i);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function ZN(r, t, e) {
  const n = {}, i = h(t, ["pageSize"]);
  e !== void 0 && i != null && p(e, ["_query", "pageSize"], i);
  const o = h(t, ["pageToken"]);
  return e !== void 0 && o != null && p(e, ["_query", "pageToken"], o), n;
}
function jN(r, t) {
  const e = {}, n = h(t, ["config"]);
  return n != null && p(e, ["config"], ZN(r, n, e)), e;
}
function QN(r, t) {
  const e = {}, n = h(t, ["details"]);
  n != null && p(e, ["details"], n);
  const i = h(t, ["message"]);
  i != null && p(e, ["message"], i);
  const o = h(t, ["code"]);
  return o != null && p(e, ["code"], o), e;
}
function XN(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["displayName"]);
  i != null && p(e, ["displayName"], i);
  const o = h(t, ["mimeType"]);
  o != null && p(e, ["mimeType"], o);
  const s = h(t, ["sizeBytes"]);
  s != null && p(e, ["sizeBytes"], s);
  const u = h(t, ["createTime"]);
  u != null && p(e, ["createTime"], u);
  const l = h(t, [
    "expirationTime"
  ]);
  l != null && p(e, ["expirationTime"], l);
  const c = h(t, ["updateTime"]);
  c != null && p(e, ["updateTime"], c);
  const d = h(t, ["sha256Hash"]);
  d != null && p(e, ["sha256Hash"], d);
  const g = h(t, ["uri"]);
  g != null && p(e, ["uri"], g);
  const y = h(t, ["downloadUri"]);
  y != null && p(e, ["downloadUri"], y);
  const w = h(t, ["state"]);
  w != null && p(e, ["state"], w);
  const b = h(t, ["source"]);
  b != null && p(e, ["source"], b);
  const _ = h(t, [
    "videoMetadata"
  ]);
  _ != null && p(e, ["videoMetadata"], _);
  const C = h(t, ["error"]);
  return C != null && p(e, ["error"], QN(r, C)), e;
}
function eD(r, t) {
  const e = {}, n = h(t, ["file"]);
  n != null && p(e, ["file"], XN(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function tD(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "file"], rT(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function nD(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "file"], rT(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function rD(r, t) {
  const e = {}, n = h(t, ["details"]);
  n != null && p(e, ["details"], n);
  const i = h(t, ["message"]);
  i != null && p(e, ["message"], i);
  const o = h(t, ["code"]);
  return o != null && p(e, ["code"], o), e;
}
function Ah(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["displayName"]);
  i != null && p(e, ["displayName"], i);
  const o = h(t, ["mimeType"]);
  o != null && p(e, ["mimeType"], o);
  const s = h(t, ["sizeBytes"]);
  s != null && p(e, ["sizeBytes"], s);
  const u = h(t, ["createTime"]);
  u != null && p(e, ["createTime"], u);
  const l = h(t, [
    "expirationTime"
  ]);
  l != null && p(e, ["expirationTime"], l);
  const c = h(t, ["updateTime"]);
  c != null && p(e, ["updateTime"], c);
  const d = h(t, ["sha256Hash"]);
  d != null && p(e, ["sha256Hash"], d);
  const g = h(t, ["uri"]);
  g != null && p(e, ["uri"], g);
  const y = h(t, ["downloadUri"]);
  y != null && p(e, ["downloadUri"], y);
  const w = h(t, ["state"]);
  w != null && p(e, ["state"], w);
  const b = h(t, ["source"]);
  b != null && p(e, ["source"], b);
  const _ = h(t, [
    "videoMetadata"
  ]);
  _ != null && p(e, ["videoMetadata"], _);
  const C = h(t, ["error"]);
  return C != null && p(e, ["error"], rD(r, C)), e;
}
function iD(r, t) {
  const e = {}, n = h(t, [
    "nextPageToken"
  ]);
  n != null && p(e, ["nextPageToken"], n);
  const i = h(t, ["files"]);
  if (i != null) {
    let o = i;
    Array.isArray(o) && (o = o.map((s) => Ah(r, s))), p(e, ["files"], o);
  }
  return e;
}
function oD() {
  return {};
}
function sD() {
  return {};
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class aD extends Cs {
  constructor(t) {
    super(), this.apiClient = t, this.list = async (e = {}) => new hu(po.PAGED_ITEM_FILES, (n) => this.listInternal(n), await this.listInternal(e), e);
  }
  /**
   * Uploads a file asynchronously to the Gemini API.
   * This method is not available in Vertex AI.
   * Supported upload sources:
   * - Node.js: File path (string) or Blob object.
   * - Browser: Blob object (e.g., File).
   *
   * @remarks
   * The `mimeType` can be specified in the `config` parameter. If omitted:
   *  - For file path (string) inputs, the `mimeType` will be inferred from the
   *     file extension.
   *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
   *     property.
   * Somex eamples for file extension to mimeType mapping:
   * .txt -> text/plain
   * .json -> application/json
   * .jpg  -> image/jpeg
   * .png -> image/png
   * .mp3 -> audio/mpeg
   * .mp4 -> video/mp4
   *
   * This section can contain multiple paragraphs and code examples.
   *
   * @param params - Optional parameters specified in the
   *        `types.UploadFileParameters` interface.
   *         @see {@link types.UploadFileParameters#config} for the optional
   *         config in the parameters.
   * @return A promise that resolves to a `types.File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   * the `mimeType` can be provided in the `params.config` parameter.
   * @throws An error occurs if a suitable upload location cannot be established.
   *
   * @example
   * The following code uploads a file to Gemini API.
   *
   * ```ts
   * const file = await ai.files.upload({file: 'file.txt', config: {
   *   mimeType: 'text/plain',
   * }});
   * console.log(file.name);
   * ```
   */
  async upload(t) {
    if (this.apiClient.isVertexAI())
      throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
    return this.apiClient.uploadFile(t.file, t.config).then((e) => Ah(this.apiClient, e));
  }
  /**
   * Downloads a remotely stored file asynchronously to a location specified in
   * the `params` object. This method only works on Node environment, to
   * download files in the browser, use a browser compliant method like an <a>
   * tag.
   *
   * @param params - The parameters for the download request.
   *
   * @example
   * The following code downloads an example file named "files/mehozpxf877d" as
   * "file.txt".
   *
   * ```ts
   * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
   * ```
   */
  async download(t) {
    await this.apiClient.downloadFile(t);
  }
  async listInternal(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const u = jN(this.apiClient, t);
      return o = ke("files", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => {
        const c = iD(this.apiClient, l), d = new OL();
        return Object.assign(d, c), d;
      });
    }
  }
  async createInternal(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const u = eD(this.apiClient, t);
      return o = ke("upload/v1beta/files", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then(() => {
        const l = oD(), c = new LL();
        return Object.assign(c, l), c;
      });
    }
  }
  /**
   * Retrieves the file information from the service.
   *
   * @param params - The parameters for the get request
   * @return The Promise that resolves to the types.File object requested.
   *
   * @example
   * ```ts
   * const config: GetFileParameters = {
   *   name: fileName,
   * };
   * file = await ai.files.get(config);
   * console.log(file.name);
   * ```
   */
  async get(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const u = tD(this.apiClient, t);
      return o = ke("files/{file}", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => Ah(this.apiClient, l));
    }
  }
  /**
   * Deletes a remotely stored file.
   *
   * @param params - The parameters for the delete request.
   * @return The DeleteFileResponse, the response for the delete method.
   *
   * @example
   * The following code deletes an example file named "files/mehozpxf877d".
   *
   * ```ts
   * await ai.files.delete({name: file.name});
   * ```
   */
  async delete(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const u = nD(this.apiClient, t);
      return o = ke("files/{file}", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "DELETE",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then(() => {
        const l = sD(), c = new NL();
        return Object.assign(c, l), c;
      });
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function lD(r, t) {
  const e = {}, n = h(t, ["voiceName"]);
  return n != null && p(e, ["voiceName"], n), e;
}
function uD(r, t) {
  const e = {}, n = h(t, ["voiceName"]);
  return n != null && p(e, ["voiceName"], n), e;
}
function aT(r, t) {
  const e = {}, n = h(t, [
    "prebuiltVoiceConfig"
  ]);
  return n != null && p(e, ["prebuiltVoiceConfig"], lD(r, n)), e;
}
function cD(r, t) {
  const e = {}, n = h(t, [
    "prebuiltVoiceConfig"
  ]);
  return n != null && p(e, ["prebuiltVoiceConfig"], uD(r, n)), e;
}
function fD(r, t) {
  const e = {}, n = h(t, ["speaker"]);
  n != null && p(e, ["speaker"], n);
  const i = h(t, ["voiceConfig"]);
  return i != null && p(e, ["voiceConfig"], aT(r, i)), e;
}
function dD(r, t) {
  const e = {}, n = h(t, [
    "speakerVoiceConfigs"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => fD(r, o))), p(e, ["speakerVoiceConfigs"], i);
  }
  return e;
}
function hD(r, t) {
  const e = {}, n = h(t, ["voiceConfig"]);
  n != null && p(e, ["voiceConfig"], aT(r, n));
  const i = h(t, [
    "multiSpeakerVoiceConfig"
  ]);
  i != null && p(e, ["multiSpeakerVoiceConfig"], dD(r, i));
  const o = h(t, ["languageCode"]);
  return o != null && p(e, ["languageCode"], o), e;
}
function pD(r, t) {
  const e = {}, n = h(t, ["voiceConfig"]);
  if (n != null && p(e, ["voiceConfig"], cD(r, n)), h(t, ["multiSpeakerVoiceConfig"]) !== void 0)
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  const i = h(t, ["languageCode"]);
  return i != null && p(e, ["languageCode"], i), e;
}
function mD(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function gD(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function yD(r, t) {
  const e = {};
  if (h(t, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const n = h(t, ["data"]);
  n != null && p(e, ["data"], n);
  const i = h(t, ["mimeType"]);
  return i != null && p(e, ["mimeType"], i), e;
}
function vD(r, t) {
  const e = {}, n = h(t, ["displayName"]);
  n != null && p(e, ["displayName"], n);
  const i = h(t, ["data"]);
  i != null && p(e, ["data"], i);
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function _D(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], mD(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], yD(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function wD(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], gD(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], vD(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function bD(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => _D(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function TD(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => wD(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function CD(r, t) {
  const e = {}, n = h(t, ["behavior"]);
  n != null && p(e, ["behavior"], n);
  const i = h(t, ["description"]);
  i != null && p(e, ["description"], i);
  const o = h(t, ["name"]);
  o != null && p(e, ["name"], o);
  const s = h(t, ["parameters"]);
  s != null && p(e, ["parameters"], s);
  const u = h(t, ["response"]);
  return u != null && p(e, ["response"], u), e;
}
function SD(r, t) {
  const e = {};
  if (h(t, ["behavior"]) !== void 0)
    throw new Error("behavior parameter is not supported in Vertex AI.");
  const n = h(t, ["description"]);
  n != null && p(e, ["description"], n);
  const i = h(t, ["name"]);
  i != null && p(e, ["name"], i);
  const o = h(t, ["parameters"]);
  o != null && p(e, ["parameters"], o);
  const s = h(t, ["response"]);
  return s != null && p(e, ["response"], s), e;
}
function ED(r, t) {
  const e = {}, n = h(t, ["startTime"]);
  n != null && p(e, ["startTime"], n);
  const i = h(t, ["endTime"]);
  return i != null && p(e, ["endTime"], i), e;
}
function AD(r, t) {
  const e = {}, n = h(t, ["startTime"]);
  n != null && p(e, ["startTime"], n);
  const i = h(t, ["endTime"]);
  return i != null && p(e, ["endTime"], i), e;
}
function xD(r, t) {
  const e = {}, n = h(t, [
    "timeRangeFilter"
  ]);
  return n != null && p(e, ["timeRangeFilter"], ED(r, n)), e;
}
function RD(r, t) {
  const e = {}, n = h(t, [
    "timeRangeFilter"
  ]);
  return n != null && p(e, ["timeRangeFilter"], AD(r, n)), e;
}
function ID(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "dynamicThreshold"
  ]);
  return i != null && p(e, ["dynamicThreshold"], i), e;
}
function MD(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "dynamicThreshold"
  ]);
  return i != null && p(e, ["dynamicThreshold"], i), e;
}
function kD(r, t) {
  const e = {}, n = h(t, [
    "dynamicRetrievalConfig"
  ]);
  return n != null && p(e, ["dynamicRetrievalConfig"], ID(r, n)), e;
}
function PD(r, t) {
  const e = {}, n = h(t, [
    "dynamicRetrievalConfig"
  ]);
  return n != null && p(e, ["dynamicRetrievalConfig"], MD(r, n)), e;
}
function OD() {
  return {};
}
function LD(r, t) {
  const e = {}, n = h(t, ["apiKeyString"]);
  return n != null && p(e, ["apiKeyString"], n), e;
}
function ND(r, t) {
  const e = {}, n = h(t, ["apiKeyConfig"]);
  n != null && p(e, ["apiKeyConfig"], LD(r, n));
  const i = h(t, ["authType"]);
  i != null && p(e, ["authType"], i);
  const o = h(t, [
    "googleServiceAccountConfig"
  ]);
  o != null && p(e, ["googleServiceAccountConfig"], o);
  const s = h(t, [
    "httpBasicAuthConfig"
  ]);
  s != null && p(e, ["httpBasicAuthConfig"], s);
  const u = h(t, ["oauthConfig"]);
  u != null && p(e, ["oauthConfig"], u);
  const l = h(t, ["oidcConfig"]);
  return l != null && p(e, ["oidcConfig"], l), e;
}
function DD(r, t) {
  const e = {}, n = h(t, ["authConfig"]);
  return n != null && p(e, ["authConfig"], ND(r, n)), e;
}
function FD() {
  return {};
}
function $D(r, t) {
  const e = {}, n = h(t, [
    "functionDeclarations"
  ]);
  if (n != null) {
    let l = n;
    Array.isArray(l) && (l = l.map((c) => CD(r, c))), p(e, ["functionDeclarations"], l);
  }
  if (h(t, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const i = h(t, ["googleSearch"]);
  i != null && p(e, ["googleSearch"], xD(r, i));
  const o = h(t, [
    "googleSearchRetrieval"
  ]);
  if (o != null && p(e, ["googleSearchRetrieval"], kD(r, o)), h(t, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  if (h(t, ["googleMaps"]) !== void 0)
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  h(t, ["urlContext"]) != null && p(e, ["urlContext"], FD());
  const u = h(t, [
    "codeExecution"
  ]);
  return u != null && p(e, ["codeExecution"], u), e;
}
function UD(r, t) {
  const e = {}, n = h(t, [
    "functionDeclarations"
  ]);
  if (n != null) {
    let d = n;
    Array.isArray(d) && (d = d.map((g) => SD(r, g))), p(e, ["functionDeclarations"], d);
  }
  const i = h(t, ["retrieval"]);
  i != null && p(e, ["retrieval"], i);
  const o = h(t, ["googleSearch"]);
  o != null && p(e, ["googleSearch"], RD(r, o));
  const s = h(t, [
    "googleSearchRetrieval"
  ]);
  s != null && p(e, ["googleSearchRetrieval"], PD(r, s)), h(t, [
    "enterpriseWebSearch"
  ]) != null && p(e, ["enterpriseWebSearch"], OD());
  const l = h(t, ["googleMaps"]);
  if (l != null && p(e, ["googleMaps"], DD(r, l)), h(t, ["urlContext"]) !== void 0)
    throw new Error("urlContext parameter is not supported in Vertex AI.");
  const c = h(t, [
    "codeExecution"
  ]);
  return c != null && p(e, ["codeExecution"], c), e;
}
function qD(r, t) {
  const e = {}, n = h(t, ["handle"]);
  if (n != null && p(e, ["handle"], n), h(t, ["transparent"]) !== void 0)
    throw new Error("transparent parameter is not supported in Gemini API.");
  return e;
}
function BD(r, t) {
  const e = {}, n = h(t, ["handle"]);
  n != null && p(e, ["handle"], n);
  const i = h(t, ["transparent"]);
  return i != null && p(e, ["transparent"], i), e;
}
function Ov() {
  return {};
}
function Lv() {
  return {};
}
function VD(r, t) {
  const e = {}, n = h(t, ["disabled"]);
  n != null && p(e, ["disabled"], n);
  const i = h(t, [
    "startOfSpeechSensitivity"
  ]);
  i != null && p(e, ["startOfSpeechSensitivity"], i);
  const o = h(t, [
    "endOfSpeechSensitivity"
  ]);
  o != null && p(e, ["endOfSpeechSensitivity"], o);
  const s = h(t, [
    "prefixPaddingMs"
  ]);
  s != null && p(e, ["prefixPaddingMs"], s);
  const u = h(t, [
    "silenceDurationMs"
  ]);
  return u != null && p(e, ["silenceDurationMs"], u), e;
}
function HD(r, t) {
  const e = {}, n = h(t, ["disabled"]);
  n != null && p(e, ["disabled"], n);
  const i = h(t, [
    "startOfSpeechSensitivity"
  ]);
  i != null && p(e, ["startOfSpeechSensitivity"], i);
  const o = h(t, [
    "endOfSpeechSensitivity"
  ]);
  o != null && p(e, ["endOfSpeechSensitivity"], o);
  const s = h(t, [
    "prefixPaddingMs"
  ]);
  s != null && p(e, ["prefixPaddingMs"], s);
  const u = h(t, [
    "silenceDurationMs"
  ]);
  return u != null && p(e, ["silenceDurationMs"], u), e;
}
function GD(r, t) {
  const e = {}, n = h(t, [
    "automaticActivityDetection"
  ]);
  n != null && p(e, ["automaticActivityDetection"], VD(r, n));
  const i = h(t, [
    "activityHandling"
  ]);
  i != null && p(e, ["activityHandling"], i);
  const o = h(t, ["turnCoverage"]);
  return o != null && p(e, ["turnCoverage"], o), e;
}
function WD(r, t) {
  const e = {}, n = h(t, [
    "automaticActivityDetection"
  ]);
  n != null && p(e, ["automaticActivityDetection"], HD(r, n));
  const i = h(t, [
    "activityHandling"
  ]);
  i != null && p(e, ["activityHandling"], i);
  const o = h(t, ["turnCoverage"]);
  return o != null && p(e, ["turnCoverage"], o), e;
}
function KD(r, t) {
  const e = {}, n = h(t, ["targetTokens"]);
  return n != null && p(e, ["targetTokens"], n), e;
}
function JD(r, t) {
  const e = {}, n = h(t, ["targetTokens"]);
  return n != null && p(e, ["targetTokens"], n), e;
}
function zD(r, t) {
  const e = {}, n = h(t, [
    "triggerTokens"
  ]);
  n != null && p(e, ["triggerTokens"], n);
  const i = h(t, [
    "slidingWindow"
  ]);
  return i != null && p(e, ["slidingWindow"], KD(r, i)), e;
}
function YD(r, t) {
  const e = {}, n = h(t, [
    "triggerTokens"
  ]);
  n != null && p(e, ["triggerTokens"], n);
  const i = h(t, [
    "slidingWindow"
  ]);
  return i != null && p(e, ["slidingWindow"], JD(r, i)), e;
}
function ZD(r, t) {
  const e = {}, n = h(t, [
    "proactiveAudio"
  ]);
  return n != null && p(e, ["proactiveAudio"], n), e;
}
function jD(r, t) {
  const e = {}, n = h(t, [
    "proactiveAudio"
  ]);
  return n != null && p(e, ["proactiveAudio"], n), e;
}
function QD(r, t, e) {
  const n = {}, i = h(t, [
    "generationConfig"
  ]);
  e !== void 0 && i != null && p(e, ["setup", "generationConfig"], i);
  const o = h(t, [
    "responseModalities"
  ]);
  e !== void 0 && o != null && p(e, ["setup", "generationConfig", "responseModalities"], o);
  const s = h(t, ["temperature"]);
  e !== void 0 && s != null && p(e, ["setup", "generationConfig", "temperature"], s);
  const u = h(t, ["topP"]);
  e !== void 0 && u != null && p(e, ["setup", "generationConfig", "topP"], u);
  const l = h(t, ["topK"]);
  e !== void 0 && l != null && p(e, ["setup", "generationConfig", "topK"], l);
  const c = h(t, [
    "maxOutputTokens"
  ]);
  e !== void 0 && c != null && p(e, ["setup", "generationConfig", "maxOutputTokens"], c);
  const d = h(t, [
    "mediaResolution"
  ]);
  e !== void 0 && d != null && p(e, ["setup", "generationConfig", "mediaResolution"], d);
  const g = h(t, ["seed"]);
  e !== void 0 && g != null && p(e, ["setup", "generationConfig", "seed"], g);
  const y = h(t, ["speechConfig"]);
  e !== void 0 && y != null && p(e, ["setup", "generationConfig", "speechConfig"], hD(r, tT(r, y)));
  const w = h(t, [
    "enableAffectiveDialog"
  ]);
  e !== void 0 && w != null && p(e, ["setup", "generationConfig", "enableAffectiveDialog"], w);
  const b = h(t, [
    "systemInstruction"
  ]);
  e !== void 0 && b != null && p(e, ["setup", "systemInstruction"], bD(r, Zt(r, b)));
  const _ = h(t, ["tools"]);
  if (e !== void 0 && _ != null) {
    let D = du(r, _);
    Array.isArray(D) && (D = D.map((U) => $D(r, fu(r, U)))), p(e, ["setup", "tools"], D);
  }
  const C = h(t, [
    "sessionResumption"
  ]);
  e !== void 0 && C != null && p(e, ["setup", "sessionResumption"], qD(r, C));
  const m = h(t, [
    "inputAudioTranscription"
  ]);
  e !== void 0 && m != null && p(e, ["setup", "inputAudioTranscription"], Ov());
  const T = h(t, [
    "outputAudioTranscription"
  ]);
  e !== void 0 && T != null && p(e, ["setup", "outputAudioTranscription"], Ov());
  const S = h(t, [
    "realtimeInputConfig"
  ]);
  e !== void 0 && S != null && p(e, ["setup", "realtimeInputConfig"], GD(r, S));
  const A = h(t, [
    "contextWindowCompression"
  ]);
  e !== void 0 && A != null && p(e, ["setup", "contextWindowCompression"], zD(r, A));
  const x = h(t, ["proactivity"]);
  return e !== void 0 && x != null && p(e, ["setup", "proactivity"], ZD(r, x)), n;
}
function XD(r, t, e) {
  const n = {}, i = h(t, [
    "generationConfig"
  ]);
  e !== void 0 && i != null && p(e, ["setup", "generationConfig"], i);
  const o = h(t, [
    "responseModalities"
  ]);
  e !== void 0 && o != null && p(e, ["setup", "generationConfig", "responseModalities"], o);
  const s = h(t, ["temperature"]);
  e !== void 0 && s != null && p(e, ["setup", "generationConfig", "temperature"], s);
  const u = h(t, ["topP"]);
  e !== void 0 && u != null && p(e, ["setup", "generationConfig", "topP"], u);
  const l = h(t, ["topK"]);
  e !== void 0 && l != null && p(e, ["setup", "generationConfig", "topK"], l);
  const c = h(t, [
    "maxOutputTokens"
  ]);
  e !== void 0 && c != null && p(e, ["setup", "generationConfig", "maxOutputTokens"], c);
  const d = h(t, [
    "mediaResolution"
  ]);
  e !== void 0 && d != null && p(e, ["setup", "generationConfig", "mediaResolution"], d);
  const g = h(t, ["seed"]);
  e !== void 0 && g != null && p(e, ["setup", "generationConfig", "seed"], g);
  const y = h(t, ["speechConfig"]);
  e !== void 0 && y != null && p(e, ["setup", "generationConfig", "speechConfig"], pD(r, tT(r, y)));
  const w = h(t, [
    "enableAffectiveDialog"
  ]);
  e !== void 0 && w != null && p(e, ["setup", "generationConfig", "enableAffectiveDialog"], w);
  const b = h(t, [
    "systemInstruction"
  ]);
  e !== void 0 && b != null && p(e, ["setup", "systemInstruction"], TD(r, Zt(r, b)));
  const _ = h(t, ["tools"]);
  if (e !== void 0 && _ != null) {
    let D = du(r, _);
    Array.isArray(D) && (D = D.map((U) => UD(r, fu(r, U)))), p(e, ["setup", "tools"], D);
  }
  const C = h(t, [
    "sessionResumption"
  ]);
  e !== void 0 && C != null && p(e, ["setup", "sessionResumption"], BD(r, C));
  const m = h(t, [
    "inputAudioTranscription"
  ]);
  e !== void 0 && m != null && p(e, ["setup", "inputAudioTranscription"], Lv());
  const T = h(t, [
    "outputAudioTranscription"
  ]);
  e !== void 0 && T != null && p(e, ["setup", "outputAudioTranscription"], Lv());
  const S = h(t, [
    "realtimeInputConfig"
  ]);
  e !== void 0 && S != null && p(e, ["setup", "realtimeInputConfig"], WD(r, S));
  const A = h(t, [
    "contextWindowCompression"
  ]);
  e !== void 0 && A != null && p(e, ["setup", "contextWindowCompression"], YD(r, A));
  const x = h(t, ["proactivity"]);
  return e !== void 0 && x != null && p(e, ["setup", "proactivity"], jD(r, x)), n;
}
function e2(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["setup", "model"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], QD(r, i, e)), e;
}
function t2(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["setup", "model"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], XD(r, i, e)), e;
}
function n2() {
  return {};
}
function r2() {
  return {};
}
function i2() {
  return {};
}
function o2() {
  return {};
}
function s2(r, t) {
  const e = {}, n = h(t, ["media"]);
  n != null && p(e, ["mediaChunks"], jb(r, n));
  const i = h(t, ["audio"]);
  i != null && p(e, ["audio"], UL(r, i));
  const o = h(t, [
    "audioStreamEnd"
  ]);
  o != null && p(e, ["audioStreamEnd"], o);
  const s = h(t, ["video"]);
  s != null && p(e, ["video"], $L(r, s));
  const u = h(t, ["text"]);
  return u != null && p(e, ["text"], u), h(t, [
    "activityStart"
  ]) != null && p(e, ["activityStart"], n2()), h(t, ["activityEnd"]) != null && p(e, ["activityEnd"], i2()), e;
}
function a2(r, t) {
  const e = {}, n = h(t, ["media"]);
  if (n != null && p(e, ["mediaChunks"], jb(r, n)), h(t, ["audio"]) !== void 0)
    throw new Error("audio parameter is not supported in Vertex AI.");
  const i = h(t, [
    "audioStreamEnd"
  ]);
  if (i != null && p(e, ["audioStreamEnd"], i), h(t, ["video"]) !== void 0)
    throw new Error("video parameter is not supported in Vertex AI.");
  if (h(t, ["text"]) !== void 0)
    throw new Error("text parameter is not supported in Vertex AI.");
  return h(t, [
    "activityStart"
  ]) != null && p(e, ["activityStart"], r2()), h(t, ["activityEnd"]) != null && p(e, ["activityEnd"], o2()), e;
}
function lT(r, t) {
  const e = {}, n = h(t, ["text"]);
  n != null && p(e, ["text"], n);
  const i = h(t, ["weight"]);
  return i != null && p(e, ["weight"], i), e;
}
function l2(r, t) {
  const e = {}, n = h(t, [
    "weightedPrompts"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => lT(r, o))), p(e, ["weightedPrompts"], i);
  }
  return e;
}
function uT(r, t) {
  const e = {}, n = h(t, ["temperature"]);
  n != null && p(e, ["temperature"], n);
  const i = h(t, ["topK"]);
  i != null && p(e, ["topK"], i);
  const o = h(t, ["seed"]);
  o != null && p(e, ["seed"], o);
  const s = h(t, ["guidance"]);
  s != null && p(e, ["guidance"], s);
  const u = h(t, ["bpm"]);
  u != null && p(e, ["bpm"], u);
  const l = h(t, ["density"]);
  l != null && p(e, ["density"], l);
  const c = h(t, ["brightness"]);
  c != null && p(e, ["brightness"], c);
  const d = h(t, ["scale"]);
  d != null && p(e, ["scale"], d);
  const g = h(t, ["muteBass"]);
  g != null && p(e, ["muteBass"], g);
  const y = h(t, ["muteDrums"]);
  y != null && p(e, ["muteDrums"], y);
  const w = h(t, [
    "onlyBassAndDrums"
  ]);
  w != null && p(e, ["onlyBassAndDrums"], w);
  const b = h(t, [
    "musicGenerationMode"
  ]);
  return b != null && p(e, ["musicGenerationMode"], b), e;
}
function u2(r, t) {
  const e = {}, n = h(t, [
    "musicGenerationConfig"
  ]);
  return n != null && p(e, ["musicGenerationConfig"], uT(r, n)), e;
}
function cT(r, t) {
  const e = {}, n = h(t, ["model"]);
  return n != null && p(e, ["model"], n), e;
}
function fT(r, t) {
  const e = {}, n = h(t, [
    "weightedPrompts"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => lT(r, o))), p(e, ["weightedPrompts"], i);
  }
  return e;
}
function xh(r, t) {
  const e = {}, n = h(t, ["setup"]);
  n != null && p(e, ["setup"], cT(r, n));
  const i = h(t, [
    "clientContent"
  ]);
  i != null && p(e, ["clientContent"], fT(r, i));
  const o = h(t, [
    "musicGenerationConfig"
  ]);
  o != null && p(e, ["musicGenerationConfig"], uT(r, o));
  const s = h(t, [
    "playbackControl"
  ]);
  return s != null && p(e, ["playbackControl"], s), e;
}
function c2() {
  return {};
}
function f2() {
  return {};
}
function d2(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function h2(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function p2(r, t) {
  const e = {}, n = h(t, ["data"]);
  n != null && p(e, ["data"], n);
  const i = h(t, ["mimeType"]);
  return i != null && p(e, ["mimeType"], i), e;
}
function m2(r, t) {
  const e = {}, n = h(t, ["displayName"]);
  n != null && p(e, ["displayName"], n);
  const i = h(t, ["data"]);
  i != null && p(e, ["data"], i);
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function g2(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], d2(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], p2(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function y2(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], h2(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], m2(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function v2(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => g2(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function _2(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => y2(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function Nv(r, t) {
  const e = {}, n = h(t, ["text"]);
  n != null && p(e, ["text"], n);
  const i = h(t, ["finished"]);
  return i != null && p(e, ["finished"], i), e;
}
function Dv(r, t) {
  const e = {}, n = h(t, ["text"]);
  n != null && p(e, ["text"], n);
  const i = h(t, ["finished"]);
  return i != null && p(e, ["finished"], i), e;
}
function w2(r, t) {
  const e = {}, n = h(t, ["retrievedUrl"]);
  n != null && p(e, ["retrievedUrl"], n);
  const i = h(t, [
    "urlRetrievalStatus"
  ]);
  return i != null && p(e, ["urlRetrievalStatus"], i), e;
}
function b2(r, t) {
  const e = {}, n = h(t, ["urlMetadata"]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => w2(r, o))), p(e, ["urlMetadata"], i);
  }
  return e;
}
function T2(r, t) {
  const e = {}, n = h(t, ["modelTurn"]);
  n != null && p(e, ["modelTurn"], v2(r, n));
  const i = h(t, ["turnComplete"]);
  i != null && p(e, ["turnComplete"], i);
  const o = h(t, ["interrupted"]);
  o != null && p(e, ["interrupted"], o);
  const s = h(t, [
    "groundingMetadata"
  ]);
  s != null && p(e, ["groundingMetadata"], s);
  const u = h(t, [
    "generationComplete"
  ]);
  u != null && p(e, ["generationComplete"], u);
  const l = h(t, [
    "inputTranscription"
  ]);
  l != null && p(e, ["inputTranscription"], Nv(r, l));
  const c = h(t, [
    "outputTranscription"
  ]);
  c != null && p(e, ["outputTranscription"], Nv(r, c));
  const d = h(t, [
    "urlContextMetadata"
  ]);
  return d != null && p(e, ["urlContextMetadata"], b2(r, d)), e;
}
function C2(r, t) {
  const e = {}, n = h(t, ["modelTurn"]);
  n != null && p(e, ["modelTurn"], _2(r, n));
  const i = h(t, ["turnComplete"]);
  i != null && p(e, ["turnComplete"], i);
  const o = h(t, ["interrupted"]);
  o != null && p(e, ["interrupted"], o);
  const s = h(t, [
    "groundingMetadata"
  ]);
  s != null && p(e, ["groundingMetadata"], s);
  const u = h(t, [
    "generationComplete"
  ]);
  u != null && p(e, ["generationComplete"], u);
  const l = h(t, [
    "inputTranscription"
  ]);
  l != null && p(e, ["inputTranscription"], Dv(r, l));
  const c = h(t, [
    "outputTranscription"
  ]);
  return c != null && p(e, ["outputTranscription"], Dv(r, c)), e;
}
function S2(r, t) {
  const e = {}, n = h(t, ["id"]);
  n != null && p(e, ["id"], n);
  const i = h(t, ["args"]);
  i != null && p(e, ["args"], i);
  const o = h(t, ["name"]);
  return o != null && p(e, ["name"], o), e;
}
function E2(r, t) {
  const e = {}, n = h(t, ["args"]);
  n != null && p(e, ["args"], n);
  const i = h(t, ["name"]);
  return i != null && p(e, ["name"], i), e;
}
function A2(r, t) {
  const e = {}, n = h(t, [
    "functionCalls"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => S2(r, o))), p(e, ["functionCalls"], i);
  }
  return e;
}
function x2(r, t) {
  const e = {}, n = h(t, [
    "functionCalls"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => E2(r, o))), p(e, ["functionCalls"], i);
  }
  return e;
}
function R2(r, t) {
  const e = {}, n = h(t, ["ids"]);
  return n != null && p(e, ["ids"], n), e;
}
function I2(r, t) {
  const e = {}, n = h(t, ["ids"]);
  return n != null && p(e, ["ids"], n), e;
}
function Ta(r, t) {
  const e = {}, n = h(t, ["modality"]);
  n != null && p(e, ["modality"], n);
  const i = h(t, ["tokenCount"]);
  return i != null && p(e, ["tokenCount"], i), e;
}
function Ca(r, t) {
  const e = {}, n = h(t, ["modality"]);
  n != null && p(e, ["modality"], n);
  const i = h(t, ["tokenCount"]);
  return i != null && p(e, ["tokenCount"], i), e;
}
function M2(r, t) {
  const e = {}, n = h(t, [
    "promptTokenCount"
  ]);
  n != null && p(e, ["promptTokenCount"], n);
  const i = h(t, [
    "cachedContentTokenCount"
  ]);
  i != null && p(e, ["cachedContentTokenCount"], i);
  const o = h(t, [
    "responseTokenCount"
  ]);
  o != null && p(e, ["responseTokenCount"], o);
  const s = h(t, [
    "toolUsePromptTokenCount"
  ]);
  s != null && p(e, ["toolUsePromptTokenCount"], s);
  const u = h(t, [
    "thoughtsTokenCount"
  ]);
  u != null && p(e, ["thoughtsTokenCount"], u);
  const l = h(t, [
    "totalTokenCount"
  ]);
  l != null && p(e, ["totalTokenCount"], l);
  const c = h(t, [
    "promptTokensDetails"
  ]);
  if (c != null) {
    let w = c;
    Array.isArray(w) && (w = w.map((b) => Ta(r, b))), p(e, ["promptTokensDetails"], w);
  }
  const d = h(t, [
    "cacheTokensDetails"
  ]);
  if (d != null) {
    let w = d;
    Array.isArray(w) && (w = w.map((b) => Ta(r, b))), p(e, ["cacheTokensDetails"], w);
  }
  const g = h(t, [
    "responseTokensDetails"
  ]);
  if (g != null) {
    let w = g;
    Array.isArray(w) && (w = w.map((b) => Ta(r, b))), p(e, ["responseTokensDetails"], w);
  }
  const y = h(t, [
    "toolUsePromptTokensDetails"
  ]);
  if (y != null) {
    let w = y;
    Array.isArray(w) && (w = w.map((b) => Ta(r, b))), p(e, ["toolUsePromptTokensDetails"], w);
  }
  return e;
}
function k2(r, t) {
  const e = {}, n = h(t, [
    "promptTokenCount"
  ]);
  n != null && p(e, ["promptTokenCount"], n);
  const i = h(t, [
    "cachedContentTokenCount"
  ]);
  i != null && p(e, ["cachedContentTokenCount"], i);
  const o = h(t, [
    "candidatesTokenCount"
  ]);
  o != null && p(e, ["responseTokenCount"], o);
  const s = h(t, [
    "toolUsePromptTokenCount"
  ]);
  s != null && p(e, ["toolUsePromptTokenCount"], s);
  const u = h(t, [
    "thoughtsTokenCount"
  ]);
  u != null && p(e, ["thoughtsTokenCount"], u);
  const l = h(t, [
    "totalTokenCount"
  ]);
  l != null && p(e, ["totalTokenCount"], l);
  const c = h(t, [
    "promptTokensDetails"
  ]);
  if (c != null) {
    let b = c;
    Array.isArray(b) && (b = b.map((_) => Ca(r, _))), p(e, ["promptTokensDetails"], b);
  }
  const d = h(t, [
    "cacheTokensDetails"
  ]);
  if (d != null) {
    let b = d;
    Array.isArray(b) && (b = b.map((_) => Ca(r, _))), p(e, ["cacheTokensDetails"], b);
  }
  const g = h(t, [
    "candidatesTokensDetails"
  ]);
  if (g != null) {
    let b = g;
    Array.isArray(b) && (b = b.map((_) => Ca(r, _))), p(e, ["responseTokensDetails"], b);
  }
  const y = h(t, [
    "toolUsePromptTokensDetails"
  ]);
  if (y != null) {
    let b = y;
    Array.isArray(b) && (b = b.map((_) => Ca(r, _))), p(e, ["toolUsePromptTokensDetails"], b);
  }
  const w = h(t, ["trafficType"]);
  return w != null && p(e, ["trafficType"], w), e;
}
function P2(r, t) {
  const e = {}, n = h(t, ["timeLeft"]);
  return n != null && p(e, ["timeLeft"], n), e;
}
function O2(r, t) {
  const e = {}, n = h(t, ["timeLeft"]);
  return n != null && p(e, ["timeLeft"], n), e;
}
function L2(r, t) {
  const e = {}, n = h(t, ["newHandle"]);
  n != null && p(e, ["newHandle"], n);
  const i = h(t, ["resumable"]);
  i != null && p(e, ["resumable"], i);
  const o = h(t, [
    "lastConsumedClientMessageIndex"
  ]);
  return o != null && p(e, ["lastConsumedClientMessageIndex"], o), e;
}
function N2(r, t) {
  const e = {}, n = h(t, ["newHandle"]);
  n != null && p(e, ["newHandle"], n);
  const i = h(t, ["resumable"]);
  i != null && p(e, ["resumable"], i);
  const o = h(t, [
    "lastConsumedClientMessageIndex"
  ]);
  return o != null && p(e, ["lastConsumedClientMessageIndex"], o), e;
}
function D2(r, t) {
  const e = {};
  h(t, [
    "setupComplete"
  ]) != null && p(e, ["setupComplete"], c2());
  const i = h(t, [
    "serverContent"
  ]);
  i != null && p(e, ["serverContent"], T2(r, i));
  const o = h(t, ["toolCall"]);
  o != null && p(e, ["toolCall"], A2(r, o));
  const s = h(t, [
    "toolCallCancellation"
  ]);
  s != null && p(e, ["toolCallCancellation"], R2(r, s));
  const u = h(t, [
    "usageMetadata"
  ]);
  u != null && p(e, ["usageMetadata"], M2(r, u));
  const l = h(t, ["goAway"]);
  l != null && p(e, ["goAway"], P2(r, l));
  const c = h(t, [
    "sessionResumptionUpdate"
  ]);
  return c != null && p(e, ["sessionResumptionUpdate"], L2(r, c)), e;
}
function F2(r, t) {
  const e = {};
  h(t, [
    "setupComplete"
  ]) != null && p(e, ["setupComplete"], f2());
  const i = h(t, [
    "serverContent"
  ]);
  i != null && p(e, ["serverContent"], C2(r, i));
  const o = h(t, ["toolCall"]);
  o != null && p(e, ["toolCall"], x2(r, o));
  const s = h(t, [
    "toolCallCancellation"
  ]);
  s != null && p(e, ["toolCallCancellation"], I2(r, s));
  const u = h(t, [
    "usageMetadata"
  ]);
  u != null && p(e, ["usageMetadata"], k2(r, u));
  const l = h(t, ["goAway"]);
  l != null && p(e, ["goAway"], O2(r, l));
  const c = h(t, [
    "sessionResumptionUpdate"
  ]);
  return c != null && p(e, ["sessionResumptionUpdate"], N2(r, c)), e;
}
function $2() {
  return {};
}
function U2(r, t) {
  const e = {}, n = h(t, ["text"]);
  n != null && p(e, ["text"], n);
  const i = h(t, ["weight"]);
  return i != null && p(e, ["weight"], i), e;
}
function q2(r, t) {
  const e = {}, n = h(t, [
    "weightedPrompts"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => U2(r, o))), p(e, ["weightedPrompts"], i);
  }
  return e;
}
function B2(r, t) {
  const e = {}, n = h(t, ["temperature"]);
  n != null && p(e, ["temperature"], n);
  const i = h(t, ["topK"]);
  i != null && p(e, ["topK"], i);
  const o = h(t, ["seed"]);
  o != null && p(e, ["seed"], o);
  const s = h(t, ["guidance"]);
  s != null && p(e, ["guidance"], s);
  const u = h(t, ["bpm"]);
  u != null && p(e, ["bpm"], u);
  const l = h(t, ["density"]);
  l != null && p(e, ["density"], l);
  const c = h(t, ["brightness"]);
  c != null && p(e, ["brightness"], c);
  const d = h(t, ["scale"]);
  d != null && p(e, ["scale"], d);
  const g = h(t, ["muteBass"]);
  g != null && p(e, ["muteBass"], g);
  const y = h(t, ["muteDrums"]);
  y != null && p(e, ["muteDrums"], y);
  const w = h(t, [
    "onlyBassAndDrums"
  ]);
  w != null && p(e, ["onlyBassAndDrums"], w);
  const b = h(t, [
    "musicGenerationMode"
  ]);
  return b != null && p(e, ["musicGenerationMode"], b), e;
}
function V2(r, t) {
  const e = {}, n = h(t, [
    "clientContent"
  ]);
  n != null && p(e, ["clientContent"], q2(r, n));
  const i = h(t, [
    "musicGenerationConfig"
  ]);
  return i != null && p(e, ["musicGenerationConfig"], B2(r, i)), e;
}
function H2(r, t) {
  const e = {}, n = h(t, ["data"]);
  n != null && p(e, ["data"], n);
  const i = h(t, ["mimeType"]);
  i != null && p(e, ["mimeType"], i);
  const o = h(t, [
    "sourceMetadata"
  ]);
  return o != null && p(e, ["sourceMetadata"], V2(r, o)), e;
}
function G2(r, t) {
  const e = {}, n = h(t, ["audioChunks"]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => H2(r, o))), p(e, ["audioChunks"], i);
  }
  return e;
}
function W2(r, t) {
  const e = {}, n = h(t, ["text"]);
  n != null && p(e, ["text"], n);
  const i = h(t, [
    "filteredReason"
  ]);
  return i != null && p(e, ["filteredReason"], i), e;
}
function K2(r, t) {
  const e = {};
  h(t, [
    "setupComplete"
  ]) != null && p(e, ["setupComplete"], $2());
  const i = h(t, [
    "serverContent"
  ]);
  i != null && p(e, ["serverContent"], G2(r, i));
  const o = h(t, [
    "filteredPrompt"
  ]);
  return o != null && p(e, ["filteredPrompt"], W2(r, o)), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function J2(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function z2(r, t) {
  const e = {};
  if (h(t, ["displayName"]) !== void 0)
    throw new Error("displayName parameter is not supported in Gemini API.");
  const n = h(t, ["data"]);
  n != null && p(e, ["data"], n);
  const i = h(t, ["mimeType"]);
  return i != null && p(e, ["mimeType"], i), e;
}
function Y2(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], J2(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], z2(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function pu(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => Y2(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function Z2(r, t) {
  const e = {};
  if (h(t, ["method"]) !== void 0)
    throw new Error("method parameter is not supported in Gemini API.");
  const n = h(t, ["category"]);
  n != null && p(e, ["category"], n);
  const i = h(t, ["threshold"]);
  return i != null && p(e, ["threshold"], i), e;
}
function j2(r, t) {
  const e = {}, n = h(t, ["behavior"]);
  n != null && p(e, ["behavior"], n);
  const i = h(t, ["description"]);
  i != null && p(e, ["description"], i);
  const o = h(t, ["name"]);
  o != null && p(e, ["name"], o);
  const s = h(t, ["parameters"]);
  s != null && p(e, ["parameters"], s);
  const u = h(t, ["response"]);
  return u != null && p(e, ["response"], u), e;
}
function Q2(r, t) {
  const e = {}, n = h(t, ["startTime"]);
  n != null && p(e, ["startTime"], n);
  const i = h(t, ["endTime"]);
  return i != null && p(e, ["endTime"], i), e;
}
function X2(r, t) {
  const e = {}, n = h(t, [
    "timeRangeFilter"
  ]);
  return n != null && p(e, ["timeRangeFilter"], Q2(r, n)), e;
}
function eF(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "dynamicThreshold"
  ]);
  return i != null && p(e, ["dynamicThreshold"], i), e;
}
function tF(r, t) {
  const e = {}, n = h(t, [
    "dynamicRetrievalConfig"
  ]);
  return n != null && p(e, ["dynamicRetrievalConfig"], eF(r, n)), e;
}
function nF() {
  return {};
}
function rF(r, t) {
  const e = {}, n = h(t, [
    "functionDeclarations"
  ]);
  if (n != null) {
    let l = n;
    Array.isArray(l) && (l = l.map((c) => j2(r, c))), p(e, ["functionDeclarations"], l);
  }
  if (h(t, ["retrieval"]) !== void 0)
    throw new Error("retrieval parameter is not supported in Gemini API.");
  const i = h(t, ["googleSearch"]);
  i != null && p(e, ["googleSearch"], X2(r, i));
  const o = h(t, [
    "googleSearchRetrieval"
  ]);
  if (o != null && p(e, ["googleSearchRetrieval"], tF(r, o)), h(t, ["enterpriseWebSearch"]) !== void 0)
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  if (h(t, ["googleMaps"]) !== void 0)
    throw new Error("googleMaps parameter is not supported in Gemini API.");
  h(t, ["urlContext"]) != null && p(e, ["urlContext"], nF());
  const u = h(t, [
    "codeExecution"
  ]);
  return u != null && p(e, ["codeExecution"], u), e;
}
function iF(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "allowedFunctionNames"
  ]);
  return i != null && p(e, ["allowedFunctionNames"], i), e;
}
function oF(r, t) {
  const e = {}, n = h(t, ["latitude"]);
  n != null && p(e, ["latitude"], n);
  const i = h(t, ["longitude"]);
  return i != null && p(e, ["longitude"], i), e;
}
function sF(r, t) {
  const e = {}, n = h(t, ["latLng"]);
  return n != null && p(e, ["latLng"], oF(r, n)), e;
}
function aF(r, t) {
  const e = {}, n = h(t, [
    "functionCallingConfig"
  ]);
  n != null && p(e, ["functionCallingConfig"], iF(r, n));
  const i = h(t, [
    "retrievalConfig"
  ]);
  return i != null && p(e, ["retrievalConfig"], sF(r, i)), e;
}
function lF(r, t) {
  const e = {}, n = h(t, ["voiceName"]);
  return n != null && p(e, ["voiceName"], n), e;
}
function dT(r, t) {
  const e = {}, n = h(t, [
    "prebuiltVoiceConfig"
  ]);
  return n != null && p(e, ["prebuiltVoiceConfig"], lF(r, n)), e;
}
function uF(r, t) {
  const e = {}, n = h(t, ["speaker"]);
  n != null && p(e, ["speaker"], n);
  const i = h(t, ["voiceConfig"]);
  return i != null && p(e, ["voiceConfig"], dT(r, i)), e;
}
function cF(r, t) {
  const e = {}, n = h(t, [
    "speakerVoiceConfigs"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => uF(r, o))), p(e, ["speakerVoiceConfigs"], i);
  }
  return e;
}
function fF(r, t) {
  const e = {}, n = h(t, ["voiceConfig"]);
  n != null && p(e, ["voiceConfig"], dT(r, n));
  const i = h(t, [
    "multiSpeakerVoiceConfig"
  ]);
  i != null && p(e, ["multiSpeakerVoiceConfig"], cF(r, i));
  const o = h(t, ["languageCode"]);
  return o != null && p(e, ["languageCode"], o), e;
}
function dF(r, t) {
  const e = {}, n = h(t, [
    "includeThoughts"
  ]);
  n != null && p(e, ["includeThoughts"], n);
  const i = h(t, [
    "thinkingBudget"
  ]);
  return i != null && p(e, ["thinkingBudget"], i), e;
}
function hF(r, t, e) {
  const n = {}, i = h(t, [
    "systemInstruction"
  ]);
  e !== void 0 && i != null && p(e, ["systemInstruction"], pu(r, Zt(r, i)));
  const o = h(t, ["temperature"]);
  o != null && p(n, ["temperature"], o);
  const s = h(t, ["topP"]);
  s != null && p(n, ["topP"], s);
  const u = h(t, ["topK"]);
  u != null && p(n, ["topK"], u);
  const l = h(t, [
    "candidateCount"
  ]);
  l != null && p(n, ["candidateCount"], l);
  const c = h(t, [
    "maxOutputTokens"
  ]);
  c != null && p(n, ["maxOutputTokens"], c);
  const d = h(t, [
    "stopSequences"
  ]);
  d != null && p(n, ["stopSequences"], d);
  const g = h(t, [
    "responseLogprobs"
  ]);
  g != null && p(n, ["responseLogprobs"], g);
  const y = h(t, ["logprobs"]);
  y != null && p(n, ["logprobs"], y);
  const w = h(t, [
    "presencePenalty"
  ]);
  w != null && p(n, ["presencePenalty"], w);
  const b = h(t, [
    "frequencyPenalty"
  ]);
  b != null && p(n, ["frequencyPenalty"], b);
  const _ = h(t, ["seed"]);
  _ != null && p(n, ["seed"], _);
  const C = h(t, [
    "responseMimeType"
  ]);
  C != null && p(n, ["responseMimeType"], C);
  const m = h(t, [
    "responseSchema"
  ]);
  if (m != null && p(n, ["responseSchema"], Wl(r, m)), h(t, ["routingConfig"]) !== void 0)
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  if (h(t, ["modelSelectionConfig"]) !== void 0)
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  const T = h(t, [
    "safetySettings"
  ]);
  if (e !== void 0 && T != null) {
    let H = T;
    Array.isArray(H) && (H = H.map((V) => Z2(r, V))), p(e, ["safetySettings"], H);
  }
  const S = h(t, ["tools"]);
  if (e !== void 0 && S != null) {
    let H = du(r, S);
    Array.isArray(H) && (H = H.map((V) => rF(r, fu(r, V)))), p(e, ["tools"], H);
  }
  const A = h(t, ["toolConfig"]);
  if (e !== void 0 && A != null && p(e, ["toolConfig"], aF(r, A)), h(t, ["labels"]) !== void 0)
    throw new Error("labels parameter is not supported in Gemini API.");
  const x = h(t, [
    "cachedContent"
  ]);
  e !== void 0 && x != null && p(e, ["cachedContent"], Kr(r, x));
  const D = h(t, [
    "responseModalities"
  ]);
  D != null && p(n, ["responseModalities"], D);
  const U = h(t, [
    "mediaResolution"
  ]);
  U != null && p(n, ["mediaResolution"], U);
  const O = h(t, ["speechConfig"]);
  if (O != null && p(n, ["speechConfig"], fF(r, eT(r, O))), h(t, ["audioTimestamp"]) !== void 0)
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  const k = h(t, [
    "thinkingConfig"
  ]);
  return k != null && p(n, ["thinkingConfig"], dF(r, k)), n;
}
function Fv(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["contents"]);
  if (i != null) {
    let s = Pn(r, i);
    Array.isArray(s) && (s = s.map((u) => pu(r, u))), p(e, ["contents"], s);
  }
  const o = h(t, ["config"]);
  return o != null && p(e, ["generationConfig"], hF(r, o, e)), e;
}
function pF(r, t, e) {
  const n = {}, i = h(t, ["taskType"]);
  e !== void 0 && i != null && p(e, ["requests[]", "taskType"], i);
  const o = h(t, ["title"]);
  e !== void 0 && o != null && p(e, ["requests[]", "title"], o);
  const s = h(t, [
    "outputDimensionality"
  ]);
  if (e !== void 0 && s != null && p(e, ["requests[]", "outputDimensionality"], s), h(t, ["mimeType"]) !== void 0)
    throw new Error("mimeType parameter is not supported in Gemini API.");
  if (h(t, ["autoTruncate"]) !== void 0)
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  return n;
}
function mF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["contents"]);
  i != null && p(e, ["requests[]", "content"], Xb(r, i));
  const o = h(t, ["config"]);
  o != null && p(e, ["config"], pF(r, o, e));
  const s = h(t, ["model"]);
  return s !== void 0 && p(e, ["requests[]", "model"], dt(r, s)), e;
}
function gF(r, t, e) {
  const n = {};
  if (h(t, ["outputGcsUri"]) !== void 0)
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  if (h(t, ["negativePrompt"]) !== void 0)
    throw new Error("negativePrompt parameter is not supported in Gemini API.");
  const i = h(t, [
    "numberOfImages"
  ]);
  e !== void 0 && i != null && p(e, ["parameters", "sampleCount"], i);
  const o = h(t, ["aspectRatio"]);
  e !== void 0 && o != null && p(e, ["parameters", "aspectRatio"], o);
  const s = h(t, [
    "guidanceScale"
  ]);
  if (e !== void 0 && s != null && p(e, ["parameters", "guidanceScale"], s), h(t, ["seed"]) !== void 0)
    throw new Error("seed parameter is not supported in Gemini API.");
  const u = h(t, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && u != null && p(e, ["parameters", "safetySetting"], u);
  const l = h(t, [
    "personGeneration"
  ]);
  e !== void 0 && l != null && p(e, ["parameters", "personGeneration"], l);
  const c = h(t, [
    "includeSafetyAttributes"
  ]);
  e !== void 0 && c != null && p(e, ["parameters", "includeSafetyAttributes"], c);
  const d = h(t, [
    "includeRaiReason"
  ]);
  e !== void 0 && d != null && p(e, ["parameters", "includeRaiReason"], d);
  const g = h(t, ["language"]);
  e !== void 0 && g != null && p(e, ["parameters", "language"], g);
  const y = h(t, [
    "outputMimeType"
  ]);
  e !== void 0 && y != null && p(e, ["parameters", "outputOptions", "mimeType"], y);
  const w = h(t, [
    "outputCompressionQuality"
  ]);
  if (e !== void 0 && w != null && p(e, ["parameters", "outputOptions", "compressionQuality"], w), h(t, ["addWatermark"]) !== void 0)
    throw new Error("addWatermark parameter is not supported in Gemini API.");
  if (h(t, ["enhancePrompt"]) !== void 0)
    throw new Error("enhancePrompt parameter is not supported in Gemini API.");
  return n;
}
function yF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["prompt"]);
  i != null && p(e, ["instances[0]", "prompt"], i);
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], gF(r, o, e)), e;
}
function vF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "name"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function _F(r, t, e) {
  const n = {}, i = h(t, ["pageSize"]);
  e !== void 0 && i != null && p(e, ["_query", "pageSize"], i);
  const o = h(t, ["pageToken"]);
  e !== void 0 && o != null && p(e, ["_query", "pageToken"], o);
  const s = h(t, ["filter"]);
  e !== void 0 && s != null && p(e, ["_query", "filter"], s);
  const u = h(t, ["queryBase"]);
  return e !== void 0 && u != null && p(e, ["_url", "models_url"], iT(r, u)), n;
}
function wF(r, t) {
  const e = {}, n = h(t, ["config"]);
  return n != null && p(e, ["config"], _F(r, n, e)), e;
}
function bF(r, t, e) {
  const n = {}, i = h(t, ["displayName"]);
  e !== void 0 && i != null && p(e, ["displayName"], i);
  const o = h(t, ["description"]);
  e !== void 0 && o != null && p(e, ["description"], o);
  const s = h(t, [
    "defaultCheckpointId"
  ]);
  return e !== void 0 && s != null && p(e, ["defaultCheckpointId"], s), n;
}
function TF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "name"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], bF(r, i, e)), e;
}
function CF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "name"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function SF(r, t) {
  const e = {};
  if (h(t, ["systemInstruction"]) !== void 0)
    throw new Error("systemInstruction parameter is not supported in Gemini API.");
  if (h(t, ["tools"]) !== void 0)
    throw new Error("tools parameter is not supported in Gemini API.");
  if (h(t, ["generationConfig"]) !== void 0)
    throw new Error("generationConfig parameter is not supported in Gemini API.");
  return e;
}
function EF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["contents"]);
  if (i != null) {
    let s = Pn(r, i);
    Array.isArray(s) && (s = s.map((u) => pu(r, u))), p(e, ["contents"], s);
  }
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], SF(r, o)), e;
}
function AF(r, t) {
  const e = {};
  if (h(t, ["gcsUri"]) !== void 0)
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  const n = h(t, ["imageBytes"]);
  n != null && p(e, ["bytesBase64Encoded"], Jr(r, n));
  const i = h(t, ["mimeType"]);
  return i != null && p(e, ["mimeType"], i), e;
}
function xF(r, t, e) {
  const n = {}, i = h(t, [
    "numberOfVideos"
  ]);
  if (e !== void 0 && i != null && p(e, ["parameters", "sampleCount"], i), h(t, ["outputGcsUri"]) !== void 0)
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  if (h(t, ["fps"]) !== void 0)
    throw new Error("fps parameter is not supported in Gemini API.");
  const o = h(t, [
    "durationSeconds"
  ]);
  if (e !== void 0 && o != null && p(e, ["parameters", "durationSeconds"], o), h(t, ["seed"]) !== void 0)
    throw new Error("seed parameter is not supported in Gemini API.");
  const s = h(t, ["aspectRatio"]);
  if (e !== void 0 && s != null && p(e, ["parameters", "aspectRatio"], s), h(t, ["resolution"]) !== void 0)
    throw new Error("resolution parameter is not supported in Gemini API.");
  const u = h(t, [
    "personGeneration"
  ]);
  if (e !== void 0 && u != null && p(e, ["parameters", "personGeneration"], u), h(t, ["pubsubTopic"]) !== void 0)
    throw new Error("pubsubTopic parameter is not supported in Gemini API.");
  const l = h(t, [
    "negativePrompt"
  ]);
  if (e !== void 0 && l != null && p(e, ["parameters", "negativePrompt"], l), h(t, ["enhancePrompt"]) !== void 0)
    throw new Error("enhancePrompt parameter is not supported in Gemini API.");
  return n;
}
function RF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["prompt"]);
  i != null && p(e, ["instances[0]", "prompt"], i);
  const o = h(t, ["image"]);
  o != null && p(e, ["instances[0]", "image"], AF(r, o));
  const s = h(t, ["config"]);
  return s != null && p(e, ["config"], xF(r, s, e)), e;
}
function IF(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function MF(r, t) {
  const e = {}, n = h(t, ["displayName"]);
  n != null && p(e, ["displayName"], n);
  const i = h(t, ["data"]);
  i != null && p(e, ["data"], i);
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function kF(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], IF(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], MF(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function vo(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => kF(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function PF(r, t) {
  const e = {}, n = h(t, [
    "featureSelectionPreference"
  ]);
  return n != null && p(e, ["featureSelectionPreference"], n), e;
}
function OF(r, t) {
  const e = {}, n = h(t, ["method"]);
  n != null && p(e, ["method"], n);
  const i = h(t, ["category"]);
  i != null && p(e, ["category"], i);
  const o = h(t, ["threshold"]);
  return o != null && p(e, ["threshold"], o), e;
}
function LF(r, t) {
  const e = {};
  if (h(t, ["behavior"]) !== void 0)
    throw new Error("behavior parameter is not supported in Vertex AI.");
  const n = h(t, ["description"]);
  n != null && p(e, ["description"], n);
  const i = h(t, ["name"]);
  i != null && p(e, ["name"], i);
  const o = h(t, ["parameters"]);
  o != null && p(e, ["parameters"], o);
  const s = h(t, ["response"]);
  return s != null && p(e, ["response"], s), e;
}
function NF(r, t) {
  const e = {}, n = h(t, ["startTime"]);
  n != null && p(e, ["startTime"], n);
  const i = h(t, ["endTime"]);
  return i != null && p(e, ["endTime"], i), e;
}
function DF(r, t) {
  const e = {}, n = h(t, [
    "timeRangeFilter"
  ]);
  return n != null && p(e, ["timeRangeFilter"], NF(r, n)), e;
}
function FF(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "dynamicThreshold"
  ]);
  return i != null && p(e, ["dynamicThreshold"], i), e;
}
function $F(r, t) {
  const e = {}, n = h(t, [
    "dynamicRetrievalConfig"
  ]);
  return n != null && p(e, ["dynamicRetrievalConfig"], FF(r, n)), e;
}
function UF() {
  return {};
}
function qF(r, t) {
  const e = {}, n = h(t, ["apiKeyString"]);
  return n != null && p(e, ["apiKeyString"], n), e;
}
function BF(r, t) {
  const e = {}, n = h(t, ["apiKeyConfig"]);
  n != null && p(e, ["apiKeyConfig"], qF(r, n));
  const i = h(t, ["authType"]);
  i != null && p(e, ["authType"], i);
  const o = h(t, [
    "googleServiceAccountConfig"
  ]);
  o != null && p(e, ["googleServiceAccountConfig"], o);
  const s = h(t, [
    "httpBasicAuthConfig"
  ]);
  s != null && p(e, ["httpBasicAuthConfig"], s);
  const u = h(t, ["oauthConfig"]);
  u != null && p(e, ["oauthConfig"], u);
  const l = h(t, ["oidcConfig"]);
  return l != null && p(e, ["oidcConfig"], l), e;
}
function VF(r, t) {
  const e = {}, n = h(t, ["authConfig"]);
  return n != null && p(e, ["authConfig"], BF(r, n)), e;
}
function hT(r, t) {
  const e = {}, n = h(t, [
    "functionDeclarations"
  ]);
  if (n != null) {
    let d = n;
    Array.isArray(d) && (d = d.map((g) => LF(r, g))), p(e, ["functionDeclarations"], d);
  }
  const i = h(t, ["retrieval"]);
  i != null && p(e, ["retrieval"], i);
  const o = h(t, ["googleSearch"]);
  o != null && p(e, ["googleSearch"], DF(r, o));
  const s = h(t, [
    "googleSearchRetrieval"
  ]);
  s != null && p(e, ["googleSearchRetrieval"], $F(r, s)), h(t, [
    "enterpriseWebSearch"
  ]) != null && p(e, ["enterpriseWebSearch"], UF());
  const l = h(t, ["googleMaps"]);
  if (l != null && p(e, ["googleMaps"], VF(r, l)), h(t, ["urlContext"]) !== void 0)
    throw new Error("urlContext parameter is not supported in Vertex AI.");
  const c = h(t, [
    "codeExecution"
  ]);
  return c != null && p(e, ["codeExecution"], c), e;
}
function HF(r, t) {
  const e = {}, n = h(t, ["mode"]);
  n != null && p(e, ["mode"], n);
  const i = h(t, [
    "allowedFunctionNames"
  ]);
  return i != null && p(e, ["allowedFunctionNames"], i), e;
}
function GF(r, t) {
  const e = {}, n = h(t, ["latitude"]);
  n != null && p(e, ["latitude"], n);
  const i = h(t, ["longitude"]);
  return i != null && p(e, ["longitude"], i), e;
}
function WF(r, t) {
  const e = {}, n = h(t, ["latLng"]);
  return n != null && p(e, ["latLng"], GF(r, n)), e;
}
function KF(r, t) {
  const e = {}, n = h(t, [
    "functionCallingConfig"
  ]);
  n != null && p(e, ["functionCallingConfig"], HF(r, n));
  const i = h(t, [
    "retrievalConfig"
  ]);
  return i != null && p(e, ["retrievalConfig"], WF(r, i)), e;
}
function JF(r, t) {
  const e = {}, n = h(t, ["voiceName"]);
  return n != null && p(e, ["voiceName"], n), e;
}
function zF(r, t) {
  const e = {}, n = h(t, [
    "prebuiltVoiceConfig"
  ]);
  return n != null && p(e, ["prebuiltVoiceConfig"], JF(r, n)), e;
}
function YF(r, t) {
  const e = {}, n = h(t, ["voiceConfig"]);
  if (n != null && p(e, ["voiceConfig"], zF(r, n)), h(t, ["multiSpeakerVoiceConfig"]) !== void 0)
    throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
  const i = h(t, ["languageCode"]);
  return i != null && p(e, ["languageCode"], i), e;
}
function ZF(r, t) {
  const e = {}, n = h(t, [
    "includeThoughts"
  ]);
  n != null && p(e, ["includeThoughts"], n);
  const i = h(t, [
    "thinkingBudget"
  ]);
  return i != null && p(e, ["thinkingBudget"], i), e;
}
function jF(r, t, e) {
  const n = {}, i = h(t, [
    "systemInstruction"
  ]);
  e !== void 0 && i != null && p(e, ["systemInstruction"], vo(r, Zt(r, i)));
  const o = h(t, ["temperature"]);
  o != null && p(n, ["temperature"], o);
  const s = h(t, ["topP"]);
  s != null && p(n, ["topP"], s);
  const u = h(t, ["topK"]);
  u != null && p(n, ["topK"], u);
  const l = h(t, [
    "candidateCount"
  ]);
  l != null && p(n, ["candidateCount"], l);
  const c = h(t, [
    "maxOutputTokens"
  ]);
  c != null && p(n, ["maxOutputTokens"], c);
  const d = h(t, [
    "stopSequences"
  ]);
  d != null && p(n, ["stopSequences"], d);
  const g = h(t, [
    "responseLogprobs"
  ]);
  g != null && p(n, ["responseLogprobs"], g);
  const y = h(t, ["logprobs"]);
  y != null && p(n, ["logprobs"], y);
  const w = h(t, [
    "presencePenalty"
  ]);
  w != null && p(n, ["presencePenalty"], w);
  const b = h(t, [
    "frequencyPenalty"
  ]);
  b != null && p(n, ["frequencyPenalty"], b);
  const _ = h(t, ["seed"]);
  _ != null && p(n, ["seed"], _);
  const C = h(t, [
    "responseMimeType"
  ]);
  C != null && p(n, ["responseMimeType"], C);
  const m = h(t, [
    "responseSchema"
  ]);
  m != null && p(n, ["responseSchema"], Wl(r, m));
  const T = h(t, [
    "routingConfig"
  ]);
  T != null && p(n, ["routingConfig"], T);
  const S = h(t, [
    "modelSelectionConfig"
  ]);
  S != null && p(n, ["modelConfig"], PF(r, S));
  const A = h(t, [
    "safetySettings"
  ]);
  if (e !== void 0 && A != null) {
    let j = A;
    Array.isArray(j) && (j = j.map((K) => OF(r, K))), p(e, ["safetySettings"], j);
  }
  const x = h(t, ["tools"]);
  if (e !== void 0 && x != null) {
    let j = du(r, x);
    Array.isArray(j) && (j = j.map((K) => hT(r, fu(r, K)))), p(e, ["tools"], j);
  }
  const D = h(t, ["toolConfig"]);
  e !== void 0 && D != null && p(e, ["toolConfig"], KF(r, D));
  const U = h(t, ["labels"]);
  e !== void 0 && U != null && p(e, ["labels"], U);
  const O = h(t, [
    "cachedContent"
  ]);
  e !== void 0 && O != null && p(e, ["cachedContent"], Kr(r, O));
  const k = h(t, [
    "responseModalities"
  ]);
  k != null && p(n, ["responseModalities"], k);
  const H = h(t, [
    "mediaResolution"
  ]);
  H != null && p(n, ["mediaResolution"], H);
  const V = h(t, ["speechConfig"]);
  V != null && p(n, ["speechConfig"], YF(r, eT(r, V)));
  const N = h(t, [
    "audioTimestamp"
  ]);
  N != null && p(n, ["audioTimestamp"], N);
  const $ = h(t, [
    "thinkingConfig"
  ]);
  return $ != null && p(n, ["thinkingConfig"], ZF(r, $)), n;
}
function $v(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["contents"]);
  if (i != null) {
    let s = Pn(r, i);
    Array.isArray(s) && (s = s.map((u) => vo(r, u))), p(e, ["contents"], s);
  }
  const o = h(t, ["config"]);
  return o != null && p(e, ["generationConfig"], jF(r, o, e)), e;
}
function QF(r, t, e) {
  const n = {}, i = h(t, ["taskType"]);
  e !== void 0 && i != null && p(e, ["instances[]", "task_type"], i);
  const o = h(t, ["title"]);
  e !== void 0 && o != null && p(e, ["instances[]", "title"], o);
  const s = h(t, [
    "outputDimensionality"
  ]);
  e !== void 0 && s != null && p(e, ["parameters", "outputDimensionality"], s);
  const u = h(t, ["mimeType"]);
  e !== void 0 && u != null && p(e, ["instances[]", "mimeType"], u);
  const l = h(t, ["autoTruncate"]);
  return e !== void 0 && l != null && p(e, ["parameters", "autoTruncate"], l), n;
}
function XF(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["contents"]);
  i != null && p(e, ["instances[]", "content"], Xb(r, i));
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], QF(r, o, e)), e;
}
function e$(r, t, e) {
  const n = {}, i = h(t, ["outputGcsUri"]);
  e !== void 0 && i != null && p(e, ["parameters", "storageUri"], i);
  const o = h(t, [
    "negativePrompt"
  ]);
  e !== void 0 && o != null && p(e, ["parameters", "negativePrompt"], o);
  const s = h(t, [
    "numberOfImages"
  ]);
  e !== void 0 && s != null && p(e, ["parameters", "sampleCount"], s);
  const u = h(t, ["aspectRatio"]);
  e !== void 0 && u != null && p(e, ["parameters", "aspectRatio"], u);
  const l = h(t, [
    "guidanceScale"
  ]);
  e !== void 0 && l != null && p(e, ["parameters", "guidanceScale"], l);
  const c = h(t, ["seed"]);
  e !== void 0 && c != null && p(e, ["parameters", "seed"], c);
  const d = h(t, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && d != null && p(e, ["parameters", "safetySetting"], d);
  const g = h(t, [
    "personGeneration"
  ]);
  e !== void 0 && g != null && p(e, ["parameters", "personGeneration"], g);
  const y = h(t, [
    "includeSafetyAttributes"
  ]);
  e !== void 0 && y != null && p(e, ["parameters", "includeSafetyAttributes"], y);
  const w = h(t, [
    "includeRaiReason"
  ]);
  e !== void 0 && w != null && p(e, ["parameters", "includeRaiReason"], w);
  const b = h(t, ["language"]);
  e !== void 0 && b != null && p(e, ["parameters", "language"], b);
  const _ = h(t, [
    "outputMimeType"
  ]);
  e !== void 0 && _ != null && p(e, ["parameters", "outputOptions", "mimeType"], _);
  const C = h(t, [
    "outputCompressionQuality"
  ]);
  e !== void 0 && C != null && p(e, ["parameters", "outputOptions", "compressionQuality"], C);
  const m = h(t, ["addWatermark"]);
  e !== void 0 && m != null && p(e, ["parameters", "addWatermark"], m);
  const T = h(t, [
    "enhancePrompt"
  ]);
  return e !== void 0 && T != null && p(e, ["parameters", "enhancePrompt"], T), n;
}
function t$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["prompt"]);
  i != null && p(e, ["instances[0]", "prompt"], i);
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], e$(r, o, e)), e;
}
function fp(r, t) {
  const e = {}, n = h(t, ["gcsUri"]);
  n != null && p(e, ["gcsUri"], n);
  const i = h(t, ["imageBytes"]);
  i != null && p(e, ["bytesBase64Encoded"], Jr(r, i));
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function n$(r, t) {
  const e = {}, n = h(t, ["maskMode"]);
  n != null && p(e, ["maskMode"], n);
  const i = h(t, [
    "segmentationClasses"
  ]);
  i != null && p(e, ["maskClasses"], i);
  const o = h(t, ["maskDilation"]);
  return o != null && p(e, ["dilation"], o), e;
}
function r$(r, t) {
  const e = {}, n = h(t, ["controlType"]);
  n != null && p(e, ["controlType"], n);
  const i = h(t, [
    "enableControlImageComputation"
  ]);
  return i != null && p(e, ["computeControl"], i), e;
}
function i$(r, t) {
  const e = {}, n = h(t, [
    "styleDescription"
  ]);
  return n != null && p(e, ["styleDescription"], n), e;
}
function o$(r, t) {
  const e = {}, n = h(t, ["subjectType"]);
  n != null && p(e, ["subjectType"], n);
  const i = h(t, [
    "subjectDescription"
  ]);
  return i != null && p(e, ["subjectDescription"], i), e;
}
function s$(r, t) {
  const e = {}, n = h(t, [
    "referenceImage"
  ]);
  n != null && p(e, ["referenceImage"], fp(r, n));
  const i = h(t, ["referenceId"]);
  i != null && p(e, ["referenceId"], i);
  const o = h(t, [
    "referenceType"
  ]);
  o != null && p(e, ["referenceType"], o);
  const s = h(t, [
    "maskImageConfig"
  ]);
  s != null && p(e, ["maskImageConfig"], n$(r, s));
  const u = h(t, [
    "controlImageConfig"
  ]);
  u != null && p(e, ["controlImageConfig"], r$(r, u));
  const l = h(t, [
    "styleImageConfig"
  ]);
  l != null && p(e, ["styleImageConfig"], i$(r, l));
  const c = h(t, [
    "subjectImageConfig"
  ]);
  return c != null && p(e, ["subjectImageConfig"], o$(r, c)), e;
}
function a$(r, t, e) {
  const n = {}, i = h(t, ["outputGcsUri"]);
  e !== void 0 && i != null && p(e, ["parameters", "storageUri"], i);
  const o = h(t, [
    "negativePrompt"
  ]);
  e !== void 0 && o != null && p(e, ["parameters", "negativePrompt"], o);
  const s = h(t, [
    "numberOfImages"
  ]);
  e !== void 0 && s != null && p(e, ["parameters", "sampleCount"], s);
  const u = h(t, ["aspectRatio"]);
  e !== void 0 && u != null && p(e, ["parameters", "aspectRatio"], u);
  const l = h(t, [
    "guidanceScale"
  ]);
  e !== void 0 && l != null && p(e, ["parameters", "guidanceScale"], l);
  const c = h(t, ["seed"]);
  e !== void 0 && c != null && p(e, ["parameters", "seed"], c);
  const d = h(t, [
    "safetyFilterLevel"
  ]);
  e !== void 0 && d != null && p(e, ["parameters", "safetySetting"], d);
  const g = h(t, [
    "personGeneration"
  ]);
  e !== void 0 && g != null && p(e, ["parameters", "personGeneration"], g);
  const y = h(t, [
    "includeSafetyAttributes"
  ]);
  e !== void 0 && y != null && p(e, ["parameters", "includeSafetyAttributes"], y);
  const w = h(t, [
    "includeRaiReason"
  ]);
  e !== void 0 && w != null && p(e, ["parameters", "includeRaiReason"], w);
  const b = h(t, ["language"]);
  e !== void 0 && b != null && p(e, ["parameters", "language"], b);
  const _ = h(t, [
    "outputMimeType"
  ]);
  e !== void 0 && _ != null && p(e, ["parameters", "outputOptions", "mimeType"], _);
  const C = h(t, [
    "outputCompressionQuality"
  ]);
  e !== void 0 && C != null && p(e, ["parameters", "outputOptions", "compressionQuality"], C);
  const m = h(t, ["editMode"]);
  e !== void 0 && m != null && p(e, ["parameters", "editMode"], m);
  const T = h(t, ["baseSteps"]);
  return e !== void 0 && T != null && p(e, ["parameters", "editConfig", "baseSteps"], T), n;
}
function l$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["prompt"]);
  i != null && p(e, ["instances[0]", "prompt"], i);
  const o = h(t, [
    "referenceImages"
  ]);
  if (o != null) {
    let u = o;
    Array.isArray(u) && (u = u.map((l) => s$(r, l))), p(e, ["instances[0]", "referenceImages"], u);
  }
  const s = h(t, ["config"]);
  return s != null && p(e, ["config"], a$(r, s, e)), e;
}
function u$(r, t, e) {
  const n = {}, i = h(t, [
    "includeRaiReason"
  ]);
  e !== void 0 && i != null && p(e, ["parameters", "includeRaiReason"], i);
  const o = h(t, [
    "outputMimeType"
  ]);
  e !== void 0 && o != null && p(e, ["parameters", "outputOptions", "mimeType"], o);
  const s = h(t, [
    "outputCompressionQuality"
  ]);
  e !== void 0 && s != null && p(e, ["parameters", "outputOptions", "compressionQuality"], s);
  const u = h(t, [
    "numberOfImages"
  ]);
  e !== void 0 && u != null && p(e, ["parameters", "sampleCount"], u);
  const l = h(t, ["mode"]);
  return e !== void 0 && l != null && p(e, ["parameters", "mode"], l), n;
}
function c$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["image"]);
  i != null && p(e, ["instances[0]", "image"], fp(r, i));
  const o = h(t, [
    "upscaleFactor"
  ]);
  o != null && p(e, ["parameters", "upscaleConfig", "upscaleFactor"], o);
  const s = h(t, ["config"]);
  return s != null && p(e, ["config"], u$(r, s, e)), e;
}
function f$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "name"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function d$(r, t, e) {
  const n = {}, i = h(t, ["pageSize"]);
  e !== void 0 && i != null && p(e, ["_query", "pageSize"], i);
  const o = h(t, ["pageToken"]);
  e !== void 0 && o != null && p(e, ["_query", "pageToken"], o);
  const s = h(t, ["filter"]);
  e !== void 0 && s != null && p(e, ["_query", "filter"], s);
  const u = h(t, ["queryBase"]);
  return e !== void 0 && u != null && p(e, ["_url", "models_url"], iT(r, u)), n;
}
function h$(r, t) {
  const e = {}, n = h(t, ["config"]);
  return n != null && p(e, ["config"], d$(r, n, e)), e;
}
function p$(r, t, e) {
  const n = {}, i = h(t, ["displayName"]);
  e !== void 0 && i != null && p(e, ["displayName"], i);
  const o = h(t, ["description"]);
  e !== void 0 && o != null && p(e, ["description"], o);
  const s = h(t, [
    "defaultCheckpointId"
  ]);
  return e !== void 0 && s != null && p(e, ["defaultCheckpointId"], s), n;
}
function m$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], p$(r, i, e)), e;
}
function g$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "name"], dt(r, n));
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function y$(r, t, e) {
  const n = {}, i = h(t, [
    "systemInstruction"
  ]);
  e !== void 0 && i != null && p(e, ["systemInstruction"], vo(r, Zt(r, i)));
  const o = h(t, ["tools"]);
  if (e !== void 0 && o != null) {
    let u = o;
    Array.isArray(u) && (u = u.map((l) => hT(r, l))), p(e, ["tools"], u);
  }
  const s = h(t, [
    "generationConfig"
  ]);
  return e !== void 0 && s != null && p(e, ["generationConfig"], s), n;
}
function v$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["contents"]);
  if (i != null) {
    let s = Pn(r, i);
    Array.isArray(s) && (s = s.map((u) => vo(r, u))), p(e, ["contents"], s);
  }
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], y$(r, o, e)), e;
}
function _$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["contents"]);
  if (i != null) {
    let s = Pn(r, i);
    Array.isArray(s) && (s = s.map((u) => vo(r, u))), p(e, ["contents"], s);
  }
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], o), e;
}
function w$(r, t, e) {
  const n = {}, i = h(t, [
    "numberOfVideos"
  ]);
  e !== void 0 && i != null && p(e, ["parameters", "sampleCount"], i);
  const o = h(t, ["outputGcsUri"]);
  e !== void 0 && o != null && p(e, ["parameters", "storageUri"], o);
  const s = h(t, ["fps"]);
  e !== void 0 && s != null && p(e, ["parameters", "fps"], s);
  const u = h(t, [
    "durationSeconds"
  ]);
  e !== void 0 && u != null && p(e, ["parameters", "durationSeconds"], u);
  const l = h(t, ["seed"]);
  e !== void 0 && l != null && p(e, ["parameters", "seed"], l);
  const c = h(t, ["aspectRatio"]);
  e !== void 0 && c != null && p(e, ["parameters", "aspectRatio"], c);
  const d = h(t, ["resolution"]);
  e !== void 0 && d != null && p(e, ["parameters", "resolution"], d);
  const g = h(t, [
    "personGeneration"
  ]);
  e !== void 0 && g != null && p(e, ["parameters", "personGeneration"], g);
  const y = h(t, ["pubsubTopic"]);
  e !== void 0 && y != null && p(e, ["parameters", "pubsubTopic"], y);
  const w = h(t, [
    "negativePrompt"
  ]);
  e !== void 0 && w != null && p(e, ["parameters", "negativePrompt"], w);
  const b = h(t, [
    "enhancePrompt"
  ]);
  return e !== void 0 && b != null && p(e, ["parameters", "enhancePrompt"], b), n;
}
function b$(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["_url", "model"], dt(r, n));
  const i = h(t, ["prompt"]);
  i != null && p(e, ["instances[0]", "prompt"], i);
  const o = h(t, ["image"]);
  o != null && p(e, ["instances[0]", "image"], fp(r, o));
  const s = h(t, ["config"]);
  return s != null && p(e, ["config"], w$(r, s, e)), e;
}
function T$(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function C$(r, t) {
  const e = {}, n = h(t, ["data"]);
  n != null && p(e, ["data"], n);
  const i = h(t, ["mimeType"]);
  return i != null && p(e, ["mimeType"], i), e;
}
function S$(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], T$(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], C$(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function E$(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => S$(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function A$(r, t) {
  const e = {}, n = h(t, ["citationSources"]);
  return n != null && p(e, ["citations"], n), e;
}
function x$(r, t) {
  const e = {}, n = h(t, ["retrievedUrl"]);
  n != null && p(e, ["retrievedUrl"], n);
  const i = h(t, [
    "urlRetrievalStatus"
  ]);
  return i != null && p(e, ["urlRetrievalStatus"], i), e;
}
function R$(r, t) {
  const e = {}, n = h(t, ["urlMetadata"]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => x$(r, o))), p(e, ["urlMetadata"], i);
  }
  return e;
}
function I$(r, t) {
  const e = {}, n = h(t, ["content"]);
  n != null && p(e, ["content"], E$(r, n));
  const i = h(t, [
    "citationMetadata"
  ]);
  i != null && p(e, ["citationMetadata"], A$(r, i));
  const o = h(t, ["tokenCount"]);
  o != null && p(e, ["tokenCount"], o);
  const s = h(t, ["finishReason"]);
  s != null && p(e, ["finishReason"], s);
  const u = h(t, [
    "urlContextMetadata"
  ]);
  u != null && p(e, ["urlContextMetadata"], R$(r, u));
  const l = h(t, ["avgLogprobs"]);
  l != null && p(e, ["avgLogprobs"], l);
  const c = h(t, [
    "groundingMetadata"
  ]);
  c != null && p(e, ["groundingMetadata"], c);
  const d = h(t, ["index"]);
  d != null && p(e, ["index"], d);
  const g = h(t, [
    "logprobsResult"
  ]);
  g != null && p(e, ["logprobsResult"], g);
  const y = h(t, [
    "safetyRatings"
  ]);
  return y != null && p(e, ["safetyRatings"], y), e;
}
function Uv(r, t) {
  const e = {}, n = h(t, ["candidates"]);
  if (n != null) {
    let u = n;
    Array.isArray(u) && (u = u.map((l) => I$(r, l))), p(e, ["candidates"], u);
  }
  const i = h(t, ["modelVersion"]);
  i != null && p(e, ["modelVersion"], i);
  const o = h(t, [
    "promptFeedback"
  ]);
  o != null && p(e, ["promptFeedback"], o);
  const s = h(t, [
    "usageMetadata"
  ]);
  return s != null && p(e, ["usageMetadata"], s), e;
}
function M$(r, t) {
  const e = {}, n = h(t, ["values"]);
  return n != null && p(e, ["values"], n), e;
}
function k$() {
  return {};
}
function P$(r, t) {
  const e = {}, n = h(t, ["embeddings"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => M$(r, s))), p(e, ["embeddings"], o);
  }
  return h(t, ["metadata"]) != null && p(e, ["metadata"], k$()), e;
}
function O$(r, t) {
  const e = {}, n = h(t, [
    "bytesBase64Encoded"
  ]);
  n != null && p(e, ["imageBytes"], Jr(r, n));
  const i = h(t, ["mimeType"]);
  return i != null && p(e, ["mimeType"], i), e;
}
function pT(r, t) {
  const e = {}, n = h(t, [
    "safetyAttributes",
    "categories"
  ]);
  n != null && p(e, ["categories"], n);
  const i = h(t, [
    "safetyAttributes",
    "scores"
  ]);
  i != null && p(e, ["scores"], i);
  const o = h(t, ["contentType"]);
  return o != null && p(e, ["contentType"], o), e;
}
function L$(r, t) {
  const e = {}, n = h(t, ["_self"]);
  n != null && p(e, ["image"], O$(r, n));
  const i = h(t, [
    "raiFilteredReason"
  ]);
  i != null && p(e, ["raiFilteredReason"], i);
  const o = h(t, ["_self"]);
  return o != null && p(e, ["safetyAttributes"], pT(r, o)), e;
}
function N$(r, t) {
  const e = {}, n = h(t, [
    "predictions"
  ]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => L$(r, s))), p(e, ["generatedImages"], o);
  }
  const i = h(t, [
    "positivePromptSafetyAttributes"
  ]);
  return i != null && p(e, ["positivePromptSafetyAttributes"], pT(r, i)), e;
}
function D$(r, t) {
  const e = {}, n = h(t, ["baseModel"]);
  n != null && p(e, ["baseModel"], n);
  const i = h(t, ["createTime"]);
  i != null && p(e, ["createTime"], i);
  const o = h(t, ["updateTime"]);
  return o != null && p(e, ["updateTime"], o), e;
}
function Rh(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["displayName"]);
  i != null && p(e, ["displayName"], i);
  const o = h(t, ["description"]);
  o != null && p(e, ["description"], o);
  const s = h(t, ["version"]);
  s != null && p(e, ["version"], s);
  const u = h(t, ["_self"]);
  u != null && p(e, ["tunedModelInfo"], D$(r, u));
  const l = h(t, [
    "inputTokenLimit"
  ]);
  l != null && p(e, ["inputTokenLimit"], l);
  const c = h(t, [
    "outputTokenLimit"
  ]);
  c != null && p(e, ["outputTokenLimit"], c);
  const d = h(t, [
    "supportedGenerationMethods"
  ]);
  return d != null && p(e, ["supportedActions"], d), e;
}
function F$(r, t) {
  const e = {}, n = h(t, [
    "nextPageToken"
  ]);
  n != null && p(e, ["nextPageToken"], n);
  const i = h(t, ["_self"]);
  if (i != null) {
    let o = oT(r, i);
    Array.isArray(o) && (o = o.map((s) => Rh(r, s))), p(e, ["models"], o);
  }
  return e;
}
function $$() {
  return {};
}
function U$(r, t) {
  const e = {}, n = h(t, ["totalTokens"]);
  n != null && p(e, ["totalTokens"], n);
  const i = h(t, [
    "cachedContentTokenCount"
  ]);
  return i != null && p(e, ["cachedContentTokenCount"], i), e;
}
function q$(r, t) {
  const e = {}, n = h(t, ["video", "uri"]);
  n != null && p(e, ["uri"], n);
  const i = h(t, [
    "video",
    "encodedVideo"
  ]);
  i != null && p(e, ["videoBytes"], Jr(r, i));
  const o = h(t, ["encoding"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function B$(r, t) {
  const e = {}, n = h(t, ["_self"]);
  return n != null && p(e, ["video"], q$(r, n)), e;
}
function V$(r, t) {
  const e = {}, n = h(t, [
    "generatedSamples"
  ]);
  if (n != null) {
    let s = n;
    Array.isArray(s) && (s = s.map((u) => B$(r, u))), p(e, ["generatedVideos"], s);
  }
  const i = h(t, [
    "raiMediaFilteredCount"
  ]);
  i != null && p(e, ["raiMediaFilteredCount"], i);
  const o = h(t, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && p(e, ["raiMediaFilteredReasons"], o), e;
}
function H$(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["metadata"]);
  i != null && p(e, ["metadata"], i);
  const o = h(t, ["done"]);
  o != null && p(e, ["done"], o);
  const s = h(t, ["error"]);
  s != null && p(e, ["error"], s);
  const u = h(t, [
    "response",
    "generateVideoResponse"
  ]);
  return u != null && p(e, ["response"], V$(r, u)), e;
}
function G$(r, t) {
  const e = {}, n = h(t, ["fps"]);
  n != null && p(e, ["fps"], n);
  const i = h(t, ["endOffset"]);
  i != null && p(e, ["endOffset"], i);
  const o = h(t, ["startOffset"]);
  return o != null && p(e, ["startOffset"], o), e;
}
function W$(r, t) {
  const e = {}, n = h(t, ["displayName"]);
  n != null && p(e, ["displayName"], n);
  const i = h(t, ["data"]);
  i != null && p(e, ["data"], i);
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function K$(r, t) {
  const e = {}, n = h(t, [
    "videoMetadata"
  ]);
  n != null && p(e, ["videoMetadata"], G$(r, n));
  const i = h(t, ["thought"]);
  i != null && p(e, ["thought"], i);
  const o = h(t, ["inlineData"]);
  o != null && p(e, ["inlineData"], W$(r, o));
  const s = h(t, [
    "codeExecutionResult"
  ]);
  s != null && p(e, ["codeExecutionResult"], s);
  const u = h(t, [
    "executableCode"
  ]);
  u != null && p(e, ["executableCode"], u);
  const l = h(t, ["fileData"]);
  l != null && p(e, ["fileData"], l);
  const c = h(t, ["functionCall"]);
  c != null && p(e, ["functionCall"], c);
  const d = h(t, [
    "functionResponse"
  ]);
  d != null && p(e, ["functionResponse"], d);
  const g = h(t, ["text"]);
  return g != null && p(e, ["text"], g), e;
}
function J$(r, t) {
  const e = {}, n = h(t, ["parts"]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => K$(r, s))), p(e, ["parts"], o);
  }
  const i = h(t, ["role"]);
  return i != null && p(e, ["role"], i), e;
}
function z$(r, t) {
  const e = {}, n = h(t, ["citations"]);
  return n != null && p(e, ["citations"], n), e;
}
function Y$(r, t) {
  const e = {}, n = h(t, ["content"]);
  n != null && p(e, ["content"], J$(r, n));
  const i = h(t, [
    "citationMetadata"
  ]);
  i != null && p(e, ["citationMetadata"], z$(r, i));
  const o = h(t, [
    "finishMessage"
  ]);
  o != null && p(e, ["finishMessage"], o);
  const s = h(t, ["finishReason"]);
  s != null && p(e, ["finishReason"], s);
  const u = h(t, ["avgLogprobs"]);
  u != null && p(e, ["avgLogprobs"], u);
  const l = h(t, [
    "groundingMetadata"
  ]);
  l != null && p(e, ["groundingMetadata"], l);
  const c = h(t, ["index"]);
  c != null && p(e, ["index"], c);
  const d = h(t, [
    "logprobsResult"
  ]);
  d != null && p(e, ["logprobsResult"], d);
  const g = h(t, [
    "safetyRatings"
  ]);
  return g != null && p(e, ["safetyRatings"], g), e;
}
function qv(r, t) {
  const e = {}, n = h(t, ["candidates"]);
  if (n != null) {
    let c = n;
    Array.isArray(c) && (c = c.map((d) => Y$(r, d))), p(e, ["candidates"], c);
  }
  const i = h(t, ["createTime"]);
  i != null && p(e, ["createTime"], i);
  const o = h(t, ["responseId"]);
  o != null && p(e, ["responseId"], o);
  const s = h(t, ["modelVersion"]);
  s != null && p(e, ["modelVersion"], s);
  const u = h(t, [
    "promptFeedback"
  ]);
  u != null && p(e, ["promptFeedback"], u);
  const l = h(t, [
    "usageMetadata"
  ]);
  return l != null && p(e, ["usageMetadata"], l), e;
}
function Z$(r, t) {
  const e = {}, n = h(t, ["truncated"]);
  n != null && p(e, ["truncated"], n);
  const i = h(t, ["token_count"]);
  return i != null && p(e, ["tokenCount"], i), e;
}
function j$(r, t) {
  const e = {}, n = h(t, ["values"]);
  n != null && p(e, ["values"], n);
  const i = h(t, ["statistics"]);
  return i != null && p(e, ["statistics"], Z$(r, i)), e;
}
function Q$(r, t) {
  const e = {}, n = h(t, [
    "billableCharacterCount"
  ]);
  return n != null && p(e, ["billableCharacterCount"], n), e;
}
function X$(r, t) {
  const e = {}, n = h(t, [
    "predictions[]",
    "embeddings"
  ]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => j$(r, s))), p(e, ["embeddings"], o);
  }
  const i = h(t, ["metadata"]);
  return i != null && p(e, ["metadata"], Q$(r, i)), e;
}
function eU(r, t) {
  const e = {}, n = h(t, ["gcsUri"]);
  n != null && p(e, ["gcsUri"], n);
  const i = h(t, [
    "bytesBase64Encoded"
  ]);
  i != null && p(e, ["imageBytes"], Jr(r, i));
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function mT(r, t) {
  const e = {}, n = h(t, [
    "safetyAttributes",
    "categories"
  ]);
  n != null && p(e, ["categories"], n);
  const i = h(t, [
    "safetyAttributes",
    "scores"
  ]);
  i != null && p(e, ["scores"], i);
  const o = h(t, ["contentType"]);
  return o != null && p(e, ["contentType"], o), e;
}
function dp(r, t) {
  const e = {}, n = h(t, ["_self"]);
  n != null && p(e, ["image"], eU(r, n));
  const i = h(t, [
    "raiFilteredReason"
  ]);
  i != null && p(e, ["raiFilteredReason"], i);
  const o = h(t, ["_self"]);
  o != null && p(e, ["safetyAttributes"], mT(r, o));
  const s = h(t, ["prompt"]);
  return s != null && p(e, ["enhancedPrompt"], s), e;
}
function tU(r, t) {
  const e = {}, n = h(t, [
    "predictions"
  ]);
  if (n != null) {
    let o = n;
    Array.isArray(o) && (o = o.map((s) => dp(r, s))), p(e, ["generatedImages"], o);
  }
  const i = h(t, [
    "positivePromptSafetyAttributes"
  ]);
  return i != null && p(e, ["positivePromptSafetyAttributes"], mT(r, i)), e;
}
function nU(r, t) {
  const e = {}, n = h(t, [
    "predictions"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => dp(r, o))), p(e, ["generatedImages"], i);
  }
  return e;
}
function rU(r, t) {
  const e = {}, n = h(t, [
    "predictions"
  ]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => dp(r, o))), p(e, ["generatedImages"], i);
  }
  return e;
}
function iU(r, t) {
  const e = {}, n = h(t, ["endpoint"]);
  n != null && p(e, ["name"], n);
  const i = h(t, [
    "deployedModelId"
  ]);
  return i != null && p(e, ["deployedModelId"], i), e;
}
function oU(r, t) {
  const e = {}, n = h(t, [
    "labels",
    "google-vertex-llm-tuning-base-model-id"
  ]);
  n != null && p(e, ["baseModel"], n);
  const i = h(t, ["createTime"]);
  i != null && p(e, ["createTime"], i);
  const o = h(t, ["updateTime"]);
  return o != null && p(e, ["updateTime"], o), e;
}
function sU(r, t) {
  const e = {}, n = h(t, ["checkpointId"]);
  n != null && p(e, ["checkpointId"], n);
  const i = h(t, ["epoch"]);
  i != null && p(e, ["epoch"], i);
  const o = h(t, ["step"]);
  return o != null && p(e, ["step"], o), e;
}
function Ih(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["displayName"]);
  i != null && p(e, ["displayName"], i);
  const o = h(t, ["description"]);
  o != null && p(e, ["description"], o);
  const s = h(t, ["versionId"]);
  s != null && p(e, ["version"], s);
  const u = h(t, ["deployedModels"]);
  if (u != null) {
    let y = u;
    Array.isArray(y) && (y = y.map((w) => iU(r, w))), p(e, ["endpoints"], y);
  }
  const l = h(t, ["labels"]);
  l != null && p(e, ["labels"], l);
  const c = h(t, ["_self"]);
  c != null && p(e, ["tunedModelInfo"], oU(r, c));
  const d = h(t, [
    "defaultCheckpointId"
  ]);
  d != null && p(e, ["defaultCheckpointId"], d);
  const g = h(t, ["checkpoints"]);
  if (g != null) {
    let y = g;
    Array.isArray(y) && (y = y.map((w) => sU(r, w))), p(e, ["checkpoints"], y);
  }
  return e;
}
function aU(r, t) {
  const e = {}, n = h(t, [
    "nextPageToken"
  ]);
  n != null && p(e, ["nextPageToken"], n);
  const i = h(t, ["_self"]);
  if (i != null) {
    let o = oT(r, i);
    Array.isArray(o) && (o = o.map((s) => Ih(r, s))), p(e, ["models"], o);
  }
  return e;
}
function lU() {
  return {};
}
function uU(r, t) {
  const e = {}, n = h(t, ["totalTokens"]);
  return n != null && p(e, ["totalTokens"], n), e;
}
function cU(r, t) {
  const e = {}, n = h(t, ["tokensInfo"]);
  return n != null && p(e, ["tokensInfo"], n), e;
}
function fU(r, t) {
  const e = {}, n = h(t, ["gcsUri"]);
  n != null && p(e, ["uri"], n);
  const i = h(t, [
    "bytesBase64Encoded"
  ]);
  i != null && p(e, ["videoBytes"], Jr(r, i));
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function dU(r, t) {
  const e = {}, n = h(t, ["_self"]);
  return n != null && p(e, ["video"], fU(r, n)), e;
}
function hU(r, t) {
  const e = {}, n = h(t, ["videos"]);
  if (n != null) {
    let s = n;
    Array.isArray(s) && (s = s.map((u) => dU(r, u))), p(e, ["generatedVideos"], s);
  }
  const i = h(t, [
    "raiMediaFilteredCount"
  ]);
  i != null && p(e, ["raiMediaFilteredCount"], i);
  const o = h(t, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && p(e, ["raiMediaFilteredReasons"], o), e;
}
function pU(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["metadata"]);
  i != null && p(e, ["metadata"], i);
  const o = h(t, ["done"]);
  o != null && p(e, ["done"], o);
  const s = h(t, ["error"]);
  s != null && p(e, ["error"], s);
  const u = h(t, ["response"]);
  return u != null && p(e, ["response"], hU(r, u)), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const mU = "Content-Type", gU = "X-Server-Timeout", yU = "User-Agent", Mh = "x-goog-api-client", vU = "1.0.0", _U = `google-genai-sdk/${vU}`, wU = "v1beta1", bU = "v1beta", Bv = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
class gT extends Error {
  constructor(t, e) {
    e ? super(t, { cause: e }) : super(t, { cause: new Error().stack }), this.message = t, this.name = "ClientError";
  }
}
class kh extends Error {
  constructor(t, e) {
    e ? super(t, { cause: e }) : super(t, { cause: new Error().stack }), this.message = t, this.name = "ServerError";
  }
}
class TU {
  constructor(t) {
    var e, n;
    this.clientOptions = Object.assign(Object.assign({}, t), { project: t.project, location: t.location, apiKey: t.apiKey, vertexai: t.vertexai });
    const i = {};
    this.clientOptions.vertexai ? (i.apiVersion = (e = this.clientOptions.apiVersion) !== null && e !== void 0 ? e : wU, i.baseUrl = this.baseUrlFromProjectLocation(), this.normalizeAuthParameters()) : (i.apiVersion = (n = this.clientOptions.apiVersion) !== null && n !== void 0 ? n : bU, i.baseUrl = "https://generativelanguage.googleapis.com/"), i.headers = this.getDefaultHeaders(), this.clientOptions.httpOptions = i, t.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(i, t.httpOptions));
  }
  /**
   * Determines the base URL for Vertex AI based on project and location.
   * Uses the global endpoint if location is 'global' or if project/location
   * are not specified (implying API key usage).
   * @private
   */
  baseUrlFromProjectLocation() {
    return this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global" ? `https://${this.clientOptions.location}-aiplatform.googleapis.com/` : "https://aiplatform.googleapis.com/";
  }
  /**
   * Normalizes authentication parameters for Vertex AI.
   * If project and location are provided, API key is cleared.
   * If project and location are not provided (implying API key usage),
   * project and location are cleared.
   * @private
   */
  normalizeAuthParameters() {
    if (this.clientOptions.project && this.clientOptions.location) {
      this.clientOptions.apiKey = void 0;
      return;
    }
    this.clientOptions.project = void 0, this.clientOptions.location = void 0;
  }
  isVertexAI() {
    var t;
    return (t = this.clientOptions.vertexai) !== null && t !== void 0 ? t : !1;
  }
  getProject() {
    return this.clientOptions.project;
  }
  getLocation() {
    return this.clientOptions.location;
  }
  getApiVersion() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0)
      return this.clientOptions.httpOptions.apiVersion;
    throw new Error("API version is not set.");
  }
  getBaseUrl() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0)
      return this.clientOptions.httpOptions.baseUrl;
    throw new Error("Base URL is not set.");
  }
  getRequestUrl() {
    return this.getRequestUrlInternal(this.clientOptions.httpOptions);
  }
  getHeaders() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0)
      return this.clientOptions.httpOptions.headers;
    throw new Error("Headers are not set.");
  }
  getRequestUrlInternal(t) {
    if (!t || t.baseUrl === void 0 || t.apiVersion === void 0)
      throw new Error("HTTP options are not correctly set.");
    const n = [t.baseUrl.endsWith("/") ? t.baseUrl.slice(0, -1) : t.baseUrl];
    return t.apiVersion && t.apiVersion !== "" && n.push(t.apiVersion), n.join("/");
  }
  getBaseResourcePath() {
    return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
  }
  getApiKey() {
    return this.clientOptions.apiKey;
  }
  getWebsocketBaseUrl() {
    const t = this.getBaseUrl(), e = new URL(t);
    return e.protocol = e.protocol == "http:" ? "ws" : "wss", e.toString();
  }
  setBaseUrl(t) {
    if (this.clientOptions.httpOptions)
      this.clientOptions.httpOptions.baseUrl = t;
    else
      throw new Error("HTTP options are not correctly set.");
  }
  constructUrl(t, e, n) {
    const i = [this.getRequestUrlInternal(e)];
    return n && i.push(this.getBaseResourcePath()), t !== "" && i.push(t), new URL(`${i.join("/")}`);
  }
  shouldPrependVertexProjectPath(t) {
    return !(this.clientOptions.apiKey || !this.clientOptions.vertexai || t.path.startsWith("projects/") || t.httpMethod === "GET" && t.path.startsWith("publishers/google/models"));
  }
  async request(t) {
    let e = this.clientOptions.httpOptions;
    t.httpOptions && (e = this.patchHttpOptions(this.clientOptions.httpOptions, t.httpOptions));
    const n = this.shouldPrependVertexProjectPath(t), i = this.constructUrl(t.path, e, n);
    if (t.queryParams)
      for (const [s, u] of Object.entries(t.queryParams))
        i.searchParams.append(s, String(u));
    let o = {};
    if (t.httpMethod === "GET") {
      if (t.body && t.body !== "{}")
        throw new Error("Request body should be empty for GET request, but got non empty request body");
    } else
      o.body = t.body;
    return o = await this.includeExtraHttpOptionsToRequestInit(o, e, t.abortSignal), this.unaryApiCall(i, o, t.httpMethod);
  }
  patchHttpOptions(t, e) {
    const n = JSON.parse(JSON.stringify(t));
    for (const [i, o] of Object.entries(e))
      typeof o == "object" ? n[i] = Object.assign(Object.assign({}, n[i]), o) : o !== void 0 && (n[i] = o);
    return n;
  }
  async requestStream(t) {
    let e = this.clientOptions.httpOptions;
    t.httpOptions && (e = this.patchHttpOptions(this.clientOptions.httpOptions, t.httpOptions));
    const n = this.shouldPrependVertexProjectPath(t), i = this.constructUrl(t.path, e, n);
    (!i.searchParams.has("alt") || i.searchParams.get("alt") !== "sse") && i.searchParams.set("alt", "sse");
    let o = {};
    return o.body = t.body, o = await this.includeExtraHttpOptionsToRequestInit(o, e, t.abortSignal), this.streamApiCall(i, o, t.httpMethod);
  }
  async includeExtraHttpOptionsToRequestInit(t, e, n) {
    if (e && e.timeout || n) {
      const i = new AbortController(), o = i.signal;
      e.timeout && e?.timeout > 0 && setTimeout(() => i.abort(), e.timeout), n && n.addEventListener("abort", () => {
        i.abort();
      }), t.signal = o;
    }
    return t.headers = await this.getHeadersInternal(e), t;
  }
  async unaryApiCall(t, e, n) {
    return this.apiCall(t.toString(), Object.assign(Object.assign({}, e), { method: n })).then(async (i) => (await Vv(i), new Sh(i))).catch((i) => {
      throw i instanceof Error ? i : new Error(JSON.stringify(i));
    });
  }
  async streamApiCall(t, e, n) {
    return this.apiCall(t.toString(), Object.assign(Object.assign({}, e), { method: n })).then(async (i) => (await Vv(i), this.processStreamResponse(i))).catch((i) => {
      throw i instanceof Error ? i : new Error(JSON.stringify(i));
    });
  }
  processStreamResponse(t) {
    var e;
    return us(this, arguments, function* () {
      const i = (e = t?.body) === null || e === void 0 ? void 0 : e.getReader(), o = new TextDecoder("utf-8");
      if (!i)
        throw new Error("Response body is empty");
      try {
        let s = "";
        for (; ; ) {
          const { done: u, value: l } = yield yt(i.read());
          if (u) {
            if (s.trim().length > 0)
              throw new Error("Incomplete JSON segment at the end");
            break;
          }
          const c = o.decode(l);
          try {
            const g = JSON.parse(c);
            if ("error" in g) {
              const y = JSON.parse(JSON.stringify(g.error)), w = y.status, b = y.code, _ = `got status: ${w}. ${JSON.stringify(g)}`;
              if (b >= 400 && b < 500)
                throw new gT(_);
              if (b >= 500 && b < 600)
                throw new kh(_);
            }
          } catch (g) {
            const y = g;
            if (y.name === "ClientError" || y.name === "ServerError")
              throw g;
          }
          s += c;
          let d = s.match(Bv);
          for (; d; ) {
            const g = d[1];
            try {
              const y = new Response(g, {
                headers: t?.headers,
                status: t?.status,
                statusText: t?.statusText
              });
              yield yield yt(new Sh(y)), s = s.slice(d[0].length), d = s.match(Bv);
            } catch (y) {
              throw new Error(`exception parsing stream chunk ${g}. ${y}`);
            }
          }
        }
      } finally {
        i.releaseLock();
      }
    });
  }
  async apiCall(t, e) {
    return fetch(t, e).catch((n) => {
      throw new Error(`exception ${n} sending request`);
    });
  }
  getDefaultHeaders() {
    const t = {}, e = _U + " " + this.clientOptions.userAgentExtra;
    return t[yU] = e, t[Mh] = e, t[mU] = "application/json", t;
  }
  async getHeadersInternal(t) {
    const e = new Headers();
    if (t && t.headers) {
      for (const [n, i] of Object.entries(t.headers))
        e.append(n, i);
      t.timeout && t.timeout > 0 && e.append(gU, String(Math.ceil(t.timeout / 1e3)));
    }
    return await this.clientOptions.auth.addAuthHeaders(e), e;
  }
  /**
   * Uploads a file asynchronously using Gemini API only, this is not supported
   * in Vertex AI.
   *
   * @param file The string path to the file to be uploaded or a Blob object.
   * @param config Optional parameters specified in the `UploadFileConfig`
   *     interface. @see {@link UploadFileConfig}
   * @return A promise that resolves to a `File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   */
  async uploadFile(t, e) {
    var n;
    const i = {};
    e != null && (i.mimeType = e.mimeType, i.name = e.name, i.displayName = e.displayName), i.name && !i.name.startsWith("files/") && (i.name = `files/${i.name}`);
    const o = this.clientOptions.uploader, s = await o.stat(t);
    i.sizeBytes = String(s.size);
    const u = (n = e?.mimeType) !== null && n !== void 0 ? n : s.type;
    if (u === void 0 || u === "")
      throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
    i.mimeType = u;
    const l = await this.fetchUploadUrl(i, e);
    return o.upload(t, l, this);
  }
  /**
   * Downloads a file asynchronously to the specified path.
   *
   * @params params - The parameters for the download request, see {@link
   * DownloadFileParameters}
   */
  async downloadFile(t) {
    await this.clientOptions.downloader.download(t, this);
  }
  async fetchUploadUrl(t, e) {
    var n;
    let i = {};
    e?.httpOptions ? i = e.httpOptions : i = {
      apiVersion: "",
      headers: {
        "Content-Type": "application/json",
        "X-Goog-Upload-Protocol": "resumable",
        "X-Goog-Upload-Command": "start",
        "X-Goog-Upload-Header-Content-Length": `${t.sizeBytes}`,
        "X-Goog-Upload-Header-Content-Type": `${t.mimeType}`
      }
    };
    const o = {
      file: t
    }, s = await this.request({
      path: ke("upload/v1beta/files", o._url),
      body: JSON.stringify(o),
      httpMethod: "POST",
      httpOptions: i
    });
    if (!s || !s?.headers)
      throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
    const u = (n = s?.headers) === null || n === void 0 ? void 0 : n["x-goog-upload-url"];
    if (u === void 0)
      throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
    return u;
  }
}
async function Vv(r) {
  var t;
  if (r === void 0)
    throw new kh("response is undefined");
  if (!r.ok) {
    const e = r.status, n = r.statusText;
    let i;
    !((t = r.headers.get("content-type")) === null || t === void 0) && t.includes("application/json") ? i = await r.json() : i = {
      error: {
        message: await r.text(),
        code: r.status,
        status: r.statusText
      }
    };
    const o = `got status: ${e} ${n}. ${JSON.stringify(i)}`;
    throw e >= 400 && e < 500 ? new gT(o) : e >= 500 && e < 600 ? new kh(o) : new Error(o);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Hv = "mcp_used/unknown";
function yT(r) {
  for (const t of r)
    if (hp(t) || typeof t == "object" && "inputSchema" in t)
      return !0;
  return !1;
}
function vT(r) {
  var t;
  const e = (t = r[Mh]) !== null && t !== void 0 ? t : "";
  e.includes(Hv) || (r[Mh] = (e + ` ${Hv}`).trimStart());
}
function CU(r) {
  var t, e, n;
  return (n = (e = (t = r.config) === null || t === void 0 ? void 0 : t.tools) === null || e === void 0 ? void 0 : e.some((i) => hp(i))) !== null && n !== void 0 ? n : !1;
}
function SU(r) {
  var t, e, n;
  return (n = (e = (t = r.config) === null || t === void 0 ? void 0 : t.tools) === null || e === void 0 ? void 0 : e.some((i) => !hp(i))) !== null && n !== void 0 ? n : !1;
}
function hp(r) {
  return r !== null && typeof r == "object" && "tool" in r && "callTool" in r;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
async function EU(r, t, e) {
  const n = new FL();
  let i;
  e.data instanceof Blob ? i = JSON.parse(await e.data.text()) : i = JSON.parse(e.data);
  const o = K2(r, i);
  Object.assign(n, o), t(n);
}
class AU {
  constructor(t, e, n) {
    this.apiClient = t, this.auth = e, this.webSocketFactory = n;
  }
  /**
       Establishes a connection to the specified model and returns a
       LiveMusicSession object representing that connection.
  
       @experimental
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model = 'models/lyria-realtime-exp';
       const session = await ai.live.music.connect({
         model: model,
         callbacks: {
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(t) {
    var e, n;
    if (this.apiClient.isVertexAI())
      throw new Error("Live music is not supported for Vertex AI.");
    console.warn("Live music generation is experimental and may change in future versions.");
    const i = this.apiClient.getWebsocketBaseUrl(), o = this.apiClient.getApiVersion(), s = IU(this.apiClient.getDefaultHeaders()), u = this.apiClient.getApiKey(), l = `${i}/ws/google.ai.generativelanguage.${o}.GenerativeService.BidiGenerateMusic?key=${u}`;
    let c = () => {
    };
    const d = new Promise((S) => {
      c = S;
    }), g = t.callbacks, y = function() {
      c({});
    }, w = this.apiClient, b = {
      onopen: y,
      onmessage: (S) => {
        EU(w, g.onmessage, S);
      },
      onerror: (e = g?.onerror) !== null && e !== void 0 ? e : function(S) {
      },
      onclose: (n = g?.onclose) !== null && n !== void 0 ? n : function(S) {
      }
    }, _ = this.webSocketFactory.create(l, RU(s), b);
    _.connect(), await d;
    const C = dt(this.apiClient, t.model), m = cT(this.apiClient, {
      model: C
    }), T = xh(this.apiClient, { setup: m });
    return _.send(JSON.stringify(T)), new xU(_, this.apiClient);
  }
}
class xU {
  constructor(t, e) {
    this.conn = t, this.apiClient = e;
  }
  /**
      Sets inputs to steer music generation. Updates the session's current
      weighted prompts.
  
      @param params - Contains one property, `weightedPrompts`.
  
        - `weightedPrompts` to send to the model; weights are normalized to
          sum to 1.0.
  
      @experimental
     */
  async setWeightedPrompts(t) {
    if (!t.weightedPrompts || Object.keys(t.weightedPrompts).length === 0)
      throw new Error("Weighted prompts must be set and contain at least one entry.");
    const e = l2(this.apiClient, t), n = fT(this.apiClient, e);
    this.conn.send(JSON.stringify({ clientContent: n }));
  }
  /**
      Sets a configuration to the model. Updates the session's current
      music generation config.
  
      @param params - Contains one property, `musicGenerationConfig`.
  
        - `musicGenerationConfig` to set in the model. Passing an empty or
      undefined config to the model will reset the config to defaults.
  
      @experimental
     */
  async setMusicGenerationConfig(t) {
    t.musicGenerationConfig || (t.musicGenerationConfig = {});
    const e = u2(this.apiClient, t), n = xh(this.apiClient, e);
    this.conn.send(JSON.stringify(n));
  }
  sendPlaybackControl(t) {
    const e = xh(this.apiClient, {
      playbackControl: t
    });
    this.conn.send(JSON.stringify(e));
  }
  /**
   * Start the music stream.
   *
   * @experimental
   */
  play() {
    this.sendPlaybackControl(Zi.PLAY);
  }
  /**
   * Temporarily halt the music stream. Use `play` to resume from the current
   * position.
   *
   * @experimental
   */
  pause() {
    this.sendPlaybackControl(Zi.PAUSE);
  }
  /**
   * Stop the music stream and reset the state. Retains the current prompts
   * and config.
   *
   * @experimental
   */
  stop() {
    this.sendPlaybackControl(Zi.STOP);
  }
  /**
   * Resets the context of the music generation without stopping it.
   * Retains the current prompts and config.
   *
   * @experimental
   */
  resetContext() {
    this.sendPlaybackControl(Zi.RESET_CONTEXT);
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
     */
  close() {
    this.conn.close();
  }
}
function RU(r) {
  const t = {};
  return r.forEach((e, n) => {
    t[n] = e;
  }), t;
}
function IU(r) {
  const t = new Headers();
  for (const [e, n] of Object.entries(r))
    t.append(e, n);
  return t;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const MU = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
async function kU(r, t, e) {
  const n = new DL();
  let i;
  if (e.data instanceof Blob ? i = JSON.parse(await e.data.text()) : i = JSON.parse(e.data), r.isVertexAI()) {
    const o = F2(r, i);
    Object.assign(n, o);
  } else {
    const o = D2(r, i);
    Object.assign(n, o);
  }
  t(n);
}
class PU {
  constructor(t, e, n) {
    this.apiClient = t, this.auth = e, this.webSocketFactory = n, this.music = new AU(this.apiClient, this.auth, this.webSocketFactory);
  }
  /**
       Establishes a connection to the specified model with the given
       configuration and returns a Session object representing that connection.
  
       @experimental Built-in MCP support is an experimental feature, may change in
       future versions.
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-2.0-flash-live-001';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         },
         callbacks: {
           onopen: () => {
             console.log('Connected to the socket.');
           },
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(t) {
    var e, n, i, o, s, u;
    const l = this.apiClient.getWebsocketBaseUrl(), c = this.apiClient.getApiVersion();
    let d;
    const g = this.apiClient.getDefaultHeaders();
    t.config && t.config.tools && yT(t.config.tools) && vT(g);
    const y = DU(g);
    if (this.apiClient.isVertexAI())
      d = `${l}/ws/google.cloud.aiplatform.${c}.LlmBidiService/BidiGenerateContent`, await this.auth.addAuthHeaders(y);
    else {
      const k = this.apiClient.getApiKey();
      d = `${l}/ws/google.ai.generativelanguage.${c}.GenerativeService.BidiGenerateContent?key=${k}`;
    }
    let w = () => {
    };
    const b = new Promise((k) => {
      w = k;
    }), _ = t.callbacks, C = function() {
      var k;
      (k = _?.onopen) === null || k === void 0 || k.call(_), w({});
    }, m = this.apiClient, T = {
      onopen: C,
      onmessage: (k) => {
        kU(m, _.onmessage, k);
      },
      onerror: (e = _?.onerror) !== null && e !== void 0 ? e : function(k) {
      },
      onclose: (n = _?.onclose) !== null && n !== void 0 ? n : function(k) {
      }
    }, S = this.webSocketFactory.create(d, NU(y), T);
    S.connect(), await b;
    let A = dt(this.apiClient, t.model);
    if (this.apiClient.isVertexAI() && A.startsWith("publishers/")) {
      const k = this.apiClient.getProject(), H = this.apiClient.getLocation();
      A = `projects/${k}/locations/${H}/` + A;
    }
    let x = {};
    this.apiClient.isVertexAI() && ((i = t.config) === null || i === void 0 ? void 0 : i.responseModalities) === void 0 && (t.config === void 0 ? t.config = { responseModalities: [Hl.AUDIO] } : t.config.responseModalities = [Hl.AUDIO]), !((o = t.config) === null || o === void 0) && o.generationConfig && console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
    const D = (u = (s = t.config) === null || s === void 0 ? void 0 : s.tools) !== null && u !== void 0 ? u : [], U = [];
    for (const k of D)
      if (this.isCallableTool(k)) {
        const H = k;
        U.push(await H.tool());
      } else
        U.push(k);
    U.length > 0 && (t.config.tools = U);
    const O = {
      model: A,
      config: t.config,
      callbacks: t.callbacks
    };
    return this.apiClient.isVertexAI() ? x = t2(this.apiClient, O) : x = e2(this.apiClient, O), delete x.config, S.send(JSON.stringify(x)), new LU(S, this.apiClient);
  }
  // TODO: b/416041229 - Abstract this method to a common place.
  isCallableTool(t) {
    return "callTool" in t && typeof t.callTool == "function";
  }
}
const OU = {
  turnComplete: !0
};
class LU {
  constructor(t, e) {
    this.conn = t, this.apiClient = e;
  }
  tLiveClientContent(t, e) {
    if (e.turns !== null && e.turns !== void 0) {
      let n = [];
      try {
        n = Pn(t, e.turns), t.isVertexAI() ? n = n.map((i) => vo(t, i)) : n = n.map((i) => pu(t, i));
      } catch {
        throw new Error(`Failed to parse client content "turns", type: '${typeof e.turns}'`);
      }
      return {
        clientContent: { turns: n, turnComplete: e.turnComplete }
      };
    }
    return {
      clientContent: { turnComplete: e.turnComplete }
    };
  }
  tLiveClienttToolResponse(t, e) {
    let n = [];
    if (e.functionResponses == null)
      throw new Error("functionResponses is required.");
    if (Array.isArray(e.functionResponses) ? n = e.functionResponses : n = [e.functionResponses], n.length === 0)
      throw new Error("functionResponses is required.");
    for (const o of n) {
      if (typeof o != "object" || o === null || !("name" in o) || !("response" in o))
        throw new Error(`Could not parse function response, type '${typeof o}'.`);
      if (!t.isVertexAI() && !("id" in o))
        throw new Error(MU);
    }
    return {
      toolResponse: { functionResponses: n }
    };
  }
  /**
      Send a message over the established connection.
  
      @param params - Contains two **optional** properties, `turns` and
          `turnComplete`.
  
        - `turns` will be converted to a `Content[]`
        - `turnComplete: true` [default] indicates that you are done sending
          content and expect a response. If `turnComplete: false`, the server
          will wait for additional messages before starting generation.
  
      @experimental
  
      @remarks
      There are two ways to send messages to the live API:
      `sendClientContent` and `sendRealtimeInput`.
  
      `sendClientContent` messages are added to the model context **in order**.
      Having a conversation using `sendClientContent` messages is roughly
      equivalent to using the `Chat.sendMessageStream`, except that the state of
      the `chat` history is stored on the API server instead of locally.
  
      Because of `sendClientContent`'s order guarantee, the model cannot respons
      as quickly to `sendClientContent` messages as to `sendRealtimeInput`
      messages. This makes the biggest difference when sending objects that have
      significant preprocessing time (typically images).
  
      The `sendClientContent` message sends a `Content[]`
      which has more options than the `Blob` sent by `sendRealtimeInput`.
  
      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
  
      - Sending anything that can't be represented as a `Blob` (text,
      `sendClientContent({turns="Hello?"}`)).
      - Managing turns when not using audio input and voice activity detection.
        (`sendClientContent({turnComplete:true})` or the short form
      `sendClientContent()`)
      - Prefilling a conversation context
        ```
        sendClientContent({
            turns: [
              Content({role:user, parts:...}),
              Content({role:user, parts:...}),
              ...
            ]
        })
        ```
      @experimental
     */
  sendClientContent(t) {
    t = Object.assign(Object.assign({}, OU), t);
    const e = this.tLiveClientContent(this.apiClient, t);
    this.conn.send(JSON.stringify(e));
  }
  /**
      Send a realtime message over the established connection.
  
      @param params - Contains one property, `media`.
  
        - `media` will be converted to a `Blob`
  
      @experimental
  
      @remarks
      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
  
      With `sendRealtimeInput` the api will respond to audio automatically
      based on voice activity detection (VAD).
  
      `sendRealtimeInput` is optimized for responsivness at the expense of
      deterministic ordering guarantees. Audio and video tokens are to the
      context when they become available.
  
      Note: The Call signature expects a `Blob` object, but only a subset
      of audio and image mimetypes are allowed.
     */
  sendRealtimeInput(t) {
    let e = {};
    this.apiClient.isVertexAI() ? e = {
      realtimeInput: a2(this.apiClient, t)
    } : e = {
      realtimeInput: s2(this.apiClient, t)
    }, this.conn.send(JSON.stringify(e));
  }
  /**
      Send a function response message over the established connection.
  
      @param params - Contains property `functionResponses`.
  
        - `functionResponses` will be converted to a `functionResponses[]`
  
      @remarks
      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
  
      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
  
      @experimental
     */
  sendToolResponse(t) {
    if (t.functionResponses == null)
      throw new Error("Tool response parameters are required.");
    const e = this.tLiveClienttToolResponse(this.apiClient, t);
    this.conn.send(JSON.stringify(e));
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-2.0-flash-live-001';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         }
       });
  
       session.close();
       ```
     */
  close() {
    this.conn.close();
  }
}
function NU(r) {
  const t = {};
  return r.forEach((e, n) => {
    t[n] = e;
  }), t;
}
function DU(r) {
  const t = new Headers();
  for (const [e, n] of Object.entries(r))
    t.append(e, n);
  return t;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Gv = 10;
function Wv(r) {
  var t, e, n;
  if (!((t = r?.automaticFunctionCalling) === null || t === void 0) && t.disable)
    return !0;
  let i = !1;
  for (const s of (e = r?.tools) !== null && e !== void 0 ? e : [])
    if (Tl(s)) {
      i = !0;
      break;
    }
  if (!i)
    return !0;
  const o = (n = r?.automaticFunctionCalling) === null || n === void 0 ? void 0 : n.maximumRemoteCalls;
  return o && (o < 0 || !Number.isInteger(o)) || o == 0 ? (console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", o), !0) : !1;
}
function Tl(r) {
  return "callTool" in r && typeof r.callTool == "function";
}
function Kv(r) {
  var t;
  return !(!((t = r?.automaticFunctionCalling) === null || t === void 0) && t.ignoreCallHistory);
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class FU extends Cs {
  constructor(t) {
    super(), this.apiClient = t, this.generateContent = async (e) => {
      var n, i, o, s, u;
      const l = await this.processParamsForMcpUsage(e);
      if (!CU(e) || Wv(e.config))
        return await this.generateContentInternal(l);
      if (SU(e))
        throw new Error("Automatic function calling with CallableTools and Tools is not yet supported.");
      let c, d;
      const g = Pn(this.apiClient, l.contents), y = (o = (i = (n = l.config) === null || n === void 0 ? void 0 : n.automaticFunctionCalling) === null || i === void 0 ? void 0 : i.maximumRemoteCalls) !== null && o !== void 0 ? o : Gv;
      let w = 0;
      for (; w < y && (c = await this.generateContentInternal(l), !(!c.functionCalls || c.functionCalls.length === 0)); ) {
        const b = c.candidates[0].content, _ = [];
        for (const C of (u = (s = e.config) === null || s === void 0 ? void 0 : s.tools) !== null && u !== void 0 ? u : [])
          if (Tl(C)) {
            const T = await C.callTool(c.functionCalls);
            _.push(...T);
          }
        w++, d = {
          role: "user",
          parts: _
        }, l.contents = Pn(this.apiClient, l.contents), l.contents.push(b), l.contents.push(d), Kv(l.config) && (g.push(b), g.push(d));
      }
      return Kv(l.config) && (c.automaticFunctionCallingHistory = g), c;
    }, this.generateContentStream = async (e) => {
      if (Wv(e.config)) {
        const n = await this.processParamsForMcpUsage(e);
        return await this.generateContentStreamInternal(n);
      } else
        return await this.processAfcStream(e);
    }, this.generateImages = async (e) => await this.generateImagesInternal(e).then((n) => {
      var i;
      let o;
      const s = [];
      if (n?.generatedImages)
        for (const l of n.generatedImages)
          l && l?.safetyAttributes && ((i = l?.safetyAttributes) === null || i === void 0 ? void 0 : i.contentType) === "Positive Prompt" ? o = l?.safetyAttributes : s.push(l);
      let u;
      return o ? u = {
        generatedImages: s,
        positivePromptSafetyAttributes: o
      } : u = {
        generatedImages: s
      }, u;
    }), this.list = async (e) => {
      var n;
      const s = {
        config: Object.assign(Object.assign({}, {
          queryBase: !0
        }), e?.config)
      };
      if (this.apiClient.isVertexAI() && !s.config.queryBase) {
        if (!((n = s.config) === null || n === void 0) && n.filter)
          throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
        s.config.filter = "labels.tune-type:*";
      }
      return new hu(po.PAGED_ITEM_MODELS, (u) => this.listInternal(u), await this.listInternal(s), s);
    }, this.editImage = async (e) => {
      const n = {
        model: e.model,
        prompt: e.prompt,
        referenceImages: [],
        config: e.config
      };
      return e.referenceImages && e.referenceImages && (n.referenceImages = e.referenceImages.map((i) => i.toReferenceImageAPI())), await this.editImageInternal(n);
    }, this.upscaleImage = async (e) => {
      let n = {
        numberOfImages: 1,
        mode: "upscale"
      };
      e.config && (n = Object.assign(Object.assign({}, n), e.config));
      const i = {
        model: e.model,
        image: e.image,
        upscaleFactor: e.upscaleFactor,
        config: n
      };
      return await this.upscaleImageInternal(i);
    };
  }
  /**
   * Transforms the CallableTools in the parameters to be simply Tools, it
   * copies the params into a new object and replaces the tools, it does not
   * modify the original params. Also sets the MCP usage header if there are
   * MCP tools in the parameters.
   */
  async processParamsForMcpUsage(t) {
    var e, n, i;
    const o = (e = t.config) === null || e === void 0 ? void 0 : e.tools;
    if (!o)
      return t;
    const s = await Promise.all(o.map(async (l) => Tl(l) ? await l.tool() : l)), u = {
      model: t.model,
      contents: t.contents,
      config: Object.assign(Object.assign({}, t.config), { tools: s })
    };
    if (u.config.tools = s, t.config && t.config.tools && yT(t.config.tools)) {
      const l = (i = (n = t.config.httpOptions) === null || n === void 0 ? void 0 : n.headers) !== null && i !== void 0 ? i : {};
      let c = Object.assign({}, l);
      Object.keys(c).length === 0 && (c = this.apiClient.getDefaultHeaders()), vT(c), u.config.httpOptions = Object.assign(Object.assign({}, t.config.httpOptions), { headers: c });
    }
    return u;
  }
  async initAfcToolsMap(t) {
    var e, n, i;
    const o = /* @__PURE__ */ new Map();
    for (const s of (n = (e = t.config) === null || e === void 0 ? void 0 : e.tools) !== null && n !== void 0 ? n : [])
      if (Tl(s)) {
        const u = s, l = await u.tool();
        for (const c of (i = l.functionDeclarations) !== null && i !== void 0 ? i : []) {
          if (!c.name)
            throw new Error("Function declaration name is required.");
          if (o.has(c.name))
            throw new Error(`Duplicate tool declaration name: ${c.name}`);
          o.set(c.name, u);
        }
      }
    return o;
  }
  async processAfcStream(t) {
    var e, n, i;
    const o = (i = (n = (e = t.config) === null || e === void 0 ? void 0 : e.automaticFunctionCalling) === null || n === void 0 ? void 0 : n.maximumRemoteCalls) !== null && i !== void 0 ? i : Gv;
    let s = !1, u = 0;
    const l = await this.initAfcToolsMap(t);
    return function(c, d, g) {
      var y, w;
      return us(this, arguments, function* () {
        for (var b, _, C, m; u < o; ) {
          s && (u++, s = !1);
          const x = yield yt(c.processParamsForMcpUsage(g)), D = yield yt(c.generateContentStreamInternal(x)), U = [], O = [];
          try {
            for (var T = !0, S = (_ = void 0, bl(D)), A; A = yield yt(S.next()), b = A.done, !b; T = !0) {
              m = A.value, T = !1;
              const k = m;
              if (yield yield yt(k), k.candidates && (!((y = k.candidates[0]) === null || y === void 0) && y.content)) {
                O.push(k.candidates[0].content);
                for (const H of (w = k.candidates[0].content.parts) !== null && w !== void 0 ? w : [])
                  if (u < o && H.functionCall) {
                    if (!H.functionCall.name)
                      throw new Error("Function call name was not returned by the model.");
                    if (d.has(H.functionCall.name)) {
                      const V = yield yt(d.get(H.functionCall.name).callTool([H.functionCall]));
                      U.push(...V);
                    } else
                      throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${d.keys()}, mising tool: ${H.functionCall.name}`);
                  }
              }
            }
          } catch (k) {
            _ = { error: k };
          } finally {
            try {
              !T && !b && (C = S.return) && (yield yt(C.call(S)));
            } finally {
              if (_) throw _.error;
            }
          }
          if (U.length > 0) {
            s = !0;
            const k = new Wo();
            k.candidates = [
              {
                content: {
                  role: "user",
                  parts: U
                }
              }
            ], yield yield yt(k);
            const H = [];
            H.push(...O), H.push({
              role: "user",
              parts: U
            });
            const V = Pn(c.apiClient, g.contents).concat(H);
            g.contents = V;
          } else
            break;
        }
      });
    }(this, l, t);
  }
  async generateContentInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = $v(this.apiClient, t);
      return u = ke("{model}:generateContent", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = qv(this.apiClient, d), y = new Wo();
        return Object.assign(y, g), y;
      });
    } else {
      const c = Fv(this.apiClient, t);
      return u = ke("{model}:generateContent", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = Uv(this.apiClient, d), y = new Wo();
        return Object.assign(y, g), y;
      });
    }
  }
  async generateContentStreamInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = $v(this.apiClient, t);
      u = ke("{model}:streamGenerateContent?alt=sse", c._url), l = c._query, delete c.config, delete c._url, delete c._query;
      const d = this.apiClient;
      return s = d.requestStream({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }), s.then(function(g) {
        return us(this, arguments, function* () {
          var y, w, b, _;
          try {
            for (var C = !0, m = bl(g), T; T = yield yt(m.next()), y = T.done, !y; C = !0) {
              _ = T.value, C = !1;
              const A = qv(d, yield yt(_.json())), x = new Wo();
              Object.assign(x, A), yield yield yt(x);
            }
          } catch (S) {
            w = { error: S };
          } finally {
            try {
              !C && !y && (b = m.return) && (yield yt(b.call(m)));
            } finally {
              if (w) throw w.error;
            }
          }
        });
      });
    } else {
      const c = Fv(this.apiClient, t);
      u = ke("{model}:streamGenerateContent?alt=sse", c._url), l = c._query, delete c.config, delete c._url, delete c._query;
      const d = this.apiClient;
      return s = d.requestStream({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }), s.then(function(g) {
        return us(this, arguments, function* () {
          var y, w, b, _;
          try {
            for (var C = !0, m = bl(g), T; T = yield yt(m.next()), y = T.done, !y; C = !0) {
              _ = T.value, C = !1;
              const A = Uv(d, yield yt(_.json())), x = new Wo();
              Object.assign(x, A), yield yield yt(x);
            }
          } catch (S) {
            w = { error: S };
          } finally {
            try {
              !C && !y && (b = m.return) && (yield yt(b.call(m)));
            } finally {
              if (w) throw w.error;
            }
          }
        });
      });
    }
  }
  /**
   * Calculates embeddings for the given contents. Only text is supported.
   *
   * @param params - The parameters for embedding contents.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.embedContent({
   *  model: 'text-embedding-004',
   *  contents: [
   *    'What is your name?',
   *    'What is your favorite color?',
   *  ],
   *  config: {
   *    outputDimensionality: 64,
   *  },
   * });
   * console.log(response);
   * ```
   */
  async embedContent(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = XF(this.apiClient, t);
      return u = ke("{model}:predict", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = X$(this.apiClient, d), y = new yv();
        return Object.assign(y, g), y;
      });
    } else {
      const c = mF(this.apiClient, t);
      return u = ke("{model}:batchEmbedContents", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = P$(this.apiClient, d), y = new yv();
        return Object.assign(y, g), y;
      });
    }
  }
  /**
   * Generates an image based on a text description and configuration.
   *
   * @param params - The parameters for generating images.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateImages({
   *  model: 'imagen-3.0-generate-002',
   *  prompt: 'Robot holding a red skateboard',
   *  config: {
   *    numberOfImages: 1,
   *    includeRaiReason: true,
   *  },
   * });
   * console.log(response?.generatedImages?.[0]?.image?.imageBytes);
   * ```
   */
  async generateImagesInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = t$(this.apiClient, t);
      return u = ke("{model}:predict", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = tU(this.apiClient, d), y = new vv();
        return Object.assign(y, g), y;
      });
    } else {
      const c = yF(this.apiClient, t);
      return u = ke("{model}:predict", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = N$(this.apiClient, d), y = new vv();
        return Object.assign(y, g), y;
      });
    }
  }
  async editImageInternal(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI()) {
      const u = l$(this.apiClient, t);
      return o = ke("{model}:predict", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => {
        const c = nU(this.apiClient, l), d = new ML();
        return Object.assign(d, c), d;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  async upscaleImageInternal(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI()) {
      const u = c$(this.apiClient, t);
      return o = ke("{model}:predict", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => {
        const c = rU(this.apiClient, l), d = new kL();
        return Object.assign(d, c), d;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  /**
   * Fetches information about a model by name.
   *
   * @example
   * ```ts
   * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
   * ```
   */
  async get(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = f$(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => Ih(this.apiClient, d));
    } else {
      const c = vF(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => Rh(this.apiClient, d));
    }
  }
  async listInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = h$(this.apiClient, t);
      return u = ke("{models_url}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = aU(this.apiClient, d), y = new _v();
        return Object.assign(y, g), y;
      });
    } else {
      const c = wF(this.apiClient, t);
      return u = ke("{models_url}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = F$(this.apiClient, d), y = new _v();
        return Object.assign(y, g), y;
      });
    }
  }
  /**
   * Updates a tuned model by its name.
   *
   * @param params - The parameters for updating the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.update({
   *   model: 'tuned-model-name',
   *   config: {
   *     displayName: 'New display name',
   *     description: 'New description',
   *   },
   * });
   * ```
   */
  async update(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = m$(this.apiClient, t);
      return u = ke("{model}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "PATCH",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => Ih(this.apiClient, d));
    } else {
      const c = TF(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "PATCH",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => Rh(this.apiClient, d));
    }
  }
  /**
   * Deletes a tuned model by its name.
   *
   * @param params - The parameters for deleting the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.delete({model: 'tuned-model-name'});
   * ```
   */
  async delete(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = g$(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "DELETE",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then(() => {
        const d = lU(), g = new wv();
        return Object.assign(g, d), g;
      });
    } else {
      const c = CF(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "DELETE",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then(() => {
        const d = $$(), g = new wv();
        return Object.assign(g, d), g;
      });
    }
  }
  /**
   * Counts the number of tokens in the given contents. Multimodal input is
   * supported for Gemini models.
   *
   * @param params - The parameters for counting tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.countTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'The quick brown fox jumps over the lazy dog.'
   * });
   * console.log(response);
   * ```
   */
  async countTokens(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = v$(this.apiClient, t);
      return u = ke("{model}:countTokens", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = uU(this.apiClient, d), y = new bv();
        return Object.assign(y, g), y;
      });
    } else {
      const c = EF(this.apiClient, t);
      return u = ke("{model}:countTokens", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = U$(this.apiClient, d), y = new bv();
        return Object.assign(y, g), y;
      });
    }
  }
  /**
   * Given a list of contents, returns a corresponding TokensInfo containing
   * the list of tokens and list of token ids.
   *
   * This method is not supported by the Gemini Developer API.
   *
   * @param params - The parameters for computing tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.computeTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'What is your name?'
   * });
   * console.log(response);
   * ```
   */
  async computeTokens(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI()) {
      const u = _$(this.apiClient, t);
      return o = ke("{model}:computeTokens", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => {
        const c = cU(this.apiClient, l), d = new PL();
        return Object.assign(d, c), d;
      });
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  /**
   *  Generates videos based on a text description and configuration.
   *
   * @param params - The parameters for generating videos.
   * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.
   *
   * @example
   * ```ts
   * const operation = await ai.models.generateVideos({
   *  model: 'veo-2.0-generate-001',
   *  prompt: 'A neon hologram of a cat driving at top speed',
   *  config: {
   *    numberOfVideos: 1
   * });
   *
   * while (!operation.done) {
   *   await new Promise(resolve => setTimeout(resolve, 10000));
   *   operation = await ai.operations.getVideosOperation({operation: operation});
   * }
   *
   * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);
   * ```
   */
  async generateVideos(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = b$(this.apiClient, t);
      return u = ke("{model}:predictLongRunning", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => pU(this.apiClient, d));
    } else {
      const c = RF(this.apiClient, t);
      return u = ke("{model}:predictLongRunning", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "POST",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => H$(this.apiClient, d));
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function $U(r, t) {
  const e = {}, n = h(t, [
    "operationName"
  ]);
  n != null && p(e, ["_url", "operationName"], n);
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function UU(r, t) {
  const e = {}, n = h(t, [
    "operationName"
  ]);
  n != null && p(e, ["_url", "operationName"], n);
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function qU(r, t) {
  const e = {}, n = h(t, [
    "operationName"
  ]);
  n != null && p(e, ["operationName"], n);
  const i = h(t, ["resourceName"]);
  i != null && p(e, ["_url", "resourceName"], i);
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], o), e;
}
function BU(r, t) {
  const e = {}, n = h(t, ["video", "uri"]);
  n != null && p(e, ["uri"], n);
  const i = h(t, [
    "video",
    "encodedVideo"
  ]);
  i != null && p(e, ["videoBytes"], Jr(r, i));
  const o = h(t, ["encoding"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function VU(r, t) {
  const e = {}, n = h(t, ["_self"]);
  return n != null && p(e, ["video"], BU(r, n)), e;
}
function HU(r, t) {
  const e = {}, n = h(t, [
    "generatedSamples"
  ]);
  if (n != null) {
    let s = n;
    Array.isArray(s) && (s = s.map((u) => VU(r, u))), p(e, ["generatedVideos"], s);
  }
  const i = h(t, [
    "raiMediaFilteredCount"
  ]);
  i != null && p(e, ["raiMediaFilteredCount"], i);
  const o = h(t, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && p(e, ["raiMediaFilteredReasons"], o), e;
}
function GU(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["metadata"]);
  i != null && p(e, ["metadata"], i);
  const o = h(t, ["done"]);
  o != null && p(e, ["done"], o);
  const s = h(t, ["error"]);
  s != null && p(e, ["error"], s);
  const u = h(t, [
    "response",
    "generateVideoResponse"
  ]);
  return u != null && p(e, ["response"], HU(r, u)), e;
}
function WU(r, t) {
  const e = {}, n = h(t, ["gcsUri"]);
  n != null && p(e, ["uri"], n);
  const i = h(t, [
    "bytesBase64Encoded"
  ]);
  i != null && p(e, ["videoBytes"], Jr(r, i));
  const o = h(t, ["mimeType"]);
  return o != null && p(e, ["mimeType"], o), e;
}
function KU(r, t) {
  const e = {}, n = h(t, ["_self"]);
  return n != null && p(e, ["video"], WU(r, n)), e;
}
function JU(r, t) {
  const e = {}, n = h(t, ["videos"]);
  if (n != null) {
    let s = n;
    Array.isArray(s) && (s = s.map((u) => KU(r, u))), p(e, ["generatedVideos"], s);
  }
  const i = h(t, [
    "raiMediaFilteredCount"
  ]);
  i != null && p(e, ["raiMediaFilteredCount"], i);
  const o = h(t, [
    "raiMediaFilteredReasons"
  ]);
  return o != null && p(e, ["raiMediaFilteredReasons"], o), e;
}
function Jv(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["metadata"]);
  i != null && p(e, ["metadata"], i);
  const o = h(t, ["done"]);
  o != null && p(e, ["done"], o);
  const s = h(t, ["error"]);
  s != null && p(e, ["error"], s);
  const u = h(t, ["response"]);
  return u != null && p(e, ["response"], JU(r, u)), e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class zU extends Cs {
  constructor(t) {
    super(), this.apiClient = t;
  }
  /**
   * Gets the status of a long-running operation.
   *
   * @param parameters The parameters for the get operation request.
   * @return The updated Operation object, with the latest status or result.
   */
  async getVideosOperation(t) {
    const e = t.operation, n = t.config;
    if (e.name === void 0 || e.name === "")
      throw new Error("Operation name is required.");
    if (this.apiClient.isVertexAI()) {
      const i = e.name.split("/operations/")[0];
      let o;
      return n && "httpOptions" in n && (o = n.httpOptions), this.fetchPredictVideosOperationInternal({
        operationName: e.name,
        resourceName: i,
        config: { httpOptions: o }
      });
    } else
      return this.getVideosOperationInternal({
        operationName: e.name,
        config: n
      });
  }
  async getVideosOperationInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = UU(this.apiClient, t);
      return u = ke("{operationName}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => Jv(this.apiClient, d));
    } else {
      const c = $U(this.apiClient, t);
      return u = ke("{operationName}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => GU(this.apiClient, d));
    }
  }
  async fetchPredictVideosOperationInternal(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI()) {
      const u = qU(this.apiClient, t);
      return o = ke("{resourceName}:fetchPredictOperation", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => Jv(this.apiClient, l));
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function YU(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], n);
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function ZU(r, t, e) {
  const n = {}, i = h(t, ["pageSize"]);
  e !== void 0 && i != null && p(e, ["_query", "pageSize"], i);
  const o = h(t, ["pageToken"]);
  e !== void 0 && o != null && p(e, ["_query", "pageToken"], o);
  const s = h(t, ["filter"]);
  return e !== void 0 && s != null && p(e, ["_query", "filter"], s), n;
}
function jU(r, t) {
  const e = {}, n = h(t, ["config"]);
  return n != null && p(e, ["config"], ZU(r, n, e)), e;
}
function QU(r, t) {
  const e = {}, n = h(t, ["textInput"]);
  n != null && p(e, ["textInput"], n);
  const i = h(t, ["output"]);
  return i != null && p(e, ["output"], i), e;
}
function XU(r, t) {
  const e = {};
  if (h(t, ["gcsUri"]) !== void 0)
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  const n = h(t, ["examples"]);
  if (n != null) {
    let i = n;
    Array.isArray(i) && (i = i.map((o) => QU(r, o))), p(e, ["examples", "examples"], i);
  }
  return e;
}
function eq(r, t, e) {
  const n = {};
  if (h(t, ["validationDataset"]) !== void 0)
    throw new Error("validationDataset parameter is not supported in Gemini API.");
  const i = h(t, [
    "tunedModelDisplayName"
  ]);
  if (e !== void 0 && i != null && p(e, ["displayName"], i), h(t, ["description"]) !== void 0)
    throw new Error("description parameter is not supported in Gemini API.");
  const o = h(t, ["epochCount"]);
  e !== void 0 && o != null && p(e, ["tuningTask", "hyperparameters", "epochCount"], o);
  const s = h(t, [
    "learningRateMultiplier"
  ]);
  if (s != null && p(n, ["tuningTask", "hyperparameters", "learningRateMultiplier"], s), h(t, ["exportLastCheckpointOnly"]) !== void 0)
    throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
  if (h(t, ["adapterSize"]) !== void 0)
    throw new Error("adapterSize parameter is not supported in Gemini API.");
  const u = h(t, ["batchSize"]);
  e !== void 0 && u != null && p(e, ["tuningTask", "hyperparameters", "batchSize"], u);
  const l = h(t, ["learningRate"]);
  return e !== void 0 && l != null && p(e, ["tuningTask", "hyperparameters", "learningRate"], l), n;
}
function tq(r, t) {
  const e = {}, n = h(t, ["baseModel"]);
  n != null && p(e, ["baseModel"], n);
  const i = h(t, [
    "trainingDataset"
  ]);
  i != null && p(e, ["tuningTask", "trainingData"], XU(r, i));
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], eq(r, o, e)), e;
}
function nq(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["_url", "name"], n);
  const i = h(t, ["config"]);
  return i != null && p(e, ["config"], i), e;
}
function rq(r, t, e) {
  const n = {}, i = h(t, ["pageSize"]);
  e !== void 0 && i != null && p(e, ["_query", "pageSize"], i);
  const o = h(t, ["pageToken"]);
  e !== void 0 && o != null && p(e, ["_query", "pageToken"], o);
  const s = h(t, ["filter"]);
  return e !== void 0 && s != null && p(e, ["_query", "filter"], s), n;
}
function iq(r, t) {
  const e = {}, n = h(t, ["config"]);
  return n != null && p(e, ["config"], rq(r, n, e)), e;
}
function oq(r, t, e) {
  const n = {}, i = h(t, ["gcsUri"]);
  if (e !== void 0 && i != null && p(e, ["supervisedTuningSpec", "trainingDatasetUri"], i), h(t, ["examples"]) !== void 0)
    throw new Error("examples parameter is not supported in Vertex AI.");
  return n;
}
function sq(r, t) {
  const e = {}, n = h(t, ["gcsUri"]);
  return n != null && p(e, ["validationDatasetUri"], n), e;
}
function aq(r, t, e) {
  const n = {}, i = h(t, [
    "validationDataset"
  ]);
  e !== void 0 && i != null && p(e, ["supervisedTuningSpec"], sq(r, i));
  const o = h(t, [
    "tunedModelDisplayName"
  ]);
  e !== void 0 && o != null && p(e, ["tunedModelDisplayName"], o);
  const s = h(t, ["description"]);
  e !== void 0 && s != null && p(e, ["description"], s);
  const u = h(t, ["epochCount"]);
  e !== void 0 && u != null && p(e, ["supervisedTuningSpec", "hyperParameters", "epochCount"], u);
  const l = h(t, [
    "learningRateMultiplier"
  ]);
  e !== void 0 && l != null && p(e, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], l);
  const c = h(t, [
    "exportLastCheckpointOnly"
  ]);
  e !== void 0 && c != null && p(e, ["supervisedTuningSpec", "exportLastCheckpointOnly"], c);
  const d = h(t, ["adapterSize"]);
  if (e !== void 0 && d != null && p(e, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], d), h(t, ["batchSize"]) !== void 0)
    throw new Error("batchSize parameter is not supported in Vertex AI.");
  if (h(t, ["learningRate"]) !== void 0)
    throw new Error("learningRate parameter is not supported in Vertex AI.");
  return n;
}
function lq(r, t) {
  const e = {}, n = h(t, ["baseModel"]);
  n != null && p(e, ["baseModel"], n);
  const i = h(t, [
    "trainingDataset"
  ]);
  i != null && p(e, ["supervisedTuningSpec", "trainingDatasetUri"], oq(r, i, e));
  const o = h(t, ["config"]);
  return o != null && p(e, ["config"], aq(r, o, e)), e;
}
function uq(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["model"], n);
  const i = h(t, ["name"]);
  return i != null && p(e, ["endpoint"], i), e;
}
function _T(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["state"]);
  i != null && p(e, ["state"], nT(r, i));
  const o = h(t, ["createTime"]);
  o != null && p(e, ["createTime"], o);
  const s = h(t, [
    "tuningTask",
    "startTime"
  ]);
  s != null && p(e, ["startTime"], s);
  const u = h(t, [
    "tuningTask",
    "completeTime"
  ]);
  u != null && p(e, ["endTime"], u);
  const l = h(t, ["updateTime"]);
  l != null && p(e, ["updateTime"], l);
  const c = h(t, ["description"]);
  c != null && p(e, ["description"], c);
  const d = h(t, ["baseModel"]);
  d != null && p(e, ["baseModel"], d);
  const g = h(t, ["_self"]);
  g != null && p(e, ["tunedModel"], uq(r, g));
  const y = h(t, [
    "distillationSpec"
  ]);
  y != null && p(e, ["distillationSpec"], y);
  const w = h(t, ["experiment"]);
  w != null && p(e, ["experiment"], w);
  const b = h(t, ["labels"]);
  b != null && p(e, ["labels"], b);
  const _ = h(t, ["pipelineJob"]);
  _ != null && p(e, ["pipelineJob"], _);
  const C = h(t, [
    "tunedModelDisplayName"
  ]);
  return C != null && p(e, ["tunedModelDisplayName"], C), e;
}
function cq(r, t) {
  const e = {}, n = h(t, [
    "nextPageToken"
  ]);
  n != null && p(e, ["nextPageToken"], n);
  const i = h(t, ["tunedModels"]);
  if (i != null) {
    let o = i;
    Array.isArray(o) && (o = o.map((s) => _T(r, s))), p(e, ["tuningJobs"], o);
  }
  return e;
}
function fq(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["metadata"]);
  i != null && p(e, ["metadata"], i);
  const o = h(t, ["done"]);
  o != null && p(e, ["done"], o);
  const s = h(t, ["error"]);
  return s != null && p(e, ["error"], s), e;
}
function dq(r, t) {
  const e = {}, n = h(t, ["checkpointId"]);
  n != null && p(e, ["checkpointId"], n);
  const i = h(t, ["epoch"]);
  i != null && p(e, ["epoch"], i);
  const o = h(t, ["step"]);
  o != null && p(e, ["step"], o);
  const s = h(t, ["endpoint"]);
  return s != null && p(e, ["endpoint"], s), e;
}
function hq(r, t) {
  const e = {}, n = h(t, ["model"]);
  n != null && p(e, ["model"], n);
  const i = h(t, ["endpoint"]);
  i != null && p(e, ["endpoint"], i);
  const o = h(t, ["checkpoints"]);
  if (o != null) {
    let s = o;
    Array.isArray(s) && (s = s.map((u) => dq(r, u))), p(e, ["checkpoints"], s);
  }
  return e;
}
function Ph(r, t) {
  const e = {}, n = h(t, ["name"]);
  n != null && p(e, ["name"], n);
  const i = h(t, ["state"]);
  i != null && p(e, ["state"], nT(r, i));
  const o = h(t, ["createTime"]);
  o != null && p(e, ["createTime"], o);
  const s = h(t, ["startTime"]);
  s != null && p(e, ["startTime"], s);
  const u = h(t, ["endTime"]);
  u != null && p(e, ["endTime"], u);
  const l = h(t, ["updateTime"]);
  l != null && p(e, ["updateTime"], l);
  const c = h(t, ["error"]);
  c != null && p(e, ["error"], c);
  const d = h(t, ["description"]);
  d != null && p(e, ["description"], d);
  const g = h(t, ["baseModel"]);
  g != null && p(e, ["baseModel"], g);
  const y = h(t, ["tunedModel"]);
  y != null && p(e, ["tunedModel"], hq(r, y));
  const w = h(t, [
    "supervisedTuningSpec"
  ]);
  w != null && p(e, ["supervisedTuningSpec"], w);
  const b = h(t, [
    "tuningDataStats"
  ]);
  b != null && p(e, ["tuningDataStats"], b);
  const _ = h(t, [
    "encryptionSpec"
  ]);
  _ != null && p(e, ["encryptionSpec"], _);
  const C = h(t, [
    "partnerModelTuningSpec"
  ]);
  C != null && p(e, ["partnerModelTuningSpec"], C);
  const m = h(t, [
    "distillationSpec"
  ]);
  m != null && p(e, ["distillationSpec"], m);
  const T = h(t, ["experiment"]);
  T != null && p(e, ["experiment"], T);
  const S = h(t, ["labels"]);
  S != null && p(e, ["labels"], S);
  const A = h(t, ["pipelineJob"]);
  A != null && p(e, ["pipelineJob"], A);
  const x = h(t, [
    "tunedModelDisplayName"
  ]);
  return x != null && p(e, ["tunedModelDisplayName"], x), e;
}
function pq(r, t) {
  const e = {}, n = h(t, [
    "nextPageToken"
  ]);
  n != null && p(e, ["nextPageToken"], n);
  const i = h(t, ["tuningJobs"]);
  if (i != null) {
    let o = i;
    Array.isArray(o) && (o = o.map((s) => Ph(r, s))), p(e, ["tuningJobs"], o);
  }
  return e;
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class mq extends Cs {
  constructor(t) {
    super(), this.apiClient = t, this.get = async (e) => await this.getInternal(e), this.list = async (e = {}) => new hu(po.PAGED_ITEM_TUNING_JOBS, (n) => this.listInternal(n), await this.listInternal(e), e), this.tune = async (e) => {
      if (this.apiClient.isVertexAI())
        return await this.tuneInternal(e);
      {
        const n = await this.tuneMldevInternal(e);
        let i = "";
        return n.metadata !== void 0 && n.metadata.tunedModel !== void 0 ? i = n.metadata.tunedModel : n.name !== void 0 && n.name.includes("/operations/") && (i = n.name.split("/operations/")[0]), {
          name: i,
          state: Ch.JOB_STATE_QUEUED
        };
      }
    };
  }
  async getInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = nq(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => Ph(this.apiClient, d));
    } else {
      const c = YU(this.apiClient, t);
      return u = ke("{name}", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => _T(this.apiClient, d));
    }
  }
  async listInternal(t) {
    var e, n, i, o;
    let s, u = "", l = {};
    if (this.apiClient.isVertexAI()) {
      const c = iq(this.apiClient, t);
      return u = ke("tuningJobs", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = pq(this.apiClient, d), y = new Tv();
        return Object.assign(y, g), y;
      });
    } else {
      const c = jU(this.apiClient, t);
      return u = ke("tunedModels", c._url), l = c._query, delete c.config, delete c._url, delete c._query, s = this.apiClient.request({
        path: u,
        queryParams: l,
        body: JSON.stringify(c),
        httpMethod: "GET",
        httpOptions: (i = t.config) === null || i === void 0 ? void 0 : i.httpOptions,
        abortSignal: (o = t.config) === null || o === void 0 ? void 0 : o.abortSignal
      }).then((d) => d.json()), s.then((d) => {
        const g = cq(this.apiClient, d), y = new Tv();
        return Object.assign(y, g), y;
      });
    }
  }
  async tuneInternal(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI()) {
      const u = lq(this.apiClient, t);
      return o = ke("tuningJobs", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => Ph(this.apiClient, l));
    } else
      throw new Error("This method is only supported by the Vertex AI.");
  }
  async tuneMldevInternal(t) {
    var e, n;
    let i, o = "", s = {};
    if (this.apiClient.isVertexAI())
      throw new Error("This method is only supported by the Gemini Developer API.");
    {
      const u = tq(this.apiClient, t);
      return o = ke("tunedModels", u._url), s = u._query, delete u.config, delete u._url, delete u._query, i = this.apiClient.request({
        path: o,
        queryParams: s,
        body: JSON.stringify(u),
        httpMethod: "POST",
        httpOptions: (e = t.config) === null || e === void 0 ? void 0 : e.httpOptions,
        abortSignal: (n = t.config) === null || n === void 0 ? void 0 : n.abortSignal
      }).then((l) => l.json()), i.then((l) => fq(this.apiClient, l));
    }
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class gq {
  async download(t, e) {
    throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
  }
}
const yq = 1024 * 1024 * 8, vq = 3, _q = 1e3, wq = 2, sf = "x-goog-upload-status";
async function bq(r, t, e) {
  var n, i, o;
  let s = 0, u = 0, l = new Sh(new Response()), c = "upload";
  for (s = r.size; u < s; ) {
    const g = Math.min(yq, s - u), y = r.slice(u, u + g);
    u + g >= s && (c += ", finalize");
    let w = 0, b = _q;
    for (; w < vq && (l = await e.request({
      path: "",
      body: y,
      httpMethod: "POST",
      httpOptions: {
        apiVersion: "",
        baseUrl: t,
        headers: {
          "X-Goog-Upload-Command": c,
          "X-Goog-Upload-Offset": String(u),
          "Content-Length": String(g)
        }
      }
    }), !(!((n = l?.headers) === null || n === void 0) && n[sf])); )
      w++, await Cq(b), b = b * wq;
    if (u += g, ((i = l?.headers) === null || i === void 0 ? void 0 : i[sf]) !== "active")
      break;
    if (s <= u)
      throw new Error("All content has been uploaded, but the upload status is not finalized.");
  }
  const d = await l?.json();
  if (((o = l?.headers) === null || o === void 0 ? void 0 : o[sf]) !== "final")
    throw new Error("Failed to upload file: Upload status is not finalized.");
  return d.file;
}
async function Tq(r) {
  return { size: r.size, type: r.type };
}
function Cq(r) {
  return new Promise((t) => setTimeout(t, r));
}
class Sq {
  async upload(t, e, n) {
    if (typeof t == "string")
      throw new Error("File path is not supported in browser uploader.");
    return await bq(t, e, n);
  }
  async stat(t) {
    if (typeof t == "string")
      throw new Error("File path is not supported in browser uploader.");
    return await Tq(t);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Eq {
  create(t, e, n) {
    return new Aq(t, e, n);
  }
}
class Aq {
  constructor(t, e, n) {
    this.url = t, this.headers = e, this.callbacks = n;
  }
  connect() {
    this.ws = new WebSocket(this.url), this.ws.onopen = this.callbacks.onopen, this.ws.onerror = this.callbacks.onerror, this.ws.onclose = this.callbacks.onclose, this.ws.onmessage = this.callbacks.onmessage;
  }
  send(t) {
    if (this.ws === void 0)
      throw new Error("WebSocket is not connected");
    this.ws.send(t);
  }
  close() {
    if (this.ws === void 0)
      throw new Error("WebSocket is not connected");
    this.ws.close();
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const zv = "x-goog-api-key";
class xq {
  constructor(t) {
    this.apiKey = t;
  }
  async addAuthHeaders(t) {
    t.get(zv) === null && t.append(zv, this.apiKey);
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Rq = "gl-node/";
class Iq {
  constructor(t) {
    var e;
    if (t.apiKey == null)
      throw new Error("An API Key must be set when running in a browser");
    if (t.project || t.location)
      throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
    this.vertexai = (e = t.vertexai) !== null && e !== void 0 ? e : !1, this.apiKey = t.apiKey;
    const n = IL(
      t,
      /*vertexBaseUrlFromEnv*/
      void 0,
      /*geminiBaseUrlFromEnv*/
      void 0
    );
    n && (t.httpOptions ? t.httpOptions.baseUrl = n : t.httpOptions = { baseUrl: n }), this.apiVersion = t.apiVersion;
    const i = new xq(this.apiKey);
    this.apiClient = new TU({
      auth: i,
      apiVersion: this.apiVersion,
      apiKey: this.apiKey,
      vertexai: this.vertexai,
      httpOptions: t.httpOptions,
      userAgentExtra: Rq + "web",
      uploader: new Sq(),
      downloader: new gq()
    }), this.models = new FU(this.apiClient), this.live = new PU(this.apiClient, i, new Eq()), this.chats = new zN(this.models, this.apiClient), this.caches = new WN(this.apiClient), this.files = new aD(this.apiClient), this.operations = new zU(this.apiClient), this.tunings = new mq(this.apiClient);
  }
}
var ns = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var Mq = ns.exports, Yv;
function kq() {
  return Yv || (Yv = 1, function(r, t) {
    (function() {
      var e, n = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", u = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", c = 500, d = "__lodash_placeholder__", g = 1, y = 2, w = 4, b = 1, _ = 2, C = 1, m = 2, T = 4, S = 8, A = 16, x = 32, D = 64, U = 128, O = 256, k = 512, H = 30, V = "...", N = 800, $ = 16, j = 1, K = 2, P = 3, I = 1 / 0, B = 9007199254740991, W = 17976931348623157e292, z = NaN, ee = 4294967295, ne = ee - 1, ce = ee >>> 1, te = [
        ["ary", U],
        ["bind", C],
        ["bindKey", m],
        ["curry", S],
        ["curryRight", A],
        ["flip", k],
        ["partial", x],
        ["partialRight", D],
        ["rearg", O]
      ], fe = "[object Arguments]", Y = "[object Array]", Z = "[object AsyncFunction]", ie = "[object Boolean]", me = "[object Date]", Ce = "[object DOMException]", F = "[object Error]", q = "[object Function]", de = "[object GeneratorFunction]", ye = "[object Map]", nt = "[object Number]", $e = "[object Null]", Ve = "[object Object]", Sn = "[object Promise]", Si = "[object Proxy]", yr = "[object RegExp]", jt = "[object Set]", vr = "[object String]", _r = "[object Symbol]", Ro = "[object Undefined]", Yn = "[object WeakMap]", zr = "[object WeakSet]", fn = "[object ArrayBuffer]", Qt = "[object DataView]", Lu = "[object Float32Array]", Nu = "[object Float64Array]", Du = "[object Int8Array]", Fu = "[object Int16Array]", $u = "[object Int32Array]", Uu = "[object Uint8Array]", qu = "[object Uint8ClampedArray]", Bu = "[object Uint16Array]", Vu = "[object Uint32Array]", lS = /\b__p \+= '';/g, uS = /\b(__p \+=) '' \+/g, cS = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Bp = /&(?:amp|lt|gt|quot|#39);/g, Vp = /[&<>"']/g, fS = RegExp(Bp.source), dS = RegExp(Vp.source), hS = /<%-([\s\S]+?)%>/g, pS = /<%([\s\S]+?)%>/g, Hp = /<%=([\s\S]+?)%>/g, mS = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, gS = /^\w*$/, yS = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Hu = /[\\^$.*+?()[\]{}|]/g, vS = RegExp(Hu.source), Gu = /^\s+/, _S = /\s/, wS = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, bS = /\{\n\/\* \[wrapped with (.+)\] \*/, TS = /,? & /, CS = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, SS = /[()=,{}\[\]\/\s]/, ES = /\\(\\)?/g, AS = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Gp = /\w*$/, xS = /^[-+]0x[0-9a-f]+$/i, RS = /^0b[01]+$/i, IS = /^\[object .+?Constructor\]$/, MS = /^0o[0-7]+$/i, kS = /^(?:0|[1-9]\d*)$/, PS = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ps = /($^)/, OS = /['\n\r\u2028\u2029\\]/g, Os = "\\ud800-\\udfff", LS = "\\u0300-\\u036f", NS = "\\ufe20-\\ufe2f", DS = "\\u20d0-\\u20ff", Wp = LS + NS + DS, Kp = "\\u2700-\\u27bf", Jp = "a-z\\xdf-\\xf6\\xf8-\\xff", FS = "\\xac\\xb1\\xd7\\xf7", $S = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", US = "\\u2000-\\u206f", qS = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", zp = "A-Z\\xc0-\\xd6\\xd8-\\xde", Yp = "\\ufe0e\\ufe0f", Zp = FS + $S + US + qS, Wu = "[']", BS = "[" + Os + "]", jp = "[" + Zp + "]", Ls = "[" + Wp + "]", Qp = "\\d+", VS = "[" + Kp + "]", Xp = "[" + Jp + "]", em = "[^" + Os + Zp + Qp + Kp + Jp + zp + "]", Ku = "\\ud83c[\\udffb-\\udfff]", HS = "(?:" + Ls + "|" + Ku + ")", tm = "[^" + Os + "]", Ju = "(?:\\ud83c[\\udde6-\\uddff]){2}", zu = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ei = "[" + zp + "]", nm = "\\u200d", rm = "(?:" + Xp + "|" + em + ")", GS = "(?:" + Ei + "|" + em + ")", im = "(?:" + Wu + "(?:d|ll|m|re|s|t|ve))?", om = "(?:" + Wu + "(?:D|LL|M|RE|S|T|VE))?", sm = HS + "?", am = "[" + Yp + "]?", WS = "(?:" + nm + "(?:" + [tm, Ju, zu].join("|") + ")" + am + sm + ")*", KS = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", JS = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", lm = am + sm + WS, zS = "(?:" + [VS, Ju, zu].join("|") + ")" + lm, YS = "(?:" + [tm + Ls + "?", Ls, Ju, zu, BS].join("|") + ")", ZS = RegExp(Wu, "g"), jS = RegExp(Ls, "g"), Yu = RegExp(Ku + "(?=" + Ku + ")|" + YS + lm, "g"), QS = RegExp([
        Ei + "?" + Xp + "+" + im + "(?=" + [jp, Ei, "$"].join("|") + ")",
        GS + "+" + om + "(?=" + [jp, Ei + rm, "$"].join("|") + ")",
        Ei + "?" + rm + "+" + im,
        Ei + "+" + om,
        JS,
        KS,
        Qp,
        zS
      ].join("|"), "g"), XS = RegExp("[" + nm + Os + Wp + Yp + "]"), eE = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, tE = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], nE = -1, ft = {};
      ft[Lu] = ft[Nu] = ft[Du] = ft[Fu] = ft[$u] = ft[Uu] = ft[qu] = ft[Bu] = ft[Vu] = !0, ft[fe] = ft[Y] = ft[fn] = ft[ie] = ft[Qt] = ft[me] = ft[F] = ft[q] = ft[ye] = ft[nt] = ft[Ve] = ft[yr] = ft[jt] = ft[vr] = ft[Yn] = !1;
      var ct = {};
      ct[fe] = ct[Y] = ct[fn] = ct[Qt] = ct[ie] = ct[me] = ct[Lu] = ct[Nu] = ct[Du] = ct[Fu] = ct[$u] = ct[ye] = ct[nt] = ct[Ve] = ct[yr] = ct[jt] = ct[vr] = ct[_r] = ct[Uu] = ct[qu] = ct[Bu] = ct[Vu] = !0, ct[F] = ct[q] = ct[Yn] = !1;
      var rE = {
        // Latin-1 Supplement block.
        : "A",
        : "A",
        : "A",
        : "A",
        : "A",
        : "A",
        : "a",
        : "a",
        : "a",
        : "a",
        : "a",
        : "a",
        : "C",
        : "c",
        : "D",
        : "d",
        : "E",
        : "E",
        : "E",
        : "E",
        : "e",
        : "e",
        : "e",
        : "e",
        : "I",
        : "I",
        : "I",
        : "I",
        : "i",
        : "i",
        : "i",
        : "i",
        : "N",
        : "n",
        : "O",
        : "O",
        : "O",
        : "O",
        : "O",
        : "O",
        : "o",
        : "o",
        : "o",
        : "o",
        : "o",
        : "o",
        : "U",
        : "U",
        : "U",
        : "U",
        : "u",
        : "u",
        : "u",
        : "u",
        : "Y",
        : "y",
        : "y",
        : "Ae",
        : "ae",
        : "Th",
        : "th",
        : "ss",
        // Latin Extended-A block.
        : "A",
        : "A",
        : "A",
        : "a",
        : "a",
        : "a",
        : "C",
        : "C",
        : "C",
        : "C",
        : "c",
        : "c",
        : "c",
        : "c",
        : "D",
        : "D",
        : "d",
        : "d",
        : "E",
        : "E",
        : "E",
        : "E",
        : "E",
        : "e",
        : "e",
        : "e",
        : "e",
        : "e",
        : "G",
        : "G",
        : "G",
        : "G",
        : "g",
        : "g",
        : "g",
        : "g",
        : "H",
        : "H",
        : "h",
        : "h",
        : "I",
        : "I",
        : "I",
        : "I",
        : "I",
        : "i",
        : "i",
        : "i",
        : "i",
        : "i",
        : "J",
        : "j",
        : "K",
        : "k",
        : "k",
        : "L",
        : "L",
        : "L",
        : "L",
        : "L",
        : "l",
        : "l",
        : "l",
        : "l",
        : "l",
        : "N",
        : "N",
        : "N",
        : "N",
        : "n",
        : "n",
        : "n",
        : "n",
        : "O",
        : "O",
        : "O",
        : "o",
        : "o",
        : "o",
        : "R",
        : "R",
        : "R",
        : "r",
        : "r",
        : "r",
        : "S",
        : "S",
        : "S",
        : "S",
        : "s",
        : "s",
        : "s",
        : "s",
        : "T",
        : "T",
        : "T",
        : "t",
        : "t",
        : "t",
        : "U",
        : "U",
        : "U",
        : "U",
        : "U",
        : "U",
        : "u",
        : "u",
        : "u",
        : "u",
        : "u",
        : "u",
        : "W",
        : "w",
        : "Y",
        : "y",
        : "Y",
        : "Z",
        : "Z",
        : "Z",
        : "z",
        : "z",
        : "z",
        : "IJ",
        : "ij",
        : "Oe",
        : "oe",
        : "'n",
        : "s"
      }, iE = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, oE = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, sE = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, aE = parseFloat, lE = parseInt, um = typeof qn == "object" && qn && qn.Object === Object && qn, uE = typeof self == "object" && self && self.Object === Object && self, Mt = um || uE || Function("return this")(), Zu = t && !t.nodeType && t, Yr = Zu && !0 && r && !r.nodeType && r, cm = Yr && Yr.exports === Zu, ju = cm && um.process, dn = function() {
        try {
          var Q = Yr && Yr.require && Yr.require("util").types;
          return Q || ju && ju.binding && ju.binding("util");
        } catch {
        }
      }(), fm = dn && dn.isArrayBuffer, dm = dn && dn.isDate, hm = dn && dn.isMap, pm = dn && dn.isRegExp, mm = dn && dn.isSet, gm = dn && dn.isTypedArray;
      function Xt(Q, se, re) {
        switch (re.length) {
          case 0:
            return Q.call(se);
          case 1:
            return Q.call(se, re[0]);
          case 2:
            return Q.call(se, re[0], re[1]);
          case 3:
            return Q.call(se, re[0], re[1], re[2]);
        }
        return Q.apply(se, re);
      }
      function cE(Q, se, re, we) {
        for (var Le = -1, et = Q == null ? 0 : Q.length; ++Le < et; ) {
          var Et = Q[Le];
          se(we, Et, re(Et), Q);
        }
        return we;
      }
      function hn(Q, se) {
        for (var re = -1, we = Q == null ? 0 : Q.length; ++re < we && se(Q[re], re, Q) !== !1; )
          ;
        return Q;
      }
      function fE(Q, se) {
        for (var re = Q == null ? 0 : Q.length; re-- && se(Q[re], re, Q) !== !1; )
          ;
        return Q;
      }
      function ym(Q, se) {
        for (var re = -1, we = Q == null ? 0 : Q.length; ++re < we; )
          if (!se(Q[re], re, Q))
            return !1;
        return !0;
      }
      function wr(Q, se) {
        for (var re = -1, we = Q == null ? 0 : Q.length, Le = 0, et = []; ++re < we; ) {
          var Et = Q[re];
          se(Et, re, Q) && (et[Le++] = Et);
        }
        return et;
      }
      function Ns(Q, se) {
        var re = Q == null ? 0 : Q.length;
        return !!re && Ai(Q, se, 0) > -1;
      }
      function Qu(Q, se, re) {
        for (var we = -1, Le = Q == null ? 0 : Q.length; ++we < Le; )
          if (re(se, Q[we]))
            return !0;
        return !1;
      }
      function ht(Q, se) {
        for (var re = -1, we = Q == null ? 0 : Q.length, Le = Array(we); ++re < we; )
          Le[re] = se(Q[re], re, Q);
        return Le;
      }
      function br(Q, se) {
        for (var re = -1, we = se.length, Le = Q.length; ++re < we; )
          Q[Le + re] = se[re];
        return Q;
      }
      function Xu(Q, se, re, we) {
        var Le = -1, et = Q == null ? 0 : Q.length;
        for (we && et && (re = Q[++Le]); ++Le < et; )
          re = se(re, Q[Le], Le, Q);
        return re;
      }
      function dE(Q, se, re, we) {
        var Le = Q == null ? 0 : Q.length;
        for (we && Le && (re = Q[--Le]); Le--; )
          re = se(re, Q[Le], Le, Q);
        return re;
      }
      function ec(Q, se) {
        for (var re = -1, we = Q == null ? 0 : Q.length; ++re < we; )
          if (se(Q[re], re, Q))
            return !0;
        return !1;
      }
      var hE = tc("length");
      function pE(Q) {
        return Q.split("");
      }
      function mE(Q) {
        return Q.match(CS) || [];
      }
      function vm(Q, se, re) {
        var we;
        return re(Q, function(Le, et, Et) {
          if (se(Le, et, Et))
            return we = et, !1;
        }), we;
      }
      function Ds(Q, se, re, we) {
        for (var Le = Q.length, et = re + (we ? 1 : -1); we ? et-- : ++et < Le; )
          if (se(Q[et], et, Q))
            return et;
        return -1;
      }
      function Ai(Q, se, re) {
        return se === se ? xE(Q, se, re) : Ds(Q, _m, re);
      }
      function gE(Q, se, re, we) {
        for (var Le = re - 1, et = Q.length; ++Le < et; )
          if (we(Q[Le], se))
            return Le;
        return -1;
      }
      function _m(Q) {
        return Q !== Q;
      }
      function wm(Q, se) {
        var re = Q == null ? 0 : Q.length;
        return re ? rc(Q, se) / re : z;
      }
      function tc(Q) {
        return function(se) {
          return se == null ? e : se[Q];
        };
      }
      function nc(Q) {
        return function(se) {
          return Q == null ? e : Q[se];
        };
      }
      function bm(Q, se, re, we, Le) {
        return Le(Q, function(et, Et, lt) {
          re = we ? (we = !1, et) : se(re, et, Et, lt);
        }), re;
      }
      function yE(Q, se) {
        var re = Q.length;
        for (Q.sort(se); re--; )
          Q[re] = Q[re].value;
        return Q;
      }
      function rc(Q, se) {
        for (var re, we = -1, Le = Q.length; ++we < Le; ) {
          var et = se(Q[we]);
          et !== e && (re = re === e ? et : re + et);
        }
        return re;
      }
      function ic(Q, se) {
        for (var re = -1, we = Array(Q); ++re < Q; )
          we[re] = se(re);
        return we;
      }
      function vE(Q, se) {
        return ht(se, function(re) {
          return [re, Q[re]];
        });
      }
      function Tm(Q) {
        return Q && Q.slice(0, Am(Q) + 1).replace(Gu, "");
      }
      function en(Q) {
        return function(se) {
          return Q(se);
        };
      }
      function oc(Q, se) {
        return ht(se, function(re) {
          return Q[re];
        });
      }
      function Io(Q, se) {
        return Q.has(se);
      }
      function Cm(Q, se) {
        for (var re = -1, we = Q.length; ++re < we && Ai(se, Q[re], 0) > -1; )
          ;
        return re;
      }
      function Sm(Q, se) {
        for (var re = Q.length; re-- && Ai(se, Q[re], 0) > -1; )
          ;
        return re;
      }
      function _E(Q, se) {
        for (var re = Q.length, we = 0; re--; )
          Q[re] === se && ++we;
        return we;
      }
      var wE = nc(rE), bE = nc(iE);
      function TE(Q) {
        return "\\" + sE[Q];
      }
      function CE(Q, se) {
        return Q == null ? e : Q[se];
      }
      function xi(Q) {
        return XS.test(Q);
      }
      function SE(Q) {
        return eE.test(Q);
      }
      function EE(Q) {
        for (var se, re = []; !(se = Q.next()).done; )
          re.push(se.value);
        return re;
      }
      function sc(Q) {
        var se = -1, re = Array(Q.size);
        return Q.forEach(function(we, Le) {
          re[++se] = [Le, we];
        }), re;
      }
      function Em(Q, se) {
        return function(re) {
          return Q(se(re));
        };
      }
      function Tr(Q, se) {
        for (var re = -1, we = Q.length, Le = 0, et = []; ++re < we; ) {
          var Et = Q[re];
          (Et === se || Et === d) && (Q[re] = d, et[Le++] = re);
        }
        return et;
      }
      function Fs(Q) {
        var se = -1, re = Array(Q.size);
        return Q.forEach(function(we) {
          re[++se] = we;
        }), re;
      }
      function AE(Q) {
        var se = -1, re = Array(Q.size);
        return Q.forEach(function(we) {
          re[++se] = [we, we];
        }), re;
      }
      function xE(Q, se, re) {
        for (var we = re - 1, Le = Q.length; ++we < Le; )
          if (Q[we] === se)
            return we;
        return -1;
      }
      function RE(Q, se, re) {
        for (var we = re + 1; we--; )
          if (Q[we] === se)
            return we;
        return we;
      }
      function Ri(Q) {
        return xi(Q) ? ME(Q) : hE(Q);
      }
      function En(Q) {
        return xi(Q) ? kE(Q) : pE(Q);
      }
      function Am(Q) {
        for (var se = Q.length; se-- && _S.test(Q.charAt(se)); )
          ;
        return se;
      }
      var IE = nc(oE);
      function ME(Q) {
        for (var se = Yu.lastIndex = 0; Yu.test(Q); )
          ++se;
        return se;
      }
      function kE(Q) {
        return Q.match(Yu) || [];
      }
      function PE(Q) {
        return Q.match(QS) || [];
      }
      var OE = function Q(se) {
        se = se == null ? Mt : Ii.defaults(Mt.Object(), se, Ii.pick(Mt, tE));
        var re = se.Array, we = se.Date, Le = se.Error, et = se.Function, Et = se.Math, lt = se.Object, ac = se.RegExp, LE = se.String, pn = se.TypeError, $s = re.prototype, NE = et.prototype, Mi = lt.prototype, Us = se["__core-js_shared__"], qs = NE.toString, ot = Mi.hasOwnProperty, DE = 0, xm = function() {
          var a = /[^.]+$/.exec(Us && Us.keys && Us.keys.IE_PROTO || "");
          return a ? "Symbol(src)_1." + a : "";
        }(), Bs = Mi.toString, FE = qs.call(lt), $E = Mt._, UE = ac(
          "^" + qs.call(ot).replace(Hu, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), Vs = cm ? se.Buffer : e, Cr = se.Symbol, Hs = se.Uint8Array, Rm = Vs ? Vs.allocUnsafe : e, Gs = Em(lt.getPrototypeOf, lt), Im = lt.create, Mm = Mi.propertyIsEnumerable, Ws = $s.splice, km = Cr ? Cr.isConcatSpreadable : e, Mo = Cr ? Cr.iterator : e, Zr = Cr ? Cr.toStringTag : e, Ks = function() {
          try {
            var a = ti(lt, "defineProperty");
            return a({}, "", {}), a;
          } catch {
          }
        }(), qE = se.clearTimeout !== Mt.clearTimeout && se.clearTimeout, BE = we && we.now !== Mt.Date.now && we.now, VE = se.setTimeout !== Mt.setTimeout && se.setTimeout, Js = Et.ceil, zs = Et.floor, lc = lt.getOwnPropertySymbols, HE = Vs ? Vs.isBuffer : e, Pm = se.isFinite, GE = $s.join, WE = Em(lt.keys, lt), At = Et.max, Pt = Et.min, KE = we.now, JE = se.parseInt, Om = Et.random, zE = $s.reverse, uc = ti(se, "DataView"), ko = ti(se, "Map"), cc = ti(se, "Promise"), ki = ti(se, "Set"), Po = ti(se, "WeakMap"), Oo = ti(lt, "create"), Ys = Po && new Po(), Pi = {}, YE = ni(uc), ZE = ni(ko), jE = ni(cc), QE = ni(ki), XE = ni(Po), Zs = Cr ? Cr.prototype : e, Lo = Zs ? Zs.valueOf : e, Lm = Zs ? Zs.toString : e;
        function M(a) {
          if (wt(a) && !Fe(a) && !(a instanceof ze)) {
            if (a instanceof mn)
              return a;
            if (ot.call(a, "__wrapped__"))
              return Ng(a);
          }
          return new mn(a);
        }
        var Oi = /* @__PURE__ */ function() {
          function a() {
          }
          return function(f) {
            if (!gt(f))
              return {};
            if (Im)
              return Im(f);
            a.prototype = f;
            var v = new a();
            return a.prototype = e, v;
          };
        }();
        function js() {
        }
        function mn(a, f) {
          this.__wrapped__ = a, this.__actions__ = [], this.__chain__ = !!f, this.__index__ = 0, this.__values__ = e;
        }
        M.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: hS,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: pS,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: Hp,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: M
          }
        }, M.prototype = js.prototype, M.prototype.constructor = M, mn.prototype = Oi(js.prototype), mn.prototype.constructor = mn;
        function ze(a) {
          this.__wrapped__ = a, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = ee, this.__views__ = [];
        }
        function e1() {
          var a = new ze(this.__wrapped__);
          return a.__actions__ = Ht(this.__actions__), a.__dir__ = this.__dir__, a.__filtered__ = this.__filtered__, a.__iteratees__ = Ht(this.__iteratees__), a.__takeCount__ = this.__takeCount__, a.__views__ = Ht(this.__views__), a;
        }
        function t1() {
          if (this.__filtered__) {
            var a = new ze(this);
            a.__dir__ = -1, a.__filtered__ = !0;
          } else
            a = this.clone(), a.__dir__ *= -1;
          return a;
        }
        function n1() {
          var a = this.__wrapped__.value(), f = this.__dir__, v = Fe(a), E = f < 0, R = v ? a.length : 0, L = pA(0, R, this.__views__), G = L.start, J = L.end, X = J - G, ae = E ? J : G - 1, le = this.__iteratees__, he = le.length, ve = 0, Se = Pt(X, this.__takeCount__);
          if (!v || !E && R == X && Se == X)
            return ig(a, this.__actions__);
          var Ie = [];
          e:
            for (; X-- && ve < Se; ) {
              ae += f;
              for (var Be = -1, Me = a[ae]; ++Be < he; ) {
                var We = le[Be], Ze = We.iteratee, rn = We.type, qt = Ze(Me);
                if (rn == K)
                  Me = qt;
                else if (!qt) {
                  if (rn == j)
                    continue e;
                  break e;
                }
              }
              Ie[ve++] = Me;
            }
          return Ie;
        }
        ze.prototype = Oi(js.prototype), ze.prototype.constructor = ze;
        function jr(a) {
          var f = -1, v = a == null ? 0 : a.length;
          for (this.clear(); ++f < v; ) {
            var E = a[f];
            this.set(E[0], E[1]);
          }
        }
        function r1() {
          this.__data__ = Oo ? Oo(null) : {}, this.size = 0;
        }
        function i1(a) {
          var f = this.has(a) && delete this.__data__[a];
          return this.size -= f ? 1 : 0, f;
        }
        function o1(a) {
          var f = this.__data__;
          if (Oo) {
            var v = f[a];
            return v === l ? e : v;
          }
          return ot.call(f, a) ? f[a] : e;
        }
        function s1(a) {
          var f = this.__data__;
          return Oo ? f[a] !== e : ot.call(f, a);
        }
        function a1(a, f) {
          var v = this.__data__;
          return this.size += this.has(a) ? 0 : 1, v[a] = Oo && f === e ? l : f, this;
        }
        jr.prototype.clear = r1, jr.prototype.delete = i1, jr.prototype.get = o1, jr.prototype.has = s1, jr.prototype.set = a1;
        function Zn(a) {
          var f = -1, v = a == null ? 0 : a.length;
          for (this.clear(); ++f < v; ) {
            var E = a[f];
            this.set(E[0], E[1]);
          }
        }
        function l1() {
          this.__data__ = [], this.size = 0;
        }
        function u1(a) {
          var f = this.__data__, v = Qs(f, a);
          if (v < 0)
            return !1;
          var E = f.length - 1;
          return v == E ? f.pop() : Ws.call(f, v, 1), --this.size, !0;
        }
        function c1(a) {
          var f = this.__data__, v = Qs(f, a);
          return v < 0 ? e : f[v][1];
        }
        function f1(a) {
          return Qs(this.__data__, a) > -1;
        }
        function d1(a, f) {
          var v = this.__data__, E = Qs(v, a);
          return E < 0 ? (++this.size, v.push([a, f])) : v[E][1] = f, this;
        }
        Zn.prototype.clear = l1, Zn.prototype.delete = u1, Zn.prototype.get = c1, Zn.prototype.has = f1, Zn.prototype.set = d1;
        function jn(a) {
          var f = -1, v = a == null ? 0 : a.length;
          for (this.clear(); ++f < v; ) {
            var E = a[f];
            this.set(E[0], E[1]);
          }
        }
        function h1() {
          this.size = 0, this.__data__ = {
            hash: new jr(),
            map: new (ko || Zn)(),
            string: new jr()
          };
        }
        function p1(a) {
          var f = ca(this, a).delete(a);
          return this.size -= f ? 1 : 0, f;
        }
        function m1(a) {
          return ca(this, a).get(a);
        }
        function g1(a) {
          return ca(this, a).has(a);
        }
        function y1(a, f) {
          var v = ca(this, a), E = v.size;
          return v.set(a, f), this.size += v.size == E ? 0 : 1, this;
        }
        jn.prototype.clear = h1, jn.prototype.delete = p1, jn.prototype.get = m1, jn.prototype.has = g1, jn.prototype.set = y1;
        function Qr(a) {
          var f = -1, v = a == null ? 0 : a.length;
          for (this.__data__ = new jn(); ++f < v; )
            this.add(a[f]);
        }
        function v1(a) {
          return this.__data__.set(a, l), this;
        }
        function _1(a) {
          return this.__data__.has(a);
        }
        Qr.prototype.add = Qr.prototype.push = v1, Qr.prototype.has = _1;
        function An(a) {
          var f = this.__data__ = new Zn(a);
          this.size = f.size;
        }
        function w1() {
          this.__data__ = new Zn(), this.size = 0;
        }
        function b1(a) {
          var f = this.__data__, v = f.delete(a);
          return this.size = f.size, v;
        }
        function T1(a) {
          return this.__data__.get(a);
        }
        function C1(a) {
          return this.__data__.has(a);
        }
        function S1(a, f) {
          var v = this.__data__;
          if (v instanceof Zn) {
            var E = v.__data__;
            if (!ko || E.length < i - 1)
              return E.push([a, f]), this.size = ++v.size, this;
            v = this.__data__ = new jn(E);
          }
          return v.set(a, f), this.size = v.size, this;
        }
        An.prototype.clear = w1, An.prototype.delete = b1, An.prototype.get = T1, An.prototype.has = C1, An.prototype.set = S1;
        function Nm(a, f) {
          var v = Fe(a), E = !v && ri(a), R = !v && !E && Rr(a), L = !v && !E && !R && Fi(a), G = v || E || R || L, J = G ? ic(a.length, LE) : [], X = J.length;
          for (var ae in a)
            (f || ot.call(a, ae)) && !(G && // Safari 9 has enumerable `arguments.length` in strict mode.
            (ae == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            R && (ae == "offset" || ae == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            L && (ae == "buffer" || ae == "byteLength" || ae == "byteOffset") || // Skip index properties.
            tr(ae, X))) && J.push(ae);
          return J;
        }
        function Dm(a) {
          var f = a.length;
          return f ? a[bc(0, f - 1)] : e;
        }
        function E1(a, f) {
          return fa(Ht(a), Xr(f, 0, a.length));
        }
        function A1(a) {
          return fa(Ht(a));
        }
        function fc(a, f, v) {
          (v !== e && !xn(a[f], v) || v === e && !(f in a)) && Qn(a, f, v);
        }
        function No(a, f, v) {
          var E = a[f];
          (!(ot.call(a, f) && xn(E, v)) || v === e && !(f in a)) && Qn(a, f, v);
        }
        function Qs(a, f) {
          for (var v = a.length; v--; )
            if (xn(a[v][0], f))
              return v;
          return -1;
        }
        function x1(a, f, v, E) {
          return Sr(a, function(R, L, G) {
            f(E, R, v(R), G);
          }), E;
        }
        function Fm(a, f) {
          return a && Fn(f, Rt(f), a);
        }
        function R1(a, f) {
          return a && Fn(f, Wt(f), a);
        }
        function Qn(a, f, v) {
          f == "__proto__" && Ks ? Ks(a, f, {
            configurable: !0,
            enumerable: !0,
            value: v,
            writable: !0
          }) : a[f] = v;
        }
        function dc(a, f) {
          for (var v = -1, E = f.length, R = re(E), L = a == null; ++v < E; )
            R[v] = L ? e : Kc(a, f[v]);
          return R;
        }
        function Xr(a, f, v) {
          return a === a && (v !== e && (a = a <= v ? a : v), f !== e && (a = a >= f ? a : f)), a;
        }
        function gn(a, f, v, E, R, L) {
          var G, J = f & g, X = f & y, ae = f & w;
          if (v && (G = R ? v(a, E, R, L) : v(a)), G !== e)
            return G;
          if (!gt(a))
            return a;
          var le = Fe(a);
          if (le) {
            if (G = gA(a), !J)
              return Ht(a, G);
          } else {
            var he = Ot(a), ve = he == q || he == de;
            if (Rr(a))
              return ag(a, J);
            if (he == Ve || he == fe || ve && !R) {
              if (G = X || ve ? {} : Ag(a), !J)
                return X ? oA(a, R1(G, a)) : iA(a, Fm(G, a));
            } else {
              if (!ct[he])
                return R ? a : {};
              G = yA(a, he, J);
            }
          }
          L || (L = new An());
          var Se = L.get(a);
          if (Se)
            return Se;
          L.set(a, G), ty(a) ? a.forEach(function(Me) {
            G.add(gn(Me, f, v, Me, a, L));
          }) : Xg(a) && a.forEach(function(Me, We) {
            G.set(We, gn(Me, f, v, We, a, L));
          });
          var Ie = ae ? X ? Pc : kc : X ? Wt : Rt, Be = le ? e : Ie(a);
          return hn(Be || a, function(Me, We) {
            Be && (We = Me, Me = a[We]), No(G, We, gn(Me, f, v, We, a, L));
          }), G;
        }
        function I1(a) {
          var f = Rt(a);
          return function(v) {
            return $m(v, a, f);
          };
        }
        function $m(a, f, v) {
          var E = v.length;
          if (a == null)
            return !E;
          for (a = lt(a); E--; ) {
            var R = v[E], L = f[R], G = a[R];
            if (G === e && !(R in a) || !L(G))
              return !1;
          }
          return !0;
        }
        function Um(a, f, v) {
          if (typeof a != "function")
            throw new pn(s);
          return Vo(function() {
            a.apply(e, v);
          }, f);
        }
        function Do(a, f, v, E) {
          var R = -1, L = Ns, G = !0, J = a.length, X = [], ae = f.length;
          if (!J)
            return X;
          v && (f = ht(f, en(v))), E ? (L = Qu, G = !1) : f.length >= i && (L = Io, G = !1, f = new Qr(f));
          e:
            for (; ++R < J; ) {
              var le = a[R], he = v == null ? le : v(le);
              if (le = E || le !== 0 ? le : 0, G && he === he) {
                for (var ve = ae; ve--; )
                  if (f[ve] === he)
                    continue e;
                X.push(le);
              } else L(f, he, E) || X.push(le);
            }
          return X;
        }
        var Sr = dg(Dn), qm = dg(pc, !0);
        function M1(a, f) {
          var v = !0;
          return Sr(a, function(E, R, L) {
            return v = !!f(E, R, L), v;
          }), v;
        }
        function Xs(a, f, v) {
          for (var E = -1, R = a.length; ++E < R; ) {
            var L = a[E], G = f(L);
            if (G != null && (J === e ? G === G && !nn(G) : v(G, J)))
              var J = G, X = L;
          }
          return X;
        }
        function k1(a, f, v, E) {
          var R = a.length;
          for (v = Ue(v), v < 0 && (v = -v > R ? 0 : R + v), E = E === e || E > R ? R : Ue(E), E < 0 && (E += R), E = v > E ? 0 : ry(E); v < E; )
            a[v++] = f;
          return a;
        }
        function Bm(a, f) {
          var v = [];
          return Sr(a, function(E, R, L) {
            f(E, R, L) && v.push(E);
          }), v;
        }
        function kt(a, f, v, E, R) {
          var L = -1, G = a.length;
          for (v || (v = _A), R || (R = []); ++L < G; ) {
            var J = a[L];
            f > 0 && v(J) ? f > 1 ? kt(J, f - 1, v, E, R) : br(R, J) : E || (R[R.length] = J);
          }
          return R;
        }
        var hc = hg(), Vm = hg(!0);
        function Dn(a, f) {
          return a && hc(a, f, Rt);
        }
        function pc(a, f) {
          return a && Vm(a, f, Rt);
        }
        function ea(a, f) {
          return wr(f, function(v) {
            return nr(a[v]);
          });
        }
        function ei(a, f) {
          f = Ar(f, a);
          for (var v = 0, E = f.length; a != null && v < E; )
            a = a[$n(f[v++])];
          return v && v == E ? a : e;
        }
        function Hm(a, f, v) {
          var E = f(a);
          return Fe(a) ? E : br(E, v(a));
        }
        function $t(a) {
          return a == null ? a === e ? Ro : $e : Zr && Zr in lt(a) ? hA(a) : AA(a);
        }
        function mc(a, f) {
          return a > f;
        }
        function P1(a, f) {
          return a != null && ot.call(a, f);
        }
        function O1(a, f) {
          return a != null && f in lt(a);
        }
        function L1(a, f, v) {
          return a >= Pt(f, v) && a < At(f, v);
        }
        function gc(a, f, v) {
          for (var E = v ? Qu : Ns, R = a[0].length, L = a.length, G = L, J = re(L), X = 1 / 0, ae = []; G--; ) {
            var le = a[G];
            G && f && (le = ht(le, en(f))), X = Pt(le.length, X), J[G] = !v && (f || R >= 120 && le.length >= 120) ? new Qr(G && le) : e;
          }
          le = a[0];
          var he = -1, ve = J[0];
          e:
            for (; ++he < R && ae.length < X; ) {
              var Se = le[he], Ie = f ? f(Se) : Se;
              if (Se = v || Se !== 0 ? Se : 0, !(ve ? Io(ve, Ie) : E(ae, Ie, v))) {
                for (G = L; --G; ) {
                  var Be = J[G];
                  if (!(Be ? Io(Be, Ie) : E(a[G], Ie, v)))
                    continue e;
                }
                ve && ve.push(Ie), ae.push(Se);
              }
            }
          return ae;
        }
        function N1(a, f, v, E) {
          return Dn(a, function(R, L, G) {
            f(E, v(R), L, G);
          }), E;
        }
        function Fo(a, f, v) {
          f = Ar(f, a), a = Mg(a, f);
          var E = a == null ? a : a[$n(vn(f))];
          return E == null ? e : Xt(E, a, v);
        }
        function Gm(a) {
          return wt(a) && $t(a) == fe;
        }
        function D1(a) {
          return wt(a) && $t(a) == fn;
        }
        function F1(a) {
          return wt(a) && $t(a) == me;
        }
        function $o(a, f, v, E, R) {
          return a === f ? !0 : a == null || f == null || !wt(a) && !wt(f) ? a !== a && f !== f : $1(a, f, v, E, $o, R);
        }
        function $1(a, f, v, E, R, L) {
          var G = Fe(a), J = Fe(f), X = G ? Y : Ot(a), ae = J ? Y : Ot(f);
          X = X == fe ? Ve : X, ae = ae == fe ? Ve : ae;
          var le = X == Ve, he = ae == Ve, ve = X == ae;
          if (ve && Rr(a)) {
            if (!Rr(f))
              return !1;
            G = !0, le = !1;
          }
          if (ve && !le)
            return L || (L = new An()), G || Fi(a) ? Cg(a, f, v, E, R, L) : fA(a, f, X, v, E, R, L);
          if (!(v & b)) {
            var Se = le && ot.call(a, "__wrapped__"), Ie = he && ot.call(f, "__wrapped__");
            if (Se || Ie) {
              var Be = Se ? a.value() : a, Me = Ie ? f.value() : f;
              return L || (L = new An()), R(Be, Me, v, E, L);
            }
          }
          return ve ? (L || (L = new An()), dA(a, f, v, E, R, L)) : !1;
        }
        function U1(a) {
          return wt(a) && Ot(a) == ye;
        }
        function yc(a, f, v, E) {
          var R = v.length, L = R, G = !E;
          if (a == null)
            return !L;
          for (a = lt(a); R--; ) {
            var J = v[R];
            if (G && J[2] ? J[1] !== a[J[0]] : !(J[0] in a))
              return !1;
          }
          for (; ++R < L; ) {
            J = v[R];
            var X = J[0], ae = a[X], le = J[1];
            if (G && J[2]) {
              if (ae === e && !(X in a))
                return !1;
            } else {
              var he = new An();
              if (E)
                var ve = E(ae, le, X, a, f, he);
              if (!(ve === e ? $o(le, ae, b | _, E, he) : ve))
                return !1;
            }
          }
          return !0;
        }
        function Wm(a) {
          if (!gt(a) || bA(a))
            return !1;
          var f = nr(a) ? UE : IS;
          return f.test(ni(a));
        }
        function q1(a) {
          return wt(a) && $t(a) == yr;
        }
        function B1(a) {
          return wt(a) && Ot(a) == jt;
        }
        function V1(a) {
          return wt(a) && ya(a.length) && !!ft[$t(a)];
        }
        function Km(a) {
          return typeof a == "function" ? a : a == null ? Kt : typeof a == "object" ? Fe(a) ? Ym(a[0], a[1]) : zm(a) : py(a);
        }
        function vc(a) {
          if (!Bo(a))
            return WE(a);
          var f = [];
          for (var v in lt(a))
            ot.call(a, v) && v != "constructor" && f.push(v);
          return f;
        }
        function H1(a) {
          if (!gt(a))
            return EA(a);
          var f = Bo(a), v = [];
          for (var E in a)
            E == "constructor" && (f || !ot.call(a, E)) || v.push(E);
          return v;
        }
        function _c(a, f) {
          return a < f;
        }
        function Jm(a, f) {
          var v = -1, E = Gt(a) ? re(a.length) : [];
          return Sr(a, function(R, L, G) {
            E[++v] = f(R, L, G);
          }), E;
        }
        function zm(a) {
          var f = Lc(a);
          return f.length == 1 && f[0][2] ? Rg(f[0][0], f[0][1]) : function(v) {
            return v === a || yc(v, a, f);
          };
        }
        function Ym(a, f) {
          return Dc(a) && xg(f) ? Rg($n(a), f) : function(v) {
            var E = Kc(v, a);
            return E === e && E === f ? Jc(v, a) : $o(f, E, b | _);
          };
        }
        function ta(a, f, v, E, R) {
          a !== f && hc(f, function(L, G) {
            if (R || (R = new An()), gt(L))
              G1(a, f, G, v, ta, E, R);
            else {
              var J = E ? E($c(a, G), L, G + "", a, f, R) : e;
              J === e && (J = L), fc(a, G, J);
            }
          }, Wt);
        }
        function G1(a, f, v, E, R, L, G) {
          var J = $c(a, v), X = $c(f, v), ae = G.get(X);
          if (ae) {
            fc(a, v, ae);
            return;
          }
          var le = L ? L(J, X, v + "", a, f, G) : e, he = le === e;
          if (he) {
            var ve = Fe(X), Se = !ve && Rr(X), Ie = !ve && !Se && Fi(X);
            le = X, ve || Se || Ie ? Fe(J) ? le = J : Tt(J) ? le = Ht(J) : Se ? (he = !1, le = ag(X, !0)) : Ie ? (he = !1, le = lg(X, !0)) : le = [] : Ho(X) || ri(X) ? (le = J, ri(J) ? le = iy(J) : (!gt(J) || nr(J)) && (le = Ag(X))) : he = !1;
          }
          he && (G.set(X, le), R(le, X, E, L, G), G.delete(X)), fc(a, v, le);
        }
        function Zm(a, f) {
          var v = a.length;
          if (v)
            return f += f < 0 ? v : 0, tr(f, v) ? a[f] : e;
        }
        function jm(a, f, v) {
          f.length ? f = ht(f, function(L) {
            return Fe(L) ? function(G) {
              return ei(G, L.length === 1 ? L[0] : L);
            } : L;
          }) : f = [Kt];
          var E = -1;
          f = ht(f, en(Re()));
          var R = Jm(a, function(L, G, J) {
            var X = ht(f, function(ae) {
              return ae(L);
            });
            return { criteria: X, index: ++E, value: L };
          });
          return yE(R, function(L, G) {
            return rA(L, G, v);
          });
        }
        function W1(a, f) {
          return Qm(a, f, function(v, E) {
            return Jc(a, E);
          });
        }
        function Qm(a, f, v) {
          for (var E = -1, R = f.length, L = {}; ++E < R; ) {
            var G = f[E], J = ei(a, G);
            v(J, G) && Uo(L, Ar(G, a), J);
          }
          return L;
        }
        function K1(a) {
          return function(f) {
            return ei(f, a);
          };
        }
        function wc(a, f, v, E) {
          var R = E ? gE : Ai, L = -1, G = f.length, J = a;
          for (a === f && (f = Ht(f)), v && (J = ht(a, en(v))); ++L < G; )
            for (var X = 0, ae = f[L], le = v ? v(ae) : ae; (X = R(J, le, X, E)) > -1; )
              J !== a && Ws.call(J, X, 1), Ws.call(a, X, 1);
          return a;
        }
        function Xm(a, f) {
          for (var v = a ? f.length : 0, E = v - 1; v--; ) {
            var R = f[v];
            if (v == E || R !== L) {
              var L = R;
              tr(R) ? Ws.call(a, R, 1) : Sc(a, R);
            }
          }
          return a;
        }
        function bc(a, f) {
          return a + zs(Om() * (f - a + 1));
        }
        function J1(a, f, v, E) {
          for (var R = -1, L = At(Js((f - a) / (v || 1)), 0), G = re(L); L--; )
            G[E ? L : ++R] = a, a += v;
          return G;
        }
        function Tc(a, f) {
          var v = "";
          if (!a || f < 1 || f > B)
            return v;
          do
            f % 2 && (v += a), f = zs(f / 2), f && (a += a);
          while (f);
          return v;
        }
        function He(a, f) {
          return Uc(Ig(a, f, Kt), a + "");
        }
        function z1(a) {
          return Dm($i(a));
        }
        function Y1(a, f) {
          var v = $i(a);
          return fa(v, Xr(f, 0, v.length));
        }
        function Uo(a, f, v, E) {
          if (!gt(a))
            return a;
          f = Ar(f, a);
          for (var R = -1, L = f.length, G = L - 1, J = a; J != null && ++R < L; ) {
            var X = $n(f[R]), ae = v;
            if (X === "__proto__" || X === "constructor" || X === "prototype")
              return a;
            if (R != G) {
              var le = J[X];
              ae = E ? E(le, X, J) : e, ae === e && (ae = gt(le) ? le : tr(f[R + 1]) ? [] : {});
            }
            No(J, X, ae), J = J[X];
          }
          return a;
        }
        var eg = Ys ? function(a, f) {
          return Ys.set(a, f), a;
        } : Kt, Z1 = Ks ? function(a, f) {
          return Ks(a, "toString", {
            configurable: !0,
            enumerable: !1,
            value: Yc(f),
            writable: !0
          });
        } : Kt;
        function j1(a) {
          return fa($i(a));
        }
        function yn(a, f, v) {
          var E = -1, R = a.length;
          f < 0 && (f = -f > R ? 0 : R + f), v = v > R ? R : v, v < 0 && (v += R), R = f > v ? 0 : v - f >>> 0, f >>>= 0;
          for (var L = re(R); ++E < R; )
            L[E] = a[E + f];
          return L;
        }
        function Q1(a, f) {
          var v;
          return Sr(a, function(E, R, L) {
            return v = f(E, R, L), !v;
          }), !!v;
        }
        function na(a, f, v) {
          var E = 0, R = a == null ? E : a.length;
          if (typeof f == "number" && f === f && R <= ce) {
            for (; E < R; ) {
              var L = E + R >>> 1, G = a[L];
              G !== null && !nn(G) && (v ? G <= f : G < f) ? E = L + 1 : R = L;
            }
            return R;
          }
          return Cc(a, f, Kt, v);
        }
        function Cc(a, f, v, E) {
          var R = 0, L = a == null ? 0 : a.length;
          if (L === 0)
            return 0;
          f = v(f);
          for (var G = f !== f, J = f === null, X = nn(f), ae = f === e; R < L; ) {
            var le = zs((R + L) / 2), he = v(a[le]), ve = he !== e, Se = he === null, Ie = he === he, Be = nn(he);
            if (G)
              var Me = E || Ie;
            else ae ? Me = Ie && (E || ve) : J ? Me = Ie && ve && (E || !Se) : X ? Me = Ie && ve && !Se && (E || !Be) : Se || Be ? Me = !1 : Me = E ? he <= f : he < f;
            Me ? R = le + 1 : L = le;
          }
          return Pt(L, ne);
        }
        function tg(a, f) {
          for (var v = -1, E = a.length, R = 0, L = []; ++v < E; ) {
            var G = a[v], J = f ? f(G) : G;
            if (!v || !xn(J, X)) {
              var X = J;
              L[R++] = G === 0 ? 0 : G;
            }
          }
          return L;
        }
        function ng(a) {
          return typeof a == "number" ? a : nn(a) ? z : +a;
        }
        function tn(a) {
          if (typeof a == "string")
            return a;
          if (Fe(a))
            return ht(a, tn) + "";
          if (nn(a))
            return Lm ? Lm.call(a) : "";
          var f = a + "";
          return f == "0" && 1 / a == -1 / 0 ? "-0" : f;
        }
        function Er(a, f, v) {
          var E = -1, R = Ns, L = a.length, G = !0, J = [], X = J;
          if (v)
            G = !1, R = Qu;
          else if (L >= i) {
            var ae = f ? null : uA(a);
            if (ae)
              return Fs(ae);
            G = !1, R = Io, X = new Qr();
          } else
            X = f ? [] : J;
          e:
            for (; ++E < L; ) {
              var le = a[E], he = f ? f(le) : le;
              if (le = v || le !== 0 ? le : 0, G && he === he) {
                for (var ve = X.length; ve--; )
                  if (X[ve] === he)
                    continue e;
                f && X.push(he), J.push(le);
              } else R(X, he, v) || (X !== J && X.push(he), J.push(le));
            }
          return J;
        }
        function Sc(a, f) {
          return f = Ar(f, a), a = Mg(a, f), a == null || delete a[$n(vn(f))];
        }
        function rg(a, f, v, E) {
          return Uo(a, f, v(ei(a, f)), E);
        }
        function ra(a, f, v, E) {
          for (var R = a.length, L = E ? R : -1; (E ? L-- : ++L < R) && f(a[L], L, a); )
            ;
          return v ? yn(a, E ? 0 : L, E ? L + 1 : R) : yn(a, E ? L + 1 : 0, E ? R : L);
        }
        function ig(a, f) {
          var v = a;
          return v instanceof ze && (v = v.value()), Xu(f, function(E, R) {
            return R.func.apply(R.thisArg, br([E], R.args));
          }, v);
        }
        function Ec(a, f, v) {
          var E = a.length;
          if (E < 2)
            return E ? Er(a[0]) : [];
          for (var R = -1, L = re(E); ++R < E; )
            for (var G = a[R], J = -1; ++J < E; )
              J != R && (L[R] = Do(L[R] || G, a[J], f, v));
          return Er(kt(L, 1), f, v);
        }
        function og(a, f, v) {
          for (var E = -1, R = a.length, L = f.length, G = {}; ++E < R; ) {
            var J = E < L ? f[E] : e;
            v(G, a[E], J);
          }
          return G;
        }
        function Ac(a) {
          return Tt(a) ? a : [];
        }
        function xc(a) {
          return typeof a == "function" ? a : Kt;
        }
        function Ar(a, f) {
          return Fe(a) ? a : Dc(a, f) ? [a] : Lg(rt(a));
        }
        var X1 = He;
        function xr(a, f, v) {
          var E = a.length;
          return v = v === e ? E : v, !f && v >= E ? a : yn(a, f, v);
        }
        var sg = qE || function(a) {
          return Mt.clearTimeout(a);
        };
        function ag(a, f) {
          if (f)
            return a.slice();
          var v = a.length, E = Rm ? Rm(v) : new a.constructor(v);
          return a.copy(E), E;
        }
        function Rc(a) {
          var f = new a.constructor(a.byteLength);
          return new Hs(f).set(new Hs(a)), f;
        }
        function eA(a, f) {
          var v = f ? Rc(a.buffer) : a.buffer;
          return new a.constructor(v, a.byteOffset, a.byteLength);
        }
        function tA(a) {
          var f = new a.constructor(a.source, Gp.exec(a));
          return f.lastIndex = a.lastIndex, f;
        }
        function nA(a) {
          return Lo ? lt(Lo.call(a)) : {};
        }
        function lg(a, f) {
          var v = f ? Rc(a.buffer) : a.buffer;
          return new a.constructor(v, a.byteOffset, a.length);
        }
        function ug(a, f) {
          if (a !== f) {
            var v = a !== e, E = a === null, R = a === a, L = nn(a), G = f !== e, J = f === null, X = f === f, ae = nn(f);
            if (!J && !ae && !L && a > f || L && G && X && !J && !ae || E && G && X || !v && X || !R)
              return 1;
            if (!E && !L && !ae && a < f || ae && v && R && !E && !L || J && v && R || !G && R || !X)
              return -1;
          }
          return 0;
        }
        function rA(a, f, v) {
          for (var E = -1, R = a.criteria, L = f.criteria, G = R.length, J = v.length; ++E < G; ) {
            var X = ug(R[E], L[E]);
            if (X) {
              if (E >= J)
                return X;
              var ae = v[E];
              return X * (ae == "desc" ? -1 : 1);
            }
          }
          return a.index - f.index;
        }
        function cg(a, f, v, E) {
          for (var R = -1, L = a.length, G = v.length, J = -1, X = f.length, ae = At(L - G, 0), le = re(X + ae), he = !E; ++J < X; )
            le[J] = f[J];
          for (; ++R < G; )
            (he || R < L) && (le[v[R]] = a[R]);
          for (; ae--; )
            le[J++] = a[R++];
          return le;
        }
        function fg(a, f, v, E) {
          for (var R = -1, L = a.length, G = -1, J = v.length, X = -1, ae = f.length, le = At(L - J, 0), he = re(le + ae), ve = !E; ++R < le; )
            he[R] = a[R];
          for (var Se = R; ++X < ae; )
            he[Se + X] = f[X];
          for (; ++G < J; )
            (ve || R < L) && (he[Se + v[G]] = a[R++]);
          return he;
        }
        function Ht(a, f) {
          var v = -1, E = a.length;
          for (f || (f = re(E)); ++v < E; )
            f[v] = a[v];
          return f;
        }
        function Fn(a, f, v, E) {
          var R = !v;
          v || (v = {});
          for (var L = -1, G = f.length; ++L < G; ) {
            var J = f[L], X = E ? E(v[J], a[J], J, v, a) : e;
            X === e && (X = a[J]), R ? Qn(v, J, X) : No(v, J, X);
          }
          return v;
        }
        function iA(a, f) {
          return Fn(a, Nc(a), f);
        }
        function oA(a, f) {
          return Fn(a, Sg(a), f);
        }
        function ia(a, f) {
          return function(v, E) {
            var R = Fe(v) ? cE : x1, L = f ? f() : {};
            return R(v, a, Re(E, 2), L);
          };
        }
        function Li(a) {
          return He(function(f, v) {
            var E = -1, R = v.length, L = R > 1 ? v[R - 1] : e, G = R > 2 ? v[2] : e;
            for (L = a.length > 3 && typeof L == "function" ? (R--, L) : e, G && Ut(v[0], v[1], G) && (L = R < 3 ? e : L, R = 1), f = lt(f); ++E < R; ) {
              var J = v[E];
              J && a(f, J, E, L);
            }
            return f;
          });
        }
        function dg(a, f) {
          return function(v, E) {
            if (v == null)
              return v;
            if (!Gt(v))
              return a(v, E);
            for (var R = v.length, L = f ? R : -1, G = lt(v); (f ? L-- : ++L < R) && E(G[L], L, G) !== !1; )
              ;
            return v;
          };
        }
        function hg(a) {
          return function(f, v, E) {
            for (var R = -1, L = lt(f), G = E(f), J = G.length; J--; ) {
              var X = G[a ? J : ++R];
              if (v(L[X], X, L) === !1)
                break;
            }
            return f;
          };
        }
        function sA(a, f, v) {
          var E = f & C, R = qo(a);
          function L() {
            var G = this && this !== Mt && this instanceof L ? R : a;
            return G.apply(E ? v : this, arguments);
          }
          return L;
        }
        function pg(a) {
          return function(f) {
            f = rt(f);
            var v = xi(f) ? En(f) : e, E = v ? v[0] : f.charAt(0), R = v ? xr(v, 1).join("") : f.slice(1);
            return E[a]() + R;
          };
        }
        function Ni(a) {
          return function(f) {
            return Xu(dy(fy(f).replace(ZS, "")), a, "");
          };
        }
        function qo(a) {
          return function() {
            var f = arguments;
            switch (f.length) {
              case 0:
                return new a();
              case 1:
                return new a(f[0]);
              case 2:
                return new a(f[0], f[1]);
              case 3:
                return new a(f[0], f[1], f[2]);
              case 4:
                return new a(f[0], f[1], f[2], f[3]);
              case 5:
                return new a(f[0], f[1], f[2], f[3], f[4]);
              case 6:
                return new a(f[0], f[1], f[2], f[3], f[4], f[5]);
              case 7:
                return new a(f[0], f[1], f[2], f[3], f[4], f[5], f[6]);
            }
            var v = Oi(a.prototype), E = a.apply(v, f);
            return gt(E) ? E : v;
          };
        }
        function aA(a, f, v) {
          var E = qo(a);
          function R() {
            for (var L = arguments.length, G = re(L), J = L, X = Di(R); J--; )
              G[J] = arguments[J];
            var ae = L < 3 && G[0] !== X && G[L - 1] !== X ? [] : Tr(G, X);
            if (L -= ae.length, L < v)
              return _g(
                a,
                f,
                oa,
                R.placeholder,
                e,
                G,
                ae,
                e,
                e,
                v - L
              );
            var le = this && this !== Mt && this instanceof R ? E : a;
            return Xt(le, this, G);
          }
          return R;
        }
        function mg(a) {
          return function(f, v, E) {
            var R = lt(f);
            if (!Gt(f)) {
              var L = Re(v, 3);
              f = Rt(f), v = function(J) {
                return L(R[J], J, R);
              };
            }
            var G = a(f, v, E);
            return G > -1 ? R[L ? f[G] : G] : e;
          };
        }
        function gg(a) {
          return er(function(f) {
            var v = f.length, E = v, R = mn.prototype.thru;
            for (a && f.reverse(); E--; ) {
              var L = f[E];
              if (typeof L != "function")
                throw new pn(s);
              if (R && !G && ua(L) == "wrapper")
                var G = new mn([], !0);
            }
            for (E = G ? E : v; ++E < v; ) {
              L = f[E];
              var J = ua(L), X = J == "wrapper" ? Oc(L) : e;
              X && Fc(X[0]) && X[1] == (U | S | x | O) && !X[4].length && X[9] == 1 ? G = G[ua(X[0])].apply(G, X[3]) : G = L.length == 1 && Fc(L) ? G[J]() : G.thru(L);
            }
            return function() {
              var ae = arguments, le = ae[0];
              if (G && ae.length == 1 && Fe(le))
                return G.plant(le).value();
              for (var he = 0, ve = v ? f[he].apply(this, ae) : le; ++he < v; )
                ve = f[he].call(this, ve);
              return ve;
            };
          });
        }
        function oa(a, f, v, E, R, L, G, J, X, ae) {
          var le = f & U, he = f & C, ve = f & m, Se = f & (S | A), Ie = f & k, Be = ve ? e : qo(a);
          function Me() {
            for (var We = arguments.length, Ze = re(We), rn = We; rn--; )
              Ze[rn] = arguments[rn];
            if (Se)
              var qt = Di(Me), on = _E(Ze, qt);
            if (E && (Ze = cg(Ze, E, R, Se)), L && (Ze = fg(Ze, L, G, Se)), We -= on, Se && We < ae) {
              var Ct = Tr(Ze, qt);
              return _g(
                a,
                f,
                oa,
                Me.placeholder,
                v,
                Ze,
                Ct,
                J,
                X,
                ae - We
              );
            }
            var Rn = he ? v : this, ir = ve ? Rn[a] : a;
            return We = Ze.length, J ? Ze = xA(Ze, J) : Ie && We > 1 && Ze.reverse(), le && X < We && (Ze.length = X), this && this !== Mt && this instanceof Me && (ir = Be || qo(ir)), ir.apply(Rn, Ze);
          }
          return Me;
        }
        function yg(a, f) {
          return function(v, E) {
            return N1(v, a, f(E), {});
          };
        }
        function sa(a, f) {
          return function(v, E) {
            var R;
            if (v === e && E === e)
              return f;
            if (v !== e && (R = v), E !== e) {
              if (R === e)
                return E;
              typeof v == "string" || typeof E == "string" ? (v = tn(v), E = tn(E)) : (v = ng(v), E = ng(E)), R = a(v, E);
            }
            return R;
          };
        }
        function Ic(a) {
          return er(function(f) {
            return f = ht(f, en(Re())), He(function(v) {
              var E = this;
              return a(f, function(R) {
                return Xt(R, E, v);
              });
            });
          });
        }
        function aa(a, f) {
          f = f === e ? " " : tn(f);
          var v = f.length;
          if (v < 2)
            return v ? Tc(f, a) : f;
          var E = Tc(f, Js(a / Ri(f)));
          return xi(f) ? xr(En(E), 0, a).join("") : E.slice(0, a);
        }
        function lA(a, f, v, E) {
          var R = f & C, L = qo(a);
          function G() {
            for (var J = -1, X = arguments.length, ae = -1, le = E.length, he = re(le + X), ve = this && this !== Mt && this instanceof G ? L : a; ++ae < le; )
              he[ae] = E[ae];
            for (; X--; )
              he[ae++] = arguments[++J];
            return Xt(ve, R ? v : this, he);
          }
          return G;
        }
        function vg(a) {
          return function(f, v, E) {
            return E && typeof E != "number" && Ut(f, v, E) && (v = E = e), f = rr(f), v === e ? (v = f, f = 0) : v = rr(v), E = E === e ? f < v ? 1 : -1 : rr(E), J1(f, v, E, a);
          };
        }
        function la(a) {
          return function(f, v) {
            return typeof f == "string" && typeof v == "string" || (f = _n(f), v = _n(v)), a(f, v);
          };
        }
        function _g(a, f, v, E, R, L, G, J, X, ae) {
          var le = f & S, he = le ? G : e, ve = le ? e : G, Se = le ? L : e, Ie = le ? e : L;
          f |= le ? x : D, f &= ~(le ? D : x), f & T || (f &= -4);
          var Be = [
            a,
            f,
            R,
            Se,
            he,
            Ie,
            ve,
            J,
            X,
            ae
          ], Me = v.apply(e, Be);
          return Fc(a) && kg(Me, Be), Me.placeholder = E, Pg(Me, a, f);
        }
        function Mc(a) {
          var f = Et[a];
          return function(v, E) {
            if (v = _n(v), E = E == null ? 0 : Pt(Ue(E), 292), E && Pm(v)) {
              var R = (rt(v) + "e").split("e"), L = f(R[0] + "e" + (+R[1] + E));
              return R = (rt(L) + "e").split("e"), +(R[0] + "e" + (+R[1] - E));
            }
            return f(v);
          };
        }
        var uA = ki && 1 / Fs(new ki([, -0]))[1] == I ? function(a) {
          return new ki(a);
        } : Qc;
        function wg(a) {
          return function(f) {
            var v = Ot(f);
            return v == ye ? sc(f) : v == jt ? AE(f) : vE(f, a(f));
          };
        }
        function Xn(a, f, v, E, R, L, G, J) {
          var X = f & m;
          if (!X && typeof a != "function")
            throw new pn(s);
          var ae = E ? E.length : 0;
          if (ae || (f &= -97, E = R = e), G = G === e ? G : At(Ue(G), 0), J = J === e ? J : Ue(J), ae -= R ? R.length : 0, f & D) {
            var le = E, he = R;
            E = R = e;
          }
          var ve = X ? e : Oc(a), Se = [
            a,
            f,
            v,
            E,
            R,
            le,
            he,
            L,
            G,
            J
          ];
          if (ve && SA(Se, ve), a = Se[0], f = Se[1], v = Se[2], E = Se[3], R = Se[4], J = Se[9] = Se[9] === e ? X ? 0 : a.length : At(Se[9] - ae, 0), !J && f & (S | A) && (f &= -25), !f || f == C)
            var Ie = sA(a, f, v);
          else f == S || f == A ? Ie = aA(a, f, J) : (f == x || f == (C | x)) && !R.length ? Ie = lA(a, f, v, E) : Ie = oa.apply(e, Se);
          var Be = ve ? eg : kg;
          return Pg(Be(Ie, Se), a, f);
        }
        function bg(a, f, v, E) {
          return a === e || xn(a, Mi[v]) && !ot.call(E, v) ? f : a;
        }
        function Tg(a, f, v, E, R, L) {
          return gt(a) && gt(f) && (L.set(f, a), ta(a, f, e, Tg, L), L.delete(f)), a;
        }
        function cA(a) {
          return Ho(a) ? e : a;
        }
        function Cg(a, f, v, E, R, L) {
          var G = v & b, J = a.length, X = f.length;
          if (J != X && !(G && X > J))
            return !1;
          var ae = L.get(a), le = L.get(f);
          if (ae && le)
            return ae == f && le == a;
          var he = -1, ve = !0, Se = v & _ ? new Qr() : e;
          for (L.set(a, f), L.set(f, a); ++he < J; ) {
            var Ie = a[he], Be = f[he];
            if (E)
              var Me = G ? E(Be, Ie, he, f, a, L) : E(Ie, Be, he, a, f, L);
            if (Me !== e) {
              if (Me)
                continue;
              ve = !1;
              break;
            }
            if (Se) {
              if (!ec(f, function(We, Ze) {
                if (!Io(Se, Ze) && (Ie === We || R(Ie, We, v, E, L)))
                  return Se.push(Ze);
              })) {
                ve = !1;
                break;
              }
            } else if (!(Ie === Be || R(Ie, Be, v, E, L))) {
              ve = !1;
              break;
            }
          }
          return L.delete(a), L.delete(f), ve;
        }
        function fA(a, f, v, E, R, L, G) {
          switch (v) {
            case Qt:
              if (a.byteLength != f.byteLength || a.byteOffset != f.byteOffset)
                return !1;
              a = a.buffer, f = f.buffer;
            case fn:
              return !(a.byteLength != f.byteLength || !L(new Hs(a), new Hs(f)));
            case ie:
            case me:
            case nt:
              return xn(+a, +f);
            case F:
              return a.name == f.name && a.message == f.message;
            case yr:
            case vr:
              return a == f + "";
            case ye:
              var J = sc;
            case jt:
              var X = E & b;
              if (J || (J = Fs), a.size != f.size && !X)
                return !1;
              var ae = G.get(a);
              if (ae)
                return ae == f;
              E |= _, G.set(a, f);
              var le = Cg(J(a), J(f), E, R, L, G);
              return G.delete(a), le;
            case _r:
              if (Lo)
                return Lo.call(a) == Lo.call(f);
          }
          return !1;
        }
        function dA(a, f, v, E, R, L) {
          var G = v & b, J = kc(a), X = J.length, ae = kc(f), le = ae.length;
          if (X != le && !G)
            return !1;
          for (var he = X; he--; ) {
            var ve = J[he];
            if (!(G ? ve in f : ot.call(f, ve)))
              return !1;
          }
          var Se = L.get(a), Ie = L.get(f);
          if (Se && Ie)
            return Se == f && Ie == a;
          var Be = !0;
          L.set(a, f), L.set(f, a);
          for (var Me = G; ++he < X; ) {
            ve = J[he];
            var We = a[ve], Ze = f[ve];
            if (E)
              var rn = G ? E(Ze, We, ve, f, a, L) : E(We, Ze, ve, a, f, L);
            if (!(rn === e ? We === Ze || R(We, Ze, v, E, L) : rn)) {
              Be = !1;
              break;
            }
            Me || (Me = ve == "constructor");
          }
          if (Be && !Me) {
            var qt = a.constructor, on = f.constructor;
            qt != on && "constructor" in a && "constructor" in f && !(typeof qt == "function" && qt instanceof qt && typeof on == "function" && on instanceof on) && (Be = !1);
          }
          return L.delete(a), L.delete(f), Be;
        }
        function er(a) {
          return Uc(Ig(a, e, $g), a + "");
        }
        function kc(a) {
          return Hm(a, Rt, Nc);
        }
        function Pc(a) {
          return Hm(a, Wt, Sg);
        }
        var Oc = Ys ? function(a) {
          return Ys.get(a);
        } : Qc;
        function ua(a) {
          for (var f = a.name + "", v = Pi[f], E = ot.call(Pi, f) ? v.length : 0; E--; ) {
            var R = v[E], L = R.func;
            if (L == null || L == a)
              return R.name;
          }
          return f;
        }
        function Di(a) {
          var f = ot.call(M, "placeholder") ? M : a;
          return f.placeholder;
        }
        function Re() {
          var a = M.iteratee || Zc;
          return a = a === Zc ? Km : a, arguments.length ? a(arguments[0], arguments[1]) : a;
        }
        function ca(a, f) {
          var v = a.__data__;
          return wA(f) ? v[typeof f == "string" ? "string" : "hash"] : v.map;
        }
        function Lc(a) {
          for (var f = Rt(a), v = f.length; v--; ) {
            var E = f[v], R = a[E];
            f[v] = [E, R, xg(R)];
          }
          return f;
        }
        function ti(a, f) {
          var v = CE(a, f);
          return Wm(v) ? v : e;
        }
        function hA(a) {
          var f = ot.call(a, Zr), v = a[Zr];
          try {
            a[Zr] = e;
            var E = !0;
          } catch {
          }
          var R = Bs.call(a);
          return E && (f ? a[Zr] = v : delete a[Zr]), R;
        }
        var Nc = lc ? function(a) {
          return a == null ? [] : (a = lt(a), wr(lc(a), function(f) {
            return Mm.call(a, f);
          }));
        } : Xc, Sg = lc ? function(a) {
          for (var f = []; a; )
            br(f, Nc(a)), a = Gs(a);
          return f;
        } : Xc, Ot = $t;
        (uc && Ot(new uc(new ArrayBuffer(1))) != Qt || ko && Ot(new ko()) != ye || cc && Ot(cc.resolve()) != Sn || ki && Ot(new ki()) != jt || Po && Ot(new Po()) != Yn) && (Ot = function(a) {
          var f = $t(a), v = f == Ve ? a.constructor : e, E = v ? ni(v) : "";
          if (E)
            switch (E) {
              case YE:
                return Qt;
              case ZE:
                return ye;
              case jE:
                return Sn;
              case QE:
                return jt;
              case XE:
                return Yn;
            }
          return f;
        });
        function pA(a, f, v) {
          for (var E = -1, R = v.length; ++E < R; ) {
            var L = v[E], G = L.size;
            switch (L.type) {
              case "drop":
                a += G;
                break;
              case "dropRight":
                f -= G;
                break;
              case "take":
                f = Pt(f, a + G);
                break;
              case "takeRight":
                a = At(a, f - G);
                break;
            }
          }
          return { start: a, end: f };
        }
        function mA(a) {
          var f = a.match(bS);
          return f ? f[1].split(TS) : [];
        }
        function Eg(a, f, v) {
          f = Ar(f, a);
          for (var E = -1, R = f.length, L = !1; ++E < R; ) {
            var G = $n(f[E]);
            if (!(L = a != null && v(a, G)))
              break;
            a = a[G];
          }
          return L || ++E != R ? L : (R = a == null ? 0 : a.length, !!R && ya(R) && tr(G, R) && (Fe(a) || ri(a)));
        }
        function gA(a) {
          var f = a.length, v = new a.constructor(f);
          return f && typeof a[0] == "string" && ot.call(a, "index") && (v.index = a.index, v.input = a.input), v;
        }
        function Ag(a) {
          return typeof a.constructor == "function" && !Bo(a) ? Oi(Gs(a)) : {};
        }
        function yA(a, f, v) {
          var E = a.constructor;
          switch (f) {
            case fn:
              return Rc(a);
            case ie:
            case me:
              return new E(+a);
            case Qt:
              return eA(a, v);
            case Lu:
            case Nu:
            case Du:
            case Fu:
            case $u:
            case Uu:
            case qu:
            case Bu:
            case Vu:
              return lg(a, v);
            case ye:
              return new E();
            case nt:
            case vr:
              return new E(a);
            case yr:
              return tA(a);
            case jt:
              return new E();
            case _r:
              return nA(a);
          }
        }
        function vA(a, f) {
          var v = f.length;
          if (!v)
            return a;
          var E = v - 1;
          return f[E] = (v > 1 ? "& " : "") + f[E], f = f.join(v > 2 ? ", " : " "), a.replace(wS, `{
/* [wrapped with ` + f + `] */
`);
        }
        function _A(a) {
          return Fe(a) || ri(a) || !!(km && a && a[km]);
        }
        function tr(a, f) {
          var v = typeof a;
          return f = f ?? B, !!f && (v == "number" || v != "symbol" && kS.test(a)) && a > -1 && a % 1 == 0 && a < f;
        }
        function Ut(a, f, v) {
          if (!gt(v))
            return !1;
          var E = typeof f;
          return (E == "number" ? Gt(v) && tr(f, v.length) : E == "string" && f in v) ? xn(v[f], a) : !1;
        }
        function Dc(a, f) {
          if (Fe(a))
            return !1;
          var v = typeof a;
          return v == "number" || v == "symbol" || v == "boolean" || a == null || nn(a) ? !0 : gS.test(a) || !mS.test(a) || f != null && a in lt(f);
        }
        function wA(a) {
          var f = typeof a;
          return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? a !== "__proto__" : a === null;
        }
        function Fc(a) {
          var f = ua(a), v = M[f];
          if (typeof v != "function" || !(f in ze.prototype))
            return !1;
          if (a === v)
            return !0;
          var E = Oc(v);
          return !!E && a === E[0];
        }
        function bA(a) {
          return !!xm && xm in a;
        }
        var TA = Us ? nr : ef;
        function Bo(a) {
          var f = a && a.constructor, v = typeof f == "function" && f.prototype || Mi;
          return a === v;
        }
        function xg(a) {
          return a === a && !gt(a);
        }
        function Rg(a, f) {
          return function(v) {
            return v == null ? !1 : v[a] === f && (f !== e || a in lt(v));
          };
        }
        function CA(a) {
          var f = ma(a, function(E) {
            return v.size === c && v.clear(), E;
          }), v = f.cache;
          return f;
        }
        function SA(a, f) {
          var v = a[1], E = f[1], R = v | E, L = R < (C | m | U), G = E == U && v == S || E == U && v == O && a[7].length <= f[8] || E == (U | O) && f[7].length <= f[8] && v == S;
          if (!(L || G))
            return a;
          E & C && (a[2] = f[2], R |= v & C ? 0 : T);
          var J = f[3];
          if (J) {
            var X = a[3];
            a[3] = X ? cg(X, J, f[4]) : J, a[4] = X ? Tr(a[3], d) : f[4];
          }
          return J = f[5], J && (X = a[5], a[5] = X ? fg(X, J, f[6]) : J, a[6] = X ? Tr(a[5], d) : f[6]), J = f[7], J && (a[7] = J), E & U && (a[8] = a[8] == null ? f[8] : Pt(a[8], f[8])), a[9] == null && (a[9] = f[9]), a[0] = f[0], a[1] = R, a;
        }
        function EA(a) {
          var f = [];
          if (a != null)
            for (var v in lt(a))
              f.push(v);
          return f;
        }
        function AA(a) {
          return Bs.call(a);
        }
        function Ig(a, f, v) {
          return f = At(f === e ? a.length - 1 : f, 0), function() {
            for (var E = arguments, R = -1, L = At(E.length - f, 0), G = re(L); ++R < L; )
              G[R] = E[f + R];
            R = -1;
            for (var J = re(f + 1); ++R < f; )
              J[R] = E[R];
            return J[f] = v(G), Xt(a, this, J);
          };
        }
        function Mg(a, f) {
          return f.length < 2 ? a : ei(a, yn(f, 0, -1));
        }
        function xA(a, f) {
          for (var v = a.length, E = Pt(f.length, v), R = Ht(a); E--; ) {
            var L = f[E];
            a[E] = tr(L, v) ? R[L] : e;
          }
          return a;
        }
        function $c(a, f) {
          if (!(f === "constructor" && typeof a[f] == "function") && f != "__proto__")
            return a[f];
        }
        var kg = Og(eg), Vo = VE || function(a, f) {
          return Mt.setTimeout(a, f);
        }, Uc = Og(Z1);
        function Pg(a, f, v) {
          var E = f + "";
          return Uc(a, vA(E, RA(mA(E), v)));
        }
        function Og(a) {
          var f = 0, v = 0;
          return function() {
            var E = KE(), R = $ - (E - v);
            if (v = E, R > 0) {
              if (++f >= N)
                return arguments[0];
            } else
              f = 0;
            return a.apply(e, arguments);
          };
        }
        function fa(a, f) {
          var v = -1, E = a.length, R = E - 1;
          for (f = f === e ? E : f; ++v < f; ) {
            var L = bc(v, R), G = a[L];
            a[L] = a[v], a[v] = G;
          }
          return a.length = f, a;
        }
        var Lg = CA(function(a) {
          var f = [];
          return a.charCodeAt(0) === 46 && f.push(""), a.replace(yS, function(v, E, R, L) {
            f.push(R ? L.replace(ES, "$1") : E || v);
          }), f;
        });
        function $n(a) {
          if (typeof a == "string" || nn(a))
            return a;
          var f = a + "";
          return f == "0" && 1 / a == -1 / 0 ? "-0" : f;
        }
        function ni(a) {
          if (a != null) {
            try {
              return qs.call(a);
            } catch {
            }
            try {
              return a + "";
            } catch {
            }
          }
          return "";
        }
        function RA(a, f) {
          return hn(te, function(v) {
            var E = "_." + v[0];
            f & v[1] && !Ns(a, E) && a.push(E);
          }), a.sort();
        }
        function Ng(a) {
          if (a instanceof ze)
            return a.clone();
          var f = new mn(a.__wrapped__, a.__chain__);
          return f.__actions__ = Ht(a.__actions__), f.__index__ = a.__index__, f.__values__ = a.__values__, f;
        }
        function IA(a, f, v) {
          (v ? Ut(a, f, v) : f === e) ? f = 1 : f = At(Ue(f), 0);
          var E = a == null ? 0 : a.length;
          if (!E || f < 1)
            return [];
          for (var R = 0, L = 0, G = re(Js(E / f)); R < E; )
            G[L++] = yn(a, R, R += f);
          return G;
        }
        function MA(a) {
          for (var f = -1, v = a == null ? 0 : a.length, E = 0, R = []; ++f < v; ) {
            var L = a[f];
            L && (R[E++] = L);
          }
          return R;
        }
        function kA() {
          var a = arguments.length;
          if (!a)
            return [];
          for (var f = re(a - 1), v = arguments[0], E = a; E--; )
            f[E - 1] = arguments[E];
          return br(Fe(v) ? Ht(v) : [v], kt(f, 1));
        }
        var PA = He(function(a, f) {
          return Tt(a) ? Do(a, kt(f, 1, Tt, !0)) : [];
        }), OA = He(function(a, f) {
          var v = vn(f);
          return Tt(v) && (v = e), Tt(a) ? Do(a, kt(f, 1, Tt, !0), Re(v, 2)) : [];
        }), LA = He(function(a, f) {
          var v = vn(f);
          return Tt(v) && (v = e), Tt(a) ? Do(a, kt(f, 1, Tt, !0), e, v) : [];
        });
        function NA(a, f, v) {
          var E = a == null ? 0 : a.length;
          return E ? (f = v || f === e ? 1 : Ue(f), yn(a, f < 0 ? 0 : f, E)) : [];
        }
        function DA(a, f, v) {
          var E = a == null ? 0 : a.length;
          return E ? (f = v || f === e ? 1 : Ue(f), f = E - f, yn(a, 0, f < 0 ? 0 : f)) : [];
        }
        function FA(a, f) {
          return a && a.length ? ra(a, Re(f, 3), !0, !0) : [];
        }
        function $A(a, f) {
          return a && a.length ? ra(a, Re(f, 3), !0) : [];
        }
        function UA(a, f, v, E) {
          var R = a == null ? 0 : a.length;
          return R ? (v && typeof v != "number" && Ut(a, f, v) && (v = 0, E = R), k1(a, f, v, E)) : [];
        }
        function Dg(a, f, v) {
          var E = a == null ? 0 : a.length;
          if (!E)
            return -1;
          var R = v == null ? 0 : Ue(v);
          return R < 0 && (R = At(E + R, 0)), Ds(a, Re(f, 3), R);
        }
        function Fg(a, f, v) {
          var E = a == null ? 0 : a.length;
          if (!E)
            return -1;
          var R = E - 1;
          return v !== e && (R = Ue(v), R = v < 0 ? At(E + R, 0) : Pt(R, E - 1)), Ds(a, Re(f, 3), R, !0);
        }
        function $g(a) {
          var f = a == null ? 0 : a.length;
          return f ? kt(a, 1) : [];
        }
        function qA(a) {
          var f = a == null ? 0 : a.length;
          return f ? kt(a, I) : [];
        }
        function BA(a, f) {
          var v = a == null ? 0 : a.length;
          return v ? (f = f === e ? 1 : Ue(f), kt(a, f)) : [];
        }
        function VA(a) {
          for (var f = -1, v = a == null ? 0 : a.length, E = {}; ++f < v; ) {
            var R = a[f];
            E[R[0]] = R[1];
          }
          return E;
        }
        function Ug(a) {
          return a && a.length ? a[0] : e;
        }
        function HA(a, f, v) {
          var E = a == null ? 0 : a.length;
          if (!E)
            return -1;
          var R = v == null ? 0 : Ue(v);
          return R < 0 && (R = At(E + R, 0)), Ai(a, f, R);
        }
        function GA(a) {
          var f = a == null ? 0 : a.length;
          return f ? yn(a, 0, -1) : [];
        }
        var WA = He(function(a) {
          var f = ht(a, Ac);
          return f.length && f[0] === a[0] ? gc(f) : [];
        }), KA = He(function(a) {
          var f = vn(a), v = ht(a, Ac);
          return f === vn(v) ? f = e : v.pop(), v.length && v[0] === a[0] ? gc(v, Re(f, 2)) : [];
        }), JA = He(function(a) {
          var f = vn(a), v = ht(a, Ac);
          return f = typeof f == "function" ? f : e, f && v.pop(), v.length && v[0] === a[0] ? gc(v, e, f) : [];
        });
        function zA(a, f) {
          return a == null ? "" : GE.call(a, f);
        }
        function vn(a) {
          var f = a == null ? 0 : a.length;
          return f ? a[f - 1] : e;
        }
        function YA(a, f, v) {
          var E = a == null ? 0 : a.length;
          if (!E)
            return -1;
          var R = E;
          return v !== e && (R = Ue(v), R = R < 0 ? At(E + R, 0) : Pt(R, E - 1)), f === f ? RE(a, f, R) : Ds(a, _m, R, !0);
        }
        function ZA(a, f) {
          return a && a.length ? Zm(a, Ue(f)) : e;
        }
        var jA = He(qg);
        function qg(a, f) {
          return a && a.length && f && f.length ? wc(a, f) : a;
        }
        function QA(a, f, v) {
          return a && a.length && f && f.length ? wc(a, f, Re(v, 2)) : a;
        }
        function XA(a, f, v) {
          return a && a.length && f && f.length ? wc(a, f, e, v) : a;
        }
        var ex = er(function(a, f) {
          var v = a == null ? 0 : a.length, E = dc(a, f);
          return Xm(a, ht(f, function(R) {
            return tr(R, v) ? +R : R;
          }).sort(ug)), E;
        });
        function tx(a, f) {
          var v = [];
          if (!(a && a.length))
            return v;
          var E = -1, R = [], L = a.length;
          for (f = Re(f, 3); ++E < L; ) {
            var G = a[E];
            f(G, E, a) && (v.push(G), R.push(E));
          }
          return Xm(a, R), v;
        }
        function qc(a) {
          return a == null ? a : zE.call(a);
        }
        function nx(a, f, v) {
          var E = a == null ? 0 : a.length;
          return E ? (v && typeof v != "number" && Ut(a, f, v) ? (f = 0, v = E) : (f = f == null ? 0 : Ue(f), v = v === e ? E : Ue(v)), yn(a, f, v)) : [];
        }
        function rx(a, f) {
          return na(a, f);
        }
        function ix(a, f, v) {
          return Cc(a, f, Re(v, 2));
        }
        function ox(a, f) {
          var v = a == null ? 0 : a.length;
          if (v) {
            var E = na(a, f);
            if (E < v && xn(a[E], f))
              return E;
          }
          return -1;
        }
        function sx(a, f) {
          return na(a, f, !0);
        }
        function ax(a, f, v) {
          return Cc(a, f, Re(v, 2), !0);
        }
        function lx(a, f) {
          var v = a == null ? 0 : a.length;
          if (v) {
            var E = na(a, f, !0) - 1;
            if (xn(a[E], f))
              return E;
          }
          return -1;
        }
        function ux(a) {
          return a && a.length ? tg(a) : [];
        }
        function cx(a, f) {
          return a && a.length ? tg(a, Re(f, 2)) : [];
        }
        function fx(a) {
          var f = a == null ? 0 : a.length;
          return f ? yn(a, 1, f) : [];
        }
        function dx(a, f, v) {
          return a && a.length ? (f = v || f === e ? 1 : Ue(f), yn(a, 0, f < 0 ? 0 : f)) : [];
        }
        function hx(a, f, v) {
          var E = a == null ? 0 : a.length;
          return E ? (f = v || f === e ? 1 : Ue(f), f = E - f, yn(a, f < 0 ? 0 : f, E)) : [];
        }
        function px(a, f) {
          return a && a.length ? ra(a, Re(f, 3), !1, !0) : [];
        }
        function mx(a, f) {
          return a && a.length ? ra(a, Re(f, 3)) : [];
        }
        var gx = He(function(a) {
          return Er(kt(a, 1, Tt, !0));
        }), yx = He(function(a) {
          var f = vn(a);
          return Tt(f) && (f = e), Er(kt(a, 1, Tt, !0), Re(f, 2));
        }), vx = He(function(a) {
          var f = vn(a);
          return f = typeof f == "function" ? f : e, Er(kt(a, 1, Tt, !0), e, f);
        });
        function _x(a) {
          return a && a.length ? Er(a) : [];
        }
        function wx(a, f) {
          return a && a.length ? Er(a, Re(f, 2)) : [];
        }
        function bx(a, f) {
          return f = typeof f == "function" ? f : e, a && a.length ? Er(a, e, f) : [];
        }
        function Bc(a) {
          if (!(a && a.length))
            return [];
          var f = 0;
          return a = wr(a, function(v) {
            if (Tt(v))
              return f = At(v.length, f), !0;
          }), ic(f, function(v) {
            return ht(a, tc(v));
          });
        }
        function Bg(a, f) {
          if (!(a && a.length))
            return [];
          var v = Bc(a);
          return f == null ? v : ht(v, function(E) {
            return Xt(f, e, E);
          });
        }
        var Tx = He(function(a, f) {
          return Tt(a) ? Do(a, f) : [];
        }), Cx = He(function(a) {
          return Ec(wr(a, Tt));
        }), Sx = He(function(a) {
          var f = vn(a);
          return Tt(f) && (f = e), Ec(wr(a, Tt), Re(f, 2));
        }), Ex = He(function(a) {
          var f = vn(a);
          return f = typeof f == "function" ? f : e, Ec(wr(a, Tt), e, f);
        }), Ax = He(Bc);
        function xx(a, f) {
          return og(a || [], f || [], No);
        }
        function Rx(a, f) {
          return og(a || [], f || [], Uo);
        }
        var Ix = He(function(a) {
          var f = a.length, v = f > 1 ? a[f - 1] : e;
          return v = typeof v == "function" ? (a.pop(), v) : e, Bg(a, v);
        });
        function Vg(a) {
          var f = M(a);
          return f.__chain__ = !0, f;
        }
        function Mx(a, f) {
          return f(a), a;
        }
        function da(a, f) {
          return f(a);
        }
        var kx = er(function(a) {
          var f = a.length, v = f ? a[0] : 0, E = this.__wrapped__, R = function(L) {
            return dc(L, a);
          };
          return f > 1 || this.__actions__.length || !(E instanceof ze) || !tr(v) ? this.thru(R) : (E = E.slice(v, +v + (f ? 1 : 0)), E.__actions__.push({
            func: da,
            args: [R],
            thisArg: e
          }), new mn(E, this.__chain__).thru(function(L) {
            return f && !L.length && L.push(e), L;
          }));
        });
        function Px() {
          return Vg(this);
        }
        function Ox() {
          return new mn(this.value(), this.__chain__);
        }
        function Lx() {
          this.__values__ === e && (this.__values__ = ny(this.value()));
          var a = this.__index__ >= this.__values__.length, f = a ? e : this.__values__[this.__index__++];
          return { done: a, value: f };
        }
        function Nx() {
          return this;
        }
        function Dx(a) {
          for (var f, v = this; v instanceof js; ) {
            var E = Ng(v);
            E.__index__ = 0, E.__values__ = e, f ? R.__wrapped__ = E : f = E;
            var R = E;
            v = v.__wrapped__;
          }
          return R.__wrapped__ = a, f;
        }
        function Fx() {
          var a = this.__wrapped__;
          if (a instanceof ze) {
            var f = a;
            return this.__actions__.length && (f = new ze(this)), f = f.reverse(), f.__actions__.push({
              func: da,
              args: [qc],
              thisArg: e
            }), new mn(f, this.__chain__);
          }
          return this.thru(qc);
        }
        function $x() {
          return ig(this.__wrapped__, this.__actions__);
        }
        var Ux = ia(function(a, f, v) {
          ot.call(a, v) ? ++a[v] : Qn(a, v, 1);
        });
        function qx(a, f, v) {
          var E = Fe(a) ? ym : M1;
          return v && Ut(a, f, v) && (f = e), E(a, Re(f, 3));
        }
        function Bx(a, f) {
          var v = Fe(a) ? wr : Bm;
          return v(a, Re(f, 3));
        }
        var Vx = mg(Dg), Hx = mg(Fg);
        function Gx(a, f) {
          return kt(ha(a, f), 1);
        }
        function Wx(a, f) {
          return kt(ha(a, f), I);
        }
        function Kx(a, f, v) {
          return v = v === e ? 1 : Ue(v), kt(ha(a, f), v);
        }
        function Hg(a, f) {
          var v = Fe(a) ? hn : Sr;
          return v(a, Re(f, 3));
        }
        function Gg(a, f) {
          var v = Fe(a) ? fE : qm;
          return v(a, Re(f, 3));
        }
        var Jx = ia(function(a, f, v) {
          ot.call(a, v) ? a[v].push(f) : Qn(a, v, [f]);
        });
        function zx(a, f, v, E) {
          a = Gt(a) ? a : $i(a), v = v && !E ? Ue(v) : 0;
          var R = a.length;
          return v < 0 && (v = At(R + v, 0)), va(a) ? v <= R && a.indexOf(f, v) > -1 : !!R && Ai(a, f, v) > -1;
        }
        var Yx = He(function(a, f, v) {
          var E = -1, R = typeof f == "function", L = Gt(a) ? re(a.length) : [];
          return Sr(a, function(G) {
            L[++E] = R ? Xt(f, G, v) : Fo(G, f, v);
          }), L;
        }), Zx = ia(function(a, f, v) {
          Qn(a, v, f);
        });
        function ha(a, f) {
          var v = Fe(a) ? ht : Jm;
          return v(a, Re(f, 3));
        }
        function jx(a, f, v, E) {
          return a == null ? [] : (Fe(f) || (f = f == null ? [] : [f]), v = E ? e : v, Fe(v) || (v = v == null ? [] : [v]), jm(a, f, v));
        }
        var Qx = ia(function(a, f, v) {
          a[v ? 0 : 1].push(f);
        }, function() {
          return [[], []];
        });
        function Xx(a, f, v) {
          var E = Fe(a) ? Xu : bm, R = arguments.length < 3;
          return E(a, Re(f, 4), v, R, Sr);
        }
        function eR(a, f, v) {
          var E = Fe(a) ? dE : bm, R = arguments.length < 3;
          return E(a, Re(f, 4), v, R, qm);
        }
        function tR(a, f) {
          var v = Fe(a) ? wr : Bm;
          return v(a, ga(Re(f, 3)));
        }
        function nR(a) {
          var f = Fe(a) ? Dm : z1;
          return f(a);
        }
        function rR(a, f, v) {
          (v ? Ut(a, f, v) : f === e) ? f = 1 : f = Ue(f);
          var E = Fe(a) ? E1 : Y1;
          return E(a, f);
        }
        function iR(a) {
          var f = Fe(a) ? A1 : j1;
          return f(a);
        }
        function oR(a) {
          if (a == null)
            return 0;
          if (Gt(a))
            return va(a) ? Ri(a) : a.length;
          var f = Ot(a);
          return f == ye || f == jt ? a.size : vc(a).length;
        }
        function sR(a, f, v) {
          var E = Fe(a) ? ec : Q1;
          return v && Ut(a, f, v) && (f = e), E(a, Re(f, 3));
        }
        var aR = He(function(a, f) {
          if (a == null)
            return [];
          var v = f.length;
          return v > 1 && Ut(a, f[0], f[1]) ? f = [] : v > 2 && Ut(f[0], f[1], f[2]) && (f = [f[0]]), jm(a, kt(f, 1), []);
        }), pa = BE || function() {
          return Mt.Date.now();
        };
        function lR(a, f) {
          if (typeof f != "function")
            throw new pn(s);
          return a = Ue(a), function() {
            if (--a < 1)
              return f.apply(this, arguments);
          };
        }
        function Wg(a, f, v) {
          return f = v ? e : f, f = a && f == null ? a.length : f, Xn(a, U, e, e, e, e, f);
        }
        function Kg(a, f) {
          var v;
          if (typeof f != "function")
            throw new pn(s);
          return a = Ue(a), function() {
            return --a > 0 && (v = f.apply(this, arguments)), a <= 1 && (f = e), v;
          };
        }
        var Vc = He(function(a, f, v) {
          var E = C;
          if (v.length) {
            var R = Tr(v, Di(Vc));
            E |= x;
          }
          return Xn(a, E, f, v, R);
        }), Jg = He(function(a, f, v) {
          var E = C | m;
          if (v.length) {
            var R = Tr(v, Di(Jg));
            E |= x;
          }
          return Xn(f, E, a, v, R);
        });
        function zg(a, f, v) {
          f = v ? e : f;
          var E = Xn(a, S, e, e, e, e, e, f);
          return E.placeholder = zg.placeholder, E;
        }
        function Yg(a, f, v) {
          f = v ? e : f;
          var E = Xn(a, A, e, e, e, e, e, f);
          return E.placeholder = Yg.placeholder, E;
        }
        function Zg(a, f, v) {
          var E, R, L, G, J, X, ae = 0, le = !1, he = !1, ve = !0;
          if (typeof a != "function")
            throw new pn(s);
          f = _n(f) || 0, gt(v) && (le = !!v.leading, he = "maxWait" in v, L = he ? At(_n(v.maxWait) || 0, f) : L, ve = "trailing" in v ? !!v.trailing : ve);
          function Se(Ct) {
            var Rn = E, ir = R;
            return E = R = e, ae = Ct, G = a.apply(ir, Rn), G;
          }
          function Ie(Ct) {
            return ae = Ct, J = Vo(We, f), le ? Se(Ct) : G;
          }
          function Be(Ct) {
            var Rn = Ct - X, ir = Ct - ae, my = f - Rn;
            return he ? Pt(my, L - ir) : my;
          }
          function Me(Ct) {
            var Rn = Ct - X, ir = Ct - ae;
            return X === e || Rn >= f || Rn < 0 || he && ir >= L;
          }
          function We() {
            var Ct = pa();
            if (Me(Ct))
              return Ze(Ct);
            J = Vo(We, Be(Ct));
          }
          function Ze(Ct) {
            return J = e, ve && E ? Se(Ct) : (E = R = e, G);
          }
          function rn() {
            J !== e && sg(J), ae = 0, E = X = R = J = e;
          }
          function qt() {
            return J === e ? G : Ze(pa());
          }
          function on() {
            var Ct = pa(), Rn = Me(Ct);
            if (E = arguments, R = this, X = Ct, Rn) {
              if (J === e)
                return Ie(X);
              if (he)
                return sg(J), J = Vo(We, f), Se(X);
            }
            return J === e && (J = Vo(We, f)), G;
          }
          return on.cancel = rn, on.flush = qt, on;
        }
        var uR = He(function(a, f) {
          return Um(a, 1, f);
        }), cR = He(function(a, f, v) {
          return Um(a, _n(f) || 0, v);
        });
        function fR(a) {
          return Xn(a, k);
        }
        function ma(a, f) {
          if (typeof a != "function" || f != null && typeof f != "function")
            throw new pn(s);
          var v = function() {
            var E = arguments, R = f ? f.apply(this, E) : E[0], L = v.cache;
            if (L.has(R))
              return L.get(R);
            var G = a.apply(this, E);
            return v.cache = L.set(R, G) || L, G;
          };
          return v.cache = new (ma.Cache || jn)(), v;
        }
        ma.Cache = jn;
        function ga(a) {
          if (typeof a != "function")
            throw new pn(s);
          return function() {
            var f = arguments;
            switch (f.length) {
              case 0:
                return !a.call(this);
              case 1:
                return !a.call(this, f[0]);
              case 2:
                return !a.call(this, f[0], f[1]);
              case 3:
                return !a.call(this, f[0], f[1], f[2]);
            }
            return !a.apply(this, f);
          };
        }
        function dR(a) {
          return Kg(2, a);
        }
        var hR = X1(function(a, f) {
          f = f.length == 1 && Fe(f[0]) ? ht(f[0], en(Re())) : ht(kt(f, 1), en(Re()));
          var v = f.length;
          return He(function(E) {
            for (var R = -1, L = Pt(E.length, v); ++R < L; )
              E[R] = f[R].call(this, E[R]);
            return Xt(a, this, E);
          });
        }), Hc = He(function(a, f) {
          var v = Tr(f, Di(Hc));
          return Xn(a, x, e, f, v);
        }), jg = He(function(a, f) {
          var v = Tr(f, Di(jg));
          return Xn(a, D, e, f, v);
        }), pR = er(function(a, f) {
          return Xn(a, O, e, e, e, f);
        });
        function mR(a, f) {
          if (typeof a != "function")
            throw new pn(s);
          return f = f === e ? f : Ue(f), He(a, f);
        }
        function gR(a, f) {
          if (typeof a != "function")
            throw new pn(s);
          return f = f == null ? 0 : At(Ue(f), 0), He(function(v) {
            var E = v[f], R = xr(v, 0, f);
            return E && br(R, E), Xt(a, this, R);
          });
        }
        function yR(a, f, v) {
          var E = !0, R = !0;
          if (typeof a != "function")
            throw new pn(s);
          return gt(v) && (E = "leading" in v ? !!v.leading : E, R = "trailing" in v ? !!v.trailing : R), Zg(a, f, {
            leading: E,
            maxWait: f,
            trailing: R
          });
        }
        function vR(a) {
          return Wg(a, 1);
        }
        function _R(a, f) {
          return Hc(xc(f), a);
        }
        function wR() {
          if (!arguments.length)
            return [];
          var a = arguments[0];
          return Fe(a) ? a : [a];
        }
        function bR(a) {
          return gn(a, w);
        }
        function TR(a, f) {
          return f = typeof f == "function" ? f : e, gn(a, w, f);
        }
        function CR(a) {
          return gn(a, g | w);
        }
        function SR(a, f) {
          return f = typeof f == "function" ? f : e, gn(a, g | w, f);
        }
        function ER(a, f) {
          return f == null || $m(a, f, Rt(f));
        }
        function xn(a, f) {
          return a === f || a !== a && f !== f;
        }
        var AR = la(mc), xR = la(function(a, f) {
          return a >= f;
        }), ri = Gm(/* @__PURE__ */ function() {
          return arguments;
        }()) ? Gm : function(a) {
          return wt(a) && ot.call(a, "callee") && !Mm.call(a, "callee");
        }, Fe = re.isArray, RR = fm ? en(fm) : D1;
        function Gt(a) {
          return a != null && ya(a.length) && !nr(a);
        }
        function Tt(a) {
          return wt(a) && Gt(a);
        }
        function IR(a) {
          return a === !0 || a === !1 || wt(a) && $t(a) == ie;
        }
        var Rr = HE || ef, MR = dm ? en(dm) : F1;
        function kR(a) {
          return wt(a) && a.nodeType === 1 && !Ho(a);
        }
        function PR(a) {
          if (a == null)
            return !0;
          if (Gt(a) && (Fe(a) || typeof a == "string" || typeof a.splice == "function" || Rr(a) || Fi(a) || ri(a)))
            return !a.length;
          var f = Ot(a);
          if (f == ye || f == jt)
            return !a.size;
          if (Bo(a))
            return !vc(a).length;
          for (var v in a)
            if (ot.call(a, v))
              return !1;
          return !0;
        }
        function OR(a, f) {
          return $o(a, f);
        }
        function LR(a, f, v) {
          v = typeof v == "function" ? v : e;
          var E = v ? v(a, f) : e;
          return E === e ? $o(a, f, e, v) : !!E;
        }
        function Gc(a) {
          if (!wt(a))
            return !1;
          var f = $t(a);
          return f == F || f == Ce || typeof a.message == "string" && typeof a.name == "string" && !Ho(a);
        }
        function NR(a) {
          return typeof a == "number" && Pm(a);
        }
        function nr(a) {
          if (!gt(a))
            return !1;
          var f = $t(a);
          return f == q || f == de || f == Z || f == Si;
        }
        function Qg(a) {
          return typeof a == "number" && a == Ue(a);
        }
        function ya(a) {
          return typeof a == "number" && a > -1 && a % 1 == 0 && a <= B;
        }
        function gt(a) {
          var f = typeof a;
          return a != null && (f == "object" || f == "function");
        }
        function wt(a) {
          return a != null && typeof a == "object";
        }
        var Xg = hm ? en(hm) : U1;
        function DR(a, f) {
          return a === f || yc(a, f, Lc(f));
        }
        function FR(a, f, v) {
          return v = typeof v == "function" ? v : e, yc(a, f, Lc(f), v);
        }
        function $R(a) {
          return ey(a) && a != +a;
        }
        function UR(a) {
          if (TA(a))
            throw new Le(o);
          return Wm(a);
        }
        function qR(a) {
          return a === null;
        }
        function BR(a) {
          return a == null;
        }
        function ey(a) {
          return typeof a == "number" || wt(a) && $t(a) == nt;
        }
        function Ho(a) {
          if (!wt(a) || $t(a) != Ve)
            return !1;
          var f = Gs(a);
          if (f === null)
            return !0;
          var v = ot.call(f, "constructor") && f.constructor;
          return typeof v == "function" && v instanceof v && qs.call(v) == FE;
        }
        var Wc = pm ? en(pm) : q1;
        function VR(a) {
          return Qg(a) && a >= -9007199254740991 && a <= B;
        }
        var ty = mm ? en(mm) : B1;
        function va(a) {
          return typeof a == "string" || !Fe(a) && wt(a) && $t(a) == vr;
        }
        function nn(a) {
          return typeof a == "symbol" || wt(a) && $t(a) == _r;
        }
        var Fi = gm ? en(gm) : V1;
        function HR(a) {
          return a === e;
        }
        function GR(a) {
          return wt(a) && Ot(a) == Yn;
        }
        function WR(a) {
          return wt(a) && $t(a) == zr;
        }
        var KR = la(_c), JR = la(function(a, f) {
          return a <= f;
        });
        function ny(a) {
          if (!a)
            return [];
          if (Gt(a))
            return va(a) ? En(a) : Ht(a);
          if (Mo && a[Mo])
            return EE(a[Mo]());
          var f = Ot(a), v = f == ye ? sc : f == jt ? Fs : $i;
          return v(a);
        }
        function rr(a) {
          if (!a)
            return a === 0 ? a : 0;
          if (a = _n(a), a === I || a === -1 / 0) {
            var f = a < 0 ? -1 : 1;
            return f * W;
          }
          return a === a ? a : 0;
        }
        function Ue(a) {
          var f = rr(a), v = f % 1;
          return f === f ? v ? f - v : f : 0;
        }
        function ry(a) {
          return a ? Xr(Ue(a), 0, ee) : 0;
        }
        function _n(a) {
          if (typeof a == "number")
            return a;
          if (nn(a))
            return z;
          if (gt(a)) {
            var f = typeof a.valueOf == "function" ? a.valueOf() : a;
            a = gt(f) ? f + "" : f;
          }
          if (typeof a != "string")
            return a === 0 ? a : +a;
          a = Tm(a);
          var v = RS.test(a);
          return v || MS.test(a) ? lE(a.slice(2), v ? 2 : 8) : xS.test(a) ? z : +a;
        }
        function iy(a) {
          return Fn(a, Wt(a));
        }
        function zR(a) {
          return a ? Xr(Ue(a), -9007199254740991, B) : a === 0 ? a : 0;
        }
        function rt(a) {
          return a == null ? "" : tn(a);
        }
        var YR = Li(function(a, f) {
          if (Bo(f) || Gt(f)) {
            Fn(f, Rt(f), a);
            return;
          }
          for (var v in f)
            ot.call(f, v) && No(a, v, f[v]);
        }), oy = Li(function(a, f) {
          Fn(f, Wt(f), a);
        }), _a = Li(function(a, f, v, E) {
          Fn(f, Wt(f), a, E);
        }), ZR = Li(function(a, f, v, E) {
          Fn(f, Rt(f), a, E);
        }), jR = er(dc);
        function QR(a, f) {
          var v = Oi(a);
          return f == null ? v : Fm(v, f);
        }
        var XR = He(function(a, f) {
          a = lt(a);
          var v = -1, E = f.length, R = E > 2 ? f[2] : e;
          for (R && Ut(f[0], f[1], R) && (E = 1); ++v < E; )
            for (var L = f[v], G = Wt(L), J = -1, X = G.length; ++J < X; ) {
              var ae = G[J], le = a[ae];
              (le === e || xn(le, Mi[ae]) && !ot.call(a, ae)) && (a[ae] = L[ae]);
            }
          return a;
        }), eI = He(function(a) {
          return a.push(e, Tg), Xt(sy, e, a);
        });
        function tI(a, f) {
          return vm(a, Re(f, 3), Dn);
        }
        function nI(a, f) {
          return vm(a, Re(f, 3), pc);
        }
        function rI(a, f) {
          return a == null ? a : hc(a, Re(f, 3), Wt);
        }
        function iI(a, f) {
          return a == null ? a : Vm(a, Re(f, 3), Wt);
        }
        function oI(a, f) {
          return a && Dn(a, Re(f, 3));
        }
        function sI(a, f) {
          return a && pc(a, Re(f, 3));
        }
        function aI(a) {
          return a == null ? [] : ea(a, Rt(a));
        }
        function lI(a) {
          return a == null ? [] : ea(a, Wt(a));
        }
        function Kc(a, f, v) {
          var E = a == null ? e : ei(a, f);
          return E === e ? v : E;
        }
        function uI(a, f) {
          return a != null && Eg(a, f, P1);
        }
        function Jc(a, f) {
          return a != null && Eg(a, f, O1);
        }
        var cI = yg(function(a, f, v) {
          f != null && typeof f.toString != "function" && (f = Bs.call(f)), a[f] = v;
        }, Yc(Kt)), fI = yg(function(a, f, v) {
          f != null && typeof f.toString != "function" && (f = Bs.call(f)), ot.call(a, f) ? a[f].push(v) : a[f] = [v];
        }, Re), dI = He(Fo);
        function Rt(a) {
          return Gt(a) ? Nm(a) : vc(a);
        }
        function Wt(a) {
          return Gt(a) ? Nm(a, !0) : H1(a);
        }
        function hI(a, f) {
          var v = {};
          return f = Re(f, 3), Dn(a, function(E, R, L) {
            Qn(v, f(E, R, L), E);
          }), v;
        }
        function pI(a, f) {
          var v = {};
          return f = Re(f, 3), Dn(a, function(E, R, L) {
            Qn(v, R, f(E, R, L));
          }), v;
        }
        var mI = Li(function(a, f, v) {
          ta(a, f, v);
        }), sy = Li(function(a, f, v, E) {
          ta(a, f, v, E);
        }), gI = er(function(a, f) {
          var v = {};
          if (a == null)
            return v;
          var E = !1;
          f = ht(f, function(L) {
            return L = Ar(L, a), E || (E = L.length > 1), L;
          }), Fn(a, Pc(a), v), E && (v = gn(v, g | y | w, cA));
          for (var R = f.length; R--; )
            Sc(v, f[R]);
          return v;
        });
        function yI(a, f) {
          return ay(a, ga(Re(f)));
        }
        var vI = er(function(a, f) {
          return a == null ? {} : W1(a, f);
        });
        function ay(a, f) {
          if (a == null)
            return {};
          var v = ht(Pc(a), function(E) {
            return [E];
          });
          return f = Re(f), Qm(a, v, function(E, R) {
            return f(E, R[0]);
          });
        }
        function _I(a, f, v) {
          f = Ar(f, a);
          var E = -1, R = f.length;
          for (R || (R = 1, a = e); ++E < R; ) {
            var L = a == null ? e : a[$n(f[E])];
            L === e && (E = R, L = v), a = nr(L) ? L.call(a) : L;
          }
          return a;
        }
        function wI(a, f, v) {
          return a == null ? a : Uo(a, f, v);
        }
        function bI(a, f, v, E) {
          return E = typeof E == "function" ? E : e, a == null ? a : Uo(a, f, v, E);
        }
        var ly = wg(Rt), uy = wg(Wt);
        function TI(a, f, v) {
          var E = Fe(a), R = E || Rr(a) || Fi(a);
          if (f = Re(f, 4), v == null) {
            var L = a && a.constructor;
            R ? v = E ? new L() : [] : gt(a) ? v = nr(L) ? Oi(Gs(a)) : {} : v = {};
          }
          return (R ? hn : Dn)(a, function(G, J, X) {
            return f(v, G, J, X);
          }), v;
        }
        function CI(a, f) {
          return a == null ? !0 : Sc(a, f);
        }
        function SI(a, f, v) {
          return a == null ? a : rg(a, f, xc(v));
        }
        function EI(a, f, v, E) {
          return E = typeof E == "function" ? E : e, a == null ? a : rg(a, f, xc(v), E);
        }
        function $i(a) {
          return a == null ? [] : oc(a, Rt(a));
        }
        function AI(a) {
          return a == null ? [] : oc(a, Wt(a));
        }
        function xI(a, f, v) {
          return v === e && (v = f, f = e), v !== e && (v = _n(v), v = v === v ? v : 0), f !== e && (f = _n(f), f = f === f ? f : 0), Xr(_n(a), f, v);
        }
        function RI(a, f, v) {
          return f = rr(f), v === e ? (v = f, f = 0) : v = rr(v), a = _n(a), L1(a, f, v);
        }
        function II(a, f, v) {
          if (v && typeof v != "boolean" && Ut(a, f, v) && (f = v = e), v === e && (typeof f == "boolean" ? (v = f, f = e) : typeof a == "boolean" && (v = a, a = e)), a === e && f === e ? (a = 0, f = 1) : (a = rr(a), f === e ? (f = a, a = 0) : f = rr(f)), a > f) {
            var E = a;
            a = f, f = E;
          }
          if (v || a % 1 || f % 1) {
            var R = Om();
            return Pt(a + R * (f - a + aE("1e-" + ((R + "").length - 1))), f);
          }
          return bc(a, f);
        }
        var MI = Ni(function(a, f, v) {
          return f = f.toLowerCase(), a + (v ? cy(f) : f);
        });
        function cy(a) {
          return zc(rt(a).toLowerCase());
        }
        function fy(a) {
          return a = rt(a), a && a.replace(PS, wE).replace(jS, "");
        }
        function kI(a, f, v) {
          a = rt(a), f = tn(f);
          var E = a.length;
          v = v === e ? E : Xr(Ue(v), 0, E);
          var R = v;
          return v -= f.length, v >= 0 && a.slice(v, R) == f;
        }
        function PI(a) {
          return a = rt(a), a && dS.test(a) ? a.replace(Vp, bE) : a;
        }
        function OI(a) {
          return a = rt(a), a && vS.test(a) ? a.replace(Hu, "\\$&") : a;
        }
        var LI = Ni(function(a, f, v) {
          return a + (v ? "-" : "") + f.toLowerCase();
        }), NI = Ni(function(a, f, v) {
          return a + (v ? " " : "") + f.toLowerCase();
        }), DI = pg("toLowerCase");
        function FI(a, f, v) {
          a = rt(a), f = Ue(f);
          var E = f ? Ri(a) : 0;
          if (!f || E >= f)
            return a;
          var R = (f - E) / 2;
          return aa(zs(R), v) + a + aa(Js(R), v);
        }
        function $I(a, f, v) {
          a = rt(a), f = Ue(f);
          var E = f ? Ri(a) : 0;
          return f && E < f ? a + aa(f - E, v) : a;
        }
        function UI(a, f, v) {
          a = rt(a), f = Ue(f);
          var E = f ? Ri(a) : 0;
          return f && E < f ? aa(f - E, v) + a : a;
        }
        function qI(a, f, v) {
          return v || f == null ? f = 0 : f && (f = +f), JE(rt(a).replace(Gu, ""), f || 0);
        }
        function BI(a, f, v) {
          return (v ? Ut(a, f, v) : f === e) ? f = 1 : f = Ue(f), Tc(rt(a), f);
        }
        function VI() {
          var a = arguments, f = rt(a[0]);
          return a.length < 3 ? f : f.replace(a[1], a[2]);
        }
        var HI = Ni(function(a, f, v) {
          return a + (v ? "_" : "") + f.toLowerCase();
        });
        function GI(a, f, v) {
          return v && typeof v != "number" && Ut(a, f, v) && (f = v = e), v = v === e ? ee : v >>> 0, v ? (a = rt(a), a && (typeof f == "string" || f != null && !Wc(f)) && (f = tn(f), !f && xi(a)) ? xr(En(a), 0, v) : a.split(f, v)) : [];
        }
        var WI = Ni(function(a, f, v) {
          return a + (v ? " " : "") + zc(f);
        });
        function KI(a, f, v) {
          return a = rt(a), v = v == null ? 0 : Xr(Ue(v), 0, a.length), f = tn(f), a.slice(v, v + f.length) == f;
        }
        function JI(a, f, v) {
          var E = M.templateSettings;
          v && Ut(a, f, v) && (f = e), a = rt(a), f = _a({}, f, E, bg);
          var R = _a({}, f.imports, E.imports, bg), L = Rt(R), G = oc(R, L), J, X, ae = 0, le = f.interpolate || Ps, he = "__p += '", ve = ac(
            (f.escape || Ps).source + "|" + le.source + "|" + (le === Hp ? AS : Ps).source + "|" + (f.evaluate || Ps).source + "|$",
            "g"
          ), Se = "//# sourceURL=" + (ot.call(f, "sourceURL") ? (f.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++nE + "]") + `
`;
          a.replace(ve, function(Me, We, Ze, rn, qt, on) {
            return Ze || (Ze = rn), he += a.slice(ae, on).replace(OS, TE), We && (J = !0, he += `' +
__e(` + We + `) +
'`), qt && (X = !0, he += `';
` + qt + `;
__p += '`), Ze && (he += `' +
((__t = (` + Ze + `)) == null ? '' : __t) +
'`), ae = on + Me.length, Me;
          }), he += `';
`;
          var Ie = ot.call(f, "variable") && f.variable;
          if (!Ie)
            he = `with (obj) {
` + he + `
}
`;
          else if (SS.test(Ie))
            throw new Le(u);
          he = (X ? he.replace(lS, "") : he).replace(uS, "$1").replace(cS, "$1;"), he = "function(" + (Ie || "obj") + `) {
` + (Ie ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (J ? ", __e = _.escape" : "") + (X ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + he + `return __p
}`;
          var Be = hy(function() {
            return et(L, Se + "return " + he).apply(e, G);
          });
          if (Be.source = he, Gc(Be))
            throw Be;
          return Be;
        }
        function zI(a) {
          return rt(a).toLowerCase();
        }
        function YI(a) {
          return rt(a).toUpperCase();
        }
        function ZI(a, f, v) {
          if (a = rt(a), a && (v || f === e))
            return Tm(a);
          if (!a || !(f = tn(f)))
            return a;
          var E = En(a), R = En(f), L = Cm(E, R), G = Sm(E, R) + 1;
          return xr(E, L, G).join("");
        }
        function jI(a, f, v) {
          if (a = rt(a), a && (v || f === e))
            return a.slice(0, Am(a) + 1);
          if (!a || !(f = tn(f)))
            return a;
          var E = En(a), R = Sm(E, En(f)) + 1;
          return xr(E, 0, R).join("");
        }
        function QI(a, f, v) {
          if (a = rt(a), a && (v || f === e))
            return a.replace(Gu, "");
          if (!a || !(f = tn(f)))
            return a;
          var E = En(a), R = Cm(E, En(f));
          return xr(E, R).join("");
        }
        function XI(a, f) {
          var v = H, E = V;
          if (gt(f)) {
            var R = "separator" in f ? f.separator : R;
            v = "length" in f ? Ue(f.length) : v, E = "omission" in f ? tn(f.omission) : E;
          }
          a = rt(a);
          var L = a.length;
          if (xi(a)) {
            var G = En(a);
            L = G.length;
          }
          if (v >= L)
            return a;
          var J = v - Ri(E);
          if (J < 1)
            return E;
          var X = G ? xr(G, 0, J).join("") : a.slice(0, J);
          if (R === e)
            return X + E;
          if (G && (J += X.length - J), Wc(R)) {
            if (a.slice(J).search(R)) {
              var ae, le = X;
              for (R.global || (R = ac(R.source, rt(Gp.exec(R)) + "g")), R.lastIndex = 0; ae = R.exec(le); )
                var he = ae.index;
              X = X.slice(0, he === e ? J : he);
            }
          } else if (a.indexOf(tn(R), J) != J) {
            var ve = X.lastIndexOf(R);
            ve > -1 && (X = X.slice(0, ve));
          }
          return X + E;
        }
        function eM(a) {
          return a = rt(a), a && fS.test(a) ? a.replace(Bp, IE) : a;
        }
        var tM = Ni(function(a, f, v) {
          return a + (v ? " " : "") + f.toUpperCase();
        }), zc = pg("toUpperCase");
        function dy(a, f, v) {
          return a = rt(a), f = v ? e : f, f === e ? SE(a) ? PE(a) : mE(a) : a.match(f) || [];
        }
        var hy = He(function(a, f) {
          try {
            return Xt(a, e, f);
          } catch (v) {
            return Gc(v) ? v : new Le(v);
          }
        }), nM = er(function(a, f) {
          return hn(f, function(v) {
            v = $n(v), Qn(a, v, Vc(a[v], a));
          }), a;
        });
        function rM(a) {
          var f = a == null ? 0 : a.length, v = Re();
          return a = f ? ht(a, function(E) {
            if (typeof E[1] != "function")
              throw new pn(s);
            return [v(E[0]), E[1]];
          }) : [], He(function(E) {
            for (var R = -1; ++R < f; ) {
              var L = a[R];
              if (Xt(L[0], this, E))
                return Xt(L[1], this, E);
            }
          });
        }
        function iM(a) {
          return I1(gn(a, g));
        }
        function Yc(a) {
          return function() {
            return a;
          };
        }
        function oM(a, f) {
          return a == null || a !== a ? f : a;
        }
        var sM = gg(), aM = gg(!0);
        function Kt(a) {
          return a;
        }
        function Zc(a) {
          return Km(typeof a == "function" ? a : gn(a, g));
        }
        function lM(a) {
          return zm(gn(a, g));
        }
        function uM(a, f) {
          return Ym(a, gn(f, g));
        }
        var cM = He(function(a, f) {
          return function(v) {
            return Fo(v, a, f);
          };
        }), fM = He(function(a, f) {
          return function(v) {
            return Fo(a, v, f);
          };
        });
        function jc(a, f, v) {
          var E = Rt(f), R = ea(f, E);
          v == null && !(gt(f) && (R.length || !E.length)) && (v = f, f = a, a = this, R = ea(f, Rt(f)));
          var L = !(gt(v) && "chain" in v) || !!v.chain, G = nr(a);
          return hn(R, function(J) {
            var X = f[J];
            a[J] = X, G && (a.prototype[J] = function() {
              var ae = this.__chain__;
              if (L || ae) {
                var le = a(this.__wrapped__), he = le.__actions__ = Ht(this.__actions__);
                return he.push({ func: X, args: arguments, thisArg: a }), le.__chain__ = ae, le;
              }
              return X.apply(a, br([this.value()], arguments));
            });
          }), a;
        }
        function dM() {
          return Mt._ === this && (Mt._ = $E), this;
        }
        function Qc() {
        }
        function hM(a) {
          return a = Ue(a), He(function(f) {
            return Zm(f, a);
          });
        }
        var pM = Ic(ht), mM = Ic(ym), gM = Ic(ec);
        function py(a) {
          return Dc(a) ? tc($n(a)) : K1(a);
        }
        function yM(a) {
          return function(f) {
            return a == null ? e : ei(a, f);
          };
        }
        var vM = vg(), _M = vg(!0);
        function Xc() {
          return [];
        }
        function ef() {
          return !1;
        }
        function wM() {
          return {};
        }
        function bM() {
          return "";
        }
        function TM() {
          return !0;
        }
        function CM(a, f) {
          if (a = Ue(a), a < 1 || a > B)
            return [];
          var v = ee, E = Pt(a, ee);
          f = Re(f), a -= ee;
          for (var R = ic(E, f); ++v < a; )
            f(v);
          return R;
        }
        function SM(a) {
          return Fe(a) ? ht(a, $n) : nn(a) ? [a] : Ht(Lg(rt(a)));
        }
        function EM(a) {
          var f = ++DE;
          return rt(a) + f;
        }
        var AM = sa(function(a, f) {
          return a + f;
        }, 0), xM = Mc("ceil"), RM = sa(function(a, f) {
          return a / f;
        }, 1), IM = Mc("floor");
        function MM(a) {
          return a && a.length ? Xs(a, Kt, mc) : e;
        }
        function kM(a, f) {
          return a && a.length ? Xs(a, Re(f, 2), mc) : e;
        }
        function PM(a) {
          return wm(a, Kt);
        }
        function OM(a, f) {
          return wm(a, Re(f, 2));
        }
        function LM(a) {
          return a && a.length ? Xs(a, Kt, _c) : e;
        }
        function NM(a, f) {
          return a && a.length ? Xs(a, Re(f, 2), _c) : e;
        }
        var DM = sa(function(a, f) {
          return a * f;
        }, 1), FM = Mc("round"), $M = sa(function(a, f) {
          return a - f;
        }, 0);
        function UM(a) {
          return a && a.length ? rc(a, Kt) : 0;
        }
        function qM(a, f) {
          return a && a.length ? rc(a, Re(f, 2)) : 0;
        }
        return M.after = lR, M.ary = Wg, M.assign = YR, M.assignIn = oy, M.assignInWith = _a, M.assignWith = ZR, M.at = jR, M.before = Kg, M.bind = Vc, M.bindAll = nM, M.bindKey = Jg, M.castArray = wR, M.chain = Vg, M.chunk = IA, M.compact = MA, M.concat = kA, M.cond = rM, M.conforms = iM, M.constant = Yc, M.countBy = Ux, M.create = QR, M.curry = zg, M.curryRight = Yg, M.debounce = Zg, M.defaults = XR, M.defaultsDeep = eI, M.defer = uR, M.delay = cR, M.difference = PA, M.differenceBy = OA, M.differenceWith = LA, M.drop = NA, M.dropRight = DA, M.dropRightWhile = FA, M.dropWhile = $A, M.fill = UA, M.filter = Bx, M.flatMap = Gx, M.flatMapDeep = Wx, M.flatMapDepth = Kx, M.flatten = $g, M.flattenDeep = qA, M.flattenDepth = BA, M.flip = fR, M.flow = sM, M.flowRight = aM, M.fromPairs = VA, M.functions = aI, M.functionsIn = lI, M.groupBy = Jx, M.initial = GA, M.intersection = WA, M.intersectionBy = KA, M.intersectionWith = JA, M.invert = cI, M.invertBy = fI, M.invokeMap = Yx, M.iteratee = Zc, M.keyBy = Zx, M.keys = Rt, M.keysIn = Wt, M.map = ha, M.mapKeys = hI, M.mapValues = pI, M.matches = lM, M.matchesProperty = uM, M.memoize = ma, M.merge = mI, M.mergeWith = sy, M.method = cM, M.methodOf = fM, M.mixin = jc, M.negate = ga, M.nthArg = hM, M.omit = gI, M.omitBy = yI, M.once = dR, M.orderBy = jx, M.over = pM, M.overArgs = hR, M.overEvery = mM, M.overSome = gM, M.partial = Hc, M.partialRight = jg, M.partition = Qx, M.pick = vI, M.pickBy = ay, M.property = py, M.propertyOf = yM, M.pull = jA, M.pullAll = qg, M.pullAllBy = QA, M.pullAllWith = XA, M.pullAt = ex, M.range = vM, M.rangeRight = _M, M.rearg = pR, M.reject = tR, M.remove = tx, M.rest = mR, M.reverse = qc, M.sampleSize = rR, M.set = wI, M.setWith = bI, M.shuffle = iR, M.slice = nx, M.sortBy = aR, M.sortedUniq = ux, M.sortedUniqBy = cx, M.split = GI, M.spread = gR, M.tail = fx, M.take = dx, M.takeRight = hx, M.takeRightWhile = px, M.takeWhile = mx, M.tap = Mx, M.throttle = yR, M.thru = da, M.toArray = ny, M.toPairs = ly, M.toPairsIn = uy, M.toPath = SM, M.toPlainObject = iy, M.transform = TI, M.unary = vR, M.union = gx, M.unionBy = yx, M.unionWith = vx, M.uniq = _x, M.uniqBy = wx, M.uniqWith = bx, M.unset = CI, M.unzip = Bc, M.unzipWith = Bg, M.update = SI, M.updateWith = EI, M.values = $i, M.valuesIn = AI, M.without = Tx, M.words = dy, M.wrap = _R, M.xor = Cx, M.xorBy = Sx, M.xorWith = Ex, M.zip = Ax, M.zipObject = xx, M.zipObjectDeep = Rx, M.zipWith = Ix, M.entries = ly, M.entriesIn = uy, M.extend = oy, M.extendWith = _a, jc(M, M), M.add = AM, M.attempt = hy, M.camelCase = MI, M.capitalize = cy, M.ceil = xM, M.clamp = xI, M.clone = bR, M.cloneDeep = CR, M.cloneDeepWith = SR, M.cloneWith = TR, M.conformsTo = ER, M.deburr = fy, M.defaultTo = oM, M.divide = RM, M.endsWith = kI, M.eq = xn, M.escape = PI, M.escapeRegExp = OI, M.every = qx, M.find = Vx, M.findIndex = Dg, M.findKey = tI, M.findLast = Hx, M.findLastIndex = Fg, M.findLastKey = nI, M.floor = IM, M.forEach = Hg, M.forEachRight = Gg, M.forIn = rI, M.forInRight = iI, M.forOwn = oI, M.forOwnRight = sI, M.get = Kc, M.gt = AR, M.gte = xR, M.has = uI, M.hasIn = Jc, M.head = Ug, M.identity = Kt, M.includes = zx, M.indexOf = HA, M.inRange = RI, M.invoke = dI, M.isArguments = ri, M.isArray = Fe, M.isArrayBuffer = RR, M.isArrayLike = Gt, M.isArrayLikeObject = Tt, M.isBoolean = IR, M.isBuffer = Rr, M.isDate = MR, M.isElement = kR, M.isEmpty = PR, M.isEqual = OR, M.isEqualWith = LR, M.isError = Gc, M.isFinite = NR, M.isFunction = nr, M.isInteger = Qg, M.isLength = ya, M.isMap = Xg, M.isMatch = DR, M.isMatchWith = FR, M.isNaN = $R, M.isNative = UR, M.isNil = BR, M.isNull = qR, M.isNumber = ey, M.isObject = gt, M.isObjectLike = wt, M.isPlainObject = Ho, M.isRegExp = Wc, M.isSafeInteger = VR, M.isSet = ty, M.isString = va, M.isSymbol = nn, M.isTypedArray = Fi, M.isUndefined = HR, M.isWeakMap = GR, M.isWeakSet = WR, M.join = zA, M.kebabCase = LI, M.last = vn, M.lastIndexOf = YA, M.lowerCase = NI, M.lowerFirst = DI, M.lt = KR, M.lte = JR, M.max = MM, M.maxBy = kM, M.mean = PM, M.meanBy = OM, M.min = LM, M.minBy = NM, M.stubArray = Xc, M.stubFalse = ef, M.stubObject = wM, M.stubString = bM, M.stubTrue = TM, M.multiply = DM, M.nth = ZA, M.noConflict = dM, M.noop = Qc, M.now = pa, M.pad = FI, M.padEnd = $I, M.padStart = UI, M.parseInt = qI, M.random = II, M.reduce = Xx, M.reduceRight = eR, M.repeat = BI, M.replace = VI, M.result = _I, M.round = FM, M.runInContext = Q, M.sample = nR, M.size = oR, M.snakeCase = HI, M.some = sR, M.sortedIndex = rx, M.sortedIndexBy = ix, M.sortedIndexOf = ox, M.sortedLastIndex = sx, M.sortedLastIndexBy = ax, M.sortedLastIndexOf = lx, M.startCase = WI, M.startsWith = KI, M.subtract = $M, M.sum = UM, M.sumBy = qM, M.template = JI, M.times = CM, M.toFinite = rr, M.toInteger = Ue, M.toLength = ry, M.toLower = zI, M.toNumber = _n, M.toSafeInteger = zR, M.toString = rt, M.toUpper = YI, M.trim = ZI, M.trimEnd = jI, M.trimStart = QI, M.truncate = XI, M.unescape = eM, M.uniqueId = EM, M.upperCase = tM, M.upperFirst = zc, M.each = Hg, M.eachRight = Gg, M.first = Ug, jc(M, function() {
          var a = {};
          return Dn(M, function(f, v) {
            ot.call(M.prototype, v) || (a[v] = f);
          }), a;
        }(), { chain: !1 }), M.VERSION = n, hn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(a) {
          M[a].placeholder = M;
        }), hn(["drop", "take"], function(a, f) {
          ze.prototype[a] = function(v) {
            v = v === e ? 1 : At(Ue(v), 0);
            var E = this.__filtered__ && !f ? new ze(this) : this.clone();
            return E.__filtered__ ? E.__takeCount__ = Pt(v, E.__takeCount__) : E.__views__.push({
              size: Pt(v, ee),
              type: a + (E.__dir__ < 0 ? "Right" : "")
            }), E;
          }, ze.prototype[a + "Right"] = function(v) {
            return this.reverse()[a](v).reverse();
          };
        }), hn(["filter", "map", "takeWhile"], function(a, f) {
          var v = f + 1, E = v == j || v == P;
          ze.prototype[a] = function(R) {
            var L = this.clone();
            return L.__iteratees__.push({
              iteratee: Re(R, 3),
              type: v
            }), L.__filtered__ = L.__filtered__ || E, L;
          };
        }), hn(["head", "last"], function(a, f) {
          var v = "take" + (f ? "Right" : "");
          ze.prototype[a] = function() {
            return this[v](1).value()[0];
          };
        }), hn(["initial", "tail"], function(a, f) {
          var v = "drop" + (f ? "" : "Right");
          ze.prototype[a] = function() {
            return this.__filtered__ ? new ze(this) : this[v](1);
          };
        }), ze.prototype.compact = function() {
          return this.filter(Kt);
        }, ze.prototype.find = function(a) {
          return this.filter(a).head();
        }, ze.prototype.findLast = function(a) {
          return this.reverse().find(a);
        }, ze.prototype.invokeMap = He(function(a, f) {
          return typeof a == "function" ? new ze(this) : this.map(function(v) {
            return Fo(v, a, f);
          });
        }), ze.prototype.reject = function(a) {
          return this.filter(ga(Re(a)));
        }, ze.prototype.slice = function(a, f) {
          a = Ue(a);
          var v = this;
          return v.__filtered__ && (a > 0 || f < 0) ? new ze(v) : (a < 0 ? v = v.takeRight(-a) : a && (v = v.drop(a)), f !== e && (f = Ue(f), v = f < 0 ? v.dropRight(-f) : v.take(f - a)), v);
        }, ze.prototype.takeRightWhile = function(a) {
          return this.reverse().takeWhile(a).reverse();
        }, ze.prototype.toArray = function() {
          return this.take(ee);
        }, Dn(ze.prototype, function(a, f) {
          var v = /^(?:filter|find|map|reject)|While$/.test(f), E = /^(?:head|last)$/.test(f), R = M[E ? "take" + (f == "last" ? "Right" : "") : f], L = E || /^find/.test(f);
          R && (M.prototype[f] = function() {
            var G = this.__wrapped__, J = E ? [1] : arguments, X = G instanceof ze, ae = J[0], le = X || Fe(G), he = function(We) {
              var Ze = R.apply(M, br([We], J));
              return E && ve ? Ze[0] : Ze;
            };
            le && v && typeof ae == "function" && ae.length != 1 && (X = le = !1);
            var ve = this.__chain__, Se = !!this.__actions__.length, Ie = L && !ve, Be = X && !Se;
            if (!L && le) {
              G = Be ? G : new ze(this);
              var Me = a.apply(G, J);
              return Me.__actions__.push({ func: da, args: [he], thisArg: e }), new mn(Me, ve);
            }
            return Ie && Be ? a.apply(this, J) : (Me = this.thru(he), Ie ? E ? Me.value()[0] : Me.value() : Me);
          });
        }), hn(["pop", "push", "shift", "sort", "splice", "unshift"], function(a) {
          var f = $s[a], v = /^(?:push|sort|unshift)$/.test(a) ? "tap" : "thru", E = /^(?:pop|shift)$/.test(a);
          M.prototype[a] = function() {
            var R = arguments;
            if (E && !this.__chain__) {
              var L = this.value();
              return f.apply(Fe(L) ? L : [], R);
            }
            return this[v](function(G) {
              return f.apply(Fe(G) ? G : [], R);
            });
          };
        }), Dn(ze.prototype, function(a, f) {
          var v = M[f];
          if (v) {
            var E = v.name + "";
            ot.call(Pi, E) || (Pi[E] = []), Pi[E].push({ name: f, func: v });
          }
        }), Pi[oa(e, m).name] = [{
          name: "wrapper",
          func: e
        }], ze.prototype.clone = e1, ze.prototype.reverse = t1, ze.prototype.value = n1, M.prototype.at = kx, M.prototype.chain = Px, M.prototype.commit = Ox, M.prototype.next = Lx, M.prototype.plant = Dx, M.prototype.reverse = Fx, M.prototype.toJSON = M.prototype.valueOf = M.prototype.value = $x, M.prototype.first = M.prototype.head, Mo && (M.prototype[Mo] = Nx), M;
      }, Ii = OE();
      Yr ? ((Yr.exports = Ii)._ = Ii, Zu._ = Ii) : Mt._ = Ii;
    }).call(Mq);
  }(ns, ns.exports)), ns.exports;
}
var m4 = kq();
const Pq = {
  fromNativeThread(r) {
    const t = [];
    for (const e of r.messages)
      switch (e.role) {
        case "user": {
          const n = qq(e);
          if (n.length === 0)
            continue;
          t.push({
            role: "user",
            parts: n
          });
          break;
        }
        case "assistant": {
          const n = e.content.filter(
            (s) => !(s.type === "tool_use" && s.inputPartialJSON || s.type === "server_tool_use" || s.type === "web_search_tool_result")
          ), i = os(r);
          for (const s of n)
            if (s.type === "tool_use" && !i.get(s.id)?.run)
              throw new Error(
                `(bug) corresponding tool_result not found for tool_use (id=${s.id}, name=${s.name})`
              );
          if (n.length === 0)
            break;
          const o = Bq(n);
          o.length > 0 && t.push({
            role: "model",
            parts: o
          });
          break;
        }
      }
    return t;
  },
  toNativeThread(r) {
    return { messages: [] };
  }
}, Zv = "gemini-2.5-pro-preview-05-06", Oq = 1048576, Lq = 65535;
async function* Nq(r, t, e, n, i) {
  const o = await it(wn, i);
  i?.throwIfAborted();
  const s = await Uq(o, { threadID: n });
  i?.throwIfAborted();
  const u = r.pop();
  if (u?.role !== "user")
    throw oe.warn("expected last message to be a user message", u), new Error("expected last message to be a user message");
  const l = Dq(t), c = {
    model: Zv,
    history: r,
    config: {
      thinkingConfig: {
        includeThoughts: !0
      }
    }
  }, d = await s.chats.create(c), g = {
    message: u.parts ?? [],
    config: {
      tools: [l],
      systemInstruction: e,
      maxOutputTokens: Lq,
      thinkingConfig: {
        includeThoughts: !0
      }
    }
  }, y = await d.sendMessageStream(g), w = [];
  for await (const _ of y)
    w.push(_), yield _;
  const b = w.at(-1);
  return {
    "~debugParamsUsed": {
      model: Zv,
      chatParams: c,
      messageParams: g,
      streamedMessages: w
    },
    "~debugUsage": {
      maxInputTokens: Oq,
      inputTokens: b?.usageMetadata?.promptTokenCount ?? 0,
      outputTokens: (b?.usageMetadata?.candidatesTokenCount ?? 0) + (b?.usageMetadata?.thoughtsTokenCount ?? 0),
      totalInputTokens: b?.usageMetadata?.promptTokenCount ?? 0,
      cacheCreationInputTokens: 0,
      cacheReadInputTokens: 0
    }
  };
}
function Dq(r) {
  return {
    functionDeclarations: [...r.map(Fq)]
  };
}
function Fq(r) {
  return {
    name: r.name,
    description: r.description ?? "",
    parameters: Oh(r.inputSchema)
  };
}
const $q = {
  string: Lt.STRING,
  number: Lt.NUMBER,
  integer: Lt.INTEGER,
  boolean: Lt.BOOLEAN,
  object: Lt.OBJECT,
  array: Lt.ARRAY
};
function Oh(r) {
  const t = {}, e = $q[r.type ?? "any"];
  return e && (t.type = e), r.description && (t.description = r.description), r.required && (t.required = r.required), r.properties && (t.properties = Object.fromEntries(
    Object.entries(r.properties).map(([n, i]) => [
      n,
      Oh(i)
    ])
  )), r.items && (t.items = Oh(r.items)), t;
}
async function Uq(r, t) {
  const { settings: e, secrets: n } = r, { url: i } = e, o = await n.getToken("apiKey", i);
  if (!o)
    throw new Error("API key not found. You must provide an API key in settings.");
  return new Iq({
    apiKey: "",
    vertexai: !0,
    httpOptions: {
      baseUrl: new URL("/api/provider/google", i).toString(),
      headers: {
        Authorization: "Bearer " + o,
        [YM]: t?.threadID || ""
      }
    }
  });
}
function qq(r) {
  const t = [];
  r.fileMentions && r.fileMentions.files.length > 0 && t.push({ text: JM(r.fileMentions) }), r.userState && t.push({ text: zM(r.userState) });
  for (const e of r.content)
    if (e.type === "text")
      t.push({ text: e.text });
    else if (e.type === "image")
      e.source.type === "base64" && "mediaType" in e.source && "data" in e.source ? t.push({
        inlineData: {
          mimeType: e.source.mediaType,
          data: e.source.data
        }
      }) : e.source.type === "url" && "url" in e.source && t.push({ text: `[Image URL: ${e.source.url}]` });
    else if (e.type === "tool_result") {
      const n = {};
      e.run.status === "done" ? n.output = e.run.result : e.run.status === "error" ? n.error = e.run.error?.message ?? "Error executing tool" : n.error = `Tool status: ${e.run.status}`;
      const [, i] = e.toolUseID.split("__"), o = {
        name: i,
        response: n
      };
      t.push({ functionResponse: o });
    }
  return t;
}
function Bq(r) {
  const t = [];
  for (const e of r)
    e.type === "text" ? t.push({ text: e.text }) : e.type === "tool_use" ? t.push({
      functionCall: {
        name: e.name,
        args: e.input ?? {}
      }
    }) : e.type === "thinking" ? t.push({ text: e.thinking, thought: !0 }) : e.type === "redacted_thinking" && t.push({ text: "[Redacted thinking]" });
  return t;
}
const pp = Symbol.for("yaml.alias"), Lh = Symbol.for("yaml.document"), Ur = Symbol.for("yaml.map"), wT = Symbol.for("yaml.pair"), Kn = Symbol.for("yaml.scalar"), _o = Symbol.for("yaml.seq"), Tn = Symbol.for("yaml.node.type"), bi = (r) => !!r && typeof r == "object" && r[Tn] === pp, Ti = (r) => !!r && typeof r == "object" && r[Tn] === Lh, wo = (r) => !!r && typeof r == "object" && r[Tn] === Ur, mt = (r) => !!r && typeof r == "object" && r[Tn] === wT, ut = (r) => !!r && typeof r == "object" && r[Tn] === Kn, bo = (r) => !!r && typeof r == "object" && r[Tn] === _o;
function vt(r) {
  if (r && typeof r == "object")
    switch (r[Tn]) {
      case Ur:
      case _o:
        return !0;
    }
  return !1;
}
function _t(r) {
  if (r && typeof r == "object")
    switch (r[Tn]) {
      case pp:
      case Ur:
      case Kn:
      case _o:
        return !0;
    }
  return !1;
}
const Vq = (r) => (ut(r) || vt(r)) && !!r.anchor, Yt = Symbol("break visit"), bT = Symbol("skip children"), Hn = Symbol("remove node");
function Vr(r, t) {
  const e = TT(t);
  Ti(r) ? ji(null, r.contents, e, Object.freeze([r])) === Hn && (r.contents = null) : ji(null, r, e, Object.freeze([]));
}
Vr.BREAK = Yt;
Vr.SKIP = bT;
Vr.REMOVE = Hn;
function ji(r, t, e, n) {
  const i = CT(r, t, e, n);
  if (_t(i) || mt(i))
    return ST(r, n, i), ji(r, i, e, n);
  if (typeof i != "symbol") {
    if (vt(t)) {
      n = Object.freeze(n.concat(t));
      for (let o = 0; o < t.items.length; ++o) {
        const s = ji(o, t.items[o], e, n);
        if (typeof s == "number")
          o = s - 1;
        else {
          if (s === Yt)
            return Yt;
          s === Hn && (t.items.splice(o, 1), o -= 1);
        }
      }
    } else if (mt(t)) {
      n = Object.freeze(n.concat(t));
      const o = ji("key", t.key, e, n);
      if (o === Yt)
        return Yt;
      o === Hn && (t.key = null);
      const s = ji("value", t.value, e, n);
      if (s === Yt)
        return Yt;
      s === Hn && (t.value = null);
    }
  }
  return i;
}
async function mu(r, t) {
  const e = TT(t);
  Ti(r) ? await Qi(null, r.contents, e, Object.freeze([r])) === Hn && (r.contents = null) : await Qi(null, r, e, Object.freeze([]));
}
mu.BREAK = Yt;
mu.SKIP = bT;
mu.REMOVE = Hn;
async function Qi(r, t, e, n) {
  const i = await CT(r, t, e, n);
  if (_t(i) || mt(i))
    return ST(r, n, i), Qi(r, i, e, n);
  if (typeof i != "symbol") {
    if (vt(t)) {
      n = Object.freeze(n.concat(t));
      for (let o = 0; o < t.items.length; ++o) {
        const s = await Qi(o, t.items[o], e, n);
        if (typeof s == "number")
          o = s - 1;
        else {
          if (s === Yt)
            return Yt;
          s === Hn && (t.items.splice(o, 1), o -= 1);
        }
      }
    } else if (mt(t)) {
      n = Object.freeze(n.concat(t));
      const o = await Qi("key", t.key, e, n);
      if (o === Yt)
        return Yt;
      o === Hn && (t.key = null);
      const s = await Qi("value", t.value, e, n);
      if (s === Yt)
        return Yt;
      s === Hn && (t.value = null);
    }
  }
  return i;
}
function TT(r) {
  return typeof r == "object" && (r.Collection || r.Node || r.Value) ? Object.assign({
    Alias: r.Node,
    Map: r.Node,
    Scalar: r.Node,
    Seq: r.Node
  }, r.Value && {
    Map: r.Value,
    Scalar: r.Value,
    Seq: r.Value
  }, r.Collection && {
    Map: r.Collection,
    Seq: r.Collection
  }, r) : r;
}
function CT(r, t, e, n) {
  if (typeof e == "function")
    return e(r, t, n);
  if (wo(t))
    return e.Map?.(r, t, n);
  if (bo(t))
    return e.Seq?.(r, t, n);
  if (mt(t))
    return e.Pair?.(r, t, n);
  if (ut(t))
    return e.Scalar?.(r, t, n);
  if (bi(t))
    return e.Alias?.(r, t, n);
}
function ST(r, t, e) {
  const n = t[t.length - 1];
  if (vt(n))
    n.items[r] = e;
  else if (mt(n))
    r === "key" ? n.key = e : n.value = e;
  else if (Ti(n))
    n.contents = e;
  else {
    const i = bi(n) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
const Hq = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, Gq = (r) => r.replace(/[!,[\]{}]/g, (t) => Hq[t]);
class Bt {
  constructor(t, e) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Bt.defaultYaml, t), this.tags = Object.assign({}, Bt.defaultTags, e);
  }
  clone() {
    const t = new Bt(this.yaml, this.tags);
    return t.docStart = this.docStart, t;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const t = new Bt(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Bt.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Bt.defaultTags);
        break;
    }
    return t;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(t, e) {
    this.atNextDocument && (this.yaml = { explicit: Bt.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Bt.defaultTags), this.atNextDocument = !1);
    const n = t.trim().split(/[ \t]+/), i = n.shift();
    switch (i) {
      case "%TAG": {
        if (n.length !== 2 && (e(0, "%TAG directive should contain exactly two parts"), n.length < 2))
          return !1;
        const [o, s] = n;
        return this.tags[o] = s, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, n.length !== 1)
          return e(0, "%YAML directive should contain exactly one part"), !1;
        const [o] = n;
        if (o === "1.1" || o === "1.2")
          return this.yaml.version = o, !0;
        {
          const s = /^\d+\.\d+$/.test(o);
          return e(6, `Unsupported YAML version ${o}`, s), !1;
        }
      }
      default:
        return e(0, `Unknown directive ${i}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(t, e) {
    if (t === "!")
      return "!";
    if (t[0] !== "!")
      return e(`Not a valid tag: ${t}`), null;
    if (t[1] === "<") {
      const s = t.slice(2, -1);
      return s === "!" || s === "!!" ? (e(`Verbatim tags aren't resolved, so ${t} is invalid.`), null) : (t[t.length - 1] !== ">" && e("Verbatim tags must end with a >"), s);
    }
    const [, n, i] = t.match(/^(.*!)([^!]*)$/s);
    i || e(`The ${t} tag has no suffix`);
    const o = this.tags[n];
    if (o)
      try {
        return o + decodeURIComponent(i);
      } catch (s) {
        return e(String(s)), null;
      }
    return n === "!" ? t : (e(`Could not resolve tag: ${t}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(t) {
    for (const [e, n] of Object.entries(this.tags))
      if (t.startsWith(n))
        return e + Gq(t.substring(n.length));
    return t[0] === "!" ? t : `!<${t}>`;
  }
  toString(t) {
    const e = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags);
    let i;
    if (t && n.length > 0 && _t(t.contents)) {
      const o = {};
      Vr(t.contents, (s, u) => {
        _t(u) && u.tag && (o[u.tag] = !0);
      }), i = Object.keys(o);
    } else
      i = [];
    for (const [o, s] of n)
      o === "!!" && s === "tag:yaml.org,2002:" || (!t || i.some((u) => u.startsWith(s))) && e.push(`%TAG ${o} ${s}`);
    return e.join(`
`);
  }
}
Bt.defaultYaml = { explicit: !1, version: "1.2" };
Bt.defaultTags = { "!!": "tag:yaml.org,2002:" };
function ET(r) {
  if (/[\x00-\x19\s,[\]{}]/.test(r)) {
    const e = `Anchor must not contain whitespace or control characters: ${JSON.stringify(r)}`;
    throw new Error(e);
  }
  return !0;
}
function AT(r) {
  const t = /* @__PURE__ */ new Set();
  return Vr(r, {
    Value(e, n) {
      n.anchor && t.add(n.anchor);
    }
  }), t;
}
function xT(r, t) {
  for (let e = 1; ; ++e) {
    const n = `${r}${e}`;
    if (!t.has(n))
      return n;
  }
}
function Wq(r, t) {
  const e = [], n = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (o) => {
      e.push(o), i || (i = AT(r));
      const s = xT(t, i);
      return i.add(s), s;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const o of e) {
        const s = n.get(o);
        if (typeof s == "object" && s.anchor && (ut(s.node) || vt(s.node)))
          s.node.anchor = s.anchor;
        else {
          const u = new Error("Failed to resolve repeated object (this should not happen)");
          throw u.source = o, u;
        }
      }
    },
    sourceObjects: n
  };
}
function Xi(r, t, e, n) {
  if (n && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0, o = n.length; i < o; ++i) {
        const s = n[i], u = Xi(r, n, String(i), s);
        u === void 0 ? delete n[i] : u !== s && (n[i] = u);
      }
    else if (n instanceof Map)
      for (const i of Array.from(n.keys())) {
        const o = n.get(i), s = Xi(r, n, i, o);
        s === void 0 ? n.delete(i) : s !== o && n.set(i, s);
      }
    else if (n instanceof Set)
      for (const i of Array.from(n)) {
        const o = Xi(r, n, i, i);
        o === void 0 ? n.delete(i) : o !== i && (n.delete(i), n.add(o));
      }
    else
      for (const [i, o] of Object.entries(n)) {
        const s = Xi(r, n, i, o);
        s === void 0 ? delete n[i] : s !== o && (n[i] = s);
      }
  return r.call(t, e, n);
}
function bn(r, t, e) {
  if (Array.isArray(r))
    return r.map((n, i) => bn(n, String(i), e));
  if (r && typeof r.toJSON == "function") {
    if (!e || !Vq(r))
      return r.toJSON(t, e);
    const n = { aliasCount: 0, count: 1, res: void 0 };
    e.anchors.set(r, n), e.onCreate = (o) => {
      n.res = o, delete e.onCreate;
    };
    const i = r.toJSON(t, e);
    return e.onCreate && e.onCreate(i), i;
  }
  return typeof r == "bigint" && !e?.keep ? Number(r) : r;
}
class mp {
  constructor(t) {
    Object.defineProperty(this, Tn, { value: t });
  }
  /** Create a copy of this node.  */
  clone() {
    const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (t.range = this.range.slice()), t;
  }
  /** A plain JavaScript representation of this node. */
  toJS(t, { mapAsMap: e, maxAliasCount: n, onAnchor: i, reviver: o } = {}) {
    if (!Ti(t))
      throw new TypeError("A document argument is required");
    const s = {
      anchors: /* @__PURE__ */ new Map(),
      doc: t,
      keep: !0,
      mapAsMap: e === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof n == "number" ? n : 100
    }, u = bn(this, "", s);
    if (typeof i == "function")
      for (const { count: l, res: c } of s.anchors.values())
        i(c, l);
    return typeof o == "function" ? Xi(o, { "": u }, "", u) : u;
  }
}
class gu extends mp {
  constructor(t) {
    super(pp), this.source = t, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(t) {
    let e;
    return Vr(t, {
      Node: (n, i) => {
        if (i === this)
          return Vr.BREAK;
        i.anchor === this.source && (e = i);
      }
    }), e;
  }
  toJSON(t, e) {
    if (!e)
      return { source: this.source };
    const { anchors: n, doc: i, maxAliasCount: o } = e, s = this.resolve(i);
    if (!s) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let u = n.get(s);
    if (u || (bn(s, null, e), u = n.get(s)), !u || u.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (o >= 0 && (u.count += 1, u.aliasCount === 0 && (u.aliasCount = Cl(i, s, n)), u.count * u.aliasCount > o)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return u.res;
  }
  toString(t, e, n) {
    const i = `*${this.source}`;
    if (t) {
      if (ET(this.source), t.options.verifyAliasOrder && !t.anchors.has(this.source)) {
        const o = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(o);
      }
      if (t.implicitKey)
        return `${i} `;
    }
    return i;
  }
}
function Cl(r, t, e) {
  if (bi(t)) {
    const n = t.resolve(r), i = e && n && e.get(n);
    return i ? i.count * i.aliasCount : 0;
  } else if (vt(t)) {
    let n = 0;
    for (const i of t.items) {
      const o = Cl(r, i, e);
      o > n && (n = o);
    }
    return n;
  } else if (mt(t)) {
    const n = Cl(r, t.key, e), i = Cl(r, t.value, e);
    return Math.max(n, i);
  }
  return 1;
}
const RT = (r) => !r || typeof r != "function" && typeof r != "object";
class De extends mp {
  constructor(t) {
    super(Kn), this.value = t;
  }
  toJSON(t, e) {
    return e?.keep ? this.value : bn(this.value, t, e);
  }
  toString() {
    return String(this.value);
  }
}
De.BLOCK_FOLDED = "BLOCK_FOLDED";
De.BLOCK_LITERAL = "BLOCK_LITERAL";
De.PLAIN = "PLAIN";
De.QUOTE_DOUBLE = "QUOTE_DOUBLE";
De.QUOTE_SINGLE = "QUOTE_SINGLE";
const Kq = "tag:yaml.org,2002:";
function Jq(r, t, e) {
  if (t) {
    const n = e.filter((o) => o.tag === t), i = n.find((o) => !o.format) ?? n[0];
    if (!i)
      throw new Error(`Tag ${t} not found`);
    return i;
  }
  return e.find((n) => n.identify?.(r) && !n.format);
}
function _s(r, t, e) {
  if (Ti(r) && (r = r.contents), _t(r))
    return r;
  if (mt(r)) {
    const g = e.schema[Ur].createNode?.(e.schema, null, e);
    return g.items.push(r), g;
  }
  (r instanceof String || r instanceof Number || r instanceof Boolean || typeof BigInt < "u" && r instanceof BigInt) && (r = r.valueOf());
  const { aliasDuplicateObjects: n, onAnchor: i, onTagObj: o, schema: s, sourceObjects: u } = e;
  let l;
  if (n && r && typeof r == "object") {
    if (l = u.get(r), l)
      return l.anchor || (l.anchor = i(r)), new gu(l.anchor);
    l = { anchor: null, node: null }, u.set(r, l);
  }
  t?.startsWith("!!") && (t = Kq + t.slice(2));
  let c = Jq(r, t, s.tags);
  if (!c) {
    if (r && typeof r.toJSON == "function" && (r = r.toJSON()), !r || typeof r != "object") {
      const g = new De(r);
      return l && (l.node = g), g;
    }
    c = r instanceof Map ? s[Ur] : Symbol.iterator in Object(r) ? s[_o] : s[Ur];
  }
  o && (o(c), delete e.onTagObj);
  const d = c?.createNode ? c.createNode(e.schema, r, e) : typeof c?.nodeClass?.from == "function" ? c.nodeClass.from(e.schema, r, e) : new De(r);
  return t ? d.tag = t : c.default || (d.tag = c.tag), l && (l.node = d), d;
}
function Kl(r, t, e) {
  let n = e;
  for (let i = t.length - 1; i >= 0; --i) {
    const o = t[i];
    if (typeof o == "number" && Number.isInteger(o) && o >= 0) {
      const s = [];
      s[o] = n, n = s;
    } else
      n = /* @__PURE__ */ new Map([[o, n]]);
  }
  return _s(n, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: r,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const rs = (r) => r == null || typeof r == "object" && !!r[Symbol.iterator]().next().done;
class IT extends mp {
  constructor(t, e) {
    super(t), Object.defineProperty(this, "schema", {
      value: e,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(t) {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return t && (e.schema = t), e.items = e.items.map((n) => _t(n) || mt(n) ? n.clone(t) : n), this.range && (e.range = this.range.slice()), e;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(t, e) {
    if (rs(t))
      this.add(e);
    else {
      const [n, ...i] = t, o = this.get(n, !0);
      if (vt(o))
        o.addIn(i, e);
      else if (o === void 0 && this.schema)
        this.set(n, Kl(this.schema, i, e));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    const [e, ...n] = t;
    if (n.length === 0)
      return this.delete(e);
    const i = this.get(e, !0);
    if (vt(i))
      return i.deleteIn(n);
    throw new Error(`Expected YAML collection at ${e}. Remaining path: ${n}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, e) {
    const [n, ...i] = t, o = this.get(n, !0);
    return i.length === 0 ? !e && ut(o) ? o.value : o : vt(o) ? o.getIn(i, e) : void 0;
  }
  hasAllNullValues(t) {
    return this.items.every((e) => {
      if (!mt(e))
        return !1;
      const n = e.value;
      return n == null || t && ut(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(t) {
    const [e, ...n] = t;
    if (n.length === 0)
      return this.has(e);
    const i = this.get(e, !0);
    return vt(i) ? i.hasIn(n) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, e) {
    const [n, ...i] = t;
    if (i.length === 0)
      this.set(n, e);
    else {
      const o = this.get(n, !0);
      if (vt(o))
        o.setIn(i, e);
      else if (o === void 0 && this.schema)
        this.set(n, Kl(this.schema, i, e));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
}
const zq = (r) => r.replace(/^(?!$)(?: $)?/gm, "#");
function cr(r, t) {
  return /^\n+$/.test(r) ? r.substring(1) : t ? r.replace(/^(?! *$)/gm, t) : r;
}
const ui = (r, t, e) => r.endsWith(`
`) ? cr(e, t) : e.includes(`
`) ? `
` + cr(e, t) : (r.endsWith(" ") ? "" : " ") + e, MT = "flow", Nh = "block", Sl = "quoted";
function yu(r, t, e = "flow", { indentAtStart: n, lineWidth: i = 80, minContentWidth: o = 20, onFold: s, onOverflow: u } = {}) {
  if (!i || i < 0)
    return r;
  i < o && (o = 0);
  const l = Math.max(1 + o, 1 + i - t.length);
  if (r.length <= l)
    return r;
  const c = [], d = {};
  let g = i - t.length;
  typeof n == "number" && (n > i - Math.max(2, o) ? c.push(0) : g = i - n);
  let y, w, b = !1, _ = -1, C = -1, m = -1;
  e === Nh && (_ = jv(r, _, t.length), _ !== -1 && (g = _ + l));
  for (let S; S = r[_ += 1]; ) {
    if (e === Sl && S === "\\") {
      switch (C = _, r[_ + 1]) {
        case "x":
          _ += 3;
          break;
        case "u":
          _ += 5;
          break;
        case "U":
          _ += 9;
          break;
        default:
          _ += 1;
      }
      m = _;
    }
    if (S === `
`)
      e === Nh && (_ = jv(r, _, t.length)), g = _ + t.length + l, y = void 0;
    else {
      if (S === " " && w && w !== " " && w !== `
` && w !== "	") {
        const A = r[_ + 1];
        A && A !== " " && A !== `
` && A !== "	" && (y = _);
      }
      if (_ >= g)
        if (y)
          c.push(y), g = y + l, y = void 0;
        else if (e === Sl) {
          for (; w === " " || w === "	"; )
            w = S, S = r[_ += 1], b = !0;
          const A = _ > m + 1 ? _ - 2 : C - 1;
          if (d[A])
            return r;
          c.push(A), d[A] = !0, g = A + l, y = void 0;
        } else
          b = !0;
    }
    w = S;
  }
  if (b && u && u(), c.length === 0)
    return r;
  s && s();
  let T = r.slice(0, c[0]);
  for (let S = 0; S < c.length; ++S) {
    const A = c[S], x = c[S + 1] || r.length;
    A === 0 ? T = `
${t}${r.slice(0, x)}` : (e === Sl && d[A] && (T += `${r[A]}\\`), T += `
${t}${r.slice(A + 1, x)}`);
  }
  return T;
}
function jv(r, t, e) {
  let n = t, i = t + 1, o = r[i];
  for (; o === " " || o === "	"; )
    if (t < i + e)
      o = r[++t];
    else {
      do
        o = r[++t];
      while (o && o !== `
`);
      n = t, i = t + 1, o = r[i];
    }
  return n;
}
const vu = (r, t) => ({
  indentAtStart: t ? r.indent.length : r.indentAtStart,
  lineWidth: r.options.lineWidth,
  minContentWidth: r.options.minContentWidth
}), _u = (r) => /^(%|---|\.\.\.)/m.test(r);
function Yq(r, t, e) {
  if (!t || t < 0)
    return !1;
  const n = t - e, i = r.length;
  if (i <= n)
    return !1;
  for (let o = 0, s = 0; o < i; ++o)
    if (r[o] === `
`) {
      if (o - s > n)
        return !0;
      if (s = o + 1, i - s <= n)
        return !1;
    }
  return !0;
}
function cs(r, t) {
  const e = JSON.stringify(r);
  if (t.options.doubleQuotedAsJSON)
    return e;
  const { implicitKey: n } = t, i = t.options.doubleQuotedMinMultiLineLength, o = t.indent || (_u(r) ? "  " : "");
  let s = "", u = 0;
  for (let l = 0, c = e[l]; c; c = e[++l])
    if (c === " " && e[l + 1] === "\\" && e[l + 2] === "n" && (s += e.slice(u, l) + "\\ ", l += 1, u = l, c = "\\"), c === "\\")
      switch (e[l + 1]) {
        case "u":
          {
            s += e.slice(u, l);
            const d = e.substr(l + 2, 4);
            switch (d) {
              case "0000":
                s += "\\0";
                break;
              case "0007":
                s += "\\a";
                break;
              case "000b":
                s += "\\v";
                break;
              case "001b":
                s += "\\e";
                break;
              case "0085":
                s += "\\N";
                break;
              case "00a0":
                s += "\\_";
                break;
              case "2028":
                s += "\\L";
                break;
              case "2029":
                s += "\\P";
                break;
              default:
                d.substr(0, 2) === "00" ? s += "\\x" + d.substr(2) : s += e.substr(l, 6);
            }
            l += 5, u = l + 1;
          }
          break;
        case "n":
          if (n || e[l + 2] === '"' || e.length < i)
            l += 1;
          else {
            for (s += e.slice(u, l) + `

`; e[l + 2] === "\\" && e[l + 3] === "n" && e[l + 4] !== '"'; )
              s += `
`, l += 2;
            s += o, e[l + 2] === " " && (s += "\\"), l += 1, u = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return s = u ? s + e.slice(u) : e, n ? s : yu(s, o, Sl, vu(t, !1));
}
function Dh(r, t) {
  if (t.options.singleQuote === !1 || t.implicitKey && r.includes(`
`) || /[ \t]\n|\n[ \t]/.test(r))
    return cs(r, t);
  const e = t.indent || (_u(r) ? "  " : ""), n = "'" + r.replace(/'/g, "''").replace(/\n+/g, `$&
${e}`) + "'";
  return t.implicitKey ? n : yu(n, e, MT, vu(t, !1));
}
function eo(r, t) {
  const { singleQuote: e } = t.options;
  let n;
  if (e === !1)
    n = cs;
  else {
    const i = r.includes('"'), o = r.includes("'");
    i && !o ? n = Dh : o && !i ? n = cs : n = e ? Dh : cs;
  }
  return n(r, t);
}
let Fh;
try {
  Fh = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  Fh = /\n+(?!\n|$)/g;
}
function El({ comment: r, type: t, value: e }, n, i, o) {
  const { blockQuote: s, commentString: u, lineWidth: l } = n.options;
  if (!s || /\n[\t ]+$/.test(e) || /^\s*$/.test(e))
    return eo(e, n);
  const c = n.indent || (n.forceBlockIndent || _u(e) ? "  " : ""), d = s === "literal" ? !0 : s === "folded" || t === De.BLOCK_FOLDED ? !1 : t === De.BLOCK_LITERAL ? !0 : !Yq(e, l, c.length);
  if (!e)
    return d ? `|
` : `>
`;
  let g, y;
  for (y = e.length; y > 0; --y) {
    const x = e[y - 1];
    if (x !== `
` && x !== "	" && x !== " ")
      break;
  }
  let w = e.substring(y);
  const b = w.indexOf(`
`);
  b === -1 ? g = "-" : e === w || b !== w.length - 1 ? (g = "+", o && o()) : g = "", w && (e = e.slice(0, -w.length), w[w.length - 1] === `
` && (w = w.slice(0, -1)), w = w.replace(Fh, `$&${c}`));
  let _ = !1, C, m = -1;
  for (C = 0; C < e.length; ++C) {
    const x = e[C];
    if (x === " ")
      _ = !0;
    else if (x === `
`)
      m = C;
    else
      break;
  }
  let T = e.substring(0, m < C ? m + 1 : C);
  T && (e = e.substring(T.length), T = T.replace(/\n+/g, `$&${c}`));
  let A = (_ ? c ? "2" : "1" : "") + g;
  if (r && (A += " " + u(r.replace(/ ?[\r\n]+/g, " ")), i && i()), !d) {
    const x = e.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`);
    let D = !1;
    const U = vu(n, !0);
    s !== "folded" && t !== De.BLOCK_FOLDED && (U.onOverflow = () => {
      D = !0;
    });
    const O = yu(`${T}${x}${w}`, c, Nh, U);
    if (!D)
      return `>${A}
${c}${O}`;
  }
  return e = e.replace(/\n+/g, `$&${c}`), `|${A}
${c}${T}${e}${w}`;
}
function Zq(r, t, e, n) {
  const { type: i, value: o } = r, { actualString: s, implicitKey: u, indent: l, indentStep: c, inFlow: d } = t;
  if (u && o.includes(`
`) || d && /[[\]{},]/.test(o))
    return eo(o, t);
  if (!o || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))
    return u || d || !o.includes(`
`) ? eo(o, t) : El(r, t, e, n);
  if (!u && !d && i !== De.PLAIN && o.includes(`
`))
    return El(r, t, e, n);
  if (_u(o)) {
    if (l === "")
      return t.forceBlockIndent = !0, El(r, t, e, n);
    if (u && l === c)
      return eo(o, t);
  }
  const g = o.replace(/\n+/g, `$&
${l}`);
  if (s) {
    const y = (_) => _.default && _.tag !== "tag:yaml.org,2002:str" && _.test?.test(g), { compat: w, tags: b } = t.doc.schema;
    if (b.some(y) || w?.some(y))
      return eo(o, t);
  }
  return u ? g : yu(g, l, MT, vu(t, !1));
}
function Ss(r, t, e, n) {
  const { implicitKey: i, inFlow: o } = t, s = typeof r.value == "string" ? r : Object.assign({}, r, { value: String(r.value) });
  let { type: u } = r;
  u !== De.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(s.value) && (u = De.QUOTE_DOUBLE);
  const l = (d) => {
    switch (d) {
      case De.BLOCK_FOLDED:
      case De.BLOCK_LITERAL:
        return i || o ? eo(s.value, t) : El(s, t, e, n);
      case De.QUOTE_DOUBLE:
        return cs(s.value, t);
      case De.QUOTE_SINGLE:
        return Dh(s.value, t);
      case De.PLAIN:
        return Zq(s, t, e, n);
      default:
        return null;
    }
  };
  let c = l(u);
  if (c === null) {
    const { defaultKeyType: d, defaultStringType: g } = t.options, y = i && d || g;
    if (c = l(y), c === null)
      throw new Error(`Unsupported default string type ${y}`);
  }
  return c;
}
function kT(r, t) {
  const e = Object.assign({
    blockQuote: !0,
    commentString: zq,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, r.schema.toStringOptions, t);
  let n;
  switch (e.collectionStyle) {
    case "block":
      n = !1;
      break;
    case "flow":
      n = !0;
      break;
    default:
      n = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: r,
    flowCollectionPadding: e.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof e.indent == "number" ? " ".repeat(e.indent) : "  ",
    inFlow: n,
    options: e
  };
}
function jq(r, t) {
  if (t.tag) {
    const i = r.filter((o) => o.tag === t.tag);
    if (i.length > 0)
      return i.find((o) => o.format === t.format) ?? i[0];
  }
  let e, n;
  if (ut(t)) {
    n = t.value;
    let i = r.filter((o) => o.identify?.(n));
    if (i.length > 1) {
      const o = i.filter((s) => s.test);
      o.length > 0 && (i = o);
    }
    e = i.find((o) => o.format === t.format) ?? i.find((o) => !o.format);
  } else
    n = t, e = r.find((i) => i.nodeClass && n instanceof i.nodeClass);
  if (!e) {
    const i = n?.constructor?.name ?? typeof n;
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return e;
}
function Qq(r, t, { anchors: e, doc: n }) {
  if (!n.directives)
    return "";
  const i = [], o = (ut(r) || vt(r)) && r.anchor;
  o && ET(o) && (e.add(o), i.push(`&${o}`));
  const s = r.tag ? r.tag : t.default ? null : t.tag;
  return s && i.push(n.directives.tagString(s)), i.join(" ");
}
function mo(r, t, e, n) {
  if (mt(r))
    return r.toString(t, e, n);
  if (bi(r)) {
    if (t.doc.directives)
      return r.toString(t);
    if (t.resolvedAliases?.has(r))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    t.resolvedAliases ? t.resolvedAliases.add(r) : t.resolvedAliases = /* @__PURE__ */ new Set([r]), r = r.resolve(t.doc);
  }
  let i;
  const o = _t(r) ? r : t.doc.createNode(r, { onTagObj: (l) => i = l });
  i || (i = jq(t.doc.schema.tags, o));
  const s = Qq(o, i, t);
  s.length > 0 && (t.indentAtStart = (t.indentAtStart ?? 0) + s.length + 1);
  const u = typeof i.stringify == "function" ? i.stringify(o, t, e, n) : ut(o) ? Ss(o, t, e, n) : o.toString(t, e, n);
  return s ? ut(o) || u[0] === "{" || u[0] === "[" ? `${s} ${u}` : `${s}
${t.indent}${u}` : u;
}
function Xq({ key: r, value: t }, e, n, i) {
  const { allNullValues: o, doc: s, indent: u, indentStep: l, options: { commentString: c, indentSeq: d, simpleKeys: g } } = e;
  let y = _t(r) && r.comment || null;
  if (g) {
    if (y)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (vt(r) || !_t(r) && typeof r == "object") {
      const U = "With simple keys, collection cannot be used as a key value";
      throw new Error(U);
    }
  }
  let w = !g && (!r || y && t == null && !e.inFlow || vt(r) || (ut(r) ? r.type === De.BLOCK_FOLDED || r.type === De.BLOCK_LITERAL : typeof r == "object"));
  e = Object.assign({}, e, {
    allNullValues: !1,
    implicitKey: !w && (g || !o),
    indent: u + l
  });
  let b = !1, _ = !1, C = mo(r, e, () => b = !0, () => _ = !0);
  if (!w && !e.inFlow && C.length > 1024) {
    if (g)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    w = !0;
  }
  if (e.inFlow) {
    if (o || t == null)
      return b && n && n(), C === "" ? "?" : w ? `? ${C}` : C;
  } else if (o && !g || t == null && w)
    return C = `? ${C}`, y && !b ? C += ui(C, e.indent, c(y)) : _ && i && i(), C;
  b && (y = null), w ? (y && (C += ui(C, e.indent, c(y))), C = `? ${C}
${u}:`) : (C = `${C}:`, y && (C += ui(C, e.indent, c(y))));
  let m, T, S;
  _t(t) ? (m = !!t.spaceBefore, T = t.commentBefore, S = t.comment) : (m = !1, T = null, S = null, t && typeof t == "object" && (t = s.createNode(t))), e.implicitKey = !1, !w && !y && ut(t) && (e.indentAtStart = C.length + 1), _ = !1, !d && l.length >= 2 && !e.inFlow && !w && bo(t) && !t.flow && !t.tag && !t.anchor && (e.indent = e.indent.substring(2));
  let A = !1;
  const x = mo(t, e, () => A = !0, () => _ = !0);
  let D = " ";
  if (y || m || T) {
    if (D = m ? `
` : "", T) {
      const U = c(T);
      D += `
${cr(U, e.indent)}`;
    }
    x === "" && !e.inFlow ? D === `
` && (D = `

`) : D += `
${e.indent}`;
  } else if (!w && vt(t)) {
    const U = x[0], O = x.indexOf(`
`), k = O !== -1, H = e.inFlow ?? t.flow ?? t.items.length === 0;
    if (k || !H) {
      let V = !1;
      if (k && (U === "&" || U === "!")) {
        let N = x.indexOf(" ");
        U === "&" && N !== -1 && N < O && x[N + 1] === "!" && (N = x.indexOf(" ", N + 1)), (N === -1 || O < N) && (V = !0);
      }
      V || (D = `
${e.indent}`);
    }
  } else (x === "" || x[0] === `
`) && (D = "");
  return C += D + x, e.inFlow ? A && n && n() : S && !A ? C += ui(C, e.indent, c(S)) : _ && i && i(), C;
}
function PT(r, t) {
  (r === "debug" || r === "warn") && console.warn(t);
}
const Sa = "<<", dr = {
  identify: (r) => r === Sa || typeof r == "symbol" && r.description === Sa,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new De(Symbol(Sa)), {
    addToJSMap: OT
  }),
  stringify: () => Sa
}, eB = (r, t) => (dr.identify(t) || ut(t) && (!t.type || t.type === De.PLAIN) && dr.identify(t.value)) && r?.doc.schema.tags.some((e) => e.tag === dr.tag && e.default);
function OT(r, t, e) {
  if (e = r && bi(e) ? e.resolve(r.doc) : e, bo(e))
    for (const n of e.items)
      af(r, t, n);
  else if (Array.isArray(e))
    for (const n of e)
      af(r, t, n);
  else
    af(r, t, e);
}
function af(r, t, e) {
  const n = r && bi(e) ? e.resolve(r.doc) : e;
  if (!wo(n))
    throw new Error("Merge sources must be maps or map aliases");
  const i = n.toJSON(null, r, Map);
  for (const [o, s] of i)
    t instanceof Map ? t.has(o) || t.set(o, s) : t instanceof Set ? t.add(o) : Object.prototype.hasOwnProperty.call(t, o) || Object.defineProperty(t, o, {
      value: s,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return t;
}
function LT(r, t, { key: e, value: n }) {
  if (_t(e) && e.addToJSMap)
    e.addToJSMap(r, t, n);
  else if (eB(r, e))
    OT(r, t, n);
  else {
    const i = bn(e, "", r);
    if (t instanceof Map)
      t.set(i, bn(n, i, r));
    else if (t instanceof Set)
      t.add(i);
    else {
      const o = tB(e, i, r), s = bn(n, o, r);
      o in t ? Object.defineProperty(t, o, {
        value: s,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : t[o] = s;
    }
  }
  return t;
}
function tB(r, t, e) {
  if (t === null)
    return "";
  if (typeof t != "object")
    return String(t);
  if (_t(r) && e?.doc) {
    const n = kT(e.doc, {});
    n.anchors = /* @__PURE__ */ new Set();
    for (const o of e.anchors.keys())
      n.anchors.add(o.anchor);
    n.inFlow = !0, n.inStringifyKey = !0;
    const i = r.toString(n);
    if (!e.mapKeyWarned) {
      let o = JSON.stringify(i);
      o.length > 40 && (o = o.substring(0, 36) + '..."'), PT(e.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${o}. Set mapAsMap: true to use object keys.`), e.mapKeyWarned = !0;
    }
    return i;
  }
  return JSON.stringify(t);
}
function gp(r, t, e) {
  const n = _s(r, void 0, e), i = _s(t, void 0, e);
  return new Dt(n, i);
}
class Dt {
  constructor(t, e = null) {
    Object.defineProperty(this, Tn, { value: wT }), this.key = t, this.value = e;
  }
  clone(t) {
    let { key: e, value: n } = this;
    return _t(e) && (e = e.clone(t)), _t(n) && (n = n.clone(t)), new Dt(e, n);
  }
  toJSON(t, e) {
    const n = e?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return LT(e, n, this);
  }
  toString(t, e, n) {
    return t?.doc ? Xq(this, t, e, n) : JSON.stringify(this);
  }
}
function NT(r, t, e) {
  return (t.inFlow ?? r.flow ? rB : nB)(r, t, e);
}
function nB({ comment: r, items: t }, e, { blockItemPrefix: n, flowChars: i, itemIndent: o, onChompKeep: s, onComment: u }) {
  const { indent: l, options: { commentString: c } } = e, d = Object.assign({}, e, { indent: o, type: null });
  let g = !1;
  const y = [];
  for (let b = 0; b < t.length; ++b) {
    const _ = t[b];
    let C = null;
    if (_t(_))
      !g && _.spaceBefore && y.push(""), Jl(e, y, _.commentBefore, g), _.comment && (C = _.comment);
    else if (mt(_)) {
      const T = _t(_.key) ? _.key : null;
      T && (!g && T.spaceBefore && y.push(""), Jl(e, y, T.commentBefore, g));
    }
    g = !1;
    let m = mo(_, d, () => C = null, () => g = !0);
    C && (m += ui(m, o, c(C))), g && C && (g = !1), y.push(n + m);
  }
  let w;
  if (y.length === 0)
    w = i.start + i.end;
  else {
    w = y[0];
    for (let b = 1; b < y.length; ++b) {
      const _ = y[b];
      w += _ ? `
${l}${_}` : `
`;
    }
  }
  return r ? (w += `
` + cr(c(r), l), u && u()) : g && s && s(), w;
}
function rB({ items: r }, t, { flowChars: e, itemIndent: n }) {
  const { indent: i, indentStep: o, flowCollectionPadding: s, options: { commentString: u } } = t;
  n += o;
  const l = Object.assign({}, t, {
    indent: n,
    inFlow: !0,
    type: null
  });
  let c = !1, d = 0;
  const g = [];
  for (let b = 0; b < r.length; ++b) {
    const _ = r[b];
    let C = null;
    if (_t(_))
      _.spaceBefore && g.push(""), Jl(t, g, _.commentBefore, !1), _.comment && (C = _.comment);
    else if (mt(_)) {
      const T = _t(_.key) ? _.key : null;
      T && (T.spaceBefore && g.push(""), Jl(t, g, T.commentBefore, !1), T.comment && (c = !0));
      const S = _t(_.value) ? _.value : null;
      S ? (S.comment && (C = S.comment), S.commentBefore && (c = !0)) : _.value == null && T?.comment && (C = T.comment);
    }
    C && (c = !0);
    let m = mo(_, l, () => C = null);
    b < r.length - 1 && (m += ","), C && (m += ui(m, n, u(C))), !c && (g.length > d || m.includes(`
`)) && (c = !0), g.push(m), d = g.length;
  }
  const { start: y, end: w } = e;
  if (g.length === 0)
    return y + w;
  if (!c) {
    const b = g.reduce((_, C) => _ + C.length + 2, 2);
    c = t.options.lineWidth > 0 && b > t.options.lineWidth;
  }
  if (c) {
    let b = y;
    for (const _ of g)
      b += _ ? `
${o}${i}${_}` : `
`;
    return `${b}
${i}${w}`;
  } else
    return `${y}${s}${g.join(" ")}${s}${w}`;
}
function Jl({ indent: r, options: { commentString: t } }, e, n, i) {
  if (n && i && (n = n.replace(/^\n+/, "")), n) {
    const o = cr(t(n), r);
    e.push(o.trimStart());
  }
}
function ci(r, t) {
  const e = ut(t) ? t.value : t;
  for (const n of r)
    if (mt(n) && (n.key === t || n.key === e || ut(n.key) && n.key.value === e))
      return n;
}
class an extends IT {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(t) {
    super(Ur, t), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(t, e, n) {
    const { keepUndefined: i, replacer: o } = n, s = new this(t), u = (l, c) => {
      if (typeof o == "function")
        c = o.call(e, l, c);
      else if (Array.isArray(o) && !o.includes(l))
        return;
      (c !== void 0 || i) && s.items.push(gp(l, c, n));
    };
    if (e instanceof Map)
      for (const [l, c] of e)
        u(l, c);
    else if (e && typeof e == "object")
      for (const l of Object.keys(e))
        u(l, e[l]);
    return typeof t.sortMapEntries == "function" && s.items.sort(t.sortMapEntries), s;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(t, e) {
    let n;
    mt(t) ? n = t : !t || typeof t != "object" || !("key" in t) ? n = new Dt(t, t?.value) : n = new Dt(t.key, t.value);
    const i = ci(this.items, n.key), o = this.schema?.sortMapEntries;
    if (i) {
      if (!e)
        throw new Error(`Key ${n.key} already set`);
      ut(i.value) && RT(n.value) ? i.value.value = n.value : i.value = n.value;
    } else if (o) {
      const s = this.items.findIndex((u) => o(n, u) < 0);
      s === -1 ? this.items.push(n) : this.items.splice(s, 0, n);
    } else
      this.items.push(n);
  }
  delete(t) {
    const e = ci(this.items, t);
    return e ? this.items.splice(this.items.indexOf(e), 1).length > 0 : !1;
  }
  get(t, e) {
    const i = ci(this.items, t)?.value;
    return (!e && ut(i) ? i.value : i) ?? void 0;
  }
  has(t) {
    return !!ci(this.items, t);
  }
  set(t, e) {
    this.add(new Dt(t, e), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(t, e, n) {
    const i = n ? new n() : e?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    e?.onCreate && e.onCreate(i);
    for (const o of this.items)
      LT(e, i, o);
    return i;
  }
  toString(t, e, n) {
    if (!t)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!mt(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !t.allNullValues && this.hasAllNullValues(!1) && (t = Object.assign({}, t, { allNullValues: !0 })), NT(this, t, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: t.indent || "",
      onChompKeep: n,
      onComment: e
    });
  }
}
const To = {
  collection: "map",
  default: !0,
  nodeClass: an,
  tag: "tag:yaml.org,2002:map",
  resolve(r, t) {
    return wo(r) || t("Expected a mapping for this tag"), r;
  },
  createNode: (r, t, e) => an.from(r, t, e)
};
class Hr extends IT {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(t) {
    super(_o, t), this.items = [];
  }
  add(t) {
    this.items.push(t);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    const e = Ea(t);
    return typeof e != "number" ? !1 : this.items.splice(e, 1).length > 0;
  }
  get(t, e) {
    const n = Ea(t);
    if (typeof n != "number")
      return;
    const i = this.items[n];
    return !e && ut(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(t) {
    const e = Ea(t);
    return typeof e == "number" && e < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(t, e) {
    const n = Ea(t);
    if (typeof n != "number")
      throw new Error(`Expected a valid index, not ${t}.`);
    const i = this.items[n];
    ut(i) && RT(e) ? i.value = e : this.items[n] = e;
  }
  toJSON(t, e) {
    const n = [];
    e?.onCreate && e.onCreate(n);
    let i = 0;
    for (const o of this.items)
      n.push(bn(o, String(i++), e));
    return n;
  }
  toString(t, e, n) {
    return t ? NT(this, t, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (t.indent || "") + "  ",
      onChompKeep: n,
      onComment: e
    }) : JSON.stringify(this);
  }
  static from(t, e, n) {
    const { replacer: i } = n, o = new this(t);
    if (e && Symbol.iterator in Object(e)) {
      let s = 0;
      for (let u of e) {
        if (typeof i == "function") {
          const l = e instanceof Set ? u : String(s++);
          u = i.call(e, l, u);
        }
        o.items.push(_s(u, void 0, n));
      }
    }
    return o;
  }
}
function Ea(r) {
  let t = ut(r) ? r.value : r;
  return t && typeof t == "string" && (t = Number(t)), typeof t == "number" && Number.isInteger(t) && t >= 0 ? t : null;
}
const Co = {
  collection: "seq",
  default: !0,
  nodeClass: Hr,
  tag: "tag:yaml.org,2002:seq",
  resolve(r, t) {
    return bo(r) || t("Expected a sequence for this tag"), r;
  },
  createNode: (r, t, e) => Hr.from(r, t, e)
}, wu = {
  identify: (r) => typeof r == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (r) => r,
  stringify(r, t, e, n) {
    return t = Object.assign({ actualString: !0 }, t), Ss(r, t, e, n);
  }
}, bu = {
  identify: (r) => r == null,
  createNode: () => new De(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new De(null),
  stringify: ({ source: r }, t) => typeof r == "string" && bu.test.test(r) ? r : t.options.nullStr
}, yp = {
  identify: (r) => typeof r == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (r) => new De(r[0] === "t" || r[0] === "T"),
  stringify({ source: r, value: t }, e) {
    if (r && yp.test.test(r)) {
      const n = r[0] === "t" || r[0] === "T";
      if (t === n)
        return r;
    }
    return t ? e.options.trueStr : e.options.falseStr;
  }
};
function Nn({ format: r, minFractionDigits: t, tag: e, value: n }) {
  if (typeof n == "bigint")
    return String(n);
  const i = typeof n == "number" ? n : Number(n);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let o = JSON.stringify(n);
  if (!r && t && (!e || e === "tag:yaml.org,2002:float") && /^\d/.test(o)) {
    let s = o.indexOf(".");
    s < 0 && (s = o.length, o += ".");
    let u = t - (o.length - s - 1);
    for (; u-- > 0; )
      o += "0";
  }
  return o;
}
const DT = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (r) => r.slice(-3).toLowerCase() === "nan" ? NaN : r[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Nn
}, FT = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (r) => parseFloat(r),
  stringify(r) {
    const t = Number(r.value);
    return isFinite(t) ? t.toExponential() : Nn(r);
  }
}, $T = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(r) {
    const t = new De(parseFloat(r)), e = r.indexOf(".");
    return e !== -1 && r[r.length - 1] === "0" && (t.minFractionDigits = r.length - e - 1), t;
  },
  stringify: Nn
}, Tu = (r) => typeof r == "bigint" || Number.isInteger(r), vp = (r, t, e, { intAsBigInt: n }) => n ? BigInt(r) : parseInt(r.substring(t), e);
function UT(r, t, e) {
  const { value: n } = r;
  return Tu(n) && n >= 0 ? e + n.toString(t) : Nn(r);
}
const qT = {
  identify: (r) => Tu(r) && r >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (r, t, e) => vp(r, 2, 8, e),
  stringify: (r) => UT(r, 8, "0o")
}, BT = {
  identify: Tu,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (r, t, e) => vp(r, 0, 10, e),
  stringify: Nn
}, VT = {
  identify: (r) => Tu(r) && r >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (r, t, e) => vp(r, 2, 16, e),
  stringify: (r) => UT(r, 16, "0x")
}, iB = [
  To,
  Co,
  wu,
  bu,
  yp,
  qT,
  BT,
  VT,
  DT,
  FT,
  $T
];
function Qv(r) {
  return typeof r == "bigint" || Number.isInteger(r);
}
const Aa = ({ value: r }) => JSON.stringify(r), oB = [
  {
    identify: (r) => typeof r == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (r) => r,
    stringify: Aa
  },
  {
    identify: (r) => r == null,
    createNode: () => new De(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: Aa
  },
  {
    identify: (r) => typeof r == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (r) => r === "true",
    stringify: Aa
  },
  {
    identify: Qv,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (r, t, { intAsBigInt: e }) => e ? BigInt(r) : parseInt(r, 10),
    stringify: ({ value: r }) => Qv(r) ? r.toString() : JSON.stringify(r)
  },
  {
    identify: (r) => typeof r == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (r) => parseFloat(r),
    stringify: Aa
  }
], sB = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(r, t) {
    return t(`Unresolved plain scalar ${JSON.stringify(r)}`), r;
  }
}, aB = [To, Co].concat(oB, sB), _p = {
  identify: (r) => r instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(r, t) {
    if (typeof atob == "function") {
      const e = atob(r.replace(/[\n\r]/g, "")), n = new Uint8Array(e.length);
      for (let i = 0; i < e.length; ++i)
        n[i] = e.charCodeAt(i);
      return n;
    } else
      return t("This environment does not support reading binary tags; either Buffer or atob is required"), r;
  },
  stringify({ comment: r, type: t, value: e }, n, i, o) {
    if (!e)
      return "";
    const s = e;
    let u;
    if (typeof btoa == "function") {
      let l = "";
      for (let c = 0; c < s.length; ++c)
        l += String.fromCharCode(s[c]);
      u = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (t || (t = De.BLOCK_LITERAL), t !== De.QUOTE_DOUBLE) {
      const l = Math.max(n.options.lineWidth - n.indent.length, n.options.minContentWidth), c = Math.ceil(u.length / l), d = new Array(c);
      for (let g = 0, y = 0; g < c; ++g, y += l)
        d[g] = u.substr(y, l);
      u = d.join(t === De.BLOCK_LITERAL ? `
` : " ");
    }
    return Ss({ comment: r, type: t, value: u }, n, i, o);
  }
};
function HT(r, t) {
  if (bo(r))
    for (let e = 0; e < r.items.length; ++e) {
      let n = r.items[e];
      if (!mt(n)) {
        if (wo(n)) {
          n.items.length > 1 && t("Each pair must have its own sequence indicator");
          const i = n.items[0] || new Dt(new De(null));
          if (n.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${n.commentBefore}
${i.key.commentBefore}` : n.commentBefore), n.comment) {
            const o = i.value ?? i.key;
            o.comment = o.comment ? `${n.comment}
${o.comment}` : n.comment;
          }
          n = i;
        }
        r.items[e] = mt(n) ? n : new Dt(n);
      }
    }
  else
    t("Expected a sequence for this tag");
  return r;
}
function GT(r, t, e) {
  const { replacer: n } = e, i = new Hr(r);
  i.tag = "tag:yaml.org,2002:pairs";
  let o = 0;
  if (t && Symbol.iterator in Object(t))
    for (let s of t) {
      typeof n == "function" && (s = n.call(t, String(o++), s));
      let u, l;
      if (Array.isArray(s))
        if (s.length === 2)
          u = s[0], l = s[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${s}`);
      else if (s && s instanceof Object) {
        const c = Object.keys(s);
        if (c.length === 1)
          u = c[0], l = s[u];
        else
          throw new TypeError(`Expected tuple with one key, not ${c.length} keys`);
      } else
        u = s;
      i.items.push(gp(u, l, e));
    }
  return i;
}
const wp = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: HT,
  createNode: GT
};
class oo extends Hr {
  constructor() {
    super(), this.add = an.prototype.add.bind(this), this.delete = an.prototype.delete.bind(this), this.get = an.prototype.get.bind(this), this.has = an.prototype.has.bind(this), this.set = an.prototype.set.bind(this), this.tag = oo.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(t, e) {
    if (!e)
      return super.toJSON(t);
    const n = /* @__PURE__ */ new Map();
    e?.onCreate && e.onCreate(n);
    for (const i of this.items) {
      let o, s;
      if (mt(i) ? (o = bn(i.key, "", e), s = bn(i.value, o, e)) : o = bn(i, "", e), n.has(o))
        throw new Error("Ordered maps must not include duplicate keys");
      n.set(o, s);
    }
    return n;
  }
  static from(t, e, n) {
    const i = GT(t, e, n), o = new this();
    return o.items = i.items, o;
  }
}
oo.tag = "tag:yaml.org,2002:omap";
const bp = {
  collection: "seq",
  identify: (r) => r instanceof Map,
  nodeClass: oo,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(r, t) {
    const e = HT(r, t), n = [];
    for (const { key: i } of e.items)
      ut(i) && (n.includes(i.value) ? t(`Ordered maps must not include duplicate keys: ${i.value}`) : n.push(i.value));
    return Object.assign(new oo(), e);
  },
  createNode: (r, t, e) => oo.from(r, t, e)
};
function WT({ value: r, source: t }, e) {
  return t && (r ? KT : JT).test.test(t) ? t : r ? e.options.trueStr : e.options.falseStr;
}
const KT = {
  identify: (r) => r === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new De(!0),
  stringify: WT
}, JT = {
  identify: (r) => r === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new De(!1),
  stringify: WT
}, lB = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (r) => r.slice(-3).toLowerCase() === "nan" ? NaN : r[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Nn
}, uB = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (r) => parseFloat(r.replace(/_/g, "")),
  stringify(r) {
    const t = Number(r.value);
    return isFinite(t) ? t.toExponential() : Nn(r);
  }
}, cB = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(r) {
    const t = new De(parseFloat(r.replace(/_/g, ""))), e = r.indexOf(".");
    if (e !== -1) {
      const n = r.substring(e + 1).replace(/_/g, "");
      n[n.length - 1] === "0" && (t.minFractionDigits = n.length);
    }
    return t;
  },
  stringify: Nn
}, Es = (r) => typeof r == "bigint" || Number.isInteger(r);
function Cu(r, t, e, { intAsBigInt: n }) {
  const i = r[0];
  if ((i === "-" || i === "+") && (t += 1), r = r.substring(t).replace(/_/g, ""), n) {
    switch (e) {
      case 2:
        r = `0b${r}`;
        break;
      case 8:
        r = `0o${r}`;
        break;
      case 16:
        r = `0x${r}`;
        break;
    }
    const s = BigInt(r);
    return i === "-" ? BigInt(-1) * s : s;
  }
  const o = parseInt(r, e);
  return i === "-" ? -1 * o : o;
}
function Tp(r, t, e) {
  const { value: n } = r;
  if (Es(n)) {
    const i = n.toString(t);
    return n < 0 ? "-" + e + i.substr(1) : e + i;
  }
  return Nn(r);
}
const fB = {
  identify: Es,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (r, t, e) => Cu(r, 2, 2, e),
  stringify: (r) => Tp(r, 2, "0b")
}, dB = {
  identify: Es,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (r, t, e) => Cu(r, 1, 8, e),
  stringify: (r) => Tp(r, 8, "0")
}, hB = {
  identify: Es,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (r, t, e) => Cu(r, 0, 10, e),
  stringify: Nn
}, pB = {
  identify: Es,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (r, t, e) => Cu(r, 2, 16, e),
  stringify: (r) => Tp(r, 16, "0x")
};
class so extends an {
  constructor(t) {
    super(t), this.tag = so.tag;
  }
  add(t) {
    let e;
    mt(t) ? e = t : t && typeof t == "object" && "key" in t && "value" in t && t.value === null ? e = new Dt(t.key, null) : e = new Dt(t, null), ci(this.items, e.key) || this.items.push(e);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(t, e) {
    const n = ci(this.items, t);
    return !e && mt(n) ? ut(n.key) ? n.key.value : n.key : n;
  }
  set(t, e) {
    if (typeof e != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof e}`);
    const n = ci(this.items, t);
    n && !e ? this.items.splice(this.items.indexOf(n), 1) : !n && e && this.items.push(new Dt(t));
  }
  toJSON(t, e) {
    return super.toJSON(t, e, Set);
  }
  toString(t, e, n) {
    if (!t)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, t, { allNullValues: !0 }), e, n);
    throw new Error("Set items must all have null values");
  }
  static from(t, e, n) {
    const { replacer: i } = n, o = new this(t);
    if (e && Symbol.iterator in Object(e))
      for (let s of e)
        typeof i == "function" && (s = i.call(e, s, s)), o.items.push(gp(s, null, n));
    return o;
  }
}
so.tag = "tag:yaml.org,2002:set";
const Cp = {
  collection: "map",
  identify: (r) => r instanceof Set,
  nodeClass: so,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (r, t, e) => so.from(r, t, e),
  resolve(r, t) {
    if (wo(r)) {
      if (r.hasAllNullValues(!0))
        return Object.assign(new so(), r);
      t("Set items must all have null values");
    } else
      t("Expected a mapping for this tag");
    return r;
  }
};
function Sp(r, t) {
  const e = r[0], n = e === "-" || e === "+" ? r.substring(1) : r, i = (s) => t ? BigInt(s) : Number(s), o = n.replace(/_/g, "").split(":").reduce((s, u) => s * i(60) + i(u), i(0));
  return e === "-" ? i(-1) * o : o;
}
function zT(r) {
  let { value: t } = r, e = (s) => s;
  if (typeof t == "bigint")
    e = (s) => BigInt(s);
  else if (isNaN(t) || !isFinite(t))
    return Nn(r);
  let n = "";
  t < 0 && (n = "-", t *= e(-1));
  const i = e(60), o = [t % i];
  return t < 60 ? o.unshift(0) : (t = (t - o[0]) / i, o.unshift(t % i), t >= 60 && (t = (t - o[0]) / i, o.unshift(t))), n + o.map((s) => String(s).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const YT = {
  identify: (r) => typeof r == "bigint" || Number.isInteger(r),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (r, t, { intAsBigInt: e }) => Sp(r, e),
  stringify: zT
}, ZT = {
  identify: (r) => typeof r == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (r) => Sp(r, !1),
  stringify: zT
}, Su = {
  identify: (r) => r instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(r) {
    const t = r.match(Su.test);
    if (!t)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, e, n, i, o, s, u] = t.map(Number), l = t[7] ? Number((t[7] + "00").substr(1, 3)) : 0;
    let c = Date.UTC(e, n - 1, i, o || 0, s || 0, u || 0, l);
    const d = t[8];
    if (d && d !== "Z") {
      let g = Sp(d, !1);
      Math.abs(g) < 30 && (g *= 60), c -= 6e4 * g;
    }
    return new Date(c);
  },
  stringify: ({ value: r }) => r?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
}, Xv = [
  To,
  Co,
  wu,
  bu,
  KT,
  JT,
  fB,
  dB,
  hB,
  pB,
  lB,
  uB,
  cB,
  _p,
  dr,
  bp,
  wp,
  Cp,
  YT,
  ZT,
  Su
], e_ = /* @__PURE__ */ new Map([
  ["core", iB],
  ["failsafe", [To, Co, wu]],
  ["json", aB],
  ["yaml11", Xv],
  ["yaml-1.1", Xv]
]), t_ = {
  binary: _p,
  bool: yp,
  float: $T,
  floatExp: FT,
  floatNaN: DT,
  floatTime: ZT,
  int: BT,
  intHex: VT,
  intOct: qT,
  intTime: YT,
  map: To,
  merge: dr,
  null: bu,
  omap: bp,
  pairs: wp,
  seq: Co,
  set: Cp,
  timestamp: Su
}, mB = {
  "tag:yaml.org,2002:binary": _p,
  "tag:yaml.org,2002:merge": dr,
  "tag:yaml.org,2002:omap": bp,
  "tag:yaml.org,2002:pairs": wp,
  "tag:yaml.org,2002:set": Cp,
  "tag:yaml.org,2002:timestamp": Su
};
function lf(r, t, e) {
  const n = e_.get(t);
  if (n && !r)
    return e && !n.includes(dr) ? n.concat(dr) : n.slice();
  let i = n;
  if (!i)
    if (Array.isArray(r))
      i = [];
    else {
      const o = Array.from(e_.keys()).filter((s) => s !== "yaml11").map((s) => JSON.stringify(s)).join(", ");
      throw new Error(`Unknown schema "${t}"; use one of ${o} or define customTags array`);
    }
  if (Array.isArray(r))
    for (const o of r)
      i = i.concat(o);
  else typeof r == "function" && (i = r(i.slice()));
  return e && (i = i.concat(dr)), i.reduce((o, s) => {
    const u = typeof s == "string" ? t_[s] : s;
    if (!u) {
      const l = JSON.stringify(s), c = Object.keys(t_).map((d) => JSON.stringify(d)).join(", ");
      throw new Error(`Unknown custom tag ${l}; use one of ${c}`);
    }
    return o.includes(u) || o.push(u), o;
  }, []);
}
const gB = (r, t) => r.key < t.key ? -1 : r.key > t.key ? 1 : 0;
class Eu {
  constructor({ compat: t, customTags: e, merge: n, resolveKnownTags: i, schema: o, sortMapEntries: s, toStringDefaults: u }) {
    this.compat = Array.isArray(t) ? lf(t, "compat") : t ? lf(null, t) : null, this.name = typeof o == "string" && o || "core", this.knownTags = i ? mB : {}, this.tags = lf(e, this.name, n), this.toStringOptions = u ?? null, Object.defineProperty(this, Ur, { value: To }), Object.defineProperty(this, Kn, { value: wu }), Object.defineProperty(this, _o, { value: Co }), this.sortMapEntries = typeof s == "function" ? s : s === !0 ? gB : null;
  }
  clone() {
    const t = Object.create(Eu.prototype, Object.getOwnPropertyDescriptors(this));
    return t.tags = this.tags.slice(), t;
  }
}
function yB(r, t) {
  const e = [];
  let n = t.directives === !0;
  if (t.directives !== !1 && r.directives) {
    const l = r.directives.toString(r);
    l ? (e.push(l), n = !0) : r.directives.docStart && (n = !0);
  }
  n && e.push("---");
  const i = kT(r, t), { commentString: o } = i.options;
  if (r.commentBefore) {
    e.length !== 1 && e.unshift("");
    const l = o(r.commentBefore);
    e.unshift(cr(l, ""));
  }
  let s = !1, u = null;
  if (r.contents) {
    if (_t(r.contents)) {
      if (r.contents.spaceBefore && n && e.push(""), r.contents.commentBefore) {
        const d = o(r.contents.commentBefore);
        e.push(cr(d, ""));
      }
      i.forceBlockIndent = !!r.comment, u = r.contents.comment;
    }
    const l = u ? void 0 : () => s = !0;
    let c = mo(r.contents, i, () => u = null, l);
    u && (c += ui(c, "", o(u))), (c[0] === "|" || c[0] === ">") && e[e.length - 1] === "---" ? e[e.length - 1] = `--- ${c}` : e.push(c);
  } else
    e.push(mo(r.contents, i));
  if (r.directives?.docEnd)
    if (r.comment) {
      const l = o(r.comment);
      l.includes(`
`) ? (e.push("..."), e.push(cr(l, ""))) : e.push(`... ${l}`);
    } else
      e.push("...");
  else {
    let l = r.comment;
    l && s && (l = l.replace(/^\n+/, "")), l && ((!s || u) && e[e.length - 1] !== "" && e.push(""), e.push(cr(o(l), "")));
  }
  return e.join(`
`) + `
`;
}
class So {
  constructor(t, e, n) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, Tn, { value: Lh });
    let i = null;
    typeof e == "function" || Array.isArray(e) ? i = e : n === void 0 && e && (n = e, e = void 0);
    const o = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      stringKeys: !1,
      uniqueKeys: !0,
      version: "1.2"
    }, n);
    this.options = o;
    let { version: s } = o;
    n?._directives ? (this.directives = n._directives.atDocument(), this.directives.yaml.explicit && (s = this.directives.yaml.version)) : this.directives = new Bt({ version: s }), this.setSchema(s, n), this.contents = t === void 0 ? null : this.createNode(t, i, n);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const t = Object.create(So.prototype, {
      [Tn]: { value: Lh }
    });
    return t.commentBefore = this.commentBefore, t.comment = this.comment, t.errors = this.errors.slice(), t.warnings = this.warnings.slice(), t.options = Object.assign({}, this.options), this.directives && (t.directives = this.directives.clone()), t.schema = this.schema.clone(), t.contents = _t(this.contents) ? this.contents.clone(t.schema) : this.contents, this.range && (t.range = this.range.slice()), t;
  }
  /** Adds a value to the document. */
  add(t) {
    qi(this.contents) && this.contents.add(t);
  }
  /** Adds a value to the document. */
  addIn(t, e) {
    qi(this.contents) && this.contents.addIn(t, e);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(t, e) {
    if (!t.anchor) {
      const n = AT(this);
      t.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !e || n.has(e) ? xT(e || "a", n) : e;
    }
    return new gu(t.anchor);
  }
  createNode(t, e, n) {
    let i;
    if (typeof e == "function")
      t = e.call({ "": t }, "", t), i = e;
    else if (Array.isArray(e)) {
      const C = (T) => typeof T == "number" || T instanceof String || T instanceof Number, m = e.filter(C).map(String);
      m.length > 0 && (e = e.concat(m)), i = e;
    } else n === void 0 && e && (n = e, e = void 0);
    const { aliasDuplicateObjects: o, anchorPrefix: s, flow: u, keepUndefined: l, onTagObj: c, tag: d } = n ?? {}, { onAnchor: g, setAnchors: y, sourceObjects: w } = Wq(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      s || "a"
    ), b = {
      aliasDuplicateObjects: o ?? !0,
      keepUndefined: l ?? !1,
      onAnchor: g,
      onTagObj: c,
      replacer: i,
      schema: this.schema,
      sourceObjects: w
    }, _ = _s(t, d, b);
    return u && vt(_) && (_.flow = !0), y(), _;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(t, e, n = {}) {
    const i = this.createNode(t, null, n), o = this.createNode(e, null, n);
    return new Dt(i, o);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    return qi(this.contents) ? this.contents.delete(t) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    return rs(t) ? this.contents == null ? !1 : (this.contents = null, !0) : qi(this.contents) ? this.contents.deleteIn(t) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(t, e) {
    return vt(this.contents) ? this.contents.get(t, e) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, e) {
    return rs(t) ? !e && ut(this.contents) ? this.contents.value : this.contents : vt(this.contents) ? this.contents.getIn(t, e) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(t) {
    return vt(this.contents) ? this.contents.has(t) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(t) {
    return rs(t) ? this.contents !== void 0 : vt(this.contents) ? this.contents.hasIn(t) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(t, e) {
    this.contents == null ? this.contents = Kl(this.schema, [t], e) : qi(this.contents) && this.contents.set(t, e);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, e) {
    rs(t) ? this.contents = e : this.contents == null ? this.contents = Kl(this.schema, Array.from(t), e) : qi(this.contents) && this.contents.setIn(t, e);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(t, e = {}) {
    typeof t == "number" && (t = String(t));
    let n;
    switch (t) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Bt({ version: "1.1" }), n = { resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = t : this.directives = new Bt({ version: t }), n = { resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, n = null;
        break;
      default: {
        const i = JSON.stringify(t);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (e.schema instanceof Object)
      this.schema = e.schema;
    else if (n)
      this.schema = new Eu(Object.assign(n, e));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: t, jsonArg: e, mapAsMap: n, maxAliasCount: i, onAnchor: o, reviver: s } = {}) {
    const u = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !t,
      mapAsMap: n === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof i == "number" ? i : 100
    }, l = bn(this.contents, e ?? "", u);
    if (typeof o == "function")
      for (const { count: c, res: d } of u.anchors.values())
        o(d, c);
    return typeof s == "function" ? Xi(s, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(t, e) {
    return this.toJS({ json: !0, jsonArg: t, mapAsMap: !1, onAnchor: e });
  }
  /** A YAML representation of the document. */
  toString(t = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in t && (!Number.isInteger(t.indent) || Number(t.indent) <= 0)) {
      const e = JSON.stringify(t.indent);
      throw new Error(`"indent" option must be a positive integer, not ${e}`);
    }
    return yB(this, t);
  }
}
function qi(r) {
  if (vt(r))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class Ep extends Error {
  constructor(t, e, n, i) {
    super(), this.name = t, this.code = n, this.message = i, this.pos = e;
  }
}
class fi extends Ep {
  constructor(t, e, n) {
    super("YAMLParseError", t, e, n);
  }
}
class jT extends Ep {
  constructor(t, e, n) {
    super("YAMLWarning", t, e, n);
  }
}
const zl = (r, t) => (e) => {
  if (e.pos[0] === -1)
    return;
  e.linePos = e.pos.map((u) => t.linePos(u));
  const { line: n, col: i } = e.linePos[0];
  e.message += ` at line ${n}, column ${i}`;
  let o = i - 1, s = r.substring(t.lineStarts[n - 1], t.lineStarts[n]).replace(/[\n\r]+$/, "");
  if (o >= 60 && s.length > 80) {
    const u = Math.min(o - 39, s.length - 79);
    s = "" + s.substring(u), o -= u - 1;
  }
  if (s.length > 80 && (s = s.substring(0, 79) + ""), n > 1 && /^ *$/.test(s.substring(0, o))) {
    let u = r.substring(t.lineStarts[n - 2], t.lineStarts[n - 1]);
    u.length > 80 && (u = u.substring(0, 79) + `
`), s = u + s;
  }
  if (/[^ ]/.test(s)) {
    let u = 1;
    const l = e.linePos[1];
    l && l.line === n && l.col > i && (u = Math.max(1, Math.min(l.col - i, 80 - o)));
    const c = " ".repeat(o) + "^".repeat(u);
    e.message += `:

${s}
${c}
`;
  }
};
function go(r, { flow: t, indicator: e, next: n, offset: i, onError: o, parentIndent: s, startOnNewline: u }) {
  let l = !1, c = u, d = u, g = "", y = "", w = !1, b = !1, _ = null, C = null, m = null, T = null, S = null, A = null, x = null;
  for (const O of r)
    switch (b && (O.type !== "space" && O.type !== "newline" && O.type !== "comma" && o(O.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), b = !1), _ && (c && O.type !== "comment" && O.type !== "newline" && o(_, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), _ = null), O.type) {
      case "space":
        !t && (e !== "doc-start" || n?.type !== "flow-collection") && O.source.includes("	") && (_ = O), d = !0;
        break;
      case "comment": {
        d || o(O, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const k = O.source.substring(1) || " ";
        g ? g += y + k : g = k, y = "", c = !1;
        break;
      }
      case "newline":
        c ? g ? g += O.source : (!A || e !== "seq-item-ind") && (l = !0) : y += O.source, c = !0, w = !0, (C || m) && (T = O), d = !0;
        break;
      case "anchor":
        C && o(O, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), O.source.endsWith(":") && o(O.offset + O.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), C = O, x === null && (x = O.offset), c = !1, d = !1, b = !0;
        break;
      case "tag": {
        m && o(O, "MULTIPLE_TAGS", "A node can have at most one tag"), m = O, x === null && (x = O.offset), c = !1, d = !1, b = !0;
        break;
      }
      case e:
        (C || m) && o(O, "BAD_PROP_ORDER", `Anchors and tags must be after the ${O.source} indicator`), A && o(O, "UNEXPECTED_TOKEN", `Unexpected ${O.source} in ${t ?? "collection"}`), A = O, c = e === "seq-item-ind" || e === "explicit-key-ind", d = !1;
        break;
      case "comma":
        if (t) {
          S && o(O, "UNEXPECTED_TOKEN", `Unexpected , in ${t}`), S = O, c = !1, d = !1;
          break;
        }
      // else fallthrough
      default:
        o(O, "UNEXPECTED_TOKEN", `Unexpected ${O.type} token`), c = !1, d = !1;
    }
  const D = r[r.length - 1], U = D ? D.offset + D.source.length : i;
  return b && n && n.type !== "space" && n.type !== "newline" && n.type !== "comma" && (n.type !== "scalar" || n.source !== "") && o(n.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), _ && (c && _.indent <= s || n?.type === "block-map" || n?.type === "block-seq") && o(_, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: S,
    found: A,
    spaceBefore: l,
    comment: g,
    hasNewline: w,
    anchor: C,
    tag: m,
    newlineAfterProp: T,
    end: U,
    start: x ?? U
  };
}
function ws(r) {
  if (!r)
    return null;
  switch (r.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (r.source.includes(`
`))
        return !0;
      if (r.end) {
        for (const t of r.end)
          if (t.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const t of r.items) {
        for (const e of t.start)
          if (e.type === "newline")
            return !0;
        if (t.sep) {
          for (const e of t.sep)
            if (e.type === "newline")
              return !0;
        }
        if (ws(t.key) || ws(t.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function $h(r, t, e) {
  if (t?.type === "flow-collection") {
    const n = t.end[0];
    n.indent === r && (n.source === "]" || n.source === "}") && ws(t) && e(n, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function QT(r, t, e) {
  const { uniqueKeys: n } = r.options;
  if (n === !1)
    return !1;
  const i = typeof n == "function" ? n : (o, s) => o === s || ut(o) && ut(s) && o.value === s.value;
  return t.some((o) => i(o.key, e));
}
const n_ = "All mapping items must start at the same column";
function vB({ composeNode: r, composeEmptyNode: t }, e, n, i, o) {
  const s = o?.nodeClass ?? an, u = new s(e.schema);
  e.atRoot && (e.atRoot = !1);
  let l = n.offset, c = null;
  for (const d of n.items) {
    const { start: g, key: y, sep: w, value: b } = d, _ = go(g, {
      indicator: "explicit-key-ind",
      next: y ?? w?.[0],
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !0
    }), C = !_.found;
    if (C) {
      if (y && (y.type === "block-seq" ? i(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in y && y.indent !== n.indent && i(l, "BAD_INDENT", n_)), !_.anchor && !_.tag && !w) {
        c = _.end, _.comment && (u.comment ? u.comment += `
` + _.comment : u.comment = _.comment);
        continue;
      }
      (_.newlineAfterProp || ws(y)) && i(y ?? g[g.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else _.found?.indent !== n.indent && i(l, "BAD_INDENT", n_);
    e.atKey = !0;
    const m = _.end, T = y ? r(e, y, _, i) : t(e, m, g, null, _, i);
    e.schema.compat && $h(n.indent, y, i), e.atKey = !1, QT(e, u.items, T) && i(m, "DUPLICATE_KEY", "Map keys must be unique");
    const S = go(w ?? [], {
      indicator: "map-value-ind",
      next: b,
      offset: T.range[2],
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !y || y.type === "block-scalar"
    });
    if (l = S.end, S.found) {
      C && (b?.type === "block-map" && !S.hasNewline && i(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), e.options.strict && _.start < S.found.offset - 1024 && i(T.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const A = b ? r(e, b, S, i) : t(e, l, w, null, S, i);
      e.schema.compat && $h(n.indent, b, i), l = A.range[2];
      const x = new Dt(T, A);
      e.options.keepSourceTokens && (x.srcToken = d), u.items.push(x);
    } else {
      C && i(T.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), S.comment && (T.comment ? T.comment += `
` + S.comment : T.comment = S.comment);
      const A = new Dt(T);
      e.options.keepSourceTokens && (A.srcToken = d), u.items.push(A);
    }
  }
  return c && c < l && i(c, "IMPOSSIBLE", "Map comment with trailing content"), u.range = [n.offset, l, c ?? l], u;
}
function _B({ composeNode: r, composeEmptyNode: t }, e, n, i, o) {
  const s = o?.nodeClass ?? Hr, u = new s(e.schema);
  e.atRoot && (e.atRoot = !1), e.atKey && (e.atKey = !1);
  let l = n.offset, c = null;
  for (const { start: d, value: g } of n.items) {
    const y = go(d, {
      indicator: "seq-item-ind",
      next: g,
      offset: l,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !0
    });
    if (!y.found)
      if (y.anchor || y.tag || g)
        g && g.type === "block-seq" ? i(y.end, "BAD_INDENT", "All sequence items must start at the same column") : i(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        c = y.end, y.comment && (u.comment = y.comment);
        continue;
      }
    const w = g ? r(e, g, y, i) : t(e, y.end, d, null, y, i);
    e.schema.compat && $h(n.indent, g, i), l = w.range[2], u.items.push(w);
  }
  return u.range = [n.offset, l, c ?? l], u;
}
function As(r, t, e, n) {
  let i = "";
  if (r) {
    let o = !1, s = "";
    for (const u of r) {
      const { source: l, type: c } = u;
      switch (c) {
        case "space":
          o = !0;
          break;
        case "comment": {
          e && !o && n(u, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const d = l.substring(1) || " ";
          i ? i += s + d : i = d, s = "";
          break;
        }
        case "newline":
          i && (s += l), o = !0;
          break;
        default:
          n(u, "UNEXPECTED_TOKEN", `Unexpected ${c} at node end`);
      }
      t += l.length;
    }
  }
  return { comment: i, offset: t };
}
const uf = "Block collections are not allowed within flow collections", cf = (r) => r && (r.type === "block-map" || r.type === "block-seq");
function wB({ composeNode: r, composeEmptyNode: t }, e, n, i, o) {
  const s = n.start.source === "{", u = s ? "flow map" : "flow sequence", l = o?.nodeClass ?? (s ? an : Hr), c = new l(e.schema);
  c.flow = !0;
  const d = e.atRoot;
  d && (e.atRoot = !1), e.atKey && (e.atKey = !1);
  let g = n.offset + n.start.source.length;
  for (let C = 0; C < n.items.length; ++C) {
    const m = n.items[C], { start: T, key: S, sep: A, value: x } = m, D = go(T, {
      flow: u,
      indicator: "explicit-key-ind",
      next: S ?? A?.[0],
      offset: g,
      onError: i,
      parentIndent: n.indent,
      startOnNewline: !1
    });
    if (!D.found) {
      if (!D.anchor && !D.tag && !A && !x) {
        C === 0 && D.comma ? i(D.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${u}`) : C < n.items.length - 1 && i(D.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${u}`), D.comment && (c.comment ? c.comment += `
` + D.comment : c.comment = D.comment), g = D.end;
        continue;
      }
      !s && e.options.strict && ws(S) && i(
        S,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (C === 0)
      D.comma && i(D.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${u}`);
    else if (D.comma || i(D.start, "MISSING_CHAR", `Missing , between ${u} items`), D.comment) {
      let U = "";
      e: for (const O of T)
        switch (O.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            U = O.source.substring(1);
            break e;
          default:
            break e;
        }
      if (U) {
        let O = c.items[c.items.length - 1];
        mt(O) && (O = O.value ?? O.key), O.comment ? O.comment += `
` + U : O.comment = U, D.comment = D.comment.substring(U.length + 1);
      }
    }
    if (!s && !A && !D.found) {
      const U = x ? r(e, x, D, i) : t(e, D.end, A, null, D, i);
      c.items.push(U), g = U.range[2], cf(x) && i(U.range, "BLOCK_IN_FLOW", uf);
    } else {
      e.atKey = !0;
      const U = D.end, O = S ? r(e, S, D, i) : t(e, U, T, null, D, i);
      cf(S) && i(O.range, "BLOCK_IN_FLOW", uf), e.atKey = !1;
      const k = go(A ?? [], {
        flow: u,
        indicator: "map-value-ind",
        next: x,
        offset: O.range[2],
        onError: i,
        parentIndent: n.indent,
        startOnNewline: !1
      });
      if (k.found) {
        if (!s && !D.found && e.options.strict) {
          if (A)
            for (const N of A) {
              if (N === k.found)
                break;
              if (N.type === "newline") {
                i(N, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          D.start < k.found.offset - 1024 && i(k.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else x && ("source" in x && x.source && x.source[0] === ":" ? i(x, "MISSING_CHAR", `Missing space after : in ${u}`) : i(k.start, "MISSING_CHAR", `Missing , or : between ${u} items`));
      const H = x ? r(e, x, k, i) : k.found ? t(e, k.end, A, null, k, i) : null;
      H ? cf(x) && i(H.range, "BLOCK_IN_FLOW", uf) : k.comment && (O.comment ? O.comment += `
` + k.comment : O.comment = k.comment);
      const V = new Dt(O, H);
      if (e.options.keepSourceTokens && (V.srcToken = m), s) {
        const N = c;
        QT(e, N.items, O) && i(U, "DUPLICATE_KEY", "Map keys must be unique"), N.items.push(V);
      } else {
        const N = new an(e.schema);
        N.flow = !0, N.items.push(V);
        const $ = (H ?? O).range;
        N.range = [O.range[0], $[1], $[2]], c.items.push(N);
      }
      g = H ? H.range[2] : k.end;
    }
  }
  const y = s ? "}" : "]", [w, ...b] = n.end;
  let _ = g;
  if (w && w.source === y)
    _ = w.offset + w.source.length;
  else {
    const C = u[0].toUpperCase() + u.substring(1), m = d ? `${C} must end with a ${y}` : `${C} in block collection must be sufficiently indented and end with a ${y}`;
    i(g, d ? "MISSING_CHAR" : "BAD_INDENT", m), w && w.source.length !== 1 && b.unshift(w);
  }
  if (b.length > 0) {
    const C = As(b, _, e.options.strict, i);
    C.comment && (c.comment ? c.comment += `
` + C.comment : c.comment = C.comment), c.range = [n.offset, _, C.offset];
  } else
    c.range = [n.offset, _, _];
  return c;
}
function ff(r, t, e, n, i, o) {
  const s = e.type === "block-map" ? vB(r, t, e, n, o) : e.type === "block-seq" ? _B(r, t, e, n, o) : wB(r, t, e, n, o), u = s.constructor;
  return i === "!" || i === u.tagName ? (s.tag = u.tagName, s) : (i && (s.tag = i), s);
}
function bB(r, t, e, n, i) {
  const o = n.tag, s = o ? t.directives.tagName(o.source, (y) => i(o, "TAG_RESOLVE_FAILED", y)) : null;
  if (e.type === "block-seq") {
    const { anchor: y, newlineAfterProp: w } = n, b = y && o ? y.offset > o.offset ? y : o : y ?? o;
    b && (!w || w.offset < b.offset) && i(b, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const u = e.type === "block-map" ? "map" : e.type === "block-seq" ? "seq" : e.start.source === "{" ? "map" : "seq";
  if (!o || !s || s === "!" || s === an.tagName && u === "map" || s === Hr.tagName && u === "seq")
    return ff(r, t, e, i, s);
  let l = t.schema.tags.find((y) => y.tag === s && y.collection === u);
  if (!l) {
    const y = t.schema.knownTags[s];
    if (y && y.collection === u)
      t.schema.tags.push(Object.assign({}, y, { default: !1 })), l = y;
    else
      return y ? i(o, "BAD_COLLECTION_TYPE", `${y.tag} used for ${u} collection, but expects ${y.collection ?? "scalar"}`, !0) : i(o, "TAG_RESOLVE_FAILED", `Unresolved tag: ${s}`, !0), ff(r, t, e, i, s);
  }
  const c = ff(r, t, e, i, s, l), d = l.resolve?.(c, (y) => i(o, "TAG_RESOLVE_FAILED", y), t.options) ?? c, g = _t(d) ? d : new De(d);
  return g.range = c.range, g.tag = s, l?.format && (g.format = l.format), g;
}
function XT(r, t, e) {
  const n = t.offset, i = TB(t, r.options.strict, e);
  if (!i)
    return { value: "", type: null, comment: "", range: [n, n, n] };
  const o = i.mode === ">" ? De.BLOCK_FOLDED : De.BLOCK_LITERAL, s = t.source ? CB(t.source) : [];
  let u = s.length;
  for (let _ = s.length - 1; _ >= 0; --_) {
    const C = s[_][1];
    if (C === "" || C === "\r")
      u = _;
    else
      break;
  }
  if (u === 0) {
    const _ = i.chomp === "+" && s.length > 0 ? `
`.repeat(Math.max(1, s.length - 1)) : "";
    let C = n + i.length;
    return t.source && (C += t.source.length), { value: _, type: o, comment: i.comment, range: [n, C, C] };
  }
  let l = t.indent + i.indent, c = t.offset + i.length, d = 0;
  for (let _ = 0; _ < u; ++_) {
    const [C, m] = s[_];
    if (m === "" || m === "\r")
      i.indent === 0 && C.length > l && (l = C.length);
    else {
      C.length < l && e(c + C.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (l = C.length), d = _, l === 0 && !r.atRoot && e(c, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    c += C.length + m.length + 1;
  }
  for (let _ = s.length - 1; _ >= u; --_)
    s[_][0].length > l && (u = _ + 1);
  let g = "", y = "", w = !1;
  for (let _ = 0; _ < d; ++_)
    g += s[_][0].slice(l) + `
`;
  for (let _ = d; _ < u; ++_) {
    let [C, m] = s[_];
    c += C.length + m.length + 1;
    const T = m[m.length - 1] === "\r";
    if (T && (m = m.slice(0, -1)), m && C.length < l) {
      const A = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      e(c - m.length - (T ? 2 : 1), "BAD_INDENT", A), C = "";
    }
    o === De.BLOCK_LITERAL ? (g += y + C.slice(l) + m, y = `
`) : C.length > l || m[0] === "	" ? (y === " " ? y = `
` : !w && y === `
` && (y = `

`), g += y + C.slice(l) + m, y = `
`, w = !0) : m === "" ? y === `
` ? g += `
` : y = `
` : (g += y + m, y = " ", w = !1);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let _ = u; _ < s.length; ++_)
        g += `
` + s[_][0].slice(l);
      g[g.length - 1] !== `
` && (g += `
`);
      break;
    default:
      g += `
`;
  }
  const b = n + i.length + t.source.length;
  return { value: g, type: o, comment: i.comment, range: [n, b, b] };
}
function TB({ offset: r, props: t }, e, n) {
  if (t[0].type !== "block-scalar-header")
    return n(t[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = t[0], o = i[0];
  let s = 0, u = "", l = -1;
  for (let y = 1; y < i.length; ++y) {
    const w = i[y];
    if (!u && (w === "-" || w === "+"))
      u = w;
    else {
      const b = Number(w);
      !s && b ? s = b : l === -1 && (l = r + y);
    }
  }
  l !== -1 && n(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let c = !1, d = "", g = i.length;
  for (let y = 1; y < t.length; ++y) {
    const w = t[y];
    switch (w.type) {
      case "space":
        c = !0;
      // fallthrough
      case "newline":
        g += w.source.length;
        break;
      case "comment":
        e && !c && n(w, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), g += w.source.length, d = w.source.substring(1);
        break;
      case "error":
        n(w, "UNEXPECTED_TOKEN", w.message), g += w.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const b = `Unexpected token in block scalar header: ${w.type}`;
        n(w, "UNEXPECTED_TOKEN", b);
        const _ = w.source;
        _ && typeof _ == "string" && (g += _.length);
      }
    }
  }
  return { mode: o, indent: s, chomp: u, comment: d, length: g };
}
function CB(r) {
  const t = r.split(/\n( *)/), e = t[0], n = e.match(/^( *)/), o = [n?.[1] ? [n[1], e.slice(n[1].length)] : ["", e]];
  for (let s = 1; s < t.length; s += 2)
    o.push([t[s], t[s + 1]]);
  return o;
}
function eC(r, t, e) {
  const { offset: n, type: i, source: o, end: s } = r;
  let u, l;
  const c = (y, w, b) => e(n + y, w, b);
  switch (i) {
    case "scalar":
      u = De.PLAIN, l = SB(o, c);
      break;
    case "single-quoted-scalar":
      u = De.QUOTE_SINGLE, l = EB(o, c);
      break;
    case "double-quoted-scalar":
      u = De.QUOTE_DOUBLE, l = AB(o, c);
      break;
    /* istanbul ignore next should not happen */
    default:
      return e(r, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [n, n + o.length, n + o.length]
      };
  }
  const d = n + o.length, g = As(s, d, t, e);
  return {
    value: l,
    type: u,
    comment: g.comment,
    range: [n, d, g.offset]
  };
}
function SB(r, t) {
  let e = "";
  switch (r[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      e = "a tab character";
      break;
    case ",":
      e = "flow indicator character ,";
      break;
    case "%":
      e = "directive indicator character %";
      break;
    case "|":
    case ">": {
      e = `block scalar indicator ${r[0]}`;
      break;
    }
    case "@":
    case "`": {
      e = `reserved character ${r[0]}`;
      break;
    }
  }
  return e && t(0, "BAD_SCALAR_START", `Plain value cannot start with ${e}`), tC(r);
}
function EB(r, t) {
  return (r[r.length - 1] !== "'" || r.length === 1) && t(r.length, "MISSING_CHAR", "Missing closing 'quote"), tC(r.slice(1, -1)).replace(/''/g, "'");
}
function tC(r) {
  let t, e;
  try {
    t = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), e = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    t = /(.*?)[ \t]*\r?\n/sy, e = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let n = t.exec(r);
  if (!n)
    return r;
  let i = n[1], o = " ", s = t.lastIndex;
  for (e.lastIndex = s; n = e.exec(r); )
    n[1] === "" ? o === `
` ? i += o : o = `
` : (i += o + n[1], o = " "), s = e.lastIndex;
  const u = /[ \t]*(.*)/sy;
  return u.lastIndex = s, n = u.exec(r), i + o + (n?.[1] ?? "");
}
function AB(r, t) {
  let e = "";
  for (let n = 1; n < r.length - 1; ++n) {
    const i = r[n];
    if (!(i === "\r" && r[n + 1] === `
`))
      if (i === `
`) {
        const { fold: o, offset: s } = xB(r, n);
        e += o, n = s;
      } else if (i === "\\") {
        let o = r[++n];
        const s = RB[o];
        if (s)
          e += s;
        else if (o === `
`)
          for (o = r[n + 1]; o === " " || o === "	"; )
            o = r[++n + 1];
        else if (o === "\r" && r[n + 1] === `
`)
          for (o = r[++n + 1]; o === " " || o === "	"; )
            o = r[++n + 1];
        else if (o === "x" || o === "u" || o === "U") {
          const u = { x: 2, u: 4, U: 8 }[o];
          e += IB(r, n + 1, u, t), n += u;
        } else {
          const u = r.substr(n - 1, 2);
          t(n - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${u}`), e += u;
        }
      } else if (i === " " || i === "	") {
        const o = n;
        let s = r[n + 1];
        for (; s === " " || s === "	"; )
          s = r[++n + 1];
        s !== `
` && !(s === "\r" && r[n + 2] === `
`) && (e += n > o ? r.slice(o, n + 1) : i);
      } else
        e += i;
  }
  return (r[r.length - 1] !== '"' || r.length === 1) && t(r.length, "MISSING_CHAR", 'Missing closing "quote'), e;
}
function xB(r, t) {
  let e = "", n = r[t + 1];
  for (; (n === " " || n === "	" || n === `
` || n === "\r") && !(n === "\r" && r[t + 2] !== `
`); )
    n === `
` && (e += `
`), t += 1, n = r[t + 1];
  return e || (e = " "), { fold: e, offset: t };
}
const RB = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: "",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function IB(r, t, e, n) {
  const i = r.substr(t, e), s = i.length === e && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(s)) {
    const u = r.substr(t - 2, e + 2);
    return n(t - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${u}`), u;
  }
  return String.fromCodePoint(s);
}
function nC(r, t, e, n) {
  const { value: i, type: o, comment: s, range: u } = t.type === "block-scalar" ? XT(r, t, n) : eC(t, r.options.strict, n), l = e ? r.directives.tagName(e.source, (g) => n(e, "TAG_RESOLVE_FAILED", g)) : null;
  let c;
  r.options.stringKeys && r.atKey ? c = r.schema[Kn] : l ? c = MB(r.schema, i, l, e, n) : t.type === "scalar" ? c = kB(r, i, t, n) : c = r.schema[Kn];
  let d;
  try {
    const g = c.resolve(i, (y) => n(e ?? t, "TAG_RESOLVE_FAILED", y), r.options);
    d = ut(g) ? g : new De(g);
  } catch (g) {
    const y = g instanceof Error ? g.message : String(g);
    n(e ?? t, "TAG_RESOLVE_FAILED", y), d = new De(i);
  }
  return d.range = u, d.source = i, o && (d.type = o), l && (d.tag = l), c.format && (d.format = c.format), s && (d.comment = s), d;
}
function MB(r, t, e, n, i) {
  if (e === "!")
    return r[Kn];
  const o = [];
  for (const u of r.tags)
    if (!u.collection && u.tag === e)
      if (u.default && u.test)
        o.push(u);
      else
        return u;
  for (const u of o)
    if (u.test?.test(t))
      return u;
  const s = r.knownTags[e];
  return s && !s.collection ? (r.tags.push(Object.assign({}, s, { default: !1, test: void 0 })), s) : (i(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${e}`, e !== "tag:yaml.org,2002:str"), r[Kn]);
}
function kB({ atKey: r, directives: t, schema: e }, n, i, o) {
  const s = e.tags.find((u) => (u.default === !0 || r && u.default === "key") && u.test?.test(n)) || e[Kn];
  if (e.compat) {
    const u = e.compat.find((l) => l.default && l.test?.test(n)) ?? e[Kn];
    if (s.tag !== u.tag) {
      const l = t.tagString(s.tag), c = t.tagString(u.tag), d = `Value may be parsed as either ${l} or ${c}`;
      o(i, "TAG_RESOLVE_FAILED", d, !0);
    }
  }
  return s;
}
function PB(r, t, e) {
  if (t) {
    e === null && (e = t.length);
    for (let n = e - 1; n >= 0; --n) {
      let i = t[n];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          r -= i.source.length;
          continue;
      }
      for (i = t[++n]; i?.type === "space"; )
        r += i.source.length, i = t[++n];
      break;
    }
  }
  return r;
}
const OB = { composeNode: rC, composeEmptyNode: Ap };
function rC(r, t, e, n) {
  const i = r.atKey, { spaceBefore: o, comment: s, anchor: u, tag: l } = e;
  let c, d = !0;
  switch (t.type) {
    case "alias":
      c = LB(r, t, n), (u || l) && n(t, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      c = nC(r, t, l, n), u && (c.anchor = u.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      c = bB(OB, r, t, e, n), u && (c.anchor = u.source.substring(1));
      break;
    default: {
      const g = t.type === "error" ? t.message : `Unsupported token (type: ${t.type})`;
      n(t, "UNEXPECTED_TOKEN", g), c = Ap(r, t.offset, void 0, null, e, n), d = !1;
    }
  }
  return u && c.anchor === "" && n(u, "BAD_ALIAS", "Anchor cannot be an empty string"), i && r.options.stringKeys && (!ut(c) || typeof c.value != "string" || c.tag && c.tag !== "tag:yaml.org,2002:str") && n(l ?? t, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), o && (c.spaceBefore = !0), s && (t.type === "scalar" && t.source === "" ? c.comment = s : c.commentBefore = s), r.options.keepSourceTokens && d && (c.srcToken = t), c;
}
function Ap(r, t, e, n, { spaceBefore: i, comment: o, anchor: s, tag: u, end: l }, c) {
  const d = {
    type: "scalar",
    offset: PB(t, e, n),
    indent: -1,
    source: ""
  }, g = nC(r, d, u, c);
  return s && (g.anchor = s.source.substring(1), g.anchor === "" && c(s, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (g.spaceBefore = !0), o && (g.comment = o, g.range[2] = l), g;
}
function LB({ options: r }, { offset: t, source: e, end: n }, i) {
  const o = new gu(e.substring(1));
  o.source === "" && i(t, "BAD_ALIAS", "Alias cannot be an empty string"), o.source.endsWith(":") && i(t + e.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const s = t + e.length, u = As(n, s, r.strict, i);
  return o.range = [t, s, u.offset], u.comment && (o.comment = u.comment), o;
}
function NB(r, t, { offset: e, start: n, value: i, end: o }, s) {
  const u = Object.assign({ _directives: t }, r), l = new So(void 0, u), c = {
    atKey: !1,
    atRoot: !0,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, d = go(n, {
    indicator: "doc-start",
    next: i ?? o?.[0],
    offset: e,
    onError: s,
    parentIndent: 0,
    startOnNewline: !0
  });
  d.found && (l.directives.docStart = !0, i && (i.type === "block-map" || i.type === "block-seq") && !d.hasNewline && s(d.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = i ? rC(c, i, d, s) : Ap(c, d.end, n, null, d, s);
  const g = l.contents.range[2], y = As(o, g, !1, s);
  return y.comment && (l.comment = y.comment), l.range = [e, g, y.offset], l;
}
function Ko(r) {
  if (typeof r == "number")
    return [r, r + 1];
  if (Array.isArray(r))
    return r.length === 2 ? r : [r[0], r[1]];
  const { offset: t, source: e } = r;
  return [t, t + (typeof e == "string" ? e.length : 1)];
}
function r_(r) {
  let t = "", e = !1, n = !1;
  for (let i = 0; i < r.length; ++i) {
    const o = r[i];
    switch (o[0]) {
      case "#":
        t += (t === "" ? "" : n ? `

` : `
`) + (o.substring(1) || " "), e = !0, n = !1;
        break;
      case "%":
        r[i + 1]?.[0] !== "#" && (i += 1), e = !1;
        break;
      default:
        e || (n = !0), e = !1;
    }
  }
  return { comment: t, afterEmptyLine: n };
}
class xp {
  constructor(t = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (e, n, i, o) => {
      const s = Ko(e);
      o ? this.warnings.push(new jT(s, n, i)) : this.errors.push(new fi(s, n, i));
    }, this.directives = new Bt({ version: t.version || "1.2" }), this.options = t;
  }
  decorate(t, e) {
    const { comment: n, afterEmptyLine: i } = r_(this.prelude);
    if (n) {
      const o = t.contents;
      if (e)
        t.comment = t.comment ? `${t.comment}
${n}` : n;
      else if (i || t.directives.docStart || !o)
        t.commentBefore = n;
      else if (vt(o) && !o.flow && o.items.length > 0) {
        let s = o.items[0];
        mt(s) && (s = s.key);
        const u = s.commentBefore;
        s.commentBefore = u ? `${n}
${u}` : n;
      } else {
        const s = o.commentBefore;
        o.commentBefore = s ? `${n}
${s}` : n;
      }
    }
    e ? (Array.prototype.push.apply(t.errors, this.errors), Array.prototype.push.apply(t.warnings, this.warnings)) : (t.errors = this.errors, t.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: r_(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(t, e = !1, n = -1) {
    for (const i of t)
      yield* this.next(i);
    yield* this.end(e, n);
  }
  /** Advance the composer by one CST token. */
  *next(t) {
    switch (t.type) {
      case "directive":
        this.directives.add(t.source, (e, n, i) => {
          const o = Ko(t);
          o[0] += e, this.onError(o, "BAD_DIRECTIVE", n, i);
        }), this.prelude.push(t.source), this.atDirectives = !0;
        break;
      case "document": {
        const e = NB(this.options, this.directives, t, this.onError);
        this.atDirectives && !e.directives.docStart && this.onError(t, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(e, !1), this.doc && (yield this.doc), this.doc = e, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(t.source);
        break;
      case "error": {
        const e = t.source ? `${t.message}: ${JSON.stringify(t.source)}` : t.message, n = new fi(Ko(t), "UNEXPECTED_TOKEN", e);
        this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const n = "Unexpected doc-end without preceding document";
          this.errors.push(new fi(Ko(t), "UNEXPECTED_TOKEN", n));
          break;
        }
        this.doc.directives.docEnd = !0;
        const e = As(t.end, t.offset + t.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), e.comment) {
          const n = this.doc.comment;
          this.doc.comment = n ? `${n}
${e.comment}` : e.comment;
        }
        this.doc.range[2] = e.offset;
        break;
      }
      default:
        this.errors.push(new fi(Ko(t), "UNEXPECTED_TOKEN", `Unsupported token ${t.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(t = !1, e = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (t) {
      const n = Object.assign({ _directives: this.directives }, this.options), i = new So(void 0, n);
      this.atDirectives && this.onError(e, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, e, e], this.decorate(i, !1), yield i;
    }
  }
}
function DB(r, t = !0, e) {
  if (r) {
    const n = (i, o, s) => {
      const u = typeof i == "number" ? i : Array.isArray(i) ? i[0] : i.offset;
      if (e)
        e(u, o, s);
      else
        throw new fi([u, u + 1], o, s);
    };
    switch (r.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return eC(r, t, n);
      case "block-scalar":
        return XT({ options: { strict: t } }, r, n);
    }
  }
  return null;
}
function FB(r, t) {
  const { implicitKey: e = !1, indent: n, inFlow: i = !1, offset: o = -1, type: s = "PLAIN" } = t, u = Ss({ type: s, value: r }, {
    implicitKey: e,
    indent: n > 0 ? " ".repeat(n) : "",
    inFlow: i,
    options: { blockQuote: !0, lineWidth: -1 }
  }), l = t.end ?? [
    { type: "newline", offset: -1, indent: n, source: `
` }
  ];
  switch (u[0]) {
    case "|":
    case ">": {
      const c = u.indexOf(`
`), d = u.substring(0, c), g = u.substring(c + 1) + `
`, y = [
        { type: "block-scalar-header", offset: o, indent: n, source: d }
      ];
      return iC(y, l) || y.push({ type: "newline", offset: -1, indent: n, source: `
` }), { type: "block-scalar", offset: o, indent: n, props: y, source: g };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: o, indent: n, source: u, end: l };
    case "'":
      return { type: "single-quoted-scalar", offset: o, indent: n, source: u, end: l };
    default:
      return { type: "scalar", offset: o, indent: n, source: u, end: l };
  }
}
function $B(r, t, e = {}) {
  let { afterKey: n = !1, implicitKey: i = !1, inFlow: o = !1, type: s } = e, u = "indent" in r ? r.indent : null;
  if (n && typeof u == "number" && (u += 2), !s)
    switch (r.type) {
      case "single-quoted-scalar":
        s = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        s = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const c = r.props[0];
        if (c.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        s = c.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        s = "PLAIN";
    }
  const l = Ss({ type: s, value: t }, {
    implicitKey: i || u === null,
    indent: u !== null && u > 0 ? " ".repeat(u) : "",
    inFlow: o,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (l[0]) {
    case "|":
    case ">":
      UB(r, l);
      break;
    case '"':
      df(r, l, "double-quoted-scalar");
      break;
    case "'":
      df(r, l, "single-quoted-scalar");
      break;
    default:
      df(r, l, "scalar");
  }
}
function UB(r, t) {
  const e = t.indexOf(`
`), n = t.substring(0, e), i = t.substring(e + 1) + `
`;
  if (r.type === "block-scalar") {
    const o = r.props[0];
    if (o.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    o.source = n, r.source = i;
  } else {
    const { offset: o } = r, s = "indent" in r ? r.indent : -1, u = [
      { type: "block-scalar-header", offset: o, indent: s, source: n }
    ];
    iC(u, "end" in r ? r.end : void 0) || u.push({ type: "newline", offset: -1, indent: s, source: `
` });
    for (const l of Object.keys(r))
      l !== "type" && l !== "offset" && delete r[l];
    Object.assign(r, { type: "block-scalar", indent: s, props: u, source: i });
  }
}
function iC(r, t) {
  if (t)
    for (const e of t)
      switch (e.type) {
        case "space":
        case "comment":
          r.push(e);
          break;
        case "newline":
          return r.push(e), !0;
      }
  return !1;
}
function df(r, t, e) {
  switch (r.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      r.type = e, r.source = t;
      break;
    case "block-scalar": {
      const n = r.props.slice(1);
      let i = t.length;
      r.props[0].type === "block-scalar-header" && (i -= r.props[0].source.length);
      for (const o of n)
        o.offset += i;
      delete r.props, Object.assign(r, { type: e, source: t, end: n });
      break;
    }
    case "block-map":
    case "block-seq": {
      const i = { type: "newline", offset: r.offset + t.length, indent: r.indent, source: `
` };
      delete r.items, Object.assign(r, { type: e, source: t, end: [i] });
      break;
    }
    default: {
      const n = "indent" in r ? r.indent : -1, i = "end" in r && Array.isArray(r.end) ? r.end.filter((o) => o.type === "space" || o.type === "comment" || o.type === "newline") : [];
      for (const o of Object.keys(r))
        o !== "type" && o !== "offset" && delete r[o];
      Object.assign(r, { type: e, indent: n, source: t, end: i });
    }
  }
}
const qB = (r) => "type" in r ? Yl(r) : Al(r);
function Yl(r) {
  switch (r.type) {
    case "block-scalar": {
      let t = "";
      for (const e of r.props)
        t += Yl(e);
      return t + r.source;
    }
    case "block-map":
    case "block-seq": {
      let t = "";
      for (const e of r.items)
        t += Al(e);
      return t;
    }
    case "flow-collection": {
      let t = r.start.source;
      for (const e of r.items)
        t += Al(e);
      for (const e of r.end)
        t += e.source;
      return t;
    }
    case "document": {
      let t = Al(r);
      if (r.end)
        for (const e of r.end)
          t += e.source;
      return t;
    }
    default: {
      let t = r.source;
      if ("end" in r && r.end)
        for (const e of r.end)
          t += e.source;
      return t;
    }
  }
}
function Al({ start: r, key: t, sep: e, value: n }) {
  let i = "";
  for (const o of r)
    i += o.source;
  if (t && (i += Yl(t)), e)
    for (const o of e)
      i += o.source;
  return n && (i += Yl(n)), i;
}
const Uh = Symbol("break visit"), BB = Symbol("skip children"), oC = Symbol("remove item");
function _i(r, t) {
  "type" in r && r.type === "document" && (r = { start: r.start, value: r.value }), sC(Object.freeze([]), r, t);
}
_i.BREAK = Uh;
_i.SKIP = BB;
_i.REMOVE = oC;
_i.itemAtPath = (r, t) => {
  let e = r;
  for (const [n, i] of t) {
    const o = e?.[n];
    if (o && "items" in o)
      e = o.items[i];
    else
      return;
  }
  return e;
};
_i.parentCollection = (r, t) => {
  const e = _i.itemAtPath(r, t.slice(0, -1)), n = t[t.length - 1][0], i = e?.[n];
  if (i && "items" in i)
    return i;
  throw new Error("Parent collection not found");
};
function sC(r, t, e) {
  let n = e(t, r);
  if (typeof n == "symbol")
    return n;
  for (const i of ["key", "value"]) {
    const o = t[i];
    if (o && "items" in o) {
      for (let s = 0; s < o.items.length; ++s) {
        const u = sC(Object.freeze(r.concat([[i, s]])), o.items[s], e);
        if (typeof u == "number")
          s = u - 1;
        else {
          if (u === Uh)
            return Uh;
          u === oC && (o.items.splice(s, 1), s -= 1);
        }
      }
      typeof n == "function" && i === "key" && (n = n(t, r));
    }
  }
  return typeof n == "function" ? n(t, r) : n;
}
const Au = "\uFEFF", xu = "", Ru = "", bs = "", VB = (r) => !!r && "items" in r, HB = (r) => !!r && (r.type === "scalar" || r.type === "single-quoted-scalar" || r.type === "double-quoted-scalar" || r.type === "block-scalar");
function GB(r) {
  switch (r) {
    case Au:
      return "<BOM>";
    case xu:
      return "<DOC>";
    case Ru:
      return "<FLOW_END>";
    case bs:
      return "<SCALAR>";
    default:
      return JSON.stringify(r);
  }
}
function aC(r) {
  switch (r) {
    case Au:
      return "byte-order-mark";
    case xu:
      return "doc-mode";
    case Ru:
      return "flow-error-end";
    case bs:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (r[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const WB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM: Au,
  DOCUMENT: xu,
  FLOW_END: Ru,
  SCALAR: bs,
  createScalarToken: FB,
  isCollection: VB,
  isScalar: HB,
  prettyToken: GB,
  resolveAsScalar: DB,
  setScalarValue: $B,
  stringify: qB,
  tokenType: aC,
  visit: _i
}, Symbol.toStringTag, { value: "Module" }));
function In(r) {
  switch (r) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const i_ = new Set("0123456789ABCDEFabcdef"), KB = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), xa = new Set(",[]{}"), JB = new Set(` ,[]{}
\r	`), hf = (r) => !r || JB.has(r);
class lC {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(t, e = !1) {
    if (t) {
      if (typeof t != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + t : t, this.lineEndPos = null;
    }
    this.atEnd = !e;
    let n = this.next ?? "stream";
    for (; n && (e || this.hasChars(1)); )
      n = yield* this.parseNext(n);
  }
  atLineEnd() {
    let t = this.pos, e = this.buffer[t];
    for (; e === " " || e === "	"; )
      e = this.buffer[++t];
    return !e || e === "#" || e === `
` ? !0 : e === "\r" ? this.buffer[t + 1] === `
` : !1;
  }
  charAt(t) {
    return this.buffer[this.pos + t];
  }
  continueScalar(t) {
    let e = this.buffer[t];
    if (this.indentNext > 0) {
      let n = 0;
      for (; e === " "; )
        e = this.buffer[++n + t];
      if (e === "\r") {
        const i = this.buffer[n + t + 1];
        if (i === `
` || !i && !this.atEnd)
          return t + n + 1;
      }
      return e === `
` || n >= this.indentNext || !e && !this.atEnd ? t + n : -1;
    }
    if (e === "-" || e === ".") {
      const n = this.buffer.substr(t, 3);
      if ((n === "---" || n === "...") && In(this.buffer[t + 3]))
        return -1;
    }
    return t;
  }
  getLine() {
    let t = this.lineEndPos;
    return (typeof t != "number" || t !== -1 && t < this.pos) && (t = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = t), t === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[t - 1] === "\r" && (t -= 1), this.buffer.substring(this.pos, t));
  }
  hasChars(t) {
    return this.pos + t <= this.buffer.length;
  }
  setNext(t) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = t, null;
  }
  peek(t) {
    return this.buffer.substr(this.pos, t);
  }
  *parseNext(t) {
    switch (t) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let t = this.getLine();
    if (t === null)
      return this.setNext("stream");
    if (t[0] === Au && (yield* this.pushCount(1), t = t.substring(1)), t[0] === "%") {
      let e = t.length, n = t.indexOf("#");
      for (; n !== -1; ) {
        const o = t[n - 1];
        if (o === " " || o === "	") {
          e = n - 1;
          break;
        } else
          n = t.indexOf("#", n + 1);
      }
      for (; ; ) {
        const o = t[e - 1];
        if (o === " " || o === "	")
          e -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(e)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(t.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const e = yield* this.pushSpaces(!0);
      return yield* this.pushCount(t.length - e), yield* this.pushNewline(), "stream";
    }
    return yield xu, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const t = this.charAt(0);
    if (!t && !this.atEnd)
      return this.setNext("line-start");
    if (t === "-" || t === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const e = this.peek(3);
      if ((e === "---" || e === "...") && In(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, e === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !In(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [t, e] = this.peek(2);
    if (!e && !this.atEnd)
      return this.setNext("block-start");
    if ((t === "-" || t === "?" || t === ":") && In(e)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const t = this.getLine();
    if (t === null)
      return this.setNext("doc");
    let e = yield* this.pushIndicators();
    switch (t[e]) {
      case "#":
        yield* this.pushCount(t.length - e);
      // fallthrough
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(hf), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return e += yield* this.parseBlockScalarHeader(), e += yield* this.pushSpaces(!0), yield* this.pushCount(t.length - e), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let t, e, n = -1;
    do
      t = yield* this.pushNewline(), t > 0 ? (e = yield* this.pushSpaces(!1), this.indentValue = n = e) : e = 0, e += yield* this.pushSpaces(!0);
    while (t + e > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((n !== -1 && n < this.indentNext && i[0] !== "#" || n === 0 && (i.startsWith("---") || i.startsWith("...")) && In(i[3])) && !(n === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield Ru, yield* this.parseLineStart();
    let o = 0;
    for (; i[o] === ","; )
      o += yield* this.pushCount(1), o += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (o += yield* this.pushIndicators(), i[o]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - o), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(hf), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const s = this.charAt(1);
        if (this.flowKey || In(s) || s === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      // fallthrough
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const t = this.charAt(0);
    let e = this.buffer.indexOf(t, this.pos + 1);
    if (t === "'")
      for (; e !== -1 && this.buffer[e + 1] === "'"; )
        e = this.buffer.indexOf("'", e + 2);
    else
      for (; e !== -1; ) {
        let o = 0;
        for (; this.buffer[e - 1 - o] === "\\"; )
          o += 1;
        if (o % 2 === 0)
          break;
        e = this.buffer.indexOf('"', e + 1);
      }
    const n = this.buffer.substring(0, e);
    let i = n.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const o = this.continueScalar(i + 1);
        if (o === -1)
          break;
        i = n.indexOf(`
`, o);
      }
      i !== -1 && (e = i - (n[i - 1] === "\r" ? 2 : 1));
    }
    if (e === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      e = this.buffer.length;
    }
    return yield* this.pushToIndex(e + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let t = this.pos;
    for (; ; ) {
      const e = this.buffer[++t];
      if (e === "+")
        this.blockScalarKeep = !0;
      else if (e > "0" && e <= "9")
        this.blockScalarIndent = Number(e) - 1;
      else if (e !== "-")
        break;
    }
    return yield* this.pushUntil((e) => In(e) || e === "#");
  }
  *parseBlockScalar() {
    let t = this.pos - 1, e = 0, n;
    e: for (let o = this.pos; n = this.buffer[o]; ++o)
      switch (n) {
        case " ":
          e += 1;
          break;
        case `
`:
          t = o, e = 0;
          break;
        case "\r": {
          const s = this.buffer[o + 1];
          if (!s && !this.atEnd)
            return this.setNext("block-scalar");
          if (s === `
`)
            break;
        }
        // fallthrough
        default:
          break e;
      }
    if (!n && !this.atEnd)
      return this.setNext("block-scalar");
    if (e >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = e : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const o = this.continueScalar(t + 1);
        if (o === -1)
          break;
        t = this.buffer.indexOf(`
`, o);
      } while (t !== -1);
      if (t === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        t = this.buffer.length;
      }
    }
    let i = t + 1;
    for (n = this.buffer[i]; n === " "; )
      n = this.buffer[++i];
    if (n === "	") {
      for (; n === "	" || n === " " || n === "\r" || n === `
`; )
        n = this.buffer[++i];
      t = i - 1;
    } else if (!this.blockScalarKeep)
      do {
        let o = t - 1, s = this.buffer[o];
        s === "\r" && (s = this.buffer[--o]);
        const u = o;
        for (; s === " "; )
          s = this.buffer[--o];
        if (s === `
` && o >= this.pos && o + 1 + e > u)
          t = o;
        else
          break;
      } while (!0);
    return yield bs, yield* this.pushToIndex(t + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const t = this.flowLevel > 0;
    let e = this.pos - 1, n = this.pos - 1, i;
    for (; i = this.buffer[++n]; )
      if (i === ":") {
        const o = this.buffer[n + 1];
        if (In(o) || t && xa.has(o))
          break;
        e = n;
      } else if (In(i)) {
        let o = this.buffer[n + 1];
        if (i === "\r" && (o === `
` ? (n += 1, i = `
`, o = this.buffer[n + 1]) : e = n), o === "#" || t && xa.has(o))
          break;
        if (i === `
`) {
          const s = this.continueScalar(n + 1);
          if (s === -1)
            break;
          n = Math.max(n, s - 2);
        }
      } else {
        if (t && xa.has(i))
          break;
        e = n;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield bs, yield* this.pushToIndex(e + 1, !0), t ? "flow" : "doc");
  }
  *pushCount(t) {
    return t > 0 ? (yield this.buffer.substr(this.pos, t), this.pos += t, t) : 0;
  }
  *pushToIndex(t, e) {
    const n = this.buffer.slice(this.pos, t);
    return n ? (yield n, this.pos += n.length, n.length) : (e && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(hf)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const t = this.flowLevel > 0, e = this.charAt(1);
        if (In(e) || t && xa.has(e))
          return t ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let t = this.pos + 2, e = this.buffer[t];
      for (; !In(e) && e !== ">"; )
        e = this.buffer[++t];
      return yield* this.pushToIndex(e === ">" ? t + 1 : t, !1);
    } else {
      let t = this.pos + 1, e = this.buffer[t];
      for (; e; )
        if (KB.has(e))
          e = this.buffer[++t];
        else if (e === "%" && i_.has(this.buffer[t + 1]) && i_.has(this.buffer[t + 2]))
          e = this.buffer[t += 3];
        else
          break;
      return yield* this.pushToIndex(t, !1);
    }
  }
  *pushNewline() {
    const t = this.buffer[this.pos];
    return t === `
` ? yield* this.pushCount(1) : t === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(t) {
    let e = this.pos - 1, n;
    do
      n = this.buffer[++e];
    while (n === " " || t && n === "	");
    const i = e - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = e), i;
  }
  *pushUntil(t) {
    let e = this.pos, n = this.buffer[e];
    for (; !t(n); )
      n = this.buffer[++e];
    return yield* this.pushToIndex(e, !1);
  }
}
class uC {
  constructor() {
    this.lineStarts = [], this.addNewLine = (t) => this.lineStarts.push(t), this.linePos = (t) => {
      let e = 0, n = this.lineStarts.length;
      for (; e < n; ) {
        const o = e + n >> 1;
        this.lineStarts[o] < t ? e = o + 1 : n = o;
      }
      if (this.lineStarts[e] === t)
        return { line: e + 1, col: 1 };
      if (e === 0)
        return { line: 0, col: t };
      const i = this.lineStarts[e - 1];
      return { line: e, col: t - i + 1 };
    };
  }
}
function Pr(r, t) {
  for (let e = 0; e < r.length; ++e)
    if (r[e].type === t)
      return !0;
  return !1;
}
function o_(r) {
  for (let t = 0; t < r.length; ++t)
    switch (r[t].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return t;
    }
  return -1;
}
function cC(r) {
  switch (r?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function Ra(r) {
  switch (r.type) {
    case "document":
      return r.start;
    case "block-map": {
      const t = r.items[r.items.length - 1];
      return t.sep ?? t.start;
    }
    case "block-seq":
      return r.items[r.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function Bi(r) {
  if (r.length === 0)
    return [];
  let t = r.length;
  e: for (; --t >= 0; )
    switch (r[t].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; r[++t]?.type === "space"; )
    ;
  return r.splice(t, r.length);
}
function s_(r) {
  if (r.start.type === "flow-seq-start")
    for (const t of r.items)
      t.sep && !t.value && !Pr(t.start, "explicit-key-ind") && !Pr(t.sep, "map-value-ind") && (t.key && (t.value = t.key), delete t.key, cC(t.value) ? t.value.end ? Array.prototype.push.apply(t.value.end, t.sep) : t.value.end = t.sep : Array.prototype.push.apply(t.start, t.sep), delete t.sep);
}
class Rp {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(t) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new lC(), this.onNewLine = t;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(t, e = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const n of this.lexer.lex(t, e))
      yield* this.next(n);
    e || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(t) {
    if (this.source = t, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += t.length;
      return;
    }
    const e = aC(t);
    if (e)
      if (e === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = e, yield* this.step(), e) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + t.length);
            break;
          case "space":
            this.atNewLine && t[0] === " " && (this.indent += t.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += t.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += t.length;
      }
    else {
      const n = `Not a YAML token: ${t}`;
      yield* this.pop({ type: "error", offset: this.offset, message: n, source: t }), this.offset += t.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const t = this.peek(1);
    if (this.type === "doc-end" && (!t || t.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!t)
      return yield* this.stream();
    switch (t.type) {
      case "document":
        return yield* this.document(t);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(t);
      case "block-scalar":
        return yield* this.blockScalar(t);
      case "block-map":
        return yield* this.blockMap(t);
      case "block-seq":
        return yield* this.blockSequence(t);
      case "flow-collection":
        return yield* this.flowCollection(t);
      case "doc-end":
        return yield* this.documentEnd(t);
    }
    yield* this.pop();
  }
  peek(t) {
    return this.stack[this.stack.length - t];
  }
  *pop(t) {
    const e = t ?? this.stack.pop();
    if (!e)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield e;
    else {
      const n = this.peek(1);
      switch (e.type === "block-scalar" ? e.indent = "indent" in n ? n.indent : 0 : e.type === "flow-collection" && n.type === "document" && (e.indent = 0), e.type === "flow-collection" && s_(e), n.type) {
        case "document":
          n.value = e;
          break;
        case "block-scalar":
          n.props.push(e);
          break;
        case "block-map": {
          const i = n.items[n.items.length - 1];
          if (i.value) {
            n.items.push({ start: [], key: e, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (i.sep)
            i.value = e;
          else {
            Object.assign(i, { key: e, sep: [] }), this.onKeyLine = !i.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const i = n.items[n.items.length - 1];
          i.value ? n.items.push({ start: [], value: e }) : i.value = e;
          break;
        }
        case "flow-collection": {
          const i = n.items[n.items.length - 1];
          !i || i.value ? n.items.push({ start: [], key: e, sep: [] }) : i.sep ? i.value = e : Object.assign(i, { key: e, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop(), yield* this.pop(e);
      }
      if ((n.type === "document" || n.type === "block-map" || n.type === "block-seq") && (e.type === "block-map" || e.type === "block-seq")) {
        const i = e.items[e.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && o_(i.start) === -1 && (e.indent === 0 || i.start.every((o) => o.type !== "comment" || o.indent < e.indent)) && (n.type === "document" ? n.end = i.start : n.items.push({ start: i.start }), e.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const t = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && t.start.push(this.sourceToken), this.stack.push(t);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(t) {
    if (t.value)
      return yield* this.lineEnd(t);
    switch (this.type) {
      case "doc-start": {
        o_(t.start) !== -1 ? (yield* this.pop(), yield* this.step()) : t.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        t.start.push(this.sourceToken);
        return;
    }
    const e = this.startBlockValue(t);
    e ? this.stack.push(e) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(t) {
    if (this.type === "map-value-ind") {
      const e = Ra(this.peek(2)), n = Bi(e);
      let i;
      t.end ? (i = t.end, i.push(this.sourceToken), delete t.end) : i = [this.sourceToken];
      const o = {
        type: "block-map",
        offset: t.offset,
        indent: t.indent,
        items: [{ start: n, key: t, sep: i }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = o;
    } else
      yield* this.lineEnd(t);
  }
  *blockScalar(t) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        t.props.push(this.sourceToken);
        return;
      case "scalar":
        if (t.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let e = this.source.indexOf(`
`) + 1;
          for (; e !== 0; )
            this.onNewLine(this.offset + e), e = this.source.indexOf(`
`, e) + 1;
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(t) {
    const e = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, e.value) {
          const n = "end" in e.value ? e.value.end : void 0;
          (Array.isArray(n) ? n[n.length - 1] : void 0)?.type === "comment" ? n?.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else e.sep ? e.sep.push(this.sourceToken) : e.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (e.value)
          t.items.push({ start: [this.sourceToken] });
        else if (e.sep)
          e.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(e.start, t.indent)) {
            const i = t.items[t.items.length - 2]?.value?.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, e.start), i.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          e.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= t.indent) {
      const n = !this.onKeyLine && this.indent === t.indent, i = n && (e.sep || e.explicitKey) && this.type !== "seq-item-ind";
      let o = [];
      if (i && e.sep && !e.value) {
        const s = [];
        for (let u = 0; u < e.sep.length; ++u) {
          const l = e.sep[u];
          switch (l.type) {
            case "newline":
              s.push(u);
              break;
            case "space":
              break;
            case "comment":
              l.indent > t.indent && (s.length = 0);
              break;
            default:
              s.length = 0;
          }
        }
        s.length >= 2 && (o = e.sep.splice(s[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || e.value ? (o.push(this.sourceToken), t.items.push({ start: o }), this.onKeyLine = !0) : e.sep ? e.sep.push(this.sourceToken) : e.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !e.sep && !e.explicitKey ? (e.start.push(this.sourceToken), e.explicitKey = !0) : i || e.value ? (o.push(this.sourceToken), t.items.push({ start: o, explicitKey: !0 })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: !0 }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (e.explicitKey)
            if (e.sep)
              if (e.value)
                t.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Pr(e.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: null, sep: [this.sourceToken] }]
                });
              else if (cC(e.key) && !Pr(e.sep, "newline")) {
                const s = Bi(e.start), u = e.key, l = e.sep;
                l.push(this.sourceToken), delete e.key, delete e.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: u, sep: l }]
                });
              } else o.length > 0 ? e.sep = e.sep.concat(o, this.sourceToken) : e.sep.push(this.sourceToken);
            else if (Pr(e.start, "newline"))
              Object.assign(e, { key: null, sep: [this.sourceToken] });
            else {
              const s = Bi(e.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: s, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            e.sep ? e.value || i ? t.items.push({ start: o, key: null, sep: [this.sourceToken] }) : Pr(e.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : e.sep.push(this.sourceToken) : Object.assign(e, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const s = this.flowScalar(this.type);
          i || e.value ? (t.items.push({ start: o, key: s, sep: [] }), this.onKeyLine = !0) : e.sep ? this.stack.push(s) : (Object.assign(e, { key: s, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const s = this.startBlockValue(t);
          if (s) {
            if (s.type === "block-seq") {
              if (!e.explicitKey && e.sep && !Pr(e.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else n && t.items.push({ start: o });
            this.stack.push(s);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(t) {
    const e = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (e.value) {
          const n = "end" in e.value ? e.value.end : void 0;
          (Array.isArray(n) ? n[n.length - 1] : void 0)?.type === "comment" ? n?.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else
          e.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (e.value)
          t.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(e.start, t.indent)) {
            const i = t.items[t.items.length - 2]?.value?.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, e.start), i.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          e.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (e.value || this.indent <= t.indent)
          break;
        e.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== t.indent)
          break;
        e.value || Pr(e.start, "seq-item-ind") ? t.items.push({ start: [this.sourceToken] }) : e.start.push(this.sourceToken);
        return;
    }
    if (this.indent > t.indent) {
      const n = this.startBlockValue(t);
      if (n) {
        this.stack.push(n);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(t) {
    const e = t.items[t.items.length - 1];
    if (this.type === "flow-error-end") {
      let n;
      do
        yield* this.pop(), n = this.peek(1);
      while (n && n.type === "flow-collection");
    } else if (t.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !e || e.sep ? t.items.push({ start: [this.sourceToken] }) : e.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !e || e.value ? t.items.push({ start: [], key: null, sep: [this.sourceToken] }) : e.sep ? e.sep.push(this.sourceToken) : Object.assign(e, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !e || e.value ? t.items.push({ start: [this.sourceToken] }) : e.sep ? e.sep.push(this.sourceToken) : e.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !e || e.value ? t.items.push({ start: [], key: i, sep: [] }) : e.sep ? this.stack.push(i) : Object.assign(e, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          t.end.push(this.sourceToken);
          return;
      }
      const n = this.startBlockValue(t);
      n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
    } else {
      const n = this.peek(2);
      if (n.type === "block-map" && (this.type === "map-value-ind" && n.indent === t.indent || this.type === "newline" && !n.items[n.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && n.type !== "flow-collection") {
        const i = Ra(n), o = Bi(i);
        s_(t);
        const s = t.end.splice(1, t.end.length);
        s.push(this.sourceToken);
        const u = {
          type: "block-map",
          offset: t.offset,
          indent: t.indent,
          items: [{ start: o, key: t, sep: s }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = u;
      } else
        yield* this.lineEnd(t);
    }
  }
  flowScalar(t) {
    if (this.onNewLine) {
      let e = this.source.indexOf(`
`) + 1;
      for (; e !== 0; )
        this.onNewLine(this.offset + e), e = this.source.indexOf(`
`, e) + 1;
    }
    return {
      type: t,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(t) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const e = Ra(t), n = Bi(e);
        return n.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, explicitKey: !0 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const e = Ra(t), n = Bi(e);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(t, e) {
    return this.type !== "comment" || this.indent <= e ? !1 : t.every((n) => n.type === "newline" || n.type === "space");
  }
  *documentEnd(t) {
    this.type !== "doc-mode" && (t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(t) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      // fallthrough
      case "space":
      case "comment":
      default:
        t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function fC(r) {
  const t = r.prettyErrors !== !1;
  return { lineCounter: r.lineCounter || t && new uC() || null, prettyErrors: t };
}
function zB(r, t = {}) {
  const { lineCounter: e, prettyErrors: n } = fC(t), i = new Rp(e?.addNewLine), o = new xp(t), s = Array.from(o.compose(i.parse(r)));
  if (n && e)
    for (const u of s)
      u.errors.forEach(zl(r, e)), u.warnings.forEach(zl(r, e));
  return s.length > 0 ? s : Object.assign([], { empty: !0 }, o.streamInfo());
}
function dC(r, t = {}) {
  const { lineCounter: e, prettyErrors: n } = fC(t), i = new Rp(e?.addNewLine), o = new xp(t);
  let s = null;
  for (const u of o.compose(i.parse(r), !0, r.length))
    if (!s)
      s = u;
    else if (s.options.logLevel !== "silent") {
      s.errors.push(new fi(u.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return n && e && (s.errors.forEach(zl(r, e)), s.warnings.forEach(zl(r, e))), s;
}
function YB(r, t, e) {
  let n;
  typeof t == "function" ? n = t : e === void 0 && t && typeof t == "object" && (e = t);
  const i = dC(r, e);
  if (!i)
    return null;
  if (i.warnings.forEach((o) => PT(i.options.logLevel, o)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: n }, e));
}
function ZB(r, t, e) {
  let n = null;
  if (typeof t == "function" || Array.isArray(t) ? n = t : e === void 0 && t && (e = t), typeof e == "string" && (e = e.length), typeof e == "number") {
    const i = Math.round(e);
    e = i < 1 ? void 0 : i > 8 ? { indent: 8 } : { indent: i };
  }
  if (r === void 0) {
    const { keepUndefined: i } = e ?? t ?? {};
    if (!i)
      return;
  }
  return Ti(r) && !n ? r.toString(e) : new So(r, n, e).toString(e);
}
const jB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias: gu,
  CST: WB,
  Composer: xp,
  Document: So,
  Lexer: lC,
  LineCounter: uC,
  Pair: Dt,
  Parser: Rp,
  Scalar: De,
  Schema: Eu,
  YAMLError: Ep,
  YAMLMap: an,
  YAMLParseError: fi,
  YAMLSeq: Hr,
  YAMLWarning: jT,
  isAlias: bi,
  isCollection: vt,
  isDocument: Ti,
  isMap: wo,
  isNode: _t,
  isPair: mt,
  isScalar: ut,
  isSeq: bo,
  parse: YB,
  parseAllDocuments: zB,
  parseDocument: dC,
  stringify: ZB,
  visit: Vr,
  visitAsync: mu
}, Symbol.toStringTag, { value: "Module" }));
function QB(r, t) {
  return r.status === "done" && r.result !== null && typeof r.result == "object" && "output" in r.result && typeof r.result.output == "string" ? t.detail === "full" && "hidden_truncatedOutput" in r.result && typeof r.result.hidden_truncatedOutput == "string" ? r.result.hidden_truncatedOutput + // Strip out the '--- Truncated ...' line explaining what got truncated
  r.result.output.split(`
`).slice(1).join(`
`) : r.result.output : jB.stringify(r);
}
function XB(r) {
  return !r || !Array.isArray(r) ? [] : r.filter((t) => t.compatibilityDate === "2025-05-13");
}
function eV(r, t) {
  if (!r) return { action: null };
  r = XB(r);
  for (const e of r)
    if (e.if !== !1)
      switch (e.on.event) {
        case "tool:pre-execute": {
          if (!(Array.isArray(e.on.tool) ? e.on.tool : [e.on.tool]).includes(t.toolUse.name))
            continue;
          const i = JSON.stringify(t.toolUse.input), o = Array.isArray(e.on["input.contains"]) ? e.on["input.contains"] : [e.on["input.contains"]];
          for (const s of o)
            if (i.includes(s) && (oe.debug(`Hook triggered: ${e.id}`, {
              hookID: e.id,
              threadID: t.threadID,
              toolName: t.toolUse.name,
              toolUseID: t.toolUse.id,
              matchString: s,
              action: e.action
            }), e.action.type === "send-user-message"))
              return {
                hookID: e.id,
                action: e.action
              };
        }
      }
  return { action: null };
}
async function tV(r, t) {
  if (!t.action) return { abortOp: !1 };
  switch (t.action.type) {
    case "send-user-message":
      return await r.handle({
        type: "user:message",
        message: {
          content: [
            {
              type: "text",
              text: t.action.message
            }
          ],
          source: { type: "hook", hook: t.hookID }
        }
      }), { abortOp: !0 };
  }
}
async function nV(r, t) {
  return (await import("./list_directory.node-Dmx2XM_W.js")).resolveArgumentDirectoryNode(r, t);
}
function rV(r, t) {
  r["~debug"] = {
    ...r["~debug"] ?? {},
    ...t.usage ? { lastInferenceUsage: t.usage } : {},
    ...t.params ? { lastInferenceInput: t.params } : {}
  };
}
function iV(r, t) {
  const e = JSON.parse(JSON.stringify(r));
  switch (e.v++, t.type) {
    case "cancelled": {
      Ia(e);
      const n = e.messages.at(-1);
      if (n?.role === "user") {
        const i = n.content.findLast(
          (o) => o.type === "tool_result"
        );
        i && (i.run.status = "cancelled");
      }
      break;
    }
    case "summary:created": {
      if (t.summary.type === "external")
        e.summaryThreads || (e.summaryThreads = []), e.summaryThreads.push(t.summary.summaryThreadID), e.messages.push({
          role: "info",
          content: [
            {
              type: "summary",
              summary: {
                type: "thread",
                thread: t.summary.summaryThreadID
              },
              usageBefore: e["~debug"]?.lastInferenceUsage
            }
          ]
        });
      else if (t.summary.type === "internal") {
        const n = e["~debug"]?.lastInferenceUsage;
        e["~debug"] = void 0, e.messages.push({
          role: "info",
          content: [
            {
              type: "summary",
              summary: {
                type: "message",
                summary: t.summary.summary
              },
              usageBefore: n
            }
          ]
        });
      }
      break;
    }
    case "user:message": {
      Ia(e);
      const n = {
        role: "user",
        ...t.message
      };
      if (t.index !== void 0) {
        if (!e.messages[t.index])
          throw new Error(`user message at index ${t.index} not found`);
        e.messages.splice(t.index, e.messages.length - t.index, n);
      } else
        e.messages.push(n);
      break;
    }
    case "user:tool-input": {
      if (!no(e, t.toolUse)) {
        oe.debug(
          `Ignoring user:tool-input delta for missing tool use ${t.toolUse} (likely deleted due to thread edit/truncation)`
        );
        break;
      }
      const i = db(e, t.toolUse);
      if (!i) {
        oe.debug(
          `Ignoring user:tool-input delta for missing tool result block ${t.toolUse} (likely deleted due to thread edit/truncation)`
        );
        break;
      }
      i.userInput = t.value;
      break;
    }
    case "tool:data": {
      if (!ZM(e, t.toolUse)) {
        oe.debug(
          `Ignoring tool:data delta for missing tool use ${t.toolUse} (likely deleted due to thread edit/truncation)`
        );
        break;
      }
      pf(e, t.toolUse, t.data);
      break;
    }
    case "assistant:message": {
      Ia(e), e.messages.push(t.message);
      break;
    }
    case "assistant:message-delta": {
      const n = t.event, i = e.messages.at(-1);
      if (n.type === "message_start") {
        if (!i || i.role !== "user")
          throw new Error("(unreachable) assistant message start without user message");
        return Ia(e), e.messages = [
          ...e.messages,
          { role: "assistant", content: [], state: { type: "streaming" } }
        ], e;
      }
      const o = lo(e, "assistant");
      if (!o)
        throw new Error("(unreachable) no last assistant message to update");
      switch (n.type) {
        case "content_block_start": {
          if (n.index !== o.content.length)
            throw new Error("(bug) content block delta out of order");
          let s;
          switch (n.content_block.type) {
            case "text":
              s = { type: "text", text: "" };
              break;
            case "thinking":
              s = { type: "thinking", thinking: "", signature: "" };
              break;
            case "redacted_thinking":
              s = {
                type: "redacted_thinking",
                data: n.content_block.data
              };
              break;
            case "tool_use":
              s = {
                type: "tool_use",
                id: n.content_block.id,
                name: n.content_block.name,
                input: n.content_block.input,
                inputPartialJSON: { json: "" }
              };
              break;
            default:
              throw new Error(
                `unsupported content block type: ${n.content_block.type}`
              );
          }
          o.content.push(s);
          break;
        }
        case "content_block_delta": {
          const s = o.content[n.index];
          if (!s)
            throw new Error("(bug) content block delta index out of bounds");
          switch (n.delta.type) {
            case "text_delta": {
              if (s.type !== "text")
                throw new Error(
                  `(bug) content block delta type mismatch: text_delta !== ${s.type}`
                );
              s.text += n.delta.text;
              break;
            }
            case "input_json_delta": {
              if (s.type !== "tool_use")
                throw new Error(
                  `(bug) content block delta type mismatch: input_json_delta !== ${s.type}`
                );
              if (!s.inputPartialJSON)
                throw new Error("(bug) input_json_delta without incomplete");
              s.inputPartialJSON.json += n.delta.partial_json;
              try {
                s.input = fb(s.inputPartialJSON.json);
              } catch {
                s.input = {};
              }
              break;
            }
            case "thinking_delta": {
              if (s.type !== "thinking")
                throw new Error(
                  `(bug) content block delta type mismatch: thinking_delta !== ${s.type}`
                );
              s.thinking += n.delta.thinking;
              break;
            }
            case "signature_delta": {
              if (s.type !== "thinking")
                throw new Error(
                  `(bug) content block delta type mismatch: signature_delta !== ${s.type}`
                );
              s.signature = n.delta.signature;
              break;
            }
          }
          break;
        }
        case "content_block_stop": {
          const s = o.content[n.index];
          if (!s)
            throw new Error("(bug) content block delta index out of bounds");
          if (s.type === "tool_use") {
            if (!s.inputPartialJSON)
              throw new Error("(bug) content block stop without incomplete");
            s.inputPartialJSON.json === "" ? s.input = {} : s.input = JSON.parse(s.inputPartialJSON.json), delete s.inputPartialJSON;
          }
          break;
        }
        case "message_delta": {
          if (n.delta.stop_reason) {
            if (n.delta.stop_reason === "max_tokens")
              for (const s of o.content)
                s.type === "tool_use" && s.inputPartialJSON && (delete s.inputPartialJSON, pf(e, s.id, {
                  status: "error",
                  error: {
                    message: "Ran into max tokens limit of 200 tokens. Received only partial input for tool."
                  }
                }));
            else
              for (const s of o.content)
                if (s.type === "tool_use" && s.inputPartialJSON) {
                  oe.debug(
                    "Found a block with inputPartialJSON still set on message_delta"
                  );
                  try {
                    s.inputPartialJSON.json !== "" ? s.input = JSON.parse(s.inputPartialJSON.json) : s.input = {};
                  } catch (u) {
                    oe.error(
                      `Failed to parse malformed JSON for tool_use ${s.id}`,
                      u,
                      {
                        threadId: r.id,
                        blockId: s.id,
                        input: s.inputPartialJSON.json
                      }
                    );
                    const l = `Malformed JSON: '${s.inputPartialJSON.json}'.`;
                    pf(e, s.id, {
                      status: "error",
                      error: {
                        message: l
                        // Pass enhanced error message to tool result
                      }
                    });
                  }
                  delete s.inputPartialJSON;
                }
            o.state = { type: "complete", stopReason: n.delta.stop_reason };
          }
          break;
        }
      }
      break;
    }
    case "inference:completed": {
      rV(e, { usage: t.usage, params: t.params });
      break;
    }
    case "title": {
      e.title = t.value || void 0;
      break;
    }
    case "environment": {
      e.env = t.env;
      break;
    }
  }
  return e;
}
function Ia(r) {
  const t = lo(r, "assistant");
  if (!t) return;
  let e = !1;
  if (t.state.type === "streaming" ? (t.state = { type: "cancelled" }, e = !0) : t.state.type === "complete" && t.content.some(
    (i) => i.type === "tool_use" && "inputPartialJSON" in i
  ) && (t.state = { type: "cancelled" }, e = !0), e) {
    for (const n of t.content)
      if (n.type === "tool_use" && n.inputPartialJSON) {
        oe.debug(`Cleaning up partial tool_use ${n.id}`, {
          name: "markPriorStreamingAssistantMessageAsCancelled",
          threadID: r.id,
          blockID: n.id
        });
        try {
          n.inputPartialJSON.json !== "" ? n.input = fb(n.inputPartialJSON.json) : n.input = {};
        } catch (i) {
          oe.warn(
            `Failed to parse partial JSON for cancelled tool_use ${n.id}:`,
            i,
            {
              name: "markPriorStreamingAssistantMessageAsCancelled",
              threadID: r.id,
              blockID: n.id,
              input: n.inputPartialJSON.json
            }
          ), n.input = {};
        }
        delete n.inputPartialJSON;
      }
  }
}
function pf(r, t, e) {
  const n = r.messages.at(-1);
  let i;
  n && n.role === "user" ? i = n : (i = { role: "user", content: [] }, r.messages.push(i));
  let o = db(r, t);
  o ? o.run = e : (o = {
    type: "tool_result",
    toolUseID: t,
    run: e
  }, i.content.push(o));
}
async function oV(r, t) {
  const e = hb(r.content);
  if (!e)
    return;
  const n = await it(wn, t), s = (await (await jM(n)).messages.create(
    {
      model: "claude-3-5-haiku-20241022",
      max_tokens: 60,
      temperature: 0.7,
      system: `You are an assistant that generates short, descriptive titles (maximum 7 words, "Sentence case" with the first word capitalized not "Title Case") based on user's message to an agentic coding tool. Your titles should be concise (max 7 words) and capture the essence of the query or topic. DO NOT ASSUME OR GUESS the user's intent beyond what is in their message. Omit generic words like "question", "request", etc. Be professional and precise. Use common software engineering terms and acronyms if they are helpful. Use the set_title tool to provide your answer.`,
      messages: [
        {
          role: "user",
          content: `<message>${e}</message>`
        }
      ],
      tools: [
        {
          name: "set_title",
          input_schema: {
            type: "object",
            properties: {
              title: {
                type: "string",
                description: 'The short thread title (maximum 7 words, "Sentence case" with the first word capitalized not "Title Case") that you generated for the message'
              }
            },
            required: ["title"]
          }
        }
      ],
      tool_choice: {
        type: "tool",
        name: "set_title",
        disable_parallel_tool_use: !0
      }
    },
    { stream: !1, signal: t }
  )).content.at(0);
  if (!s)
    throw new Error("no content in generateThreadTitle response");
  if (s.type !== "tool_use" || s.name !== "set_title")
    throw new Error("missing or invalid tool_use in generateThreadTitle response");
  return s.input && typeof s.input == "object" && "title" in s.input && typeof s.input.title == "string" ? s.input.title : void 0;
}
function sV(r, t) {
  return {
    ...t,
    waitingForUserInput: r && t?.state === "active" ? aV(r, t.inferenceState) : !1
  };
}
function aV(r, t) {
  if (t === "running")
    return !1;
  const e = r.messages.at(-1);
  return e ? e.role === "assistant" ? e.state.type === "complete" && e.state.stopReason === "end_turn" ? "user-message-reply" : !1 : e.content.some((n) => n.type === "tool_result" && n.run.status === "blocked-on-user") ? "tool-use" : !1 : "user-message-initial";
}
async function lV({
  configService: r,
  filesystem: t
}, e) {
  const i = ((await it(r.workspaceRoots)).at(0) ?? null)?.fsPath;
  if (!i)
    return {
      role: "user",
      content: e.content,
      source: e.source,
      fileMentions: void 0,
      userState: void 0
    };
  const o = (await import("./files-U5BBkj-L.js").then(
    ({ getFileMentions: u }) => u(
      hb(e.content),
      i,
      t
    )
  )).serialize();
  return {
    role: "user",
    content: e.content,
    source: e.source,
    fileMentions: o,
    userState: void 0
  };
}
const a_ = Zh(wn);
async function uV() {
  return await it(a_.observable), a_.value.last;
}
class to {
  constructor(t, e) {
    this.deps = t, this.threadID = e, this.filesystem = t.createFileSystem(this.threadID), this.createFileTracker = (n) => QM({
      ...n,
      filesystem: this.filesystem,
      threadID: this.threadID
    });
  }
  /**
   * Get or create the single {@link ThreadWorker} for the given thread.
   */
  static async getOrCreateForThread(t, e) {
    let n = this.threadWorkers.get(e);
    return n || (n = new to(t, e), this.threadWorkers.set(e, n)), n;
  }
  static threadWorkers = hP();
  static get statuses() {
    return this.threadWorkers.observable.pipe(
      Gn(
        (t) => t.size === 0 ? It.of({}) : kn(
          ...Array.from(t.values()).map(
            (e) => e.status.pipe(
              at(
                (n) => [
                  e.threadID,
                  e.threadReadWriter ? sV(e.thread, n) : void 0
                ]
              )
            )
          )
        ).pipe(at((e) => Object.fromEntries(e)))
      )
    );
  }
  static prettyPrintToolRun(t, e, n) {
    const i = this.threadWorkers.get(t);
    for (const o of i?.thread.messages ?? [])
      for (const s of o.content)
        if (s.type === "tool_result" && s.toolUseID === e)
          return QB(s.run, n);
    throw new Error(`Tool run not found for thread ${t} and tool use ${e}`);
  }
  static async cancelToolRun(t, e) {
    await this.threadWorkers.get(t)?.findAndCancelToolRun(e);
  }
  static async detachToolRun(t, e) {
    await this.threadWorkers.get(t)?.detachToolRun(e);
  }
  static async cancel(t) {
    await this.threadWorkers.get(t)?.cancel();
  }
  static dispose(t) {
    this.threadWorkers.get(t)?.dispose();
  }
  static async retry(t) {
    const e = this.threadWorkers.get(t);
    if (!e)
      throw new Error(`No active worker for thread ${t}`);
    await e.retry();
  }
  /**
   * Reverts all file changes made in this thread by restoring original file content.
   * For newly created files, they will be deleted.
   */
  static async revertFileChanges(t, e) {
    const n = this.threadWorkers.get(t);
    if (!n)
      throw new Error(`No active worker for thread ${t}`);
    await n.revertFileChanges(e);
  }
  /**
   * Cleans up backup files for a thread. This should be called when a thread is deleted.
   */
  static async cleanupThreadBackups(t, e) {
    const n = this.threadWorkers.get(e);
    if (n)
      await n.filesystem.cleanupBackupFiles();
    else {
      const i = t.createFileSystem(e);
      try {
        await i.cleanupBackupFiles(), oe.debug(`Cleaned up backup files for thread ${e}`, { threadID: e });
      } catch (o) {
        oe.error("Error cleaning up thread backups", o, { threadID: e });
      }
    }
  }
  /**
   * Checks for any in-progress tool results in the thread and re-invokes the tools
   * if they don't have a corresponding operation in this.ops.tools.
   * This happens when the ThreadWorker is disposed in the middle of an operation.
   */
  async resumeInProgressTools() {
    for (const t of this.thread.messages)
      if (t.role === "user")
        for (const e of t.content) {
          if (e.type !== "tool_result" || !(e.run.status === "in-progress" && !this.ops.tools[e.toolUseID]))
            continue;
          const i = this.findToolUseById(e.toolUseID);
          if (!i)
            continue;
          if (i.name === sh || i.name === XM) {
            this.findAndCancelToolRun(e.toolUseID);
            continue;
          }
          oe.debug(`re-invoking tool ${i.name} with ID ${e.toolUseID}`, {
            name: "resumeInProgressTools",
            threadID: this.threadID
          }), this.invokeTool(i, e.userInput);
        }
    await this.updateFileChanges();
  }
  /**
   * Find a specific tool use block by ID
   */
  findToolUseById(t) {
    for (const e of this.thread.messages)
      if (e.role === "assistant") {
        for (const n of e.content)
          if (n.type === "tool_use" && n.id === t)
            return n;
      }
  }
  /**
   * Scan thread history and track all file mentions and tool result files
   */
  trackFilesFromHistory() {
    oe.debug("Tracking files from thread history", {
      name: "trackFilesFromHistory",
      threadID: this.threadID
    });
    for (const t of this.thread.messages) {
      if (t.role === "user" && t.fileMentions?.files)
        for (const e of t.fileMentions.files)
          this.trackFile(e.path);
      if (t.role === "user") {
        for (const e of t.content)
          if (e.type === "tool_result" && e.run.status === "done")
            for (const n of e.run.files ?? [])
              this.trackFile(n);
      }
    }
  }
  /**
   * Dispose the ThreadWorker for a specific thread ID.
   */
  static disposeForThread(t) {
    const e = this.threadWorkers.get(t);
    e && (e.dispose(), this.threadWorkers.delete(t));
  }
  /**
   * The operations that we can spawn. Any other future kind of operation we perform should have
   * an {@link AbortController} recorded here.
   */
  ops = {
    tools: {},
    toolMessages: {},
    inference: null
  };
  _state = new Nr("initial");
  state = this._state.pipe(gs(), eu());
  /** Promise queue to serialize calls to handle() */
  handlePromise = Promise.resolve();
  ephemeralError = new Nr(void 0);
  inferenceState = new Nr("idle");
  fileChanges = new Nr({ files: [] });
  trackedFiles = /* @__PURE__ */ new Set();
  fileChangeRecords = /* @__PURE__ */ new Map();
  createFileTracker = ek;
  filesystem;
  status = this.state.pipe(
    Gn(
      (t) => t === "active" ? kn(this.inferenceState, this.fileChanges, this.ephemeralError).pipe(
        at(
          ([e, n, i]) => ({
            state: t,
            inferenceState: e,
            fileChanges: n,
            ephemeralError: i ? {
              message: i.message,
              stack: "stack" in i ? i.stack : void 0,
              error: "error" in i && i.error && typeof i.error == "object" && "error" in i.error ? i.error.error : void 0
            } : void 0
          })
        )
      ) : It.of({ state: t })
    )
  );
  // The ThreadWorker takes an exclusive synchronous read-writer handle for the thread. This is
  // because it needs to be able to write synchronously to it (to avoid race conditions and the
  // need for transactional reads/writes) and because the ThreadWorker assumes it's the only
  // writer. Other code can observe the thread's updates asynchronously.
  threadReadWriter = null;
  get thread() {
    if (!this.threadReadWriter)
      throw new Error(`thread read-writer not initialized for ThreadWorker: ${this.threadID}`);
    return this.threadReadWriter.read();
  }
  set thread(t) {
    if (!this.threadReadWriter)
      throw new Error(`thread read-writer not initialized for ThreadWorker: ${this.threadID}`);
    this.threadReadWriter.write(t);
  }
  async acquireThread() {
    this.threadReadWriter || (this.threadReadWriter = await this.deps.threadService.exclusiveSyncReadWriter(
      this.threadID
    ), this._state.next("active"));
  }
  /** For testing only. */
  __testing__setThread(t) {
  }
  /**
   * Resume the worker, figuring out what needs to be done based on the (possibly
   * incomplete/in-progress/invalid) state of the thread.
   */
  async resume() {
    if (this.resumed)
      return;
    if (this.resumed = !0, this.handleCalled)
      throw new Error("cannot call ThreadWorker.resume after ThreadWorker.handle");
    await this.acquireThread(), await this.restoreFileChangesFromBackups(), this.trackFilesFromHistory();
    const t = this.thread.messages.at(-1);
    if (tk(t) || nk(t)) {
      this.inferenceState.next("cancelled");
      return;
    }
    await this.resumeInProgressTools();
    const e = this.thread.messages.findLastIndex(
      (i) => i.role === "user" ? rk(i) : i.role === "assistant" && i.state.type === "complete"
    );
    if (e === -1) {
      if (this.thread.messages.length !== 0)
        throw new Error(`(bug) invalid thread: ${this.threadID}`);
      return;
    }
    const n = this.thread.messages[e];
    switch (n.role) {
      case "user":
        this.onThreadDelta({ type: "user:message", message: n });
        break;
      case "assistant":
        this.onThreadDelta({ type: "assistant:message", message: n });
        break;
    }
  }
  resumed = !1;
  async summarizeThread() {
    await this.acquireThread(), await this.cancel();
    const t = await this.deps.threadSummaryService.summarizeThread(this.threadID);
    await this.handle({
      type: "summary:created",
      summary: { type: "internal", summary: t }
    });
  }
  async createSummaryThread() {
    await this.acquireThread(), await this.cancel();
    const t = await this.deps.threadSummaryService.createSummaryThread(
      this.threadID
    );
    return await this.handle({
      type: "summary:created",
      summary: { type: "external", summaryThreadID: t }
    }), t;
  }
  /**
   * Handle a thread {@link delta}, updating the thread and reacting to it.
   */
  async handle(t, e) {
    this.handlePromise = this.handlePromise.then(async () => {
      await this.innerHandle(t, e);
    }).catch((n) => {
      oe.error("Unhandled error in handle promise queue", n, {
        threadID: this.threadID
      });
    }), await this.handlePromise;
  }
  async innerHandle(t, e) {
    if (this.isDisposed) {
      oe.debug(`Skipping ${t.type} - worker disposed.`, {
        name: "handle queue",
        threadID: this.threadID
      });
      return;
    }
    if (e?.aborted) {
      oe.debug(`Skipping ${t.type} - signal aborted.`, {
        name: "handle queue",
        threadID: this.threadID
      });
      return;
    }
    await this.resume(), this.handleCalled = !0, await this.acquireThread(), t.type === "user:message" && (t.index !== void 0 && await this.revertPriorFileChanges(t.index), t.message = await lV(
      { configService: this.deps.configService, filesystem: this.filesystem },
      t.message
    ), t.message.fileMentions?.imageBlocks?.length && (oe.debug(
      `Adding ${t.message.fileMentions.imageBlocks.length} image attachments to message`,
      {
        name: "adding image attachments",
        threadID: this.threadID
      }
    ), t.message.content = [
      ...t.message.content,
      ...t.message.fileMentions.imageBlocks
    ]), t.message.meta || (t.message.meta = {}), t.message.meta.sentAt = Date.now(), e?.throwIfAborted());
    try {
      this.ephemeralError.getValue() !== void 0 && this.ephemeralError.next(void 0), this.updateThread(t), this.onThreadDelta(t);
    } catch (n) {
      tf(n) ? oe.debug(`AbortError caught during handle processing for ${t.type}.`, {
        name: "handle queue",
        threadID: this.threadID
      }) : (oe.error("Ephemeral error during handle processing", n, {
        name: "ThreadWorker",
        threadID: this.threadID
      }), this.ephemeralError.next(n instanceof Error ? n : new Error(String(n))));
    }
  }
  handleCalled = !1;
  /**
   * Update the thread by applying the {@link delta}.
   */
  updateThread(t) {
    this.thread = iV(this.thread, t);
  }
  /**
   * React to a {@link ThreadDelta} change that has already been applied and written to the thread.
   */
  onThreadDelta(t) {
    switch (t.type) {
      case "user:message": {
        if (t.index !== void 0)
          this.trackedFiles.clear(), this.thread.messages.forEach((e) => {
            if (e.role === "user") {
              for (const n of e.content)
                if (n.type === "tool_result" && n.run.status === "done")
                  for (const i of n.run.files ?? [])
                    oe.info(`tracking (again) ${i}`, {
                      threadID: this.threadID
                    }), this.trackFile(i);
              for (const n of e.fileMentions?.files ?? [])
                oe.debug(`file: ${n.path}`, {
                  name: "tracking file mention",
                  threadID: this.threadID
                }), this.trackFile(n.path);
            }
          });
        else
          for (const e of t.message.fileMentions?.files ?? [])
            oe.debug(`file: ${e.path}`, {
              name: "tracking file mention",
              threadID: this.threadID
            }), this.trackFile(e.path);
        this.runInferenceAndUpdateThread();
        break;
      }
      case "user:tool-input": {
        const e = no(this.thread, t.toolUse);
        e && this.invokeTool(e, t.value);
        break;
      }
      case "tool:data": {
        const e = l_(this.thread, t.toolUse);
        oe.debug(
          `updated tool_result${e ? " and running inference because all tools completed" : ""}`,
          {
            name: `handleThreadDelta(${t.type}, ${t.toolUse}, ${t.data.status})`,
            threadID: this.threadID
          }
        ), e && this.inferenceState.getValue() !== "cancelled" && this.runInferenceAndUpdateThread();
        break;
      }
      case "assistant:message": {
        const e = this.findToolUsesNeedingInvocation(t.message);
        oe.debug(
          `saw ${e.length} tool uses (${e.map((n) => n.name).join(", ")})`,
          { name: `handleThreadDelta(${t.type})`, threadID: this.threadID }
        );
        for (const n of e)
          this.invokeTool(n, void 0);
        break;
      }
      case "assistant:message-delta": {
        if (t.event.type === "message_start")
          oe.debug("token usage", t.event.message.usage);
        else if (t.event.type === "message_delta" && t.inferenceStart && t.event.usage?.output_tokens) {
          const o = performance.now() - t.inferenceStart;
          oe.debug("completed message", {
            outputTokens: t.event.usage.output_tokens,
            tokensPerSecond: t.event.usage.output_tokens / o * 1e3,
            inferenceDuration: EL(o)
          });
        }
        const e = lo(this.thread, "assistant");
        if (!e)
          throw new Error("no assistant message found");
        const n = this.findToolUsesNeedingInvocation(e);
        for (const i of n)
          this.invokeTool(i, void 0);
        l_(this.thread) && this.runInferenceAndUpdateThread();
        break;
      }
    }
  }
  findToolUsesNeedingInvocation(t) {
    const e = os(this.thread);
    return t.content.filter((n) => n.type === "tool_use").filter((n) => !n.inputPartialJSON).filter(
      (n) => (
        // Only include tools that haven't been invoked yet.
        !e.has(n.id)
      )
    );
  }
  async invokeTool(t, e) {
    if (this.ops.tools[t.id])
      throw new Error(`(bug) tool invocation already in progress: ${t.id}`);
    if (t.inputPartialJSON)
      throw new Error(`(bug) tool use is incomplete: ${t.id}`);
    const n = await it(wn);
    if (n.settings?.hooks) {
      const o = eV(n.settings.hooks, {
        threadID: this.threadID,
        toolUse: t
      }), { abortOp: s } = await tV(this, o);
      if (s)
        return;
    }
    oe.debug("Invoking tool", {
      name: "invokeTool",
      threadID: this.threadID,
      toolUse: t,
      userInput: e
    });
    const i = new AbortController();
    this.ops.tools[t.id] = i, this.updateThread({
      type: "tool:data",
      toolUse: t.id,
      data: { status: "in-progress" }
    });
    try {
      const o = await it(
        this.deps.configService.workspaceRoots,
        i.signal
      ), s = ik(this.thread), u = new It((d) => {
        this.ops.toolMessages[t.id] = d;
      }), l = {
        dir: o.at(0) ?? null,
        dirs: o,
        tool: t.name,
        threadID: this.threadID,
        config: await uV(),
        trackedFiles: new Set(this.trackedFiles),
        trackFileChange: this.createToolUseFileChangeTracker(t.id),
        filesystem: this.filesystem,
        todos: s,
        systemPromptService: this.deps.systemPromptService,
        toolMessages: u,
        threadEnvironment: await this.deps.getThreadEnvironment()
      }, c = this.deps.toolService.invokeTool(t.name, { args: t.input, userInput: e }, l).pipe(
        zh(() => {
          delete this.ops.tools[t.id], this.ops.toolMessages[t.id]?.complete(), delete this.ops.toolMessages[t.id];
        })
      ).subscribe({
        next: async (d) => {
          if (oe.debug(`${t.id}, ${d.status}`, {
            name: "invokeTool",
            threadID: this.threadID
          }), pb(d) && (delete this.ops.tools[t.id], c.unsubscribe(), d.status === "done" && d.files?.length))
            for (const g of d.files)
              oe.debug(`file: ${g}`, {
                name: "tracking file from tool call",
                threadID: this.threadID
              }), this.trackFile(g);
          await this.updateFileChanges(), await this.handle(
            {
              type: "tool:data",
              toolUse: t.id,
              data: d
            },
            i.signal
          );
        },
        error: async (d) => {
          await this.handle(
            {
              type: "tool:data",
              toolUse: t.id,
              data: {
                status: "error",
                error: {
                  message: "message" in d ? d.message : String(d)
                }
              }
            },
            i.signal
          );
        },
        complete: () => {
        }
      });
      yy(i.signal, () => c.unsubscribe());
    } catch (o) {
      throw delete this.ops.tools[t.id], o;
    }
  }
  async cancelInProgressTools() {
    for (const t of Object.keys(this.ops.tools))
      await this.cancelTool(t);
  }
  cancelUnstartedTools() {
    const t = os(this.thread);
    for (const e of this.thread.messages)
      if (e.role === "assistant")
        for (const n of e.content)
          n.type === "tool_use" && !n.inputPartialJSON && !t.has(n.id) && this.updateThread({
            type: "tool:data",
            toolUse: n.id,
            data: { status: "cancelled" }
          });
  }
  async runInferenceAndUpdateThread() {
    this.ops.inference?.abort(), this.ops.inference = null, this.inferenceState.next("running");
    const t = new AbortController();
    this.ops.inference = t, this.cancelUnstartedTools(), await this.cancelInProgressTools();
    for (const i of this.thread.messages)
      if (i.role === "user")
        for (const o of i.content)
          o.type === "tool_result" && o.run.status === "blocked-on-user" && this.updateThread({
            type: "tool:data",
            toolUse: o.toolUseID,
            data: { status: "cancelled" }
          });
    if (this.thread.messages.length === 1) {
      const i = this.thread.messages[0];
      if (i.role !== "user")
        throw new Error("(bug) first message is not a user message");
      oV(i, t.signal).then((o) => {
        t.signal.aborted || this.isDisposed || this.thread.title !== o && this.updateThread({ type: "title", value: o });
      }).catch((o) => {
        tf(o) || oe.error("generateThreadTitle error", o, {
          name: "ThreadWorker",
          threadID: this.threadID
        });
      }), this.deps.getThreadEnvironment && this.deps.getThreadEnvironment().then((o) => {
        o.tags || (o.tags = []), o.tags = [`model:${ok}`], this.updateThread({
          type: "environment",
          env: { initial: o }
        });
      }).catch((o) => {
        oe.error("Failed to initialize thread environment", o, {
          threadID: this.threadID
        });
      });
    }
    const n = new Promise((i) => yy(t.signal, i));
    try {
      async function i(s) {
        let u;
        return await Promise.race([
          n,
          s.next().then((l) => {
            u = l;
          })
        ]), t.signal.throwIfAborted(), u;
      }
      if (!!1) {
        const s = performance.now(), u = await this.runInference(this.thread, t.signal);
        let l = await i(u), c = !1;
        for (; !l.done; )
          c = !0, await this.handle(
            {
              type: "assistant:message-delta",
              event: l.value,
              inferenceStart: s
            },
            t.signal
          ), l = await i(u), t.signal?.throwIfAborted();
        t.signal?.throwIfAborted();
        const d = l.value;
        !c && d.message && await this.handle(
          sk(d.message),
          t.signal
        ), await this.handle({
          type: "inference:completed",
          usage: d["~debugUsage"],
          params: d["~debugParamsUsed"]
        });
      }
    } catch (i) {
      tf(i) || ak(i) || this.ephemeralError.next(i instanceof Error ? i : new Error(String(i)));
    } finally {
      this.ops.inference === t && (this.ops.inference = null, this.inferenceState.next("idle"));
    }
  }
  async runInference(t, e) {
    const { messages: n, tools: i, systemPrompt: o } = await this.getInferenceParameters(t, e), s = lk(n, i, o, t.id, e);
    return e?.throwIfAborted(), s;
  }
  async getInferenceParameters(t, e) {
    const i = (await it(this.deps.toolService.tools, e)).map(({ spec: c, enabled: d }) => d ? c : null).filter((c) => c !== null);
    e?.throwIfAborted();
    const s = (await it(wn, e))?.settings?.["todos.enabled"] ?? !1, u = await uk(
      this.deps.systemPromptService,
      await this.deps.getThreadEnvironment(),
      s
    );
    return e?.throwIfAborted(), {
      messages: mb.fromNativeThread(t),
      tools: i,
      systemPrompt: u
    };
  }
  async runGeminiInference(t, e) {
    const i = (await it(this.deps.toolService.tools, e)).filter(({ enabled: d }) => d).map(({ spec: d }) => d);
    e?.throwIfAborted();
    const s = (await it(wn, e))?.settings?.["todos.enabled"] ?? !1, u = await ck(
      this.deps.systemPromptService,
      await this.deps.getThreadEnvironment(),
      s
    );
    e?.throwIfAborted();
    const l = Pq.fromNativeThread(t), c = Nq(l, i, u, t.id, e);
    return e?.throwIfAborted(), c;
  }
  async findAndCancelToolRun(t, e) {
    this.cancelInference(), no(this.thread, t) && await this.cancelTool(t, e);
  }
  async detachToolRun(t) {
    if (!no(this.thread, t)) return;
    const n = this.ops.toolMessages[t];
    if (!n) {
      oe.warn("unable to detach tool use, missing toolMessages", { id: t });
      return;
    }
    n.next({ type: "detach-terminal" });
  }
  cancelDataForToolRun(t) {
    const n = os(this.thread).get(t)?.run;
    let i = { status: "cancelled" };
    return n?.status === "in-progress" && n.progress && (i = {
      status: "cancelled",
      progress: n.progress
    }), i;
  }
  async cancelTool(t, e) {
    const n = this.cancelDataForToolRun(t);
    this.abortToolOp(t), oe.debug(`cancelToolRun(${t})`), await this.handle(
      {
        type: "tool:data",
        toolUse: t,
        data: n
      },
      e
    );
  }
  async cancel() {
    oe.debug("cancel: aborting inference operation and tools"), this.cancelInference(), this.cancelUnstartedTools(), this.cancelInProgressTools(), await this.handle({ type: "cancelled" }, void 0);
  }
  cancelInference() {
    this.ops.inference && (this.ops.inference.abort(fk.USER_CANCELLED), this.ops.inference = null), this.inferenceState.next("cancelled");
  }
  async retry() {
    oe.debug("retry: retrying inference operation"), this.ephemeralError.getValue() !== void 0 && this.ephemeralError.next(void 0), this.ops.inference && (this.ops.inference.abort(), this.ops.inference = null), this.inferenceState.next("idle"), await this.runInferenceAndUpdateThread();
  }
  abortToolOp(t) {
    this.ops.tools[t]?.abort(), delete this.ops.tools[t];
  }
  abortAllTools() {
    for (const t of Object.keys(this.ops.tools))
      this.abortToolOp(t);
  }
  async trackFile(t) {
    if (this.trackedFiles.has(t))
      return;
    const e = await this.workspaceRoots(), n = t.endsWith("/") ? await nV(
      e.map((i) => i.fsPath),
      t
    ) : await dk(this.filesystem, e, t);
    oe.debug("tracking file", { absolutePath: n }), this.trackedFiles.add(n);
  }
  async restoreFileChangesFromBackups() {
    try {
      const t = await hk(this.filesystem);
      for (const [e, n] of t.toolDiffs.entries())
        this.fileChangeRecords.set(e, n);
      oe.debug(`Restored ${t.toolDiffs.size} file changes from disk`), await this.updateFileChanges();
    } catch (t) {
      oe.error("Error restoring file changes", t, { threadID: this.threadID });
    }
  }
  createToolUseFileChangeTracker(t) {
    return this.createFileTracker({
      toolUseID: t,
      threadID: this.threadID,
      toolFileChanges: this.fileChangeRecords
    });
  }
  async workspaceRoots() {
    return it(this.deps.configService.workspaceRoots);
  }
  /**
   * Reverts all file changes made by this thread by restoring the original content
   * of modified files and deleting newly created files.
   */
  async revertFileChanges(t) {
    const n = (await this.workspaceRoots()).at(0);
    if (!n)
      throw new Error("No workspace root found");
    await vy(
      this.filesystem,
      this.fileChangeRecords,
      n.fsPath,
      t
    ), await this.updateFileChanges();
  }
  async revertPriorFileChanges(t) {
    const e = /* @__PURE__ */ new Set();
    this.thread.messages.slice(0, t).forEach((s) => {
      if (s.role === "user")
        for (const u of s.content)
          u.type === "tool_result" && e.add(u.toolUseID);
      else
        for (const u of s.content)
          u.type === "tool_use" && e.add(u.id);
    });
    const n = /* @__PURE__ */ new Map();
    for (const [s, u] of this.fileChangeRecords.entries())
      e.has(s) || n.set(s, u);
    if (n.size === 0) return;
    const o = (await it(this.deps.configService.workspaceRoots)).at(0);
    if (!o)
      throw new Error("No workspace root found");
    await vy(this.filesystem, n, o.fsPath);
    for (const [s, u] of n.entries())
      this.fileChangeRecords.delete(s);
    await this.updateFileChanges();
  }
  async updateFileChanges() {
    const e = (await it(this.deps.configService.workspaceRoots)).at(0), n = /* @__PURE__ */ new Map();
    for (const [o, s] of this.fileChangeRecords.entries())
      for (const [u, l] of s.entries()) {
        const c = e ? u.replace(e.fsPath + "/", "") : u;
        (!n.has(c) || l.timestamp > n.get(c).timestamp) && n.set(c, l);
      }
    const i = [];
    for (const [o, s] of n.entries()) {
      const { added: u, removed: l, modified: c, created: d, reverted: g } = pk(s);
      !u && !l && !c || i.push({
        created: d,
        path: o,
        reverted: g,
        diffStat: {
          added: u,
          removed: l,
          modified: c
        }
      });
    }
    this.fileChanges.next({
      files: i
    });
  }
  isDisposed = !1;
  dispose() {
    this.isDisposed || (this.isDisposed = !0, this.abortAllTools(), this.ops.inference && (this.ops.inference.abort(), this.ops.inference = null), this.fileChangeRecords.clear(), this.fileChanges.next({ files: [] }), this.threadReadWriter && (this.threadReadWriter.dispose(), this.threadReadWriter = null));
  }
}
function l_(r, t) {
  const e = lo(r, "assistant");
  if (!e || e.state.type !== "complete" || e.state.stopReason !== "tool_use")
    return !1;
  const n = e.content.filter((s) => s.type === "tool_use").map((s) => s.id);
  if (t && !n.includes(t))
    throw new Error(
      `(bug) updated tool use ID not found in assistant message: ${t}`
    );
  const i = os(r);
  return n.every((s) => {
    const u = i.get(s);
    return u && pb(u.run);
  });
}
const cV = `Execute a routine from your routines.amp.yaml file.

This tool allows you to run predefined routines that automate common tasks. You can optionally provide a userInput argument that describes what input should be passed to the routine.

IMPORTANT: The result of this tool (if any) should be displayed directly to the user and no further action or text should be sent to the user.
`, fV = {
  spec: {
    name: "run_routine",
    description: cV,
    inputSchema: {
      type: "object",
      properties: {
        id: {
          type: "string",
          description: "The ID of the routine to run."
        },
        file: {
          type: "string",
          description: "Optional path to the routine file. Defaults to routines.amp.yaml if not provided."
        },
        userInput: {
          type: "string",
          description: "Optional user input to pass to the routine. Can be referenced in routine steps."
        }
      },
      required: ["id"]
    },
    source: "builtin"
  },
  fn: import("./node-W217cnDV.js").then(({ runRoutine: r }) => r)
};
let u_ = !1;
async function hC(r, t = !1) {
  return u_ ? { dispose() {
  } } : (u_ = !0, await dV(r, t));
}
async function dV(r, t = !1) {
  const e = [
    r.registerTool(mk),
    r.registerTool(gk),
    r.registerTool(yk),
    r.registerTool(vk),
    r.registerTool(_k),
    r.registerTool(wk),
    r.registerTool(bk),
    r.registerTool(Tk),
    r.registerTool(Ck),
    r.registerTool(Sk),
    r.registerTool(Ek),
    r.registerTool(Ak),
    r.registerTool(xk),
    r.registerTool(Rk),
    r.registerTool(Ik),
    r.registerTool(Mk),
    r.registerTool(kk),
    r.registerTool(Pk)
  ];
  return t && e.push(r.registerTool(fV)), {
    dispose() {
      for (const n of e)
        n.dispose();
    }
  };
}
function Ma(r = "idle") {
  try {
    r === "idle" ? process.platform === "darwin" ? ii("afplay /System/Library/Sounds/Submarine.aiff") : process.platform === "win32" ? ii("powershell [console]::beep(800,200)") : process.platform === "linux" && ii("paplay /usr/share/sounds/freedesktop/stereo/message.oga || beep") : r === "requires-user-input" && (process.platform === "darwin" ? ii("afplay /System/Library/Sounds/Ping.aiff") : process.platform === "win32" ? ii("powershell [console]::beep(1000,300)") : process.platform === "linux" && ii(
      "paplay /usr/share/sounds/freedesktop/stereo/dialog-information.oga || beep -f 1000 -l 100"
    ));
  } catch (t) {
    oe.error(`Failed to play notification sound (${r}):`, t);
  }
}
var ka = { exports: {} }, Pa = {}, Oa = {}, c_;
function Iu() {
  if (c_) return Oa;
  c_ = 1;
  class r extends Error {
    /**
     * Constructs the CommanderError class
     * @param {number} exitCode suggested exit code which could be used with process.exit
     * @param {string} code an id string representing the error
     * @param {string} message human-readable description of the error
     * @constructor
     */
    constructor(n, i, o) {
      super(o), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name, this.code = i, this.exitCode = n, this.nestedError = void 0;
    }
  }
  class t extends r {
    /**
     * Constructs the InvalidArgumentError class
     * @param {string} [message] explanation of why argument is invalid
     * @constructor
     */
    constructor(n) {
      super(1, "commander.invalidArgument", n), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name;
    }
  }
  return Oa.CommanderError = r, Oa.InvalidArgumentError = t, Oa;
}
var f_;
function Ip() {
  if (f_) return Pa;
  f_ = 1;
  const { InvalidArgumentError: r } = Iu();
  class t {
    /**
     * Initialize a new command argument with the given name and description.
     * The default is that the argument is required, and you can explicitly
     * indicate this with <> around the name. Put [] around the name for an optional argument.
     *
     * @param {string} name
     * @param {string} [description]
     */
    constructor(i, o) {
      switch (this.description = o || "", this.variadic = !1, this.parseArg = void 0, this.defaultValue = void 0, this.defaultValueDescription = void 0, this.argChoices = void 0, i[0]) {
        case "<":
          this.required = !0, this._name = i.slice(1, -1);
          break;
        case "[":
          this.required = !1, this._name = i.slice(1, -1);
          break;
        default:
          this.required = !0, this._name = i;
          break;
      }
      this._name.length > 3 && this._name.slice(-3) === "..." && (this.variadic = !0, this._name = this._name.slice(0, -3));
    }
    /**
     * Return argument name.
     *
     * @return {string}
     */
    name() {
      return this._name;
    }
    /**
     * @api private
     */
    _concatValue(i, o) {
      return o === this.defaultValue || !Array.isArray(o) ? [i] : o.concat(i);
    }
    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     *
     * @param {*} value
     * @param {string} [description]
     * @return {Argument}
     */
    default(i, o) {
      return this.defaultValue = i, this.defaultValueDescription = o, this;
    }
    /**
     * Set the custom handler for processing CLI command arguments into argument values.
     *
     * @param {Function} [fn]
     * @return {Argument}
     */
    argParser(i) {
      return this.parseArg = i, this;
    }
    /**
     * Only allow argument value to be one of choices.
     *
     * @param {string[]} values
     * @return {Argument}
     */
    choices(i) {
      return this.argChoices = i.slice(), this.parseArg = (o, s) => {
        if (!this.argChoices.includes(o))
          throw new r(`Allowed choices are ${this.argChoices.join(", ")}.`);
        return this.variadic ? this._concatValue(o, s) : o;
      }, this;
    }
    /**
     * Make argument required.
     */
    argRequired() {
      return this.required = !0, this;
    }
    /**
     * Make argument optional.
     */
    argOptional() {
      return this.required = !1, this;
    }
  }
  function e(n) {
    const i = n.name() + (n.variadic === !0 ? "..." : "");
    return n.required ? "<" + i + ">" : "[" + i + "]";
  }
  return Pa.Argument = t, Pa.humanReadableArgName = e, Pa;
}
var mf = {}, gf = {}, d_;
function pC() {
  if (d_) return gf;
  d_ = 1;
  const { humanReadableArgName: r } = Ip();
  class t {
    constructor() {
      this.helpWidth = void 0, this.sortSubcommands = !1, this.sortOptions = !1, this.showGlobalOptions = !1;
    }
    /**
     * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
     *
     * @param {Command} cmd
     * @returns {Command[]}
     */
    visibleCommands(n) {
      const i = n.commands.filter((o) => !o._hidden);
      if (n._hasImplicitHelpCommand()) {
        const [, o, s] = n._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/), u = n.createCommand(o).helpOption(!1);
        u.description(n._helpCommandDescription), s && u.arguments(s), i.push(u);
      }
      return this.sortSubcommands && i.sort((o, s) => o.name().localeCompare(s.name())), i;
    }
    /**
     * Compare options for sort.
     *
     * @param {Option} a
     * @param {Option} b
     * @returns number
     */
    compareOptions(n, i) {
      const o = (s) => s.short ? s.short.replace(/^-/, "") : s.long.replace(/^--/, "");
      return o(n).localeCompare(o(i));
    }
    /**
     * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
     *
     * @param {Command} cmd
     * @returns {Option[]}
     */
    visibleOptions(n) {
      const i = n.options.filter((u) => !u.hidden), o = n._hasHelpOption && n._helpShortFlag && !n._findOption(n._helpShortFlag), s = n._hasHelpOption && !n._findOption(n._helpLongFlag);
      if (o || s) {
        let u;
        o ? s ? u = n.createOption(n._helpFlags, n._helpDescription) : u = n.createOption(n._helpShortFlag, n._helpDescription) : u = n.createOption(n._helpLongFlag, n._helpDescription), i.push(u);
      }
      return this.sortOptions && i.sort(this.compareOptions), i;
    }
    /**
     * Get an array of the visible global options. (Not including help.)
     *
     * @param {Command} cmd
     * @returns {Option[]}
     */
    visibleGlobalOptions(n) {
      if (!this.showGlobalOptions) return [];
      const i = [];
      for (let o = n.parent; o; o = o.parent) {
        const s = o.options.filter((u) => !u.hidden);
        i.push(...s);
      }
      return this.sortOptions && i.sort(this.compareOptions), i;
    }
    /**
     * Get an array of the arguments if any have a description.
     *
     * @param {Command} cmd
     * @returns {Argument[]}
     */
    visibleArguments(n) {
      return n._argsDescription && n.registeredArguments.forEach((i) => {
        i.description = i.description || n._argsDescription[i.name()] || "";
      }), n.registeredArguments.find((i) => i.description) ? n.registeredArguments : [];
    }
    /**
     * Get the command term to show in the list of subcommands.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    subcommandTerm(n) {
      const i = n.registeredArguments.map((o) => r(o)).join(" ");
      return n._name + (n._aliases[0] ? "|" + n._aliases[0] : "") + (n.options.length ? " [options]" : "") + // simplistic check for non-help option
      (i ? " " + i : "");
    }
    /**
     * Get the option term to show in the list of options.
     *
     * @param {Option} option
     * @returns {string}
     */
    optionTerm(n) {
      return n.flags;
    }
    /**
     * Get the argument term to show in the list of arguments.
     *
     * @param {Argument} argument
     * @returns {string}
     */
    argumentTerm(n) {
      return n.name();
    }
    /**
     * Get the longest command term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestSubcommandTermLength(n, i) {
      return i.visibleCommands(n).reduce((o, s) => Math.max(o, i.subcommandTerm(s).length), 0);
    }
    /**
     * Get the longest option term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestOptionTermLength(n, i) {
      return i.visibleOptions(n).reduce((o, s) => Math.max(o, i.optionTerm(s).length), 0);
    }
    /**
     * Get the longest global option term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestGlobalOptionTermLength(n, i) {
      return i.visibleGlobalOptions(n).reduce((o, s) => Math.max(o, i.optionTerm(s).length), 0);
    }
    /**
     * Get the longest argument term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestArgumentTermLength(n, i) {
      return i.visibleArguments(n).reduce((o, s) => Math.max(o, i.argumentTerm(s).length), 0);
    }
    /**
     * Get the command usage to be displayed at the top of the built-in help.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    commandUsage(n) {
      let i = n._name;
      n._aliases[0] && (i = i + "|" + n._aliases[0]);
      let o = "";
      for (let s = n.parent; s; s = s.parent)
        o = s.name() + " " + o;
      return o + i + " " + n.usage();
    }
    /**
     * Get the description for the command.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    commandDescription(n) {
      return n.description();
    }
    /**
     * Get the subcommand summary to show in the list of subcommands.
     * (Fallback to description for backwards compatibility.)
     *
     * @param {Command} cmd
     * @returns {string}
     */
    subcommandDescription(n) {
      return n.summary() || n.description();
    }
    /**
     * Get the option description to show in the list of options.
     *
     * @param {Option} option
     * @return {string}
     */
    optionDescription(n) {
      const i = [];
      return n.argChoices && i.push(
        // use stringify to match the display of the default value
        `choices: ${n.argChoices.map((o) => JSON.stringify(o)).join(", ")}`
      ), n.defaultValue !== void 0 && (n.required || n.optional || n.isBoolean() && typeof n.defaultValue == "boolean") && i.push(`default: ${n.defaultValueDescription || JSON.stringify(n.defaultValue)}`), n.presetArg !== void 0 && n.optional && i.push(`preset: ${JSON.stringify(n.presetArg)}`), n.envVar !== void 0 && i.push(`env: ${n.envVar}`), i.length > 0 ? `${n.description} (${i.join(", ")})` : n.description;
    }
    /**
     * Get the argument description to show in the list of arguments.
     *
     * @param {Argument} argument
     * @return {string}
     */
    argumentDescription(n) {
      const i = [];
      if (n.argChoices && i.push(
        // use stringify to match the display of the default value
        `choices: ${n.argChoices.map((o) => JSON.stringify(o)).join(", ")}`
      ), n.defaultValue !== void 0 && i.push(`default: ${n.defaultValueDescription || JSON.stringify(n.defaultValue)}`), i.length > 0) {
        const o = `(${i.join(", ")})`;
        return n.description ? `${n.description} ${o}` : o;
      }
      return n.description;
    }
    /**
     * Generate the built-in help text.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {string}
     */
    formatHelp(n, i) {
      const o = i.padWidth(n, i), s = i.helpWidth || 80, u = 2, l = 2;
      function c(C, m) {
        if (m) {
          const T = `${C.padEnd(o + l)}${m}`;
          return i.wrap(T, s - u, o + l);
        }
        return C;
      }
      function d(C) {
        return C.join(`
`).replace(/^/gm, " ".repeat(u));
      }
      let g = [`Usage: ${i.commandUsage(n)}`, ""];
      const y = i.commandDescription(n);
      y.length > 0 && (g = g.concat([i.wrap(y, s, 0), ""]));
      const w = i.visibleArguments(n).map((C) => c(i.argumentTerm(C), i.argumentDescription(C)));
      w.length > 0 && (g = g.concat(["Arguments:", d(w), ""]));
      const b = i.visibleOptions(n).map((C) => c(i.optionTerm(C), i.optionDescription(C)));
      if (b.length > 0 && (g = g.concat(["Options:", d(b), ""])), this.showGlobalOptions) {
        const C = i.visibleGlobalOptions(n).map((m) => c(i.optionTerm(m), i.optionDescription(m)));
        C.length > 0 && (g = g.concat(["Global Options:", d(C), ""]));
      }
      const _ = i.visibleCommands(n).map((C) => c(i.subcommandTerm(C), i.subcommandDescription(C)));
      return _.length > 0 && (g = g.concat(["Commands:", d(_), ""])), g.join(`
`);
    }
    /**
     * Calculate the pad width from the maximum term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    padWidth(n, i) {
      return Math.max(
        i.longestOptionTermLength(n, i),
        i.longestGlobalOptionTermLength(n, i),
        i.longestSubcommandTermLength(n, i),
        i.longestArgumentTermLength(n, i)
      );
    }
    /**
     * Wrap the given string to width characters per line, with lines after the first indented.
     * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
     *
     * @param {string} str
     * @param {number} width
     * @param {number} indent
     * @param {number} [minColumnWidth=40]
     * @return {string}
     *
     */
    wrap(n, i, o, s = 40) {
      const u = " \\f\\t\\v-\uFEFF", l = new RegExp(`[\\n][${u}]+`);
      if (n.match(l)) return n;
      const c = i - o;
      if (c < s) return n;
      const d = n.slice(0, o), g = n.slice(o).replace(`\r
`, `
`), y = " ".repeat(o), b = "\\s", _ = new RegExp(`
|.{1,${c - 1}}([${b}]|$)|[^${b}]+?([${b}]|$)`, "g"), C = g.match(_) || [];
      return d + C.map((m, T) => m === `
` ? "" : (T > 0 ? y : "") + m.trimEnd()).join(`
`);
    }
  }
  return gf.Help = t, gf;
}
var Jo = {}, h_;
function mC() {
  if (h_) return Jo;
  h_ = 1;
  const { InvalidArgumentError: r } = Iu();
  class t {
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {string} flags
     * @param {string} [description]
     */
    constructor(s, u) {
      this.flags = s, this.description = u || "", this.required = s.includes("<"), this.optional = s.includes("["), this.variadic = /\w\.\.\.[>\]]$/.test(s), this.mandatory = !1;
      const l = i(s);
      this.short = l.shortFlag, this.long = l.longFlag, this.negate = !1, this.long && (this.negate = this.long.startsWith("--no-")), this.defaultValue = void 0, this.defaultValueDescription = void 0, this.presetArg = void 0, this.envVar = void 0, this.parseArg = void 0, this.hidden = !1, this.argChoices = void 0, this.conflictsWith = [], this.implied = void 0;
    }
    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     *
     * @param {*} value
     * @param {string} [description]
     * @return {Option}
     */
    default(s, u) {
      return this.defaultValue = s, this.defaultValueDescription = u, this;
    }
    /**
     * Preset to use when option used without option-argument, especially optional but also boolean and negated.
     * The custom processing (parseArg) is called.
     *
     * @example
     * new Option('--color').default('GREYSCALE').preset('RGB');
     * new Option('--donate [amount]').preset('20').argParser(parseFloat);
     *
     * @param {*} arg
     * @return {Option}
     */
    preset(s) {
      return this.presetArg = s, this;
    }
    /**
     * Add option name(s) that conflict with this option.
     * An error will be displayed if conflicting options are found during parsing.
     *
     * @example
     * new Option('--rgb').conflicts('cmyk');
     * new Option('--js').conflicts(['ts', 'jsx']);
     *
     * @param {string | string[]} names
     * @return {Option}
     */
    conflicts(s) {
      return this.conflictsWith = this.conflictsWith.concat(s), this;
    }
    /**
     * Specify implied option values for when this option is set and the implied options are not.
     *
     * The custom processing (parseArg) is not called on the implied values.
     *
     * @example
     * program
     *   .addOption(new Option('--log', 'write logging information to file'))
     *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
     *
     * @param {Object} impliedOptionValues
     * @return {Option}
     */
    implies(s) {
      let u = s;
      return typeof s == "string" && (u = { [s]: !0 }), this.implied = Object.assign(this.implied || {}, u), this;
    }
    /**
     * Set environment variable to check for option value.
     *
     * An environment variable is only used if when processed the current option value is
     * undefined, or the source of the current value is 'default' or 'config' or 'env'.
     *
     * @param {string} name
     * @return {Option}
     */
    env(s) {
      return this.envVar = s, this;
    }
    /**
     * Set the custom handler for processing CLI option arguments into option values.
     *
     * @param {Function} [fn]
     * @return {Option}
     */
    argParser(s) {
      return this.parseArg = s, this;
    }
    /**
     * Whether the option is mandatory and must have a value after parsing.
     *
     * @param {boolean} [mandatory=true]
     * @return {Option}
     */
    makeOptionMandatory(s = !0) {
      return this.mandatory = !!s, this;
    }
    /**
     * Hide option in help.
     *
     * @param {boolean} [hide=true]
     * @return {Option}
     */
    hideHelp(s = !0) {
      return this.hidden = !!s, this;
    }
    /**
     * @api private
     */
    _concatValue(s, u) {
      return u === this.defaultValue || !Array.isArray(u) ? [s] : u.concat(s);
    }
    /**
     * Only allow option value to be one of choices.
     *
     * @param {string[]} values
     * @return {Option}
     */
    choices(s) {
      return this.argChoices = s.slice(), this.parseArg = (u, l) => {
        if (!this.argChoices.includes(u))
          throw new r(`Allowed choices are ${this.argChoices.join(", ")}.`);
        return this.variadic ? this._concatValue(u, l) : u;
      }, this;
    }
    /**
     * Return option name.
     *
     * @return {string}
     */
    name() {
      return this.long ? this.long.replace(/^--/, "") : this.short.replace(/^-/, "");
    }
    /**
     * Return option name, in a camelcase format that can be used
     * as a object attribute key.
     *
     * @return {string}
     * @api private
     */
    attributeName() {
      return n(this.name().replace(/^no-/, ""));
    }
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {string} arg
     * @return {boolean}
     * @api private
     */
    is(s) {
      return this.short === s || this.long === s;
    }
    /**
     * Return whether a boolean option.
     *
     * Options are one of boolean, negated, required argument, or optional argument.
     *
     * @return {boolean}
     * @api private
     */
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }
  class e {
    /**
     * @param {Option[]} options
     */
    constructor(s) {
      this.positiveOptions = /* @__PURE__ */ new Map(), this.negativeOptions = /* @__PURE__ */ new Map(), this.dualOptions = /* @__PURE__ */ new Set(), s.forEach((u) => {
        u.negate ? this.negativeOptions.set(u.attributeName(), u) : this.positiveOptions.set(u.attributeName(), u);
      }), this.negativeOptions.forEach((u, l) => {
        this.positiveOptions.has(l) && this.dualOptions.add(l);
      });
    }
    /**
     * Did the value come from the option, and not from possible matching dual option?
     *
     * @param {*} value
     * @param {Option} option
     * @returns {boolean}
     */
    valueFromOption(s, u) {
      const l = u.attributeName();
      if (!this.dualOptions.has(l)) return !0;
      const c = this.negativeOptions.get(l).presetArg, d = c !== void 0 ? c : !1;
      return u.negate === (d === s);
    }
  }
  function n(o) {
    return o.split("-").reduce((s, u) => s + u[0].toUpperCase() + u.slice(1));
  }
  function i(o) {
    let s, u;
    const l = o.split(/[ |,]+/);
    return l.length > 1 && !/^[[<]/.test(l[1]) && (s = l.shift()), u = l.shift(), !s && /^-[^-]$/.test(u) && (s = u, u = void 0), { shortFlag: s, longFlag: u };
  }
  return Jo.Option = t, Jo.splitOptionFlags = i, Jo.DualOptions = e, Jo;
}
var yf = {}, p_;
function hV() {
  if (p_) return yf;
  p_ = 1;
  const r = 3;
  function t(n, i) {
    if (Math.abs(n.length - i.length) > r) return Math.max(n.length, i.length);
    const o = [];
    for (let s = 0; s <= n.length; s++)
      o[s] = [s];
    for (let s = 0; s <= i.length; s++)
      o[0][s] = s;
    for (let s = 1; s <= i.length; s++)
      for (let u = 1; u <= n.length; u++) {
        let l = 1;
        n[u - 1] === i[s - 1] ? l = 0 : l = 1, o[u][s] = Math.min(
          o[u - 1][s] + 1,
          // deletion
          o[u][s - 1] + 1,
          // insertion
          o[u - 1][s - 1] + l
          // substitution
        ), u > 1 && s > 1 && n[u - 1] === i[s - 2] && n[u - 2] === i[s - 1] && (o[u][s] = Math.min(o[u][s], o[u - 2][s - 2] + 1));
      }
    return o[n.length][i.length];
  }
  function e(n, i) {
    if (!i || i.length === 0) return "";
    i = Array.from(new Set(i));
    const o = n.startsWith("--");
    o && (n = n.slice(2), i = i.map((c) => c.slice(2)));
    let s = [], u = r;
    const l = 0.4;
    return i.forEach((c) => {
      if (c.length <= 1) return;
      const d = t(n, c), g = Math.max(n.length, c.length);
      (g - d) / g > l && (d < u ? (u = d, s = [c]) : d === u && s.push(c));
    }), s.sort((c, d) => c.localeCompare(d)), o && (s = s.map((c) => `--${c}`)), s.length > 1 ? `
(Did you mean one of ${s.join(", ")}?)` : s.length === 1 ? `
(Did you mean ${s[0]}?)` : "";
  }
  return yf.suggestSimilar = e, yf;
}
var m_;
function pV() {
  if (m_) return mf;
  m_ = 1;
  const r = ep.EventEmitter, t = tP, e = Je, n = uo, i = iP, { Argument: o, humanReadableArgName: s } = Ip(), { CommanderError: u } = Iu(), { Help: l } = pC(), { Option: c, splitOptionFlags: d, DualOptions: g } = mC(), { suggestSimilar: y } = hV();
  class w extends r {
    /**
     * Initialize a new `Command`.
     *
     * @param {string} [name]
     */
    constructor(m) {
      super(), this.commands = [], this.options = [], this.parent = null, this._allowUnknownOption = !1, this._allowExcessArguments = !0, this.registeredArguments = [], this._args = this.registeredArguments, this.args = [], this.rawArgs = [], this.processedArgs = [], this._scriptPath = null, this._name = m || "", this._optionValues = {}, this._optionValueSources = {}, this._storeOptionsAsProperties = !1, this._actionHandler = null, this._executableHandler = !1, this._executableFile = null, this._executableDir = null, this._defaultCommandName = null, this._exitCallback = null, this._aliases = [], this._combineFlagAndOptionalValue = !0, this._description = "", this._summary = "", this._argsDescription = void 0, this._enablePositionalOptions = !1, this._passThroughOptions = !1, this._lifeCycleHooks = {}, this._showHelpAfterError = !1, this._showSuggestionAfterError = !0, this._outputConfiguration = {
        writeOut: (T) => i.stdout.write(T),
        writeErr: (T) => i.stderr.write(T),
        getOutHelpWidth: () => i.stdout.isTTY ? i.stdout.columns : void 0,
        getErrHelpWidth: () => i.stderr.isTTY ? i.stderr.columns : void 0,
        outputError: (T, S) => S(T)
      }, this._hidden = !1, this._hasHelpOption = !0, this._helpFlags = "-h, --help", this._helpDescription = "display help for command", this._helpShortFlag = "-h", this._helpLongFlag = "--help", this._addImplicitHelpCommand = void 0, this._helpCommandName = "help", this._helpCommandnameAndArgs = "help [command]", this._helpCommandDescription = "display help for command", this._helpConfiguration = {};
    }
    /**
     * Copy settings that are useful to have in common across root command and subcommands.
     *
     * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
     *
     * @param {Command} sourceCommand
     * @return {Command} `this` command for chaining
     */
    copyInheritedSettings(m) {
      return this._outputConfiguration = m._outputConfiguration, this._hasHelpOption = m._hasHelpOption, this._helpFlags = m._helpFlags, this._helpDescription = m._helpDescription, this._helpShortFlag = m._helpShortFlag, this._helpLongFlag = m._helpLongFlag, this._helpCommandName = m._helpCommandName, this._helpCommandnameAndArgs = m._helpCommandnameAndArgs, this._helpCommandDescription = m._helpCommandDescription, this._helpConfiguration = m._helpConfiguration, this._exitCallback = m._exitCallback, this._storeOptionsAsProperties = m._storeOptionsAsProperties, this._combineFlagAndOptionalValue = m._combineFlagAndOptionalValue, this._allowExcessArguments = m._allowExcessArguments, this._enablePositionalOptions = m._enablePositionalOptions, this._showHelpAfterError = m._showHelpAfterError, this._showSuggestionAfterError = m._showSuggestionAfterError, this;
    }
    /**
     * @returns {Command[]}
     * @api private
     */
    _getCommandAndAncestors() {
      const m = [];
      for (let T = this; T; T = T.parent)
        m.push(T);
      return m;
    }
    /**
     * Define a command.
     *
     * There are two styles of command: pay attention to where to put the description.
     *
     * @example
     * // Command implemented using action handler (description is supplied separately to `.command`)
     * program
     *   .command('clone <source> [destination]')
     *   .description('clone a repository into a newly created directory')
     *   .action((source, destination) => {
     *     console.log('clone command called');
     *   });
     *
     * // Command implemented using separate executable file (description is second parameter to `.command`)
     * program
     *   .command('start <service>', 'start named service')
     *   .command('stop [service]', 'stop named service, or all if no name supplied');
     *
     * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
     * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
     * @param {Object} [execOpts] - configuration options (for executable)
     * @return {Command} returns new command for action handler, or `this` for executable command
     */
    command(m, T, S) {
      let A = T, x = S;
      typeof A == "object" && A !== null && (x = A, A = null), x = x || {};
      const [, D, U] = m.match(/([^ ]+) *(.*)/), O = this.createCommand(D);
      return A && (O.description(A), O._executableHandler = !0), x.isDefault && (this._defaultCommandName = O._name), O._hidden = !!(x.noHelp || x.hidden), O._executableFile = x.executableFile || null, U && O.arguments(U), this.commands.push(O), O.parent = this, O.copyInheritedSettings(this), A ? this : O;
    }
    /**
     * Factory routine to create a new unattached command.
     *
     * See .command() for creating an attached subcommand, which uses this routine to
     * create the command. You can override createCommand to customise subcommands.
     *
     * @param {string} [name]
     * @return {Command} new command
     */
    createCommand(m) {
      return new w(m);
    }
    /**
     * You can customise the help with a subclass of Help by overriding createHelp,
     * or by overriding Help properties using configureHelp().
     *
     * @return {Help}
     */
    createHelp() {
      return Object.assign(new l(), this.configureHelp());
    }
    /**
     * You can customise the help by overriding Help properties using configureHelp(),
     * or with a subclass of Help by overriding createHelp().
     *
     * @param {Object} [configuration] - configuration options
     * @return {Command|Object} `this` command for chaining, or stored configuration
     */
    configureHelp(m) {
      return m === void 0 ? this._helpConfiguration : (this._helpConfiguration = m, this);
    }
    /**
     * The default output goes to stdout and stderr. You can customise this for special
     * applications. You can also customise the display of errors by overriding outputError.
     *
     * The configuration properties are all functions:
     *
     *     // functions to change where being written, stdout and stderr
     *     writeOut(str)
     *     writeErr(str)
     *     // matching functions to specify width for wrapping help
     *     getOutHelpWidth()
     *     getErrHelpWidth()
     *     // functions based on what is being written out
     *     outputError(str, write) // used for displaying errors, and not used for displaying help
     *
     * @param {Object} [configuration] - configuration options
     * @return {Command|Object} `this` command for chaining, or stored configuration
     */
    configureOutput(m) {
      return m === void 0 ? this._outputConfiguration : (Object.assign(this._outputConfiguration, m), this);
    }
    /**
     * Display the help or a custom message after an error occurs.
     *
     * @param {boolean|string} [displayHelp]
     * @return {Command} `this` command for chaining
     */
    showHelpAfterError(m = !0) {
      return typeof m != "string" && (m = !!m), this._showHelpAfterError = m, this;
    }
    /**
     * Display suggestion of similar commands for unknown commands, or options for unknown options.
     *
     * @param {boolean} [displaySuggestion]
     * @return {Command} `this` command for chaining
     */
    showSuggestionAfterError(m = !0) {
      return this._showSuggestionAfterError = !!m, this;
    }
    /**
     * Add a prepared subcommand.
     *
     * See .command() for creating an attached subcommand which inherits settings from its parent.
     *
     * @param {Command} cmd - new subcommand
     * @param {Object} [opts] - configuration options
     * @return {Command} `this` command for chaining
     */
    addCommand(m, T) {
      if (!m._name)
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      return T = T || {}, T.isDefault && (this._defaultCommandName = m._name), (T.noHelp || T.hidden) && (m._hidden = !0), this.commands.push(m), m.parent = this, this;
    }
    /**
     * Factory routine to create a new unattached argument.
     *
     * See .argument() for creating an attached argument, which uses this routine to
     * create the argument. You can override createArgument to return a custom argument.
     *
     * @param {string} name
     * @param {string} [description]
     * @return {Argument} new argument
     */
    createArgument(m, T) {
      return new o(m, T);
    }
    /**
     * Define argument syntax for command.
     *
     * The default is that the argument is required, and you can explicitly
     * indicate this with <> around the name. Put [] around the name for an optional argument.
     *
     * @example
     * program.argument('<input-file>');
     * program.argument('[output-file]');
     *
     * @param {string} name
     * @param {string} [description]
     * @param {Function|*} [fn] - custom argument processing function
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     */
    argument(m, T, S, A) {
      const x = this.createArgument(m, T);
      return typeof S == "function" ? x.default(A).argParser(S) : x.default(S), this.addArgument(x), this;
    }
    /**
     * Define argument syntax for command, adding multiple at once (without descriptions).
     *
     * See also .argument().
     *
     * @example
     * program.arguments('<cmd> [env]');
     *
     * @param {string} names
     * @return {Command} `this` command for chaining
     */
    arguments(m) {
      return m.trim().split(/ +/).forEach((T) => {
        this.argument(T);
      }), this;
    }
    /**
     * Define argument syntax for command, adding a prepared argument.
     *
     * @param {Argument} argument
     * @return {Command} `this` command for chaining
     */
    addArgument(m) {
      const T = this.registeredArguments.slice(-1)[0];
      if (T && T.variadic)
        throw new Error(`only the last argument can be variadic '${T.name()}'`);
      if (m.required && m.defaultValue !== void 0 && m.parseArg === void 0)
        throw new Error(`a default value for a required argument is never used: '${m.name()}'`);
      return this.registeredArguments.push(m), this;
    }
    /**
     * Override default decision whether to add implicit help command.
     *
     *    addHelpCommand() // force on
     *    addHelpCommand(false); // force off
     *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
     *
     * @return {Command} `this` command for chaining
     */
    addHelpCommand(m, T) {
      return m === !1 ? this._addImplicitHelpCommand = !1 : (this._addImplicitHelpCommand = !0, typeof m == "string" && (this._helpCommandName = m.split(" ")[0], this._helpCommandnameAndArgs = m), this._helpCommandDescription = T || this._helpCommandDescription), this;
    }
    /**
     * @return {boolean}
     * @api private
     */
    _hasImplicitHelpCommand() {
      return this._addImplicitHelpCommand === void 0 ? this.commands.length && !this._actionHandler && !this._findCommand("help") : this._addImplicitHelpCommand;
    }
    /**
     * Add hook for life cycle event.
     *
     * @param {string} event
     * @param {Function} listener
     * @return {Command} `this` command for chaining
     */
    hook(m, T) {
      const S = ["preSubcommand", "preAction", "postAction"];
      if (!S.includes(m))
        throw new Error(`Unexpected value for event passed to hook : '${m}'.
Expecting one of '${S.join("', '")}'`);
      return this._lifeCycleHooks[m] ? this._lifeCycleHooks[m].push(T) : this._lifeCycleHooks[m] = [T], this;
    }
    /**
     * Register callback to use as replacement for calling process.exit.
     *
     * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
     * @return {Command} `this` command for chaining
     */
    exitOverride(m) {
      return m ? this._exitCallback = m : this._exitCallback = (T) => {
        if (T.code !== "commander.executeSubCommandAsync")
          throw T;
      }, this;
    }
    /**
     * Call process.exit, and _exitCallback if defined.
     *
     * @param {number} exitCode exit code for using with process.exit
     * @param {string} code an id string representing the error
     * @param {string} message human-readable description of the error
     * @return never
     * @api private
     */
    _exit(m, T, S) {
      this._exitCallback && this._exitCallback(new u(m, T, S)), i.exit(m);
    }
    /**
     * Register callback `fn` for the command.
     *
     * @example
     * program
     *   .command('serve')
     *   .description('start service')
     *   .action(function() {
     *      // do work here
     *   });
     *
     * @param {Function} fn
     * @return {Command} `this` command for chaining
     */
    action(m) {
      const T = (S) => {
        const A = this.registeredArguments.length, x = S.slice(0, A);
        return this._storeOptionsAsProperties ? x[A] = this : x[A] = this.opts(), x.push(this), m.apply(this, x);
      };
      return this._actionHandler = T, this;
    }
    /**
     * Factory routine to create a new unattached option.
     *
     * See .option() for creating an attached option, which uses this routine to
     * create the option. You can override createOption to return a custom option.
     *
     * @param {string} flags
     * @param {string} [description]
     * @return {Option} new option
     */
    createOption(m, T) {
      return new c(m, T);
    }
    /**
     * Wrap parseArgs to catch 'commander.invalidArgument'.
     *
     * @param {Option | Argument} target
     * @param {string} value
     * @param {*} previous
     * @param {string} invalidArgumentMessage
     * @api private
     */
    _callParseArg(m, T, S, A) {
      try {
        return m.parseArg(T, S);
      } catch (x) {
        if (x.code === "commander.invalidArgument") {
          const D = `${A} ${x.message}`;
          this.error(D, { exitCode: x.exitCode, code: x.code });
        }
        throw x;
      }
    }
    /**
     * Add an option.
     *
     * @param {Option} option
     * @return {Command} `this` command for chaining
     */
    addOption(m) {
      const T = m.name(), S = m.attributeName();
      if (m.negate) {
        const x = m.long.replace(/^--no-/, "--");
        this._findOption(x) || this.setOptionValueWithSource(S, m.defaultValue === void 0 ? !0 : m.defaultValue, "default");
      } else m.defaultValue !== void 0 && this.setOptionValueWithSource(S, m.defaultValue, "default");
      this.options.push(m);
      const A = (x, D, U) => {
        x == null && m.presetArg !== void 0 && (x = m.presetArg);
        const O = this.getOptionValue(S);
        x !== null && m.parseArg ? x = this._callParseArg(m, x, O, D) : x !== null && m.variadic && (x = m._concatValue(x, O)), x == null && (m.negate ? x = !1 : m.isBoolean() || m.optional ? x = !0 : x = ""), this.setOptionValueWithSource(S, x, U);
      };
      return this.on("option:" + T, (x) => {
        const D = `error: option '${m.flags}' argument '${x}' is invalid.`;
        A(x, D, "cli");
      }), m.envVar && this.on("optionEnv:" + T, (x) => {
        const D = `error: option '${m.flags}' value '${x}' from env '${m.envVar}' is invalid.`;
        A(x, D, "env");
      }), this;
    }
    /**
     * Internal implementation shared by .option() and .requiredOption()
     *
     * @api private
     */
    _optionEx(m, T, S, A, x) {
      if (typeof T == "object" && T instanceof c)
        throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
      const D = this.createOption(T, S);
      if (D.makeOptionMandatory(!!m.mandatory), typeof A == "function")
        D.default(x).argParser(A);
      else if (A instanceof RegExp) {
        const U = A;
        A = (O, k) => {
          const H = U.exec(O);
          return H ? H[0] : k;
        }, D.default(x).argParser(A);
      } else
        D.default(A);
      return this.addOption(D);
    }
    /**
     * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
     *
     * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
     * option-argument is indicated by `<>` and an optional option-argument by `[]`.
     *
     * See the README for more details, and see also addOption() and requiredOption().
     *
     * @example
     * program
     *     .option('-p, --pepper', 'add pepper')
     *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
     *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
     *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
     *
     * @param {string} flags
     * @param {string} [description]
     * @param {Function|*} [parseArg] - custom option processing function or default value
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     */
    option(m, T, S, A) {
      return this._optionEx({}, m, T, S, A);
    }
    /**
    * Add a required option which must have a value after parsing. This usually means
    * the option must be specified on the command line. (Otherwise the same as .option().)
    *
    * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
    *
    * @param {string} flags
    * @param {string} [description]
    * @param {Function|*} [parseArg] - custom option processing function or default value
    * @param {*} [defaultValue]
    * @return {Command} `this` command for chaining
    */
    requiredOption(m, T, S, A) {
      return this._optionEx({ mandatory: !0 }, m, T, S, A);
    }
    /**
     * Alter parsing of short flags with optional values.
     *
     * @example
     * // for `.option('-f,--flag [value]'):
     * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
     * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
     *
     * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
     */
    combineFlagAndOptionalValue(m = !0) {
      return this._combineFlagAndOptionalValue = !!m, this;
    }
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
     * for unknown options.
     */
    allowUnknownOption(m = !0) {
      return this._allowUnknownOption = !!m, this;
    }
    /**
     * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
     *
     * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
     * for excess arguments.
     */
    allowExcessArguments(m = !0) {
      return this._allowExcessArguments = !!m, this;
    }
    /**
     * Enable positional options. Positional means global options are specified before subcommands which lets
     * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
     * The default behaviour is non-positional and global options may appear anywhere on the command line.
     *
     * @param {Boolean} [positional=true]
     */
    enablePositionalOptions(m = !0) {
      return this._enablePositionalOptions = !!m, this;
    }
    /**
     * Pass through options that come after command-arguments rather than treat them as command-options,
     * so actual command-options come before command-arguments. Turning this on for a subcommand requires
     * positional options to have been enabled on the program (parent commands).
     * The default behaviour is non-positional and options may appear before or after command-arguments.
     *
     * @param {Boolean} [passThrough=true]
     * for unknown options.
     */
    passThroughOptions(m = !0) {
      if (this._passThroughOptions = !!m, this.parent && m && !this.parent._enablePositionalOptions)
        throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
      return this;
    }
    /**
      * Whether to store option values as properties on command object,
      * or store separately (specify false). In both cases the option values can be accessed using .opts().
      *
      * @param {boolean} [storeAsProperties=true]
      * @return {Command} `this` command for chaining
      */
    storeOptionsAsProperties(m = !0) {
      if (this.options.length)
        throw new Error("call .storeOptionsAsProperties() before adding options");
      return this._storeOptionsAsProperties = !!m, this;
    }
    /**
     * Retrieve option value.
     *
     * @param {string} key
     * @return {Object} value
     */
    getOptionValue(m) {
      return this._storeOptionsAsProperties ? this[m] : this._optionValues[m];
    }
    /**
     * Store option value.
     *
     * @param {string} key
     * @param {Object} value
     * @return {Command} `this` command for chaining
     */
    setOptionValue(m, T) {
      return this.setOptionValueWithSource(m, T, void 0);
    }
    /**
      * Store option value and where the value came from.
      *
      * @param {string} key
      * @param {Object} value
      * @param {string} source - expected values are default/config/env/cli/implied
      * @return {Command} `this` command for chaining
      */
    setOptionValueWithSource(m, T, S) {
      return this._storeOptionsAsProperties ? this[m] = T : this._optionValues[m] = T, this._optionValueSources[m] = S, this;
    }
    /**
      * Get source of option value.
      * Expected values are default | config | env | cli | implied
      *
      * @param {string} key
      * @return {string}
      */
    getOptionValueSource(m) {
      return this._optionValueSources[m];
    }
    /**
      * Get source of option value. See also .optsWithGlobals().
      * Expected values are default | config | env | cli | implied
      *
      * @param {string} key
      * @return {string}
      */
    getOptionValueSourceWithGlobals(m) {
      let T;
      return this._getCommandAndAncestors().forEach((S) => {
        S.getOptionValueSource(m) !== void 0 && (T = S.getOptionValueSource(m));
      }), T;
    }
    /**
     * Get user arguments from implied or explicit arguments.
     * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
     *
     * @api private
     */
    _prepareUserArgs(m, T) {
      if (m !== void 0 && !Array.isArray(m))
        throw new Error("first parameter to parse must be array or undefined");
      T = T || {}, m === void 0 && (m = i.argv, i.versions && i.versions.electron && (T.from = "electron")), this.rawArgs = m.slice();
      let S;
      switch (T.from) {
        case void 0:
        case "node":
          this._scriptPath = m[1], S = m.slice(2);
          break;
        case "electron":
          i.defaultApp ? (this._scriptPath = m[1], S = m.slice(2)) : S = m.slice(1);
          break;
        case "user":
          S = m.slice(0);
          break;
        default:
          throw new Error(`unexpected parse option { from: '${T.from}' }`);
      }
      return !this._name && this._scriptPath && this.nameFromFilename(this._scriptPath), this._name = this._name || "program", S;
    }
    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * The default expectation is that the arguments are from node and have the application as argv[0]
     * and the script being run in argv[1], with user parameters after that.
     *
     * @example
     * program.parse(process.argv);
     * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
     * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv] - optional, defaults to process.argv
     * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
     * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
     * @return {Command} `this` command for chaining
     */
    parse(m, T) {
      const S = this._prepareUserArgs(m, T);
      return this._parseCommand([], S), this;
    }
    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
     *
     * The default expectation is that the arguments are from node and have the application as argv[0]
     * and the script being run in argv[1], with user parameters after that.
     *
     * @example
     * await program.parseAsync(process.argv);
     * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
     * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv]
     * @param {Object} [parseOptions]
     * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
     * @return {Promise}
     */
    async parseAsync(m, T) {
      const S = this._prepareUserArgs(m, T);
      return await this._parseCommand([], S), this;
    }
    /**
     * Execute a sub-command executable.
     *
     * @api private
     */
    _executeSubCommand(m, T) {
      T = T.slice();
      let S = !1;
      const A = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function x(H, V) {
        const N = e.resolve(H, V);
        if (n.existsSync(N)) return N;
        if (A.includes(e.extname(V))) return;
        const $ = A.find((j) => n.existsSync(`${N}${j}`));
        if ($) return `${N}${$}`;
      }
      this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
      let D = m._executableFile || `${this._name}-${m._name}`, U = this._executableDir || "";
      if (this._scriptPath) {
        let H;
        try {
          H = n.realpathSync(this._scriptPath);
        } catch {
          H = this._scriptPath;
        }
        U = e.resolve(e.dirname(H), U);
      }
      if (U) {
        let H = x(U, D);
        if (!H && !m._executableFile && this._scriptPath) {
          const V = e.basename(this._scriptPath, e.extname(this._scriptPath));
          V !== this._name && (H = x(U, `${V}-${m._name}`));
        }
        D = H || D;
      }
      S = A.includes(e.extname(D));
      let O;
      i.platform !== "win32" ? S ? (T.unshift(D), T = _(i.execArgv).concat(T), O = t.spawn(i.argv[0], T, { stdio: "inherit" })) : O = t.spawn(D, T, { stdio: "inherit" }) : (T.unshift(D), T = _(i.execArgv).concat(T), O = t.spawn(i.execPath, T, { stdio: "inherit" })), O.killed || ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"].forEach((V) => {
        i.on(V, () => {
          O.killed === !1 && O.exitCode === null && O.kill(V);
        });
      });
      const k = this._exitCallback;
      k ? O.on("close", () => {
        k(new u(i.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
      }) : O.on("close", i.exit.bind(i)), O.on("error", (H) => {
        if (H.code === "ENOENT") {
          const V = U ? `searched for local subcommand relative to directory '${U}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory", N = `'${D}' does not exist
 - if '${m._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${V}`;
          throw new Error(N);
        } else if (H.code === "EACCES")
          throw new Error(`'${D}' not executable`);
        if (!k)
          i.exit(1);
        else {
          const V = new u(1, "commander.executeSubCommandAsync", "(error)");
          V.nestedError = H, k(V);
        }
      }), this.runningCommand = O;
    }
    /**
     * @api private
     */
    _dispatchSubcommand(m, T, S) {
      const A = this._findCommand(m);
      A || this.help({ error: !0 });
      let x;
      return x = this._chainOrCallSubCommandHook(x, A, "preSubcommand"), x = this._chainOrCall(x, () => {
        if (A._executableHandler)
          this._executeSubCommand(A, T.concat(S));
        else
          return A._parseCommand(T, S);
      }), x;
    }
    /**
     * Invoke help directly if possible, or dispatch if necessary.
     * e.g. help foo
     *
     * @api private
     */
    _dispatchHelpCommand(m) {
      m || this.help();
      const T = this._findCommand(m);
      return T && !T._executableHandler && T.help(), this._dispatchSubcommand(m, [], [
        this._helpLongFlag || this._helpShortFlag
      ]);
    }
    /**
     * Check this.args against expected this.registeredArguments.
     *
     * @api private
     */
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((m, T) => {
        m.required && this.args[T] == null && this.missingArgument(m.name());
      }), !(this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) && this.args.length > this.registeredArguments.length && this._excessArguments(this.args);
    }
    /**
     * Process this.args using this.registeredArguments and save as this.processedArgs!
     *
     * @api private
     */
    _processArguments() {
      const m = (S, A, x) => {
        let D = A;
        if (A !== null && S.parseArg) {
          const U = `error: command-argument value '${A}' is invalid for argument '${S.name()}'.`;
          D = this._callParseArg(S, A, x, U);
        }
        return D;
      };
      this._checkNumberOfArguments();
      const T = [];
      this.registeredArguments.forEach((S, A) => {
        let x = S.defaultValue;
        S.variadic ? A < this.args.length ? (x = this.args.slice(A), S.parseArg && (x = x.reduce((D, U) => m(S, U, D), S.defaultValue))) : x === void 0 && (x = []) : A < this.args.length && (x = this.args[A], S.parseArg && (x = m(S, x, S.defaultValue))), T[A] = x;
      }), this.processedArgs = T;
    }
    /**
     * Once we have a promise we chain, but call synchronously until then.
     *
     * @param {Promise|undefined} promise
     * @param {Function} fn
     * @return {Promise|undefined}
     * @api private
     */
    _chainOrCall(m, T) {
      return m && m.then && typeof m.then == "function" ? m.then(() => T()) : T();
    }
    /**
     *
     * @param {Promise|undefined} promise
     * @param {string} event
     * @return {Promise|undefined}
     * @api private
     */
    _chainOrCallHooks(m, T) {
      let S = m;
      const A = [];
      return this._getCommandAndAncestors().reverse().filter((x) => x._lifeCycleHooks[T] !== void 0).forEach((x) => {
        x._lifeCycleHooks[T].forEach((D) => {
          A.push({ hookedCommand: x, callback: D });
        });
      }), T === "postAction" && A.reverse(), A.forEach((x) => {
        S = this._chainOrCall(S, () => x.callback(x.hookedCommand, this));
      }), S;
    }
    /**
     *
     * @param {Promise|undefined} promise
     * @param {Command} subCommand
     * @param {string} event
     * @return {Promise|undefined}
     * @api private
     */
    _chainOrCallSubCommandHook(m, T, S) {
      let A = m;
      return this._lifeCycleHooks[S] !== void 0 && this._lifeCycleHooks[S].forEach((x) => {
        A = this._chainOrCall(A, () => x(this, T));
      }), A;
    }
    /**
     * Process arguments in context of this command.
     * Returns action result, in case it is a promise.
     *
     * @api private
     */
    _parseCommand(m, T) {
      const S = this.parseOptions(T);
      if (this._parseOptionsEnv(), this._parseOptionsImplied(), m = m.concat(S.operands), T = S.unknown, this.args = m.concat(T), m && this._findCommand(m[0]))
        return this._dispatchSubcommand(m[0], m.slice(1), T);
      if (this._hasImplicitHelpCommand() && m[0] === this._helpCommandName)
        return this._dispatchHelpCommand(m[1]);
      if (this._defaultCommandName)
        return b(this, T), this._dispatchSubcommand(this._defaultCommandName, m, T);
      this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName && this.help({ error: !0 }), b(this, S.unknown), this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
      const A = () => {
        S.unknown.length > 0 && this.unknownOption(S.unknown[0]);
      }, x = `command:${this.name()}`;
      if (this._actionHandler) {
        A(), this._processArguments();
        let D;
        return D = this._chainOrCallHooks(D, "preAction"), D = this._chainOrCall(D, () => this._actionHandler(this.processedArgs)), this.parent && (D = this._chainOrCall(D, () => {
          this.parent.emit(x, m, T);
        })), D = this._chainOrCallHooks(D, "postAction"), D;
      }
      if (this.parent && this.parent.listenerCount(x))
        A(), this._processArguments(), this.parent.emit(x, m, T);
      else if (m.length) {
        if (this._findCommand("*"))
          return this._dispatchSubcommand("*", m, T);
        this.listenerCount("command:*") ? this.emit("command:*", m, T) : this.commands.length ? this.unknownCommand() : (A(), this._processArguments());
      } else this.commands.length ? (A(), this.help({ error: !0 })) : (A(), this._processArguments());
    }
    /**
     * Find matching command.
     *
     * @api private
     */
    _findCommand(m) {
      if (m)
        return this.commands.find((T) => T._name === m || T._aliases.includes(m));
    }
    /**
     * Return an option matching `arg` if any.
     *
     * @param {string} arg
     * @return {Option}
     * @api private
     */
    _findOption(m) {
      return this.options.find((T) => T.is(m));
    }
    /**
     * Display an error message if a mandatory option does not have a value.
     * Called after checking for help flags in leaf subcommand.
     *
     * @api private
     */
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((m) => {
        m.options.forEach((T) => {
          T.mandatory && m.getOptionValue(T.attributeName()) === void 0 && m.missingMandatoryOptionValue(T);
        });
      });
    }
    /**
     * Display an error message if conflicting options are used together in this.
     *
     * @api private
     */
    _checkForConflictingLocalOptions() {
      const m = this.options.filter(
        (S) => {
          const A = S.attributeName();
          return this.getOptionValue(A) === void 0 ? !1 : this.getOptionValueSource(A) !== "default";
        }
      );
      m.filter(
        (S) => S.conflictsWith.length > 0
      ).forEach((S) => {
        const A = m.find(
          (x) => S.conflictsWith.includes(x.attributeName())
        );
        A && this._conflictingOption(S, A);
      });
    }
    /**
     * Display an error message if conflicting options are used together.
     * Called after checking for help flags in leaf subcommand.
     *
     * @api private
     */
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((m) => {
        m._checkForConflictingLocalOptions();
      });
    }
    /**
     * Parse options from `argv` removing known options,
     * and return argv split into operands and unknown arguments.
     *
     * Examples:
     *
     *     argv => operands, unknown
     *     --known kkk op => [op], []
     *     op --known kkk => [op], []
     *     sub --unknown uuu op => [sub], [--unknown uuu op]
     *     sub -- --unknown uuu op => [sub --unknown uuu op], []
     *
     * @param {String[]} argv
     * @return {{operands: String[], unknown: String[]}}
     */
    parseOptions(m) {
      const T = [], S = [];
      let A = T;
      const x = m.slice();
      function D(O) {
        return O.length > 1 && O[0] === "-";
      }
      let U = null;
      for (; x.length; ) {
        const O = x.shift();
        if (O === "--") {
          A === S && A.push(O), A.push(...x);
          break;
        }
        if (U && !D(O)) {
          this.emit(`option:${U.name()}`, O);
          continue;
        }
        if (U = null, D(O)) {
          const k = this._findOption(O);
          if (k) {
            if (k.required) {
              const H = x.shift();
              H === void 0 && this.optionMissingArgument(k), this.emit(`option:${k.name()}`, H);
            } else if (k.optional) {
              let H = null;
              x.length > 0 && !D(x[0]) && (H = x.shift()), this.emit(`option:${k.name()}`, H);
            } else
              this.emit(`option:${k.name()}`);
            U = k.variadic ? k : null;
            continue;
          }
        }
        if (O.length > 2 && O[0] === "-" && O[1] !== "-") {
          const k = this._findOption(`-${O[1]}`);
          if (k) {
            k.required || k.optional && this._combineFlagAndOptionalValue ? this.emit(`option:${k.name()}`, O.slice(2)) : (this.emit(`option:${k.name()}`), x.unshift(`-${O.slice(2)}`));
            continue;
          }
        }
        if (/^--[^=]+=/.test(O)) {
          const k = O.indexOf("="), H = this._findOption(O.slice(0, k));
          if (H && (H.required || H.optional)) {
            this.emit(`option:${H.name()}`, O.slice(k + 1));
            continue;
          }
        }
        if (D(O) && (A = S), (this._enablePositionalOptions || this._passThroughOptions) && T.length === 0 && S.length === 0) {
          if (this._findCommand(O)) {
            T.push(O), x.length > 0 && S.push(...x);
            break;
          } else if (O === this._helpCommandName && this._hasImplicitHelpCommand()) {
            T.push(O), x.length > 0 && T.push(...x);
            break;
          } else if (this._defaultCommandName) {
            S.push(O), x.length > 0 && S.push(...x);
            break;
          }
        }
        if (this._passThroughOptions) {
          A.push(O), x.length > 0 && A.push(...x);
          break;
        }
        A.push(O);
      }
      return { operands: T, unknown: S };
    }
    /**
     * Return an object containing local option values as key-value pairs.
     *
     * @return {Object}
     */
    opts() {
      if (this._storeOptionsAsProperties) {
        const m = {}, T = this.options.length;
        for (let S = 0; S < T; S++) {
          const A = this.options[S].attributeName();
          m[A] = A === this._versionOptionName ? this._version : this[A];
        }
        return m;
      }
      return this._optionValues;
    }
    /**
     * Return an object containing merged local and global option values as key-value pairs.
     *
     * @return {Object}
     */
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce(
        (m, T) => Object.assign(m, T.opts()),
        {}
      );
    }
    /**
     * Display error message and exit (or call exitOverride).
     *
     * @param {string} message
     * @param {Object} [errorOptions]
     * @param {string} [errorOptions.code] - an id string representing the error
     * @param {number} [errorOptions.exitCode] - used with process.exit
     */
    error(m, T) {
      this._outputConfiguration.outputError(`${m}
`, this._outputConfiguration.writeErr), typeof this._showHelpAfterError == "string" ? this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`) : this._showHelpAfterError && (this._outputConfiguration.writeErr(`
`), this.outputHelp({ error: !0 }));
      const S = T || {}, A = S.exitCode || 1, x = S.code || "commander.error";
      this._exit(A, x, m);
    }
    /**
     * Apply any option related environment variables, if option does
     * not have a value from cli or client code.
     *
     * @api private
     */
    _parseOptionsEnv() {
      this.options.forEach((m) => {
        if (m.envVar && m.envVar in i.env) {
          const T = m.attributeName();
          (this.getOptionValue(T) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(T))) && (m.required || m.optional ? this.emit(`optionEnv:${m.name()}`, i.env[m.envVar]) : this.emit(`optionEnv:${m.name()}`));
        }
      });
    }
    /**
     * Apply any implied option values, if option is undefined or default value.
     *
     * @api private
     */
    _parseOptionsImplied() {
      const m = new g(this.options), T = (S) => this.getOptionValue(S) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(S));
      this.options.filter((S) => S.implied !== void 0 && T(S.attributeName()) && m.valueFromOption(this.getOptionValue(S.attributeName()), S)).forEach((S) => {
        Object.keys(S.implied).filter((A) => !T(A)).forEach((A) => {
          this.setOptionValueWithSource(A, S.implied[A], "implied");
        });
      });
    }
    /**
     * Argument `name` is missing.
     *
     * @param {string} name
     * @api private
     */
    missingArgument(m) {
      const T = `error: missing required argument '${m}'`;
      this.error(T, { code: "commander.missingArgument" });
    }
    /**
     * `Option` is missing an argument.
     *
     * @param {Option} option
     * @api private
     */
    optionMissingArgument(m) {
      const T = `error: option '${m.flags}' argument missing`;
      this.error(T, { code: "commander.optionMissingArgument" });
    }
    /**
     * `Option` does not have a value, and is a mandatory option.
     *
     * @param {Option} option
     * @api private
     */
    missingMandatoryOptionValue(m) {
      const T = `error: required option '${m.flags}' not specified`;
      this.error(T, { code: "commander.missingMandatoryOptionValue" });
    }
    /**
     * `Option` conflicts with another option.
     *
     * @param {Option} option
     * @param {Option} conflictingOption
     * @api private
     */
    _conflictingOption(m, T) {
      const S = (D) => {
        const U = D.attributeName(), O = this.getOptionValue(U), k = this.options.find((V) => V.negate && U === V.attributeName()), H = this.options.find((V) => !V.negate && U === V.attributeName());
        return k && (k.presetArg === void 0 && O === !1 || k.presetArg !== void 0 && O === k.presetArg) ? k : H || D;
      }, A = (D) => {
        const U = S(D), O = U.attributeName();
        return this.getOptionValueSource(O) === "env" ? `environment variable '${U.envVar}'` : `option '${U.flags}'`;
      }, x = `error: ${A(m)} cannot be used with ${A(T)}`;
      this.error(x, { code: "commander.conflictingOption" });
    }
    /**
     * Unknown option `flag`.
     *
     * @param {string} flag
     * @api private
     */
    unknownOption(m) {
      if (this._allowUnknownOption) return;
      let T = "";
      if (m.startsWith("--") && this._showSuggestionAfterError) {
        let A = [], x = this;
        do {
          const D = x.createHelp().visibleOptions(x).filter((U) => U.long).map((U) => U.long);
          A = A.concat(D), x = x.parent;
        } while (x && !x._enablePositionalOptions);
        T = y(m, A);
      }
      const S = `error: unknown option '${m}'${T}`;
      this.error(S, { code: "commander.unknownOption" });
    }
    /**
     * Excess arguments, more than expected.
     *
     * @param {string[]} receivedArgs
     * @api private
     */
    _excessArguments(m) {
      if (this._allowExcessArguments) return;
      const T = this.registeredArguments.length, S = T === 1 ? "" : "s", x = `error: too many arguments${this.parent ? ` for '${this.name()}'` : ""}. Expected ${T} argument${S} but got ${m.length}.`;
      this.error(x, { code: "commander.excessArguments" });
    }
    /**
     * Unknown command.
     *
     * @api private
     */
    unknownCommand() {
      const m = this.args[0];
      let T = "";
      if (this._showSuggestionAfterError) {
        const A = [];
        this.createHelp().visibleCommands(this).forEach((x) => {
          A.push(x.name()), x.alias() && A.push(x.alias());
        }), T = y(m, A);
      }
      const S = `error: unknown command '${m}'${T}`;
      this.error(S, { code: "commander.unknownCommand" });
    }
    /**
     * Get or set the program version.
     *
     * This method auto-registers the "-V, --version" option which will print the version number.
     *
     * You can optionally supply the flags and description to override the defaults.
     *
     * @param {string} [str]
     * @param {string} [flags]
     * @param {string} [description]
     * @return {this | string | undefined} `this` command for chaining, or version string if no arguments
     */
    version(m, T, S) {
      if (m === void 0) return this._version;
      this._version = m, T = T || "-V, --version", S = S || "output the version number";
      const A = this.createOption(T, S);
      return this._versionOptionName = A.attributeName(), this.options.push(A), this.on("option:" + A.name(), () => {
        this._outputConfiguration.writeOut(`${m}
`), this._exit(0, "commander.version", m);
      }), this;
    }
    /**
     * Set the description.
     *
     * @param {string} [str]
     * @param {Object} [argsDescription]
     * @return {string|Command}
     */
    description(m, T) {
      return m === void 0 && T === void 0 ? this._description : (this._description = m, T && (this._argsDescription = T), this);
    }
    /**
     * Set the summary. Used when listed as subcommand of parent.
     *
     * @param {string} [str]
     * @return {string|Command}
     */
    summary(m) {
      return m === void 0 ? this._summary : (this._summary = m, this);
    }
    /**
     * Set an alias for the command.
     *
     * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
     *
     * @param {string} [alias]
     * @return {string|Command}
     */
    alias(m) {
      if (m === void 0) return this._aliases[0];
      let T = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler && (T = this.commands[this.commands.length - 1]), m === T._name) throw new Error("Command alias can't be the same as its name");
      return T._aliases.push(m), this;
    }
    /**
     * Set aliases for the command.
     *
     * Only the first alias is shown in the auto-generated help.
     *
     * @param {string[]} [aliases]
     * @return {string[]|Command}
     */
    aliases(m) {
      return m === void 0 ? this._aliases : (m.forEach((T) => this.alias(T)), this);
    }
    /**
     * Set / get the command usage `str`.
     *
     * @param {string} [str]
     * @return {String|Command}
     */
    usage(m) {
      if (m === void 0) {
        if (this._usage) return this._usage;
        const T = this.registeredArguments.map((S) => s(S));
        return [].concat(
          this.options.length || this._hasHelpOption ? "[options]" : [],
          this.commands.length ? "[command]" : [],
          this.registeredArguments.length ? T : []
        ).join(" ");
      }
      return this._usage = m, this;
    }
    /**
     * Get or set the name of the command.
     *
     * @param {string} [str]
     * @return {string|Command}
     */
    name(m) {
      return m === void 0 ? this._name : (this._name = m, this);
    }
    /**
     * Set the name of the command from script filename, such as process.argv[1],
     * or require.main.filename, or __filename.
     *
     * (Used internally and public although not documented in README.)
     *
     * @example
     * program.nameFromFilename(require.main.filename);
     *
     * @param {string} filename
     * @return {Command}
     */
    nameFromFilename(m) {
      return this._name = e.basename(m, e.extname(m)), this;
    }
    /**
     * Get or set the directory for searching for executable subcommands of this command.
     *
     * @example
     * program.executableDir(__dirname);
     * // or
     * program.executableDir('subcommands');
     *
     * @param {string} [path]
     * @return {string|null|Command}
     */
    executableDir(m) {
      return m === void 0 ? this._executableDir : (this._executableDir = m, this);
    }
    /**
     * Return program help documentation.
     *
     * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
     * @return {string}
     */
    helpInformation(m) {
      const T = this.createHelp();
      return T.helpWidth === void 0 && (T.helpWidth = m && m.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth()), T.formatHelp(this, T);
    }
    /**
     * @api private
     */
    _getHelpContext(m) {
      m = m || {};
      const T = { error: !!m.error };
      let S;
      return T.error ? S = (A) => this._outputConfiguration.writeErr(A) : S = (A) => this._outputConfiguration.writeOut(A), T.write = m.write || S, T.command = this, T;
    }
    /**
     * Output help information for this command.
     *
     * Outputs built-in help, and custom text added using `.addHelpText()`.
     *
     * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
     */
    outputHelp(m) {
      let T;
      typeof m == "function" && (T = m, m = void 0);
      const S = this._getHelpContext(m);
      this._getCommandAndAncestors().reverse().forEach((x) => x.emit("beforeAllHelp", S)), this.emit("beforeHelp", S);
      let A = this.helpInformation(S);
      if (T && (A = T(A), typeof A != "string" && !Buffer.isBuffer(A)))
        throw new Error("outputHelp callback must return a string or a Buffer");
      S.write(A), this._helpLongFlag && this.emit(this._helpLongFlag), this.emit("afterHelp", S), this._getCommandAndAncestors().forEach((x) => x.emit("afterAllHelp", S));
    }
    /**
     * You can pass in flags and a description to override the help
     * flags and help description for your command. Pass in false to
     * disable the built-in help option.
     *
     * @param {string | boolean} [flags]
     * @param {string} [description]
     * @return {Command} `this` command for chaining
     */
    helpOption(m, T) {
      if (typeof m == "boolean")
        return this._hasHelpOption = m, this;
      this._helpFlags = m || this._helpFlags, this._helpDescription = T || this._helpDescription;
      const S = d(this._helpFlags);
      return this._helpShortFlag = S.shortFlag, this._helpLongFlag = S.longFlag, this;
    }
    /**
     * Output help information and exit.
     *
     * Outputs built-in help, and custom text added using `.addHelpText()`.
     *
     * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
     */
    help(m) {
      this.outputHelp(m);
      let T = i.exitCode || 0;
      T === 0 && m && typeof m != "function" && m.error && (T = 1), this._exit(T, "commander.help", "(outputHelp)");
    }
    /**
     * Add additional text to be displayed with the built-in help.
     *
     * Position is 'before' or 'after' to affect just this command,
     * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
     *
     * @param {string} position - before or after built-in help
     * @param {string | Function} text - string to add, or a function returning a string
     * @return {Command} `this` command for chaining
     */
    addHelpText(m, T) {
      const S = ["beforeAll", "before", "after", "afterAll"];
      if (!S.includes(m))
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${S.join("', '")}'`);
      const A = `${m}Help`;
      return this.on(A, (x) => {
        let D;
        typeof T == "function" ? D = T({ error: x.error, command: x.command }) : D = T, D && x.write(`${D}
`);
      }), this;
    }
  }
  function b(C, m) {
    C._hasHelpOption && m.find((S) => S === C._helpLongFlag || S === C._helpShortFlag) && (C.outputHelp(), C._exit(0, "commander.helpDisplayed", "(outputHelp)"));
  }
  function _(C) {
    return C.map((m) => {
      if (!m.startsWith("--inspect"))
        return m;
      let T, S = "127.0.0.1", A = "9229", x;
      return (x = m.match(/^(--inspect(-brk)?)$/)) !== null ? T = x[1] : (x = m.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null ? (T = x[1], /^\d+$/.test(x[3]) ? A = x[3] : S = x[3]) : (x = m.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null && (T = x[1], S = x[3], A = x[4]), T && A !== "0" ? `${T}=${S}:${parseInt(A) + 1}` : m;
    });
  }
  return mf.Command = w, mf;
}
var g_;
function mV() {
  return g_ || (g_ = 1, function(r, t) {
    const { Argument: e } = Ip(), { Command: n } = pV(), { CommanderError: i, InvalidArgumentError: o } = Iu(), { Help: s } = pC(), { Option: u } = mC();
    t = r.exports = new n(), t.program = t, t.Command = n, t.Option = u, t.Argument = e, t.Help = s, t.CommanderError = i, t.InvalidArgumentError = o, t.InvalidOptionArgumentError = o;
  }(ka, ka.exports)), ka.exports;
}
var gV = mV();
const yV = /* @__PURE__ */ jh(gV), {
  program: g4,
  createCommand: y4,
  createArgument: v4,
  createOption: _4,
  CommanderError: w4,
  InvalidArgumentError: b4,
  InvalidOptionArgumentError: T4,
  // deprecated old name
  Command: vV,
  Argument: C4,
  Option: S4,
  Help: E4
} = yV;
var gC;
(() => {
  var r = { 975: (V) => {
    function N(K) {
      if (typeof K != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(K));
    }
    function $(K, P) {
      for (var I, B = "", W = 0, z = -1, ee = 0, ne = 0; ne <= K.length; ++ne) {
        if (ne < K.length) I = K.charCodeAt(ne);
        else {
          if (I === 47) break;
          I = 47;
        }
        if (I === 47) {
          if (!(z === ne - 1 || ee === 1)) if (z !== ne - 1 && ee === 2) {
            if (B.length < 2 || W !== 2 || B.charCodeAt(B.length - 1) !== 46 || B.charCodeAt(B.length - 2) !== 46) {
              if (B.length > 2) {
                var ce = B.lastIndexOf("/");
                if (ce !== B.length - 1) {
                  ce === -1 ? (B = "", W = 0) : W = (B = B.slice(0, ce)).length - 1 - B.lastIndexOf("/"), z = ne, ee = 0;
                  continue;
                }
              } else if (B.length === 2 || B.length === 1) {
                B = "", W = 0, z = ne, ee = 0;
                continue;
              }
            }
            P && (B.length > 0 ? B += "/.." : B = "..", W = 2);
          } else B.length > 0 ? B += "/" + K.slice(z + 1, ne) : B = K.slice(z + 1, ne), W = ne - z - 1;
          z = ne, ee = 0;
        } else I === 46 && ee !== -1 ? ++ee : ee = -1;
      }
      return B;
    }
    var j = { resolve: function() {
      for (var K, P = "", I = !1, B = arguments.length - 1; B >= -1 && !I; B--) {
        var W;
        B >= 0 ? W = arguments[B] : (K === void 0 && (K = process.cwd()), W = K), N(W), W.length !== 0 && (P = W + "/" + P, I = W.charCodeAt(0) === 47);
      }
      return P = $(P, !I), I ? P.length > 0 ? "/" + P : "/" : P.length > 0 ? P : ".";
    }, normalize: function(K) {
      if (N(K), K.length === 0) return ".";
      var P = K.charCodeAt(0) === 47, I = K.charCodeAt(K.length - 1) === 47;
      return (K = $(K, !P)).length !== 0 || P || (K = "."), K.length > 0 && I && (K += "/"), P ? "/" + K : K;
    }, isAbsolute: function(K) {
      return N(K), K.length > 0 && K.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0) return ".";
      for (var K, P = 0; P < arguments.length; ++P) {
        var I = arguments[P];
        N(I), I.length > 0 && (K === void 0 ? K = I : K += "/" + I);
      }
      return K === void 0 ? "." : j.normalize(K);
    }, relative: function(K, P) {
      if (N(K), N(P), K === P || (K = j.resolve(K)) === (P = j.resolve(P))) return "";
      for (var I = 1; I < K.length && K.charCodeAt(I) === 47; ++I) ;
      for (var B = K.length, W = B - I, z = 1; z < P.length && P.charCodeAt(z) === 47; ++z) ;
      for (var ee = P.length - z, ne = W < ee ? W : ee, ce = -1, te = 0; te <= ne; ++te) {
        if (te === ne) {
          if (ee > ne) {
            if (P.charCodeAt(z + te) === 47) return P.slice(z + te + 1);
            if (te === 0) return P.slice(z + te);
          } else W > ne && (K.charCodeAt(I + te) === 47 ? ce = te : te === 0 && (ce = 0));
          break;
        }
        var fe = K.charCodeAt(I + te);
        if (fe !== P.charCodeAt(z + te)) break;
        fe === 47 && (ce = te);
      }
      var Y = "";
      for (te = I + ce + 1; te <= B; ++te) te !== B && K.charCodeAt(te) !== 47 || (Y.length === 0 ? Y += ".." : Y += "/..");
      return Y.length > 0 ? Y + P.slice(z + ce) : (z += ce, P.charCodeAt(z) === 47 && ++z, P.slice(z));
    }, _makeLong: function(K) {
      return K;
    }, dirname: function(K) {
      if (N(K), K.length === 0) return ".";
      for (var P = K.charCodeAt(0), I = P === 47, B = -1, W = !0, z = K.length - 1; z >= 1; --z) if ((P = K.charCodeAt(z)) === 47) {
        if (!W) {
          B = z;
          break;
        }
      } else W = !1;
      return B === -1 ? I ? "/" : "." : I && B === 1 ? "//" : K.slice(0, B);
    }, basename: function(K, P) {
      if (P !== void 0 && typeof P != "string") throw new TypeError('"ext" argument must be a string');
      N(K);
      var I, B = 0, W = -1, z = !0;
      if (P !== void 0 && P.length > 0 && P.length <= K.length) {
        if (P.length === K.length && P === K) return "";
        var ee = P.length - 1, ne = -1;
        for (I = K.length - 1; I >= 0; --I) {
          var ce = K.charCodeAt(I);
          if (ce === 47) {
            if (!z) {
              B = I + 1;
              break;
            }
          } else ne === -1 && (z = !1, ne = I + 1), ee >= 0 && (ce === P.charCodeAt(ee) ? --ee == -1 && (W = I) : (ee = -1, W = ne));
        }
        return B === W ? W = ne : W === -1 && (W = K.length), K.slice(B, W);
      }
      for (I = K.length - 1; I >= 0; --I) if (K.charCodeAt(I) === 47) {
        if (!z) {
          B = I + 1;
          break;
        }
      } else W === -1 && (z = !1, W = I + 1);
      return W === -1 ? "" : K.slice(B, W);
    }, extname: function(K) {
      N(K);
      for (var P = -1, I = 0, B = -1, W = !0, z = 0, ee = K.length - 1; ee >= 0; --ee) {
        var ne = K.charCodeAt(ee);
        if (ne !== 47) B === -1 && (W = !1, B = ee + 1), ne === 46 ? P === -1 ? P = ee : z !== 1 && (z = 1) : P !== -1 && (z = -1);
        else if (!W) {
          I = ee + 1;
          break;
        }
      }
      return P === -1 || B === -1 || z === 0 || z === 1 && P === B - 1 && P === I + 1 ? "" : K.slice(P, B);
    }, format: function(K) {
      if (K === null || typeof K != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof K);
      return function(P, I) {
        var B = I.dir || I.root, W = I.base || (I.name || "") + (I.ext || "");
        return B ? B === I.root ? B + W : B + "/" + W : W;
      }(0, K);
    }, parse: function(K) {
      N(K);
      var P = { root: "", dir: "", base: "", ext: "", name: "" };
      if (K.length === 0) return P;
      var I, B = K.charCodeAt(0), W = B === 47;
      W ? (P.root = "/", I = 1) : I = 0;
      for (var z = -1, ee = 0, ne = -1, ce = !0, te = K.length - 1, fe = 0; te >= I; --te) if ((B = K.charCodeAt(te)) !== 47) ne === -1 && (ce = !1, ne = te + 1), B === 46 ? z === -1 ? z = te : fe !== 1 && (fe = 1) : z !== -1 && (fe = -1);
      else if (!ce) {
        ee = te + 1;
        break;
      }
      return z === -1 || ne === -1 || fe === 0 || fe === 1 && z === ne - 1 && z === ee + 1 ? ne !== -1 && (P.base = P.name = ee === 0 && W ? K.slice(1, ne) : K.slice(ee, ne)) : (ee === 0 && W ? (P.name = K.slice(1, z), P.base = K.slice(1, ne)) : (P.name = K.slice(ee, z), P.base = K.slice(ee, ne)), P.ext = K.slice(z, ne)), ee > 0 ? P.dir = K.slice(0, ee - 1) : W && (P.dir = "/"), P;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    j.posix = j, V.exports = j;
  } }, t = {};
  function e(V) {
    var N = t[V];
    if (N !== void 0) return N.exports;
    var $ = t[V] = { exports: {} };
    return r[V]($, $.exports, e), $.exports;
  }
  e.d = (V, N) => {
    for (var $ in N) e.o(N, $) && !e.o(V, $) && Object.defineProperty(V, $, { enumerable: !0, get: N[$] });
  }, e.o = (V, N) => Object.prototype.hasOwnProperty.call(V, N), e.r = (V) => {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(V, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(V, "__esModule", { value: !0 });
  };
  var n = {};
  let i;
  e.r(n), e.d(n, { URI: () => y, Utils: () => H }), typeof process == "object" ? i = process.platform === "win32" : typeof navigator == "object" && (i = navigator.userAgent.indexOf("Windows") >= 0);
  const o = /^\w[\w\d+.-]*$/, s = /^\//, u = /^\/\//;
  function l(V, N) {
    if (!V.scheme && N) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${V.authority}", path: "${V.path}", query: "${V.query}", fragment: "${V.fragment}"}`);
    if (V.scheme && !o.test(V.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
    if (V.path) {
      if (V.authority) {
        if (!s.test(V.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      } else if (u.test(V.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
    }
  }
  const c = "", d = "/", g = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  class y {
    static isUri(N) {
      return N instanceof y || !!N && typeof N.authority == "string" && typeof N.fragment == "string" && typeof N.path == "string" && typeof N.query == "string" && typeof N.scheme == "string" && typeof N.fsPath == "string" && typeof N.with == "function" && typeof N.toString == "function";
    }
    scheme;
    authority;
    path;
    query;
    fragment;
    constructor(N, $, j, K, P, I = !1) {
      typeof N == "object" ? (this.scheme = N.scheme || c, this.authority = N.authority || c, this.path = N.path || c, this.query = N.query || c, this.fragment = N.fragment || c) : (this.scheme = /* @__PURE__ */ function(B, W) {
        return B || W ? B : "file";
      }(N, I), this.authority = $ || c, this.path = function(B, W) {
        switch (B) {
          case "https":
          case "http":
          case "file":
            W ? W[0] !== d && (W = d + W) : W = d;
        }
        return W;
      }(this.scheme, j || c), this.query = K || c, this.fragment = P || c, l(this, I));
    }
    get fsPath() {
      return T(this);
    }
    with(N) {
      if (!N) return this;
      let { scheme: $, authority: j, path: K, query: P, fragment: I } = N;
      return $ === void 0 ? $ = this.scheme : $ === null && ($ = c), j === void 0 ? j = this.authority : j === null && (j = c), K === void 0 ? K = this.path : K === null && (K = c), P === void 0 ? P = this.query : P === null && (P = c), I === void 0 ? I = this.fragment : I === null && (I = c), $ === this.scheme && j === this.authority && K === this.path && P === this.query && I === this.fragment ? this : new b($, j, K, P, I);
    }
    static parse(N, $ = !1) {
      const j = g.exec(N);
      return j ? new b(j[2] || c, D(j[4] || c), D(j[5] || c), D(j[7] || c), D(j[9] || c), $) : new b(c, c, c, c, c);
    }
    static file(N) {
      let $ = c;
      if (i && (N = N.replace(/\\/g, d)), N[0] === d && N[1] === d) {
        const j = N.indexOf(d, 2);
        j === -1 ? ($ = N.substring(2), N = d) : ($ = N.substring(2, j), N = N.substring(j) || d);
      }
      return new b("file", $, N, c, c);
    }
    static from(N) {
      const $ = new b(N.scheme, N.authority, N.path, N.query, N.fragment);
      return l($, !0), $;
    }
    toString(N = !1) {
      return S(this, N);
    }
    toJSON() {
      return this;
    }
    static revive(N) {
      if (N) {
        if (N instanceof y) return N;
        {
          const $ = new b(N);
          return $._formatted = N.external, $._fsPath = N._sep === w ? N.fsPath : null, $;
        }
      }
      return N;
    }
  }
  const w = i ? 1 : void 0;
  class b extends y {
    _formatted = null;
    _fsPath = null;
    get fsPath() {
      return this._fsPath || (this._fsPath = T(this)), this._fsPath;
    }
    toString(N = !1) {
      return N ? S(this, !0) : (this._formatted || (this._formatted = S(this, !1)), this._formatted);
    }
    toJSON() {
      const N = { $mid: 1 };
      return this._fsPath && (N.fsPath = this._fsPath, N._sep = w), this._formatted && (N.external = this._formatted), this.path && (N.path = this.path), this.scheme && (N.scheme = this.scheme), this.authority && (N.authority = this.authority), this.query && (N.query = this.query), this.fragment && (N.fragment = this.fragment), N;
    }
  }
  const _ = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
  function C(V, N, $) {
    let j, K = -1;
    for (let P = 0; P < V.length; P++) {
      const I = V.charCodeAt(P);
      if (I >= 97 && I <= 122 || I >= 65 && I <= 90 || I >= 48 && I <= 57 || I === 45 || I === 46 || I === 95 || I === 126 || N && I === 47 || $ && I === 91 || $ && I === 93 || $ && I === 58) K !== -1 && (j += encodeURIComponent(V.substring(K, P)), K = -1), j !== void 0 && (j += V.charAt(P));
      else {
        j === void 0 && (j = V.substr(0, P));
        const B = _[I];
        B !== void 0 ? (K !== -1 && (j += encodeURIComponent(V.substring(K, P)), K = -1), j += B) : K === -1 && (K = P);
      }
    }
    return K !== -1 && (j += encodeURIComponent(V.substring(K))), j !== void 0 ? j : V;
  }
  function m(V) {
    let N;
    for (let $ = 0; $ < V.length; $++) {
      const j = V.charCodeAt($);
      j === 35 || j === 63 ? (N === void 0 && (N = V.substr(0, $)), N += _[j]) : N !== void 0 && (N += V[$]);
    }
    return N !== void 0 ? N : V;
  }
  function T(V, N) {
    let $;
    return $ = V.authority && V.path.length > 1 && V.scheme === "file" ? `//${V.authority}${V.path}` : V.path.charCodeAt(0) === 47 && (V.path.charCodeAt(1) >= 65 && V.path.charCodeAt(1) <= 90 || V.path.charCodeAt(1) >= 97 && V.path.charCodeAt(1) <= 122) && V.path.charCodeAt(2) === 58 ? V.path[1].toLowerCase() + V.path.substr(2) : V.path, i && ($ = $.replace(/\//g, "\\")), $;
  }
  function S(V, N) {
    const $ = N ? m : C;
    let j = "", { scheme: K, authority: P, path: I, query: B, fragment: W } = V;
    if (K && (j += K, j += ":"), (P || K === "file") && (j += d, j += d), P) {
      let z = P.indexOf("@");
      if (z !== -1) {
        const ee = P.substr(0, z);
        P = P.substr(z + 1), z = ee.lastIndexOf(":"), z === -1 ? j += $(ee, !1, !1) : (j += $(ee.substr(0, z), !1, !1), j += ":", j += $(ee.substr(z + 1), !1, !0)), j += "@";
      }
      P = P.toLowerCase(), z = P.lastIndexOf(":"), z === -1 ? j += $(P, !1, !0) : (j += $(P.substr(0, z), !1, !0), j += P.substr(z));
    }
    if (I) {
      if (I.length >= 3 && I.charCodeAt(0) === 47 && I.charCodeAt(2) === 58) {
        const z = I.charCodeAt(1);
        z >= 65 && z <= 90 && (I = `/${String.fromCharCode(z + 32)}:${I.substr(3)}`);
      } else if (I.length >= 2 && I.charCodeAt(1) === 58) {
        const z = I.charCodeAt(0);
        z >= 65 && z <= 90 && (I = `${String.fromCharCode(z + 32)}:${I.substr(2)}`);
      }
      j += $(I, !0, !1);
    }
    return B && (j += "?", j += $(B, !1, !1)), W && (j += "#", j += N ? W : C(W, !1, !1)), j;
  }
  function A(V) {
    try {
      return decodeURIComponent(V);
    } catch {
      return V.length > 3 ? V.substr(0, 3) + A(V.substr(3)) : V;
    }
  }
  const x = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function D(V) {
    return V.match(x) ? V.replace(x, (N) => A(N)) : V;
  }
  var U = e(975);
  const O = U.posix || U, k = "/";
  var H;
  (function(V) {
    V.joinPath = function(N, ...$) {
      return N.with({ path: O.join(N.path, ...$) });
    }, V.resolvePath = function(N, ...$) {
      let j = N.path, K = !1;
      j[0] !== k && (j = k + j, K = !0);
      let P = O.resolve(j, ...$);
      return K && P[0] === k && !N.authority && (P = P.substring(1)), N.with({ path: P });
    }, V.dirname = function(N) {
      if (N.path.length === 0 || N.path === k) return N;
      let $ = O.dirname(N.path);
      return $.length === 1 && $.charCodeAt(0) === 46 && ($ = ""), N.with({ path: $ });
    }, V.basename = function(N) {
      return O.basename(N.path);
    }, V.extname = function(N) {
      return O.extname(N.path);
    };
  })(H || (H = {})), gC = n;
})();
const { URI: Mp, Utils: _V } = gC;
class qh extends Error {
  constructor(t, e) {
    super(t), this.cause = e, this.name = "StdinReadError";
  }
}
async function wV(r = {}) {
  const { maxSizeBytes: t = 1024 * 1024, timeoutMs: e = 3e4 } = r;
  if (process.stdin.isTTY)
    return {
      content: "",
      truncated: !1,
      timedOut: !1,
      bytesRead: 0
    };
  try {
    if (nP(process.stdin.fd).isCharacterDevice()) {
      const i = `/proc/self/fd/${process.stdin.fd}`;
      try {
        const o = rP(i);
        if (o === "/dev/zero")
          return oe.warn(
            "Detected /dev/zero input, returning empty content to avoid infinite read"
          ), {
            content: "",
            truncated: !1,
            timedOut: !1,
            bytesRead: 0
          };
        if (o === "/dev/random" || o === "/dev/urandom")
          throw new qh(
            `Refusing to read from special device: ${o}. This would cause infinite data consumption.`
          );
      } catch {
      }
    }
  } catch {
  }
  return new Promise((n, i) => {
    let o = "", s = 0, u = !1, l = !1, c = null;
    const d = () => {
      c && (clearTimeout(c), c = null), process.stdin.removeAllListeners("data"), process.stdin.removeAllListeners("end"), process.stdin.removeAllListeners("error");
    }, g = () => {
      d(), n({
        content: o,
        truncated: u,
        timedOut: l,
        bytesRead: s
      });
    };
    c = setTimeout(() => {
      l = !0, g();
    }, e), process.stdin.once("error", (y) => {
      d(), i(new qh("Failed to read from stdin", y));
    }), process.stdin.once("end", () => {
      g();
    }), process.stdin.on("data", (y) => {
      const w = y.length;
      if (s + w > t) {
        const b = t - s;
        b > 0 && (o += y.subarray(0, b).toString("utf8"), s = t), u = !0, g();
        return;
      }
      o += y.toString("utf8"), s += w;
    }), process.stdin.resume();
  });
}
async function bV() {
  const r = await wV();
  if (r.timedOut)
    throw new qh("Timeout while reading from stdin");
  return r.truncated && oe.warn(`Warning: stdin input was truncated at ${r.bytesRead} bytes`), r.content;
}
const Gr = gr.homedir(), { env: Ci } = process, Zl = Ci.XDG_DATA_HOME || (Gr ? Je.join(Gr, ".local", "share") : void 0), Bh = Ci.XDG_CONFIG_HOME || (Gr ? Je.join(Gr, ".config") : void 0), TV = Ci.XDG_STATE_HOME || (Gr ? Je.join(Gr, ".local", "state") : void 0), CV = Ci.XDG_CACHE_HOME || (Gr ? Je.join(Gr, ".cache") : void 0);
Ci.XDG_RUNTIME_DIR;
const SV = (Ci.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":");
Zl && SV.unshift(Zl);
const EV = (Ci.XDG_CONFIG_DIRS || "/etc/xdg").split(":");
Bh && EV.unshift(Bh);
const yC = Je.join(Zl || Je.join(nu(), ".local/share"), "amp"), xs = Je.join(
  Bh || Je.join(nu(), ".config"),
  "amp",
  "settings.json"
), Vh = "secrets.json", Hh = Je.join(yC, Vh);
function AV(r) {
  const t = r?.settingsFile ?? xs, e = new pr();
  let n;
  async function i() {
    try {
      const u = Je.dirname(t);
      await ro.mkdir(u, { recursive: !0 });
    } catch (u) {
      throw oe.error(`Failed to create config directory: ${u}`), u;
    }
  }
  async function o() {
    if (n)
      return n;
    try {
      await i();
      const u = await ro.readFile(t, "utf-8"), l = JSON.parse(u), c = {};
      for (const [d, g] of Object.entries(l))
        if (d.startsWith("amp.")) {
          const y = d.substring(4);
          c[y] = g;
        }
      return n = c, c;
    } catch (u) {
      if (u.code === "ENOENT")
        return n = {}, n;
      throw oe.error(`Failed to read settings: ${u}`), u;
    }
  }
  async function s(u) {
    try {
      await i();
      const l = {};
      for (const [c, d] of Object.entries(u))
        l[`amp.${c}`] = d;
      await ro.writeFile(t, JSON.stringify(l, null, 2), "utf-8"), n = u;
    } catch (l) {
      throw oe.error(`Failed to write settings: ${l}`), l;
    }
  }
  return {
    async get(u) {
      return (await o())[u];
    },
    async set(u, l, c) {
      if (c === "workspace")
        throw new Error(`Unsupported target: ${c}`);
      const d = await o();
      d[u] = l, await s(d), e.next([u]);
    },
    async delete(u, l) {
      if (l === "workspace")
        throw new Error(`Unsupported target: ${l}`);
      const c = await o();
      delete c[u], await s(c), e.next([u]);
    },
    async keys() {
      const u = await o();
      return Object.keys(u);
    },
    changes: e
  };
}
function Gh(r) {
  const t = yC, e = new pr();
  let n;
  async function i() {
    try {
      await ro.mkdir(t, { recursive: !0 });
    } catch (u) {
      throw oe.error(`Failed to create data directory: ${u}`), u;
    }
  }
  async function o() {
    if (n)
      return n;
    try {
      await i();
      const u = r?.dataDir ? Je.join(t, Vh) : Hh, l = await ro.readFile(u, "utf-8");
      return n = JSON.parse(l), n;
    } catch (u) {
      if (u.code === "ENOENT")
        return n = {}, n;
      throw oe.error(`Failed to read secrets: ${u}`), u;
    }
  }
  async function s(u) {
    try {
      await i();
      const l = r?.dataDir ? Je.join(t, Vh) : Hh;
      await ro.writeFile(l, JSON.stringify(u, null, 2), "utf-8"), n = u;
    } catch (l) {
      throw oe.error(`Failed to write secrets: ${l}`), l;
    }
  }
  return {
    async get(u, l) {
      return (await o())[`${u}@${l}`];
    },
    async set(u, l, c) {
      const d = `${u}@${c}`, g = await o();
      g[d] = l, await s(g), e.next(d);
    },
    changes: e
  };
}
const xV = import("./node-7PIWGuuc.js").then(
  ({ nodeFileSystem: r }) => r
);
class RV {
  constructor(t) {
    this.threadService = t;
  }
  async summarizeThread(t) {
    const e = await it(this.threadService.observe(t));
    if (!e)
      throw new Error(`Thread ${t} not found`);
    return await v_(e);
  }
  /**
   * Create a new thread that contains a summary of the original thread.
   */
  async createSummaryThread(t) {
    const e = await it(this.threadService.observe(t));
    if (!e)
      throw new Error(`Thread ${t} not found`);
    const n = await v_(e);
    return this.createThreadWithSummary(t, n);
  }
  async createThreadWithSummary(t, e) {
    const n = await it(this.threadService.observe(t));
    if (!n)
      throw new Error(`Thread ${t} not found`);
    const i = Il(), o = await this.threadService.exclusiveSyncReadWriter(i), s = o.read();
    s.originThreadID = t, s.v++, s.title = e.split(" ").slice(0, 7).join(" "), n.env && (s.env = JSON.parse(JSON.stringify(n.env))), s.messages.push({
      role: "user",
      content: [
        {
          type: "text",
          text: "Summarize the previous conversation and continue from here."
        }
      ]
    }), s.messages.push({
      role: "assistant",
      content: [
        {
          type: "text",
          text: e
        }
      ],
      state: { type: "complete", stopReason: "end_turn" }
    }), o.write(s), o.dispose();
    const u = s.v;
    return await this.threadService.flushVersion(i, u), i;
  }
}
const fs = 50, IV = `Provide a detailed but concise summary of our conversation above.

Provide enough information so that someone else can continue the conversation in your place.

Your summary should contain what I wanted, what we did, what we're doing, and what we still have to include.

Include important file paths, function names, and commands that are helpful for someone else to continue where we left off.

Address the user in the second person.

Do NOT use headings in your response. Use short paragraphs and lists.

Do NOT start with 'You asked me to explain' or 'You asked me to summarize' or other phrases to that effect. Start with the summary.",
`, vC = `

[ ... omitted remaining lines to make summarizing use less tokens ... ]`, _C = ["text", "diff", "output"];
function ao(r) {
  const t = r.split(`
`);
  return t.length > fs ? t.slice(0, fs).join(`
`) + vC : r;
}
function MV(r) {
  if (typeof r == "string")
    return ao(r);
  if (Array.isArray(r)) {
    r.length > fs && r.splice(
      fs,
      r.length - fs,
      vC
    );
    for (let t = 0; t < r.length; t++)
      typeof r[t] == "string" && (r[t] = ao(r[t]));
    return r;
  }
  if (typeof r == "object" && r !== null) {
    for (const t of _C)
      t in r && typeof r[t] == "string" && (r[t] = ao(r[t]));
    return r;
  }
  return r;
}
function kV(r) {
  if (r !== void 0) {
    if (typeof r == "string")
      return ao(r);
    if (Array.isArray(r)) {
      if (r.length > 0 && typeof r[0] == "string") {
        const t = [];
        for (const e of r)
          typeof e == "string" && t.push(ao(e));
        return t;
      }
      if (r.length > 0 && typeof r[0] == "object") {
        const t = [];
        for (const e of r)
          typeof e == "object" && e !== null && t.push(y_(e));
        return t;
      }
    }
    return typeof r == "object" && r !== null ? y_(r) : r;
  }
}
function y_(r) {
  const t = JSON.parse(JSON.stringify(r));
  for (const e of _C)
    e in t && typeof t[e] == "string" && (t[e] = ao(t[e]));
  return t;
}
function PV(r) {
  for (const t of r.messages)
    if (t.role === "user") {
      t.fileMentions = void 0;
      for (const e of t.content)
        e.type === "tool_result" && (e.run.status === "done" ? e.run.result = MV(e.run.result) : e.run.status === "cancelled" && e.run.progress && (e.run.progress = kV(e.run.progress)));
    }
}
async function v_(r) {
  const t = JSON.parse(JSON.stringify(r));
  PV(t);
  const e = mb.fromNativeThread(t);
  e.push({
    role: "user",
    content: IV
  });
  const n = await Ok(e, [], []);
  if (!n.message)
    throw new Error("Summary did not produce a message");
  return n.message?.content.filter((i) => i.type === "text").map((i) => i.type === "text" ? i.text : "").join(`

`).trimEnd();
}
var vf = {}, La = {}, _f, __;
function cn() {
  if (__) return _f;
  __ = 1;
  function r(b) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
      return typeof _;
    } : function(_) {
      return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
    }, r(b);
  }
  function t(b, _, C) {
    return Object.defineProperty(b, "prototype", { writable: !1 }), b;
  }
  function e(b, _) {
    if (!(b instanceof _)) throw new TypeError("Cannot call a class as a function");
  }
  function n(b, _, C) {
    return _ = y(_), i(b, c() ? Reflect.construct(_, C || [], y(b).constructor) : _.apply(b, C));
  }
  function i(b, _) {
    if (_ && (r(_) == "object" || typeof _ == "function")) return _;
    if (_ !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return o(b);
  }
  function o(b) {
    if (b === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return b;
  }
  function s(b, _) {
    if (typeof _ != "function" && _ !== null) throw new TypeError("Super expression must either be null or a function");
    b.prototype = Object.create(_ && _.prototype, { constructor: { value: b, writable: !0, configurable: !0 } }), Object.defineProperty(b, "prototype", { writable: !1 }), _ && g(b, _);
  }
  function u(b) {
    var _ = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return u = function(m) {
      if (m === null || !d(m)) return m;
      if (typeof m != "function") throw new TypeError("Super expression must either be null or a function");
      if (_ !== void 0) {
        if (_.has(m)) return _.get(m);
        _.set(m, T);
      }
      function T() {
        return l(m, arguments, y(this).constructor);
      }
      return T.prototype = Object.create(m.prototype, { constructor: { value: T, enumerable: !1, writable: !0, configurable: !0 } }), g(T, m);
    }, u(b);
  }
  function l(b, _, C) {
    if (c()) return Reflect.construct.apply(null, arguments);
    var m = [null];
    m.push.apply(m, _);
    var T = new (b.bind.apply(b, m))();
    return C && g(T, C.prototype), T;
  }
  function c() {
    try {
      var b = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (c = function() {
      return !!b;
    })();
  }
  function d(b) {
    try {
      return Function.toString.call(b).indexOf("[native code]") !== -1;
    } catch {
      return typeof b == "function";
    }
  }
  function g(b, _) {
    return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(C, m) {
      return C.__proto__ = m, C;
    }, g(b, _);
  }
  function y(b) {
    return y = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(_) {
      return _.__proto__ || Object.getPrototypeOf(_);
    }, y(b);
  }
  var w = /* @__PURE__ */ function(b) {
    function _(C) {
      var m;
      return e(this, _), m = n(this, _, [`Format functions must be synchronous taking a two arguments: (info, opts)
Found: `.concat(C.toString().split(`
`)[0], `
`)]), Error.captureStackTrace(m, _), m;
    }
    return s(_, b), t(_);
  }(/* @__PURE__ */ u(Error));
  return _f = function(b) {
    if (b.length > 2)
      throw new w(b);
    function _() {
      var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.options = m;
    }
    _.prototype.transform = b;
    function C(m) {
      return new _(m);
    }
    return C.Format = _, C;
  }, _f;
}
var zo = { exports: {} }, wf = { exports: {} }, bf = { exports: {} }, Tf = { exports: {} }, w_;
function OV() {
  return w_ || (w_ = 1, function(r) {
    var t = {};
    r.exports = t;
    var e = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(e).forEach(function(n) {
      var i = e[n], o = t[n] = [];
      o.open = "\x1B[" + i[0] + "m", o.close = "\x1B[" + i[1] + "m";
    });
  }(Tf)), Tf.exports;
}
var Cf, b_;
function LV() {
  return b_ || (b_ = 1, Cf = function(r, t) {
    t = t || process.argv || [];
    var e = t.indexOf("--"), n = /^-{1,2}/.test(r) ? "" : "--", i = t.indexOf(n + r);
    return i !== -1 && (e === -1 ? !0 : i < e);
  }), Cf;
}
var Sf, T_;
function NV() {
  if (T_) return Sf;
  T_ = 1;
  var r = gr, t = LV(), e = process.env, n = void 0;
  t("no-color") || t("no-colors") || t("color=false") ? n = !1 : (t("color") || t("colors") || t("color=true") || t("color=always")) && (n = !0), "FORCE_COLOR" in e && (n = e.FORCE_COLOR.length === 0 || parseInt(e.FORCE_COLOR, 10) !== 0);
  function i(u) {
    return u === 0 ? !1 : {
      level: u,
      hasBasic: !0,
      has256: u >= 2,
      has16m: u >= 3
    };
  }
  function o(u) {
    if (n === !1)
      return 0;
    if (t("color=16m") || t("color=full") || t("color=truecolor"))
      return 3;
    if (t("color=256"))
      return 2;
    if (u && !u.isTTY && n !== !0)
      return 0;
    var l = n ? 1 : 0;
    if (process.platform === "win32") {
      var c = r.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(c[0]) >= 10 && Number(c[2]) >= 10586 ? Number(c[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in e)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(g) {
        return g in e;
      }) || e.CI_NAME === "codeship" ? 1 : l;
    if ("TEAMCITY_VERSION" in e)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(e.TEAMCITY_VERSION) ? 1 : 0;
    if ("TERM_PROGRAM" in e) {
      var d = parseInt((e.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (e.TERM_PROGRAM) {
        case "iTerm.app":
          return d >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(e.TERM) ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(e.TERM) || "COLORTERM" in e ? 1 : (e.TERM === "dumb", l);
  }
  function s(u) {
    var l = o(u);
    return i(l);
  }
  return Sf = {
    supportsColor: s,
    stdout: s(process.stdout),
    stderr: s(process.stderr)
  }, Sf;
}
var Ef = { exports: {} }, C_;
function DV() {
  return C_ || (C_ = 1, function(r) {
    r.exports = function(e, n) {
      var i = "";
      e = e || "Run the trap, drop the bass", e = e.split("");
      var o = {
        a: ["@", "", "", "", "", "", ""],
        b: ["", "", "", "", "", ""],
        c: ["", "", ""],
        d: ["", "", "", "", "", ""],
        e: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        f: [""],
        g: [""],
        h: ["", "", "", "", "", ""],
        i: [""],
        j: [""],
        k: ["", "", "", ""],
        l: [""],
        m: ["", "", "", "", "", ""],
        n: ["", "", "", "", "", ""],
        o: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        p: ["", ""],
        q: [""],
        r: ["", "", "", "", "", ""],
        s: ["", "", "", ""],
        t: ["", "", ""],
        u: ["", ""],
        v: [""],
        w: ["", "", "", ""],
        x: ["", "", "", ""],
        y: ["", "", ""],
        z: ["", ""]
      };
      return e.forEach(function(s) {
        s = s.toLowerCase();
        var u = o[s] || [" "], l = Math.floor(Math.random() * u.length);
        typeof o[s] < "u" ? i += o[s][l] : i += s;
      }), i;
    };
  }(Ef)), Ef.exports;
}
var Af = { exports: {} }, S_;
function FV() {
  return S_ || (S_ = 1, function(r) {
    r.exports = function(e, n) {
      e = e || "   he is here   ";
      var i = {
        up: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        down: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ],
        mid: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " "
        ]
      }, o = [].concat(i.up, i.down, i.mid);
      function s(c) {
        var d = Math.floor(Math.random() * c);
        return d;
      }
      function u(c) {
        var d = !1;
        return o.filter(function(g) {
          d = g === c;
        }), d;
      }
      function l(c, d) {
        var g = "", y, w;
        d = d || {}, d.up = typeof d.up < "u" ? d.up : !0, d.mid = typeof d.mid < "u" ? d.mid : !0, d.down = typeof d.down < "u" ? d.down : !0, d.size = typeof d.size < "u" ? d.size : "maxi", c = c.split("");
        for (w in c)
          if (!u(w)) {
            switch (g = g + c[w], y = { up: 0, down: 0, mid: 0 }, d.size) {
              case "mini":
                y.up = s(8), y.mid = s(2), y.down = s(8);
                break;
              case "maxi":
                y.up = s(16) + 3, y.mid = s(4) + 1, y.down = s(64) + 3;
                break;
              default:
                y.up = s(8) + 1, y.mid = s(6) / 2, y.down = s(8) + 1;
                break;
            }
            var b = ["up", "mid", "down"];
            for (var _ in b)
              for (var C = b[_], m = 0; m <= y[C]; m++)
                d[C] && (g = g + i[C][s(i[C].length)]);
          }
        return g;
      }
      return l(e, n);
    };
  }(Af)), Af.exports;
}
var xf = { exports: {} }, E_;
function $V() {
  return E_ || (E_ = 1, function(r) {
    r.exports = function(t) {
      return function(e, n, i) {
        if (e === " ") return e;
        switch (n % 3) {
          case 0:
            return t.red(e);
          case 1:
            return t.white(e);
          case 2:
            return t.blue(e);
        }
      };
    };
  }(xf)), xf.exports;
}
var Rf = { exports: {} }, A_;
function UV() {
  return A_ || (A_ = 1, function(r) {
    r.exports = function(t) {
      return function(e, n, i) {
        return n % 2 === 0 ? e : t.inverse(e);
      };
    };
  }(Rf)), Rf.exports;
}
var If = { exports: {} }, x_;
function qV() {
  return x_ || (x_ = 1, function(r) {
    r.exports = function(t) {
      var e = ["red", "yellow", "green", "blue", "magenta"];
      return function(n, i, o) {
        return n === " " ? n : t[e[i++ % e.length]](n);
      };
    };
  }(If)), If.exports;
}
var Mf = { exports: {} }, R_;
function BV() {
  return R_ || (R_ = 1, function(r) {
    r.exports = function(t) {
      var e = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(n, i, o) {
        return n === " " ? n : t[e[Math.round(Math.random() * (e.length - 2))]](n);
      };
    };
  }(Mf)), Mf.exports;
}
var I_;
function VV() {
  return I_ || (I_ = 1, function(r) {
    var t = {};
    r.exports = t, t.themes = {};
    var e = Jn, n = t.styles = OV(), i = Object.defineProperties, o = new RegExp(/[\r\n]+/g);
    t.supportsColor = NV().supportsColor, typeof t.enabled > "u" && (t.enabled = t.supportsColor() !== !1), t.enable = function() {
      t.enabled = !0;
    }, t.disable = function() {
      t.enabled = !1;
    }, t.stripColors = t.strip = function(_) {
      return ("" + _).replace(/\x1B\[\d+m/g, "");
    }, t.stylize = function(C, m) {
      if (!t.enabled)
        return C + "";
      var T = n[m];
      return !T && m in t ? t[m](C) : T.open + C + T.close;
    };
    var s = /[|\\{}()[\]^$+*?.]/g, u = function(_) {
      if (typeof _ != "string")
        throw new TypeError("Expected a string");
      return _.replace(s, "\\$&");
    };
    function l(_) {
      var C = function m() {
        return g.apply(m, arguments);
      };
      return C._styles = _, C.__proto__ = d, C;
    }
    var c = function() {
      var _ = {};
      return n.grey = n.gray, Object.keys(n).forEach(function(C) {
        n[C].closeRe = new RegExp(u(n[C].close), "g"), _[C] = {
          get: function() {
            return l(this._styles.concat(C));
          }
        };
      }), _;
    }(), d = i(function() {
    }, c);
    function g() {
      var _ = Array.prototype.slice.call(arguments), C = _.map(function(x) {
        return x != null && x.constructor === String ? x : e.inspect(x);
      }).join(" ");
      if (!t.enabled || !C)
        return C;
      for (var m = C.indexOf(`
`) != -1, T = this._styles, S = T.length; S--; ) {
        var A = n[T[S]];
        C = A.open + C.replace(A.closeRe, A.open) + A.close, m && (C = C.replace(o, function(x) {
          return A.close + x + A.open;
        }));
      }
      return C;
    }
    t.setTheme = function(_) {
      if (typeof _ == "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var C in _)
        (function(m) {
          t[m] = function(T) {
            if (typeof _[m] == "object") {
              var S = T;
              for (var A in _[m])
                S = t[_[m][A]](S);
              return S;
            }
            return t[_[m]](T);
          };
        })(C);
    };
    function y() {
      var _ = {};
      return Object.keys(c).forEach(function(C) {
        _[C] = {
          get: function() {
            return l([C]);
          }
        };
      }), _;
    }
    var w = function(C, m) {
      var T = m.split("");
      return T = T.map(C), T.join("");
    };
    t.trap = DV(), t.zalgo = FV(), t.maps = {}, t.maps.america = $V()(t), t.maps.zebra = UV()(t), t.maps.rainbow = qV()(t), t.maps.random = BV()(t);
    for (var b in t.maps)
      (function(_) {
        t[_] = function(C) {
          return w(t.maps[_], C);
        };
      })(b);
    i(t, y());
  }(bf)), bf.exports;
}
var M_;
function wC() {
  return M_ || (M_ = 1, function(r) {
    var t = VV();
    r.exports = t;
  }(wf)), wf.exports;
}
var kf = {}, Pf = {}, Na = {}, k_;
function HV() {
  return k_ || (k_ = 1, Na.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9
  }, Na.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta"
  }), Na;
}
var Da = {}, P_;
function GV() {
  return P_ || (P_ = 1, Da.levels = {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6
  }, Da.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta"
  }), Da;
}
var Fa = {}, O_;
function WV() {
  return O_ || (O_ = 1, Fa.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7
  }, Fa.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue"
  }), Fa;
}
var L_;
function KV() {
  return L_ || (L_ = 1, function(r) {
    Object.defineProperty(r, "cli", {
      value: HV()
    }), Object.defineProperty(r, "npm", {
      value: GV()
    }), Object.defineProperty(r, "syslog", {
      value: WV()
    });
  }(Pf)), Pf;
}
var N_;
function bt() {
  return N_ || (N_ = 1, function(r) {
    Object.defineProperty(r, "LEVEL", {
      value: Symbol.for("level")
    }), Object.defineProperty(r, "MESSAGE", {
      value: Symbol.for("message")
    }), Object.defineProperty(r, "SPLAT", {
      value: Symbol.for("splat")
    }), Object.defineProperty(r, "configs", {
      value: KV()
    });
  }(kf)), kf;
}
var D_;
function kp() {
  if (D_) return zo.exports;
  D_ = 1;
  function r(y) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
      return typeof w;
    } : function(w) {
      return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
    }, r(y);
  }
  function t(y, w) {
    if (!(y instanceof w)) throw new TypeError("Cannot call a class as a function");
  }
  function e(y, w) {
    for (var b = 0; b < w.length; b++) {
      var _ = w[b];
      _.enumerable = _.enumerable || !1, _.configurable = !0, "value" in _ && (_.writable = !0), Object.defineProperty(y, i(_.key), _);
    }
  }
  function n(y, w, b) {
    return w && e(y.prototype, w), b && e(y, b), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function i(y) {
    var w = o(y, "string");
    return r(w) == "symbol" ? w : w + "";
  }
  function o(y, w) {
    if (r(y) != "object" || !y) return y;
    var b = y[Symbol.toPrimitive];
    if (b !== void 0) {
      var _ = b.call(y, w);
      if (r(_) != "object") return _;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(y);
  }
  var s = wC(), u = bt(), l = u.LEVEL, c = u.MESSAGE;
  s.enabled = !0;
  var d = /\s+/, g = /* @__PURE__ */ function() {
    function y() {
      var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t(this, y), w.colors && this.addColors(w.colors), this.options = w;
    }
    return n(y, [{
      key: "addColors",
      value: (
        /*
         * Adds the colors Object to the set of allColors
         * known by the Colorizer
         *
         * @param {Object} colors Set of color mappings to add.
         */
        function(b) {
          return y.addColors(b);
        }
      )
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
    }, {
      key: "colorize",
      value: function(b, _, C) {
        if (typeof C > "u" && (C = _), !Array.isArray(y.allColors[b]))
          return s[y.allColors[b]](C);
        for (var m = 0, T = y.allColors[b].length; m < T; m++)
          C = s[y.allColors[b][m]](C);
        return C;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
    }, {
      key: "transform",
      value: function(b, _) {
        return _.all && typeof b[c] == "string" && (b[c] = this.colorize(b[l], b.level, b[c])), (_.level || _.all || !_.message) && (b.level = this.colorize(b[l], b.level)), (_.all || _.message) && (b.message = this.colorize(b[l], b.level, b.message)), b;
      }
    }], [{
      key: "addColors",
      value: function(b) {
        var _ = Object.keys(b).reduce(function(C, m) {
          return C[m] = d.test(b[m]) ? b[m].split(d) : b[m], C;
        }, {});
        return y.allColors = Object.assign({}, y.allColors || {}, _), y.allColors;
      }
    }]);
  }();
  return zo.exports = function(y) {
    return new g(y);
  }, zo.exports.Colorizer = zo.exports.Format = g, zo.exports;
}
var Of, F_;
function JV() {
  if (F_) return Of;
  F_ = 1;
  var r = kp(), t = r.Colorizer;
  return Of = function(e) {
    return t.addColors(e.colors || e), e;
  }, Of;
}
var Lf, $_;
function zV() {
  if ($_) return Lf;
  $_ = 1;
  var r = cn();
  return Lf = r(function(t) {
    return t.message = "	".concat(t.message), t;
  }), Lf;
}
var $a = { exports: {} }, Yo = { exports: {} }, U_;
function bC() {
  if (U_) return Yo.exports;
  U_ = 1;
  function r(m) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(T) {
      return typeof T;
    } : function(T) {
      return T && typeof Symbol == "function" && T.constructor === Symbol && T !== Symbol.prototype ? "symbol" : typeof T;
    }, r(m);
  }
  function t(m) {
    return o(m) || i(m) || n(m) || e();
  }
  function e() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function n(m, T) {
    if (m) {
      if (typeof m == "string") return s(m, T);
      var S = {}.toString.call(m).slice(8, -1);
      return S === "Object" && m.constructor && (S = m.constructor.name), S === "Map" || S === "Set" ? Array.from(m) : S === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S) ? s(m, T) : void 0;
    }
  }
  function i(m) {
    if (typeof Symbol < "u" && m[Symbol.iterator] != null || m["@@iterator"] != null) return Array.from(m);
  }
  function o(m) {
    if (Array.isArray(m)) return s(m);
  }
  function s(m, T) {
    (T == null || T > m.length) && (T = m.length);
    for (var S = 0, A = Array(T); S < T; S++) A[S] = m[S];
    return A;
  }
  function u(m, T) {
    if (!(m instanceof T)) throw new TypeError("Cannot call a class as a function");
  }
  function l(m, T) {
    for (var S = 0; S < T.length; S++) {
      var A = T[S];
      A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(m, d(A.key), A);
    }
  }
  function c(m, T, S) {
    return T && l(m.prototype, T), S && l(m, S), Object.defineProperty(m, "prototype", { writable: !1 }), m;
  }
  function d(m) {
    var T = g(m, "string");
    return r(T) == "symbol" ? T : T + "";
  }
  function g(m, T) {
    if (r(m) != "object" || !m) return m;
    var S = m[Symbol.toPrimitive];
    if (S !== void 0) {
      var A = S.call(m, T);
      if (r(A) != "object") return A;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(m);
  }
  var y = bt(), w = y.configs, b = y.LEVEL, _ = y.MESSAGE, C = /* @__PURE__ */ function() {
    function m() {
      var T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        levels: w.npm.levels
      };
      u(this, m), this.paddings = m.paddingForLevels(T.levels, T.filler), this.options = T;
    }
    return c(m, [{
      key: "transform",
      value: (
        /**
         * Prepends the padding onto the `message` based on the `LEVEL` of
         * the `info`. This is based on the behavior of `winston@2` which also
         * prepended the level onto the message.
         *
         * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
         *
         * @param  {Info} info Logform info object
         * @param  {Object} opts Options passed along to this instance.
         * @returns {Info} Modified logform info object.
         */
        function(S, A) {
          return S.message = "".concat(this.paddings[S[b]]).concat(S.message), S[_] && (S[_] = "".concat(this.paddings[S[b]]).concat(S[_])), S;
        }
      )
    }], [{
      key: "getLongestLevel",
      value: function(S) {
        var A = Object.keys(S).map(function(x) {
          return x.length;
        });
        return Math.max.apply(Math, t(A));
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
    }, {
      key: "paddingForLevel",
      value: function(S, A, x) {
        var D = x + 1 - S.length, U = Math.floor(D / A.length), O = "".concat(A).concat(A.repeat(U));
        return O.slice(0, D);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
    }, {
      key: "paddingForLevels",
      value: function(S) {
        var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ", x = m.getLongestLevel(S);
        return Object.keys(S).reduce(function(D, U) {
          return D[U] = m.paddingForLevel(U, A, x), D;
        }, {});
      }
    }]);
  }();
  return Yo.exports = function(m) {
    return new C(m);
  }, Yo.exports.Padder = Yo.exports.Format = C, Yo.exports;
}
var q_;
function YV() {
  if (q_) return $a.exports;
  q_ = 1;
  function r(b) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
      return typeof _;
    } : function(_) {
      return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
    }, r(b);
  }
  function t(b, _) {
    if (!(b instanceof _)) throw new TypeError("Cannot call a class as a function");
  }
  function e(b, _) {
    for (var C = 0; C < _.length; C++) {
      var m = _[C];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(b, i(m.key), m);
    }
  }
  function n(b, _, C) {
    return _ && e(b.prototype, _), Object.defineProperty(b, "prototype", { writable: !1 }), b;
  }
  function i(b) {
    var _ = o(b, "string");
    return r(_) == "symbol" ? _ : _ + "";
  }
  function o(b, _) {
    if (r(b) != "object" || !b) return b;
    var C = b[Symbol.toPrimitive];
    if (C !== void 0) {
      var m = C.call(b, _);
      if (r(m) != "object") return m;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(b);
  }
  var s = kp(), u = s.Colorizer, l = bC(), c = l.Padder, d = bt(), g = d.configs, y = d.MESSAGE, w = /* @__PURE__ */ function() {
    function b() {
      var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t(this, b), _.levels || (_.levels = g.cli.levels), this.colorizer = new u(_), this.padder = new c(_), this.options = _;
    }
    return n(b, [{
      key: "transform",
      value: function(C, m) {
        return this.colorizer.transform(this.padder.transform(C, m), m), C[y] = "".concat(C.level, ":").concat(C.message), C;
      }
    }]);
  }();
  return $a.exports = function(b) {
    return new w(b);
  }, $a.exports.Format = w, $a.exports;
}
var Ua = { exports: {} }, B_;
function ZV() {
  if (B_) return Ua.exports;
  B_ = 1;
  var r = cn();
  function t(n) {
    if (n.every(e))
      return function(i) {
        for (var o = i, s = 0; s < n.length; s++)
          if (o = n[s].transform(o, n[s].options), !o)
            return !1;
        return o;
      };
  }
  function e(n) {
    if (typeof n.transform != "function")
      throw new Error(["No transform function found on format. Did you create a format instance?", "const myFormat = format(formatFn);", "const instance = myFormat();"].join(`
`));
    return !0;
  }
  return Ua.exports = function() {
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    var s = r(t(i)), u = s();
    return u.Format = s.Format, u;
  }, Ua.exports.cascade = t, Ua.exports;
}
var Nf, V_;
function jV() {
  if (V_) return Nf;
  V_ = 1;
  function r(l) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(c) {
      return typeof c;
    } : function(c) {
      return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
    }, r(l);
  }
  function t(l, c, d) {
    return (c = e(c)) in l ? Object.defineProperty(l, c, { value: d, enumerable: !0, configurable: !0, writable: !0 }) : l[c] = d, l;
  }
  function e(l) {
    var c = n(l, "string");
    return r(c) == "symbol" ? c : c + "";
  }
  function n(l, c) {
    if (r(l) != "object" || !l) return l;
    var d = l[Symbol.toPrimitive];
    if (d !== void 0) {
      var g = d.call(l, c);
      if (r(g) != "object") return g;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (c === "string" ? String : Number)(l);
  }
  var i = cn(), o = bt(), s = o.LEVEL, u = o.MESSAGE;
  return Nf = i(function(l, c) {
    var d = c.stack, g = c.cause;
    if (l instanceof Error) {
      var y = Object.assign({}, l, t(t(t({
        level: l.level
      }, s, l[s] || l.level), "message", l.message), u, l[u] || l.message));
      return d && (y.stack = l.stack), g && (y.cause = l.cause), y;
    }
    if (!(l.message instanceof Error)) return l;
    var w = l.message;
    return Object.assign(l, w), l.message = w.message, l[u] = w.message, d && (l.stack = w.stack), g && (l.cause = w.cause), l;
  }), Nf;
}
var qa = { exports: {} }, H_;
function Rs() {
  return H_ || (H_ = 1, function(r, t) {
    const { hasOwnProperty: e } = Object.prototype, n = m();
    n.configure = m, n.stringify = n, n.default = n, t.stringify = n, t.configure = m, r.exports = n;
    const i = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function o(T) {
      return T.length < 5e3 && !i.test(T) ? `"${T}"` : JSON.stringify(T);
    }
    function s(T, S) {
      if (T.length > 200 || S)
        return T.sort(S);
      for (let A = 1; A < T.length; A++) {
        const x = T[A];
        let D = A;
        for (; D !== 0 && T[D - 1] > x; )
          T[D] = T[D - 1], D--;
        T[D] = x;
      }
      return T;
    }
    const u = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function l(T) {
      return u.call(T) !== void 0 && T.length !== 0;
    }
    function c(T, S, A) {
      T.length < A && (A = T.length);
      const x = S === "," ? "" : " ";
      let D = `"0":${x}${T[0]}`;
      for (let U = 1; U < A; U++)
        D += `${S}"${U}":${x}${T[U]}`;
      return D;
    }
    function d(T) {
      if (e.call(T, "circularValue")) {
        const S = T.circularValue;
        if (typeof S == "string")
          return `"${S}"`;
        if (S == null)
          return S;
        if (S === Error || S === TypeError)
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function g(T) {
      let S;
      if (e.call(T, "deterministic") && (S = T.deterministic, typeof S != "boolean" && typeof S != "function"))
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      return S === void 0 ? !0 : S;
    }
    function y(T, S) {
      let A;
      if (e.call(T, S) && (A = T[S], typeof A != "boolean"))
        throw new TypeError(`The "${S}" argument must be of type boolean`);
      return A === void 0 ? !0 : A;
    }
    function w(T, S) {
      let A;
      if (e.call(T, S)) {
        if (A = T[S], typeof A != "number")
          throw new TypeError(`The "${S}" argument must be of type number`);
        if (!Number.isInteger(A))
          throw new TypeError(`The "${S}" argument must be an integer`);
        if (A < 1)
          throw new RangeError(`The "${S}" argument must be >= 1`);
      }
      return A === void 0 ? 1 / 0 : A;
    }
    function b(T) {
      return T === 1 ? "1 item" : `${T} items`;
    }
    function _(T) {
      const S = /* @__PURE__ */ new Set();
      for (const A of T)
        (typeof A == "string" || typeof A == "number") && S.add(String(A));
      return S;
    }
    function C(T) {
      if (e.call(T, "strict")) {
        const S = T.strict;
        if (typeof S != "boolean")
          throw new TypeError('The "strict" argument must be of type boolean');
        if (S)
          return (A) => {
            let x = `Object can not safely be stringified. Received type ${typeof A}`;
            throw typeof A != "function" && (x += ` (${A.toString()})`), new Error(x);
          };
      }
    }
    function m(T) {
      T = { ...T };
      const S = C(T);
      S && (T.bigint === void 0 && (T.bigint = !1), "circularValue" in T || (T.circularValue = Error));
      const A = d(T), x = y(T, "bigint"), D = g(T), U = typeof D == "function" ? D : void 0, O = w(T, "maximumDepth"), k = w(T, "maximumBreadth");
      function H(K, P, I, B, W, z) {
        let ee = P[K];
        switch (typeof ee == "object" && ee !== null && typeof ee.toJSON == "function" && (ee = ee.toJSON(K)), ee = B.call(P, K, ee), typeof ee) {
          case "string":
            return o(ee);
          case "object": {
            if (ee === null)
              return "null";
            if (I.indexOf(ee) !== -1)
              return A;
            let ne = "", ce = ",";
            const te = z;
            if (Array.isArray(ee)) {
              if (ee.length === 0)
                return "[]";
              if (O < I.length + 1)
                return '"[Array]"';
              I.push(ee), W !== "" && (z += W, ne += `
${z}`, ce = `,
${z}`);
              const Ce = Math.min(ee.length, k);
              let F = 0;
              for (; F < Ce - 1; F++) {
                const de = H(String(F), ee, I, B, W, z);
                ne += de !== void 0 ? de : "null", ne += ce;
              }
              const q = H(String(F), ee, I, B, W, z);
              if (ne += q !== void 0 ? q : "null", ee.length - 1 > k) {
                const de = ee.length - k - 1;
                ne += `${ce}"... ${b(de)} not stringified"`;
              }
              return W !== "" && (ne += `
${te}`), I.pop(), `[${ne}]`;
            }
            let fe = Object.keys(ee);
            const Y = fe.length;
            if (Y === 0)
              return "{}";
            if (O < I.length + 1)
              return '"[Object]"';
            let Z = "", ie = "";
            W !== "" && (z += W, ce = `,
${z}`, Z = " ");
            const me = Math.min(Y, k);
            D && !l(ee) && (fe = s(fe, U)), I.push(ee);
            for (let Ce = 0; Ce < me; Ce++) {
              const F = fe[Ce], q = H(F, ee, I, B, W, z);
              q !== void 0 && (ne += `${ie}${o(F)}:${Z}${q}`, ie = ce);
            }
            if (Y > k) {
              const Ce = Y - k;
              ne += `${ie}"...":${Z}"${b(Ce)} not stringified"`, ie = ce;
            }
            return W !== "" && ie.length > 1 && (ne = `
${z}${ne}
${te}`), I.pop(), `{${ne}}`;
          }
          case "number":
            return isFinite(ee) ? String(ee) : S ? S(ee) : "null";
          case "boolean":
            return ee === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (x)
              return String(ee);
          // fallthrough
          default:
            return S ? S(ee) : void 0;
        }
      }
      function V(K, P, I, B, W, z) {
        switch (typeof P == "object" && P !== null && typeof P.toJSON == "function" && (P = P.toJSON(K)), typeof P) {
          case "string":
            return o(P);
          case "object": {
            if (P === null)
              return "null";
            if (I.indexOf(P) !== -1)
              return A;
            const ee = z;
            let ne = "", ce = ",";
            if (Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (O < I.length + 1)
                return '"[Array]"';
              I.push(P), W !== "" && (z += W, ne += `
${z}`, ce = `,
${z}`);
              const Y = Math.min(P.length, k);
              let Z = 0;
              for (; Z < Y - 1; Z++) {
                const me = V(String(Z), P[Z], I, B, W, z);
                ne += me !== void 0 ? me : "null", ne += ce;
              }
              const ie = V(String(Z), P[Z], I, B, W, z);
              if (ne += ie !== void 0 ? ie : "null", P.length - 1 > k) {
                const me = P.length - k - 1;
                ne += `${ce}"... ${b(me)} not stringified"`;
              }
              return W !== "" && (ne += `
${ee}`), I.pop(), `[${ne}]`;
            }
            I.push(P);
            let te = "";
            W !== "" && (z += W, ce = `,
${z}`, te = " ");
            let fe = "";
            for (const Y of B) {
              const Z = V(Y, P[Y], I, B, W, z);
              Z !== void 0 && (ne += `${fe}${o(Y)}:${te}${Z}`, fe = ce);
            }
            return W !== "" && fe.length > 1 && (ne = `
${z}${ne}
${ee}`), I.pop(), `{${ne}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : S ? S(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (x)
              return String(P);
          // fallthrough
          default:
            return S ? S(P) : void 0;
        }
      }
      function N(K, P, I, B, W) {
        switch (typeof P) {
          case "string":
            return o(P);
          case "object": {
            if (P === null)
              return "null";
            if (typeof P.toJSON == "function") {
              if (P = P.toJSON(K), typeof P != "object")
                return N(K, P, I, B, W);
              if (P === null)
                return "null";
            }
            if (I.indexOf(P) !== -1)
              return A;
            const z = W;
            if (Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (O < I.length + 1)
                return '"[Array]"';
              I.push(P), W += B;
              let Z = `
${W}`;
              const ie = `,
${W}`, me = Math.min(P.length, k);
              let Ce = 0;
              for (; Ce < me - 1; Ce++) {
                const q = N(String(Ce), P[Ce], I, B, W);
                Z += q !== void 0 ? q : "null", Z += ie;
              }
              const F = N(String(Ce), P[Ce], I, B, W);
              if (Z += F !== void 0 ? F : "null", P.length - 1 > k) {
                const q = P.length - k - 1;
                Z += `${ie}"... ${b(q)} not stringified"`;
              }
              return Z += `
${z}`, I.pop(), `[${Z}]`;
            }
            let ee = Object.keys(P);
            const ne = ee.length;
            if (ne === 0)
              return "{}";
            if (O < I.length + 1)
              return '"[Object]"';
            W += B;
            const ce = `,
${W}`;
            let te = "", fe = "", Y = Math.min(ne, k);
            l(P) && (te += c(P, ce, k), ee = ee.slice(P.length), Y -= P.length, fe = ce), D && (ee = s(ee, U)), I.push(P);
            for (let Z = 0; Z < Y; Z++) {
              const ie = ee[Z], me = N(ie, P[ie], I, B, W);
              me !== void 0 && (te += `${fe}${o(ie)}: ${me}`, fe = ce);
            }
            if (ne > k) {
              const Z = ne - k;
              te += `${fe}"...": "${b(Z)} not stringified"`, fe = ce;
            }
            return fe !== "" && (te = `
${W}${te}
${z}`), I.pop(), `{${te}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : S ? S(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (x)
              return String(P);
          // fallthrough
          default:
            return S ? S(P) : void 0;
        }
      }
      function $(K, P, I) {
        switch (typeof P) {
          case "string":
            return o(P);
          case "object": {
            if (P === null)
              return "null";
            if (typeof P.toJSON == "function") {
              if (P = P.toJSON(K), typeof P != "object")
                return $(K, P, I);
              if (P === null)
                return "null";
            }
            if (I.indexOf(P) !== -1)
              return A;
            let B = "";
            const W = P.length !== void 0;
            if (W && Array.isArray(P)) {
              if (P.length === 0)
                return "[]";
              if (O < I.length + 1)
                return '"[Array]"';
              I.push(P);
              const te = Math.min(P.length, k);
              let fe = 0;
              for (; fe < te - 1; fe++) {
                const Z = $(String(fe), P[fe], I);
                B += Z !== void 0 ? Z : "null", B += ",";
              }
              const Y = $(String(fe), P[fe], I);
              if (B += Y !== void 0 ? Y : "null", P.length - 1 > k) {
                const Z = P.length - k - 1;
                B += `,"... ${b(Z)} not stringified"`;
              }
              return I.pop(), `[${B}]`;
            }
            let z = Object.keys(P);
            const ee = z.length;
            if (ee === 0)
              return "{}";
            if (O < I.length + 1)
              return '"[Object]"';
            let ne = "", ce = Math.min(ee, k);
            W && l(P) && (B += c(P, ",", k), z = z.slice(P.length), ce -= P.length, ne = ","), D && (z = s(z, U)), I.push(P);
            for (let te = 0; te < ce; te++) {
              const fe = z[te], Y = $(fe, P[fe], I);
              Y !== void 0 && (B += `${ne}${o(fe)}:${Y}`, ne = ",");
            }
            if (ee > k) {
              const te = ee - k;
              B += `${ne}"...":"${b(te)} not stringified"`;
            }
            return I.pop(), `{${B}}`;
          }
          case "number":
            return isFinite(P) ? String(P) : S ? S(P) : "null";
          case "boolean":
            return P === !0 ? "true" : "false";
          case "undefined":
            return;
          case "bigint":
            if (x)
              return String(P);
          // fallthrough
          default:
            return S ? S(P) : void 0;
        }
      }
      function j(K, P, I) {
        if (arguments.length > 1) {
          let B = "";
          if (typeof I == "number" ? B = " ".repeat(Math.min(I, 10)) : typeof I == "string" && (B = I.slice(0, 10)), P != null) {
            if (typeof P == "function")
              return H("", { "": K }, [], P, B, "");
            if (Array.isArray(P))
              return V("", K, [], _(P), B, "");
          }
          if (B.length !== 0)
            return N("", K, [], B, "");
        }
        return $("", K, []);
      }
      return j;
    }
  }(qa, qa.exports)), qa.exports;
}
var Df, G_;
function QV() {
  if (G_) return Df;
  G_ = 1;
  var r = cn(), t = bt(), e = t.MESSAGE, n = Rs();
  function i(o, s) {
    return typeof s == "bigint" ? s.toString() : s;
  }
  return Df = r(function(o, s) {
    var u = n.configure(s);
    return o[e] = u(o, s.replacer || i, s.space), o;
  }), Df;
}
var Ff, W_;
function XV() {
  if (W_) return Ff;
  W_ = 1;
  var r = cn();
  return Ff = r(function(t, e) {
    return e.message ? (t.message = "[".concat(e.label, "] ").concat(t.message), t) : (t.label = e.label, t);
  }), Ff;
}
var $f, K_;
function e5() {
  if (K_) return $f;
  K_ = 1;
  var r = cn(), t = bt(), e = t.MESSAGE, n = Rs();
  return $f = r(function(i) {
    var o = {};
    return i.message && (o["@message"] = i.message, delete i.message), i.timestamp && (o["@timestamp"] = i.timestamp, delete i.timestamp), o["@fields"] = i, i[e] = n(o), i;
  }), $f;
}
var Uf, J_;
function t5() {
  if (J_) return Uf;
  J_ = 1;
  function r(u) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, r(u);
  }
  function t(u, l, c) {
    return (l = e(l)) in u ? Object.defineProperty(u, l, { value: c, enumerable: !0, configurable: !0, writable: !0 }) : u[l] = c, u;
  }
  function e(u) {
    var l = n(u, "string");
    return r(l) == "symbol" ? l : l + "";
  }
  function n(u, l) {
    if (r(u) != "object" || !u) return u;
    var c = u[Symbol.toPrimitive];
    if (c !== void 0) {
      var d = c.call(u, l);
      if (r(d) != "object") return d;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (l === "string" ? String : Number)(u);
  }
  var i = cn();
  function o(u, l, c) {
    var d = l.reduce(function(y, w) {
      return y[w] = u[w], delete u[w], y;
    }, {}), g = Object.keys(u).reduce(function(y, w) {
      return y[w] = u[w], delete u[w], y;
    }, {});
    return Object.assign(u, d, t({}, c, g)), u;
  }
  function s(u, l, c) {
    return u[c] = l.reduce(function(d, g) {
      return d[g] = u[g], delete u[g], d;
    }, {}), u;
  }
  return Uf = i(function(u) {
    var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = "metadata";
    l.key && (c = l.key);
    var d = [];
    return !l.fillExcept && !l.fillWith && (d.push("level"), d.push("message")), l.fillExcept && (d = l.fillExcept), d.length > 0 ? o(u, d, c) : l.fillWith ? s(u, l.fillWith, c) : u;
  }), Uf;
}
var qf, z_;
function n5() {
  if (z_) return qf;
  z_ = 1;
  var r = 1e3, t = r * 60, e = t * 60, n = e * 24, i = n * 7, o = n * 365.25;
  qf = function(d, g) {
    g = g || {};
    var y = typeof d;
    if (y === "string" && d.length > 0)
      return s(d);
    if (y === "number" && isFinite(d))
      return g.long ? l(d) : u(d);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(d)
    );
  };
  function s(d) {
    if (d = String(d), !(d.length > 100)) {
      var g = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        d
      );
      if (g) {
        var y = parseFloat(g[1]), w = (g[2] || "ms").toLowerCase();
        switch (w) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return y * o;
          case "weeks":
          case "week":
          case "w":
            return y * i;
          case "days":
          case "day":
          case "d":
            return y * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return y * e;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return y * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return y * r;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return y;
          default:
            return;
        }
      }
    }
  }
  function u(d) {
    var g = Math.abs(d);
    return g >= n ? Math.round(d / n) + "d" : g >= e ? Math.round(d / e) + "h" : g >= t ? Math.round(d / t) + "m" : g >= r ? Math.round(d / r) + "s" : d + "ms";
  }
  function l(d) {
    var g = Math.abs(d);
    return g >= n ? c(d, g, n, "day") : g >= e ? c(d, g, e, "hour") : g >= t ? c(d, g, t, "minute") : g >= r ? c(d, g, r, "second") : d + " ms";
  }
  function c(d, g, y, w) {
    var b = g >= y * 1.5;
    return Math.round(d / y) + " " + w + (b ? "s" : "");
  }
  return qf;
}
var Bf, Y_;
function r5() {
  if (Y_) return Bf;
  Y_ = 1;
  var r = void 0, t = cn(), e = n5();
  return Bf = t(function(n) {
    var i = +/* @__PURE__ */ new Date();
    return r.diff = i - (r.prevTime || i), r.prevTime = i, n.ms = "+".concat(e(r.diff)), n;
  }), Bf;
}
var Vf, Z_;
function i5() {
  if (Z_) return Vf;
  Z_ = 1;
  var r = Jn.inspect, t = cn(), e = bt(), n = e.LEVEL, i = e.MESSAGE, o = e.SPLAT;
  return Vf = t(function(s) {
    var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = Object.assign({}, s);
    return delete l[n], delete l[i], delete l[o], s[i] = r(l, !1, u.depth || null, u.colorize), s;
  }), Vf;
}
var Zo = { exports: {} }, j_;
function o5() {
  if (j_) return Zo.exports;
  j_ = 1;
  function r(c) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
      return typeof d;
    } : function(d) {
      return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
    }, r(c);
  }
  function t(c, d) {
    if (!(c instanceof d)) throw new TypeError("Cannot call a class as a function");
  }
  function e(c, d) {
    for (var g = 0; g < d.length; g++) {
      var y = d[g];
      y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(c, i(y.key), y);
    }
  }
  function n(c, d, g) {
    return d && e(c.prototype, d), Object.defineProperty(c, "prototype", { writable: !1 }), c;
  }
  function i(c) {
    var d = o(c, "string");
    return r(d) == "symbol" ? d : d + "";
  }
  function o(c, d) {
    if (r(c) != "object" || !c) return c;
    var g = c[Symbol.toPrimitive];
    if (g !== void 0) {
      var y = g.call(c, d);
      if (r(y) != "object") return y;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(c);
  }
  var s = bt(), u = s.MESSAGE, l = /* @__PURE__ */ function() {
    function c(d) {
      t(this, c), this.template = d;
    }
    return n(c, [{
      key: "transform",
      value: function(g) {
        return g[u] = this.template(g), g;
      }
    }]);
  }();
  return Zo.exports = function(c) {
    return new l(c);
  }, Zo.exports.Printf = Zo.exports.Format = l, Zo.exports;
}
var Hf, Q_;
function s5() {
  if (Q_) return Hf;
  Q_ = 1;
  var r = cn(), t = bt(), e = t.MESSAGE, n = Rs();
  return Hf = r(function(i) {
    var o = n(Object.assign({}, i, {
      level: void 0,
      message: void 0,
      splat: void 0
    })), s = i.padding && i.padding[i.level] || "";
    return o !== "{}" ? i[e] = "".concat(i.level, ":").concat(s, " ").concat(i.message, " ").concat(o) : i[e] = "".concat(i.level, ":").concat(s, " ").concat(i.message), i;
  }), Hf;
}
var Gf, X_;
function a5() {
  if (X_) return Gf;
  X_ = 1;
  function r(T) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
      return typeof S;
    } : function(S) {
      return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
    }, r(T);
  }
  function t(T) {
    return o(T) || i(T) || n(T) || e();
  }
  function e() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function n(T, S) {
    if (T) {
      if (typeof T == "string") return s(T, S);
      var A = {}.toString.call(T).slice(8, -1);
      return A === "Object" && T.constructor && (A = T.constructor.name), A === "Map" || A === "Set" ? Array.from(T) : A === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(A) ? s(T, S) : void 0;
    }
  }
  function i(T) {
    if (typeof Symbol < "u" && T[Symbol.iterator] != null || T["@@iterator"] != null) return Array.from(T);
  }
  function o(T) {
    if (Array.isArray(T)) return s(T);
  }
  function s(T, S) {
    (S == null || S > T.length) && (S = T.length);
    for (var A = 0, x = Array(S); A < S; A++) x[A] = T[A];
    return x;
  }
  function u(T, S) {
    if (!(T instanceof S)) throw new TypeError("Cannot call a class as a function");
  }
  function l(T, S) {
    for (var A = 0; A < S.length; A++) {
      var x = S[A];
      x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(T, d(x.key), x);
    }
  }
  function c(T, S, A) {
    return S && l(T.prototype, S), Object.defineProperty(T, "prototype", { writable: !1 }), T;
  }
  function d(T) {
    var S = g(T, "string");
    return r(S) == "symbol" ? S : S + "";
  }
  function g(T, S) {
    if (r(T) != "object" || !T) return T;
    var A = T[Symbol.toPrimitive];
    if (A !== void 0) {
      var x = A.call(T, S);
      if (r(x) != "object") return x;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(T);
  }
  var y = Jn, w = bt(), b = w.SPLAT, _ = /%[scdjifoO%]/g, C = /%%/g, m = /* @__PURE__ */ function() {
    function T(S) {
      u(this, T), this.options = S;
    }
    return c(T, [{
      key: "_splat",
      value: function(A, x) {
        var D = A.message, U = A[b] || A.splat || [], O = D.match(C), k = O && O.length || 0, H = x.length - k, V = H - U.length, N = V < 0 ? U.splice(V, -1 * V) : [], $ = N.length;
        if ($)
          for (var j = 0; j < $; j++)
            Object.assign(A, N[j]);
        return A.message = y.format.apply(y, [D].concat(t(U))), A;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
    }, {
      key: "transform",
      value: function(A) {
        var x = A.message, D = A[b] || A.splat;
        if (!D || !D.length)
          return A;
        var U = x && x.match && x.match(_);
        if (!U && (D || D.length)) {
          var O = D.length > 1 ? D.splice(0) : D, k = O.length;
          if (k)
            for (var H = 0; H < k; H++)
              Object.assign(A, O[H]);
          return A;
        }
        return U ? this._splat(A, U) : A;
      }
    }]);
  }();
  return Gf = function(T) {
    return new m(T);
  }, Gf;
}
var TC = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g, Mr = "\\d\\d?", Ir = "\\d\\d", l5 = "\\d{3}", u5 = "\\d{4}", ds = "[^\\s]+", CC = /\[([^]*?)\]/gm;
function SC(r, t) {
  for (var e = [], n = 0, i = r.length; n < i; n++)
    e.push(r[n].substr(0, t));
  return e;
}
var e0 = function(r) {
  return function(t, e) {
    var n = e[r].map(function(o) {
      return o.toLowerCase();
    }), i = n.indexOf(t.toLowerCase());
    return i > -1 ? i : null;
  };
};
function Wr(r) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  for (var n = 0, i = t; n < i.length; n++) {
    var o = i[n];
    for (var s in o)
      r[s] = o[s];
  }
  return r;
}
var EC = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
], AC = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], c5 = SC(AC, 3), f5 = SC(EC, 3), Pp = {
  dayNamesShort: f5,
  dayNames: EC,
  monthNamesShort: c5,
  monthNames: AC,
  amPm: ["am", "pm"],
  DoFn: function(r) {
    return r + ["th", "st", "nd", "rd"][r % 10 > 3 ? 0 : (r - r % 10 !== 10 ? 1 : 0) * r % 10];
  }
}, jl = Wr({}, Pp), xC = function(r) {
  return jl = Wr(jl, r);
}, t0 = function(r) {
  return r.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
}, Jt = function(r, t) {
  for (t === void 0 && (t = 2), r = String(r); r.length < t; )
    r = "0" + r;
  return r;
}, d5 = {
  D: function(r) {
    return String(r.getDate());
  },
  DD: function(r) {
    return Jt(r.getDate());
  },
  Do: function(r, t) {
    return t.DoFn(r.getDate());
  },
  d: function(r) {
    return String(r.getDay());
  },
  dd: function(r) {
    return Jt(r.getDay());
  },
  ddd: function(r, t) {
    return t.dayNamesShort[r.getDay()];
  },
  dddd: function(r, t) {
    return t.dayNames[r.getDay()];
  },
  M: function(r) {
    return String(r.getMonth() + 1);
  },
  MM: function(r) {
    return Jt(r.getMonth() + 1);
  },
  MMM: function(r, t) {
    return t.monthNamesShort[r.getMonth()];
  },
  MMMM: function(r, t) {
    return t.monthNames[r.getMonth()];
  },
  YY: function(r) {
    return Jt(String(r.getFullYear()), 4).substr(2);
  },
  YYYY: function(r) {
    return Jt(r.getFullYear(), 4);
  },
  h: function(r) {
    return String(r.getHours() % 12 || 12);
  },
  hh: function(r) {
    return Jt(r.getHours() % 12 || 12);
  },
  H: function(r) {
    return String(r.getHours());
  },
  HH: function(r) {
    return Jt(r.getHours());
  },
  m: function(r) {
    return String(r.getMinutes());
  },
  mm: function(r) {
    return Jt(r.getMinutes());
  },
  s: function(r) {
    return String(r.getSeconds());
  },
  ss: function(r) {
    return Jt(r.getSeconds());
  },
  S: function(r) {
    return String(Math.round(r.getMilliseconds() / 100));
  },
  SS: function(r) {
    return Jt(Math.round(r.getMilliseconds() / 10), 2);
  },
  SSS: function(r) {
    return Jt(r.getMilliseconds(), 3);
  },
  a: function(r, t) {
    return r.getHours() < 12 ? t.amPm[0] : t.amPm[1];
  },
  A: function(r, t) {
    return r.getHours() < 12 ? t.amPm[0].toUpperCase() : t.amPm[1].toUpperCase();
  },
  ZZ: function(r) {
    var t = r.getTimezoneOffset();
    return (t > 0 ? "-" : "+") + Jt(Math.floor(Math.abs(t) / 60) * 100 + Math.abs(t) % 60, 4);
  },
  Z: function(r) {
    var t = r.getTimezoneOffset();
    return (t > 0 ? "-" : "+") + Jt(Math.floor(Math.abs(t) / 60), 2) + ":" + Jt(Math.abs(t) % 60, 2);
  }
}, n0 = function(r) {
  return +r - 1;
}, r0 = [null, Mr], i0 = [null, ds], o0 = [
  "isPm",
  ds,
  function(r, t) {
    var e = r.toLowerCase();
    return e === t.amPm[0] ? 0 : e === t.amPm[1] ? 1 : null;
  }
], s0 = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(r) {
    var t = (r + "").match(/([+-]|\d\d)/gi);
    if (t) {
      var e = +t[1] * 60 + parseInt(t[2], 10);
      return t[0] === "+" ? e : -e;
    }
    return 0;
  }
], h5 = {
  D: ["day", Mr],
  DD: ["day", Ir],
  Do: ["day", Mr + ds, function(r) {
    return parseInt(r, 10);
  }],
  M: ["month", Mr, n0],
  MM: ["month", Ir, n0],
  YY: [
    "year",
    Ir,
    function(r) {
      var t = /* @__PURE__ */ new Date(), e = +("" + t.getFullYear()).substr(0, 2);
      return +("" + (+r > 68 ? e - 1 : e) + r);
    }
  ],
  h: ["hour", Mr, void 0, "isPm"],
  hh: ["hour", Ir, void 0, "isPm"],
  H: ["hour", Mr],
  HH: ["hour", Ir],
  m: ["minute", Mr],
  mm: ["minute", Ir],
  s: ["second", Mr],
  ss: ["second", Ir],
  YYYY: ["year", u5],
  S: ["millisecond", "\\d", function(r) {
    return +r * 100;
  }],
  SS: ["millisecond", Ir, function(r) {
    return +r * 10;
  }],
  SSS: ["millisecond", l5],
  d: r0,
  dd: r0,
  ddd: i0,
  dddd: i0,
  MMM: ["month", ds, e0("monthNamesShort")],
  MMMM: ["month", ds, e0("monthNames")],
  a: o0,
  A: o0,
  ZZ: s0,
  Z: s0
}, Ql = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
}, RC = function(r) {
  return Wr(Ql, r);
}, IC = function(r, t, e) {
  if (t === void 0 && (t = Ql.default), e === void 0 && (e = {}), typeof r == "number" && (r = new Date(r)), Object.prototype.toString.call(r) !== "[object Date]" || isNaN(r.getTime()))
    throw new Error("Invalid Date pass to format");
  t = Ql[t] || t;
  var n = [];
  t = t.replace(CC, function(o, s) {
    return n.push(s), "@@@";
  });
  var i = Wr(Wr({}, jl), e);
  return t = t.replace(TC, function(o) {
    return d5[o](r, i);
  }), t.replace(/@@@/g, function() {
    return n.shift();
  });
};
function MC(r, t, e) {
  if (e === void 0 && (e = {}), typeof t != "string")
    throw new Error("Invalid format in fecha parse");
  if (t = Ql[t] || t, r.length > 1e3)
    return null;
  var n = /* @__PURE__ */ new Date(), i = {
    year: n.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  }, o = [], s = [], u = t.replace(CC, function(A, x) {
    return s.push(t0(x)), "@@@";
  }), l = {}, c = {};
  u = t0(u).replace(TC, function(A) {
    var x = h5[A], D = x[0], U = x[1], O = x[3];
    if (l[D])
      throw new Error("Invalid format. " + D + " specified twice in format");
    return l[D] = !0, O && (c[O] = !0), o.push(x), "(" + U + ")";
  }), Object.keys(c).forEach(function(A) {
    if (!l[A])
      throw new Error("Invalid format. " + A + " is required in specified format");
  }), u = u.replace(/@@@/g, function() {
    return s.shift();
  });
  var d = r.match(new RegExp(u, "i"));
  if (!d)
    return null;
  for (var g = Wr(Wr({}, jl), e), y = 1; y < d.length; y++) {
    var w = o[y - 1], b = w[0], _ = w[2], C = _ ? _(d[y], g) : +d[y];
    if (C == null)
      return null;
    i[b] = C;
  }
  i.isPm === 1 && i.hour != null && +i.hour != 12 ? i.hour = +i.hour + 12 : i.isPm === 0 && +i.hour == 12 && (i.hour = 0);
  var m;
  if (i.timezoneOffset == null) {
    m = new Date(i.year, i.month, i.day, i.hour, i.minute, i.second, i.millisecond);
    for (var T = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ], y = 0, S = T.length; y < S; y++)
      if (l[T[y][0]] && i[T[y][0]] !== m[T[y][1]]())
        return null;
  } else if (m = new Date(Date.UTC(i.year, i.month, i.day, i.hour, i.minute - i.timezoneOffset, i.second, i.millisecond)), i.month > 11 || i.month < 0 || i.day > 31 || i.day < 1 || i.hour > 23 || i.hour < 0 || i.minute > 59 || i.minute < 0 || i.second > 59 || i.second < 0)
    return null;
  return m;
}
var p5 = {
  format: IC,
  parse: MC,
  defaultI18n: Pp,
  setGlobalDateI18n: xC,
  setGlobalDateMasks: RC
};
const m5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assign: Wr,
  default: p5,
  defaultI18n: Pp,
  format: IC,
  parse: MC,
  setGlobalDateI18n: xC,
  setGlobalDateMasks: RC
}, Symbol.toStringTag, { value: "Module" })), g5 = /* @__PURE__ */ Lk(m5);
var Wf, a0;
function y5() {
  if (a0) return Wf;
  a0 = 1;
  var r = g5, t = cn();
  return Wf = t(function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return n.format && (e.timestamp = typeof n.format == "function" ? n.format() : r.format(/* @__PURE__ */ new Date(), n.format)), e.timestamp || (e.timestamp = (/* @__PURE__ */ new Date()).toISOString()), n.alias && (e[n.alias] = e.timestamp), e;
  }), Wf;
}
var Kf, l0;
function v5() {
  if (l0) return Kf;
  l0 = 1;
  var r = wC(), t = cn(), e = bt(), n = e.MESSAGE;
  return Kf = t(function(i, o) {
    return o.level !== !1 && (i.level = r.strip(i.level)), o.message !== !1 && (i.message = r.strip(String(i.message))), o.raw !== !1 && i[n] && (i[n] = r.strip(String(i[n]))), i;
  }), Kf;
}
var u0;
function kC() {
  if (u0) return La;
  u0 = 1;
  var r = La.format = cn();
  return La.levels = JV(), Object.defineProperty(r, "align", {
    value: zV()
  }), Object.defineProperty(r, "cli", {
    value: YV()
  }), Object.defineProperty(r, "colorize", {
    value: kp()
  }), Object.defineProperty(r, "combine", {
    value: ZV()
  }), Object.defineProperty(r, "errors", {
    value: jV()
  }), Object.defineProperty(r, "json", {
    value: QV()
  }), Object.defineProperty(r, "label", {
    value: XV()
  }), Object.defineProperty(r, "logstash", {
    value: e5()
  }), Object.defineProperty(r, "metadata", {
    value: t5()
  }), Object.defineProperty(r, "ms", {
    value: r5()
  }), Object.defineProperty(r, "padLevels", {
    value: bC()
  }), Object.defineProperty(r, "prettyPrint", {
    value: i5()
  }), Object.defineProperty(r, "printf", {
    value: o5()
  }), Object.defineProperty(r, "simple", {
    value: s5()
  }), Object.defineProperty(r, "splat", {
    value: a5()
  }), Object.defineProperty(r, "timestamp", {
    value: y5()
  }), Object.defineProperty(r, "uncolorize", {
    value: v5()
  }), La;
}
var Jf = {}, c0;
function PC() {
  return c0 || (c0 = 1, function(r) {
    var t = Jn, e = t.format;
    r.warn = {
      deprecated: function(i) {
        return function() {
          throw new Error(e("{ %s } was removed in winston@3.0.0.", i));
        };
      },
      useFormat: function(i) {
        return function() {
          throw new Error([e("{ %s } was removed in winston@3.0.0.", i), "Use a custom winston.format = winston.format(function) instead."].join(`
`));
        };
      },
      forFunctions: function(i, o, s) {
        s.forEach(function(u) {
          i[u] = r.warn[o](u);
        });
      },
      forProperties: function(i, o, s) {
        s.forEach(function(u) {
          var l = r.warn[o](u);
          Object.defineProperty(i, u, {
            get: l,
            set: l
          });
        });
      }
    };
  }(Jf)), Jf;
}
const _5 = "3.17.0", w5 = {
  version: _5
};
var zf = {}, Ba = { exports: {} }, Yf = { exports: {} }, Zf, f0;
function b5() {
  if (f0) return Zf;
  f0 = 1, Zf = r;
  function r(e, n) {
    if (t("noDeprecation"))
      return e;
    var i = !1;
    function o() {
      if (!i) {
        if (t("throwDeprecation"))
          throw new Error(n);
        t("traceDeprecation") ? console.trace(n) : console.warn(n), i = !0;
      }
      return e.apply(this, arguments);
    }
    return o;
  }
  function t(e) {
    try {
      if (!qn.localStorage) return !1;
    } catch {
      return !1;
    }
    var n = qn.localStorage[e];
    return n == null ? !1 : String(n).toLowerCase() === "true";
  }
  return Zf;
}
var jf, d0;
function OC() {
  return d0 || (d0 = 1, jf = ep.EventEmitter), jf;
}
var Qf, h0;
function LC() {
  if (h0) return Qf;
  h0 = 1;
  function r(s, u) {
    var l = this, c = this._readableState && this._readableState.destroyed, d = this._writableState && this._writableState.destroyed;
    return c || d ? (u ? u(s) : s && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(i, this, s)) : process.nextTick(i, this, s)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(s || null, function(g) {
      !u && g ? l._writableState ? l._writableState.errorEmitted ? process.nextTick(e, l) : (l._writableState.errorEmitted = !0, process.nextTick(t, l, g)) : process.nextTick(t, l, g) : u ? (process.nextTick(e, l), u(g)) : process.nextTick(e, l);
    }), this);
  }
  function t(s, u) {
    i(s, u), e(s);
  }
  function e(s) {
    s._writableState && !s._writableState.emitClose || s._readableState && !s._readableState.emitClose || s.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function i(s, u) {
    s.emit("error", u);
  }
  function o(s, u) {
    var l = s._readableState, c = s._writableState;
    l && l.autoDestroy || c && c.autoDestroy ? s.destroy(u) : s.emit("error", u);
  }
  return Qf = {
    destroy: r,
    undestroy: n,
    errorOrDestroy: o
  }, Qf;
}
var Xf = {}, p0;
function Eo() {
  if (p0) return Xf;
  p0 = 1;
  function r(u, l) {
    u.prototype = Object.create(l.prototype), u.prototype.constructor = u, u.__proto__ = l;
  }
  var t = {};
  function e(u, l, c) {
    c || (c = Error);
    function d(y, w, b) {
      return typeof l == "string" ? l : l(y, w, b);
    }
    var g = /* @__PURE__ */ function(y) {
      r(w, y);
      function w(b, _, C) {
        return y.call(this, d(b, _, C)) || this;
      }
      return w;
    }(c);
    g.prototype.name = c.name, g.prototype.code = u, t[u] = g;
  }
  function n(u, l) {
    if (Array.isArray(u)) {
      var c = u.length;
      return u = u.map(function(d) {
        return String(d);
      }), c > 2 ? "one of ".concat(l, " ").concat(u.slice(0, c - 1).join(", "), ", or ") + u[c - 1] : c === 2 ? "one of ".concat(l, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(l, " ").concat(u[0]);
    } else
      return "of ".concat(l, " ").concat(String(u));
  }
  function i(u, l, c) {
    return u.substr(0, l.length) === l;
  }
  function o(u, l, c) {
    return (c === void 0 || c > u.length) && (c = u.length), u.substring(c - l.length, c) === l;
  }
  function s(u, l, c) {
    return typeof c != "number" && (c = 0), c + l.length > u.length ? !1 : u.indexOf(l, c) !== -1;
  }
  return e("ERR_INVALID_OPT_VALUE", function(u, l) {
    return 'The value "' + l + '" is invalid for option "' + u + '"';
  }, TypeError), e("ERR_INVALID_ARG_TYPE", function(u, l, c) {
    var d;
    typeof l == "string" && i(l, "not ") ? (d = "must not be", l = l.replace(/^not /, "")) : d = "must be";
    var g;
    if (o(u, " argument"))
      g = "The ".concat(u, " ").concat(d, " ").concat(n(l, "type"));
    else {
      var y = s(u, ".") ? "property" : "argument";
      g = 'The "'.concat(u, '" ').concat(y, " ").concat(d, " ").concat(n(l, "type"));
    }
    return g += ". Received type ".concat(typeof c), g;
  }, TypeError), e("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), e("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
    return "The " + u + " method is not implemented";
  }), e("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), e("ERR_STREAM_DESTROYED", function(u) {
    return "Cannot call " + u + " after a stream was destroyed";
  }), e("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), e("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), e("ERR_STREAM_WRITE_AFTER_END", "write after end"), e("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), e("ERR_UNKNOWN_ENCODING", function(u) {
    return "Unknown encoding: " + u;
  }, TypeError), e("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Xf.codes = t, Xf;
}
var ed, m0;
function NC() {
  if (m0) return ed;
  m0 = 1;
  var r = Eo().codes.ERR_INVALID_OPT_VALUE;
  function t(n, i, o) {
    return n.highWaterMark != null ? n.highWaterMark : i ? n[o] : null;
  }
  function e(n, i, o, s) {
    var u = t(i, s, o);
    if (u != null) {
      if (!(isFinite(u) && Math.floor(u) === u) || u < 0) {
        var l = s ? o : "highWaterMark";
        throw new r(l, u);
      }
      return Math.floor(u);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return ed = {
    getHighWaterMark: e
  }, ed;
}
var Va = { exports: {} }, g0;
function Is() {
  return g0 || (g0 = 1, typeof Object.create == "function" ? Va.exports = function(t, e) {
    e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Va.exports = function(t, e) {
    if (e) {
      t.super_ = e;
      var n = function() {
      };
      n.prototype = e.prototype, t.prototype = new n(), t.prototype.constructor = t;
    }
  }), Va.exports;
}
var td, y0;
function T5() {
  if (y0) return td;
  y0 = 1;
  function r(b, _) {
    var C = Object.keys(b);
    if (Object.getOwnPropertySymbols) {
      var m = Object.getOwnPropertySymbols(b);
      _ && (m = m.filter(function(T) {
        return Object.getOwnPropertyDescriptor(b, T).enumerable;
      })), C.push.apply(C, m);
    }
    return C;
  }
  function t(b) {
    for (var _ = 1; _ < arguments.length; _++) {
      var C = arguments[_] != null ? arguments[_] : {};
      _ % 2 ? r(Object(C), !0).forEach(function(m) {
        e(b, m, C[m]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(C)) : r(Object(C)).forEach(function(m) {
        Object.defineProperty(b, m, Object.getOwnPropertyDescriptor(C, m));
      });
    }
    return b;
  }
  function e(b, _, C) {
    return _ = s(_), _ in b ? Object.defineProperty(b, _, { value: C, enumerable: !0, configurable: !0, writable: !0 }) : b[_] = C, b;
  }
  function n(b, _) {
    if (!(b instanceof _))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(b, _) {
    for (var C = 0; C < _.length; C++) {
      var m = _[C];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(b, s(m.key), m);
    }
  }
  function o(b, _, C) {
    return _ && i(b.prototype, _), Object.defineProperty(b, "prototype", { writable: !1 }), b;
  }
  function s(b) {
    var _ = u(b, "string");
    return typeof _ == "symbol" ? _ : String(_);
  }
  function u(b, _) {
    if (typeof b != "object" || b === null) return b;
    var C = b[Symbol.toPrimitive];
    if (C !== void 0) {
      var m = C.call(b, _);
      if (typeof m != "object") return m;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(b);
  }
  var l = ru, c = l.Buffer, d = Jn, g = d.inspect, y = g && g.custom || "inspect";
  function w(b, _, C) {
    c.prototype.copy.call(b, _, C);
  }
  return td = /* @__PURE__ */ function() {
    function b() {
      n(this, b), this.head = null, this.tail = null, this.length = 0;
    }
    return o(b, [{
      key: "push",
      value: function(C) {
        var m = {
          data: C,
          next: null
        };
        this.length > 0 ? this.tail.next = m : this.head = m, this.tail = m, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(C) {
        var m = {
          data: C,
          next: this.head
        };
        this.length === 0 && (this.tail = m), this.head = m, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var C = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, C;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(C) {
        if (this.length === 0) return "";
        for (var m = this.head, T = "" + m.data; m = m.next; ) T += C + m.data;
        return T;
      }
    }, {
      key: "concat",
      value: function(C) {
        if (this.length === 0) return c.alloc(0);
        for (var m = c.allocUnsafe(C >>> 0), T = this.head, S = 0; T; )
          w(T.data, m, S), S += T.data.length, T = T.next;
        return m;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(C, m) {
        var T;
        return C < this.head.data.length ? (T = this.head.data.slice(0, C), this.head.data = this.head.data.slice(C)) : C === this.head.data.length ? T = this.shift() : T = m ? this._getString(C) : this._getBuffer(C), T;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(C) {
        var m = this.head, T = 1, S = m.data;
        for (C -= S.length; m = m.next; ) {
          var A = m.data, x = C > A.length ? A.length : C;
          if (x === A.length ? S += A : S += A.slice(0, C), C -= x, C === 0) {
            x === A.length ? (++T, m.next ? this.head = m.next : this.head = this.tail = null) : (this.head = m, m.data = A.slice(x));
            break;
          }
          ++T;
        }
        return this.length -= T, S;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(C) {
        var m = c.allocUnsafe(C), T = this.head, S = 1;
        for (T.data.copy(m), C -= T.data.length; T = T.next; ) {
          var A = T.data, x = C > A.length ? A.length : C;
          if (A.copy(m, m.length - C, 0, x), C -= x, C === 0) {
            x === A.length ? (++S, T.next ? this.head = T.next : this.head = this.tail = null) : (this.head = T, T.data = A.slice(x));
            break;
          }
          ++S;
        }
        return this.length -= S, m;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: y,
      value: function(C, m) {
        return g(this, t(t({}, m), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), b;
  }(), td;
}
var nd = {}, Ha = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var v0;
function C5() {
  return v0 || (v0 = 1, function(r, t) {
    var e = ru, n = e.Buffer;
    function i(s, u) {
      for (var l in s)
        u[l] = s[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? r.exports = e : (i(e, t), t.Buffer = o);
    function o(s, u, l) {
      return n(s, u, l);
    }
    o.prototype = Object.create(n.prototype), i(n, o), o.from = function(s, u, l) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return n(s, u, l);
    }, o.alloc = function(s, u, l) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var c = n(s);
      return u !== void 0 ? typeof l == "string" ? c.fill(u, l) : c.fill(u) : c.fill(0), c;
    }, o.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n(s);
    }, o.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return e.SlowBuffer(s);
    };
  }(Ha, Ha.exports)), Ha.exports;
}
var _0;
function w0() {
  if (_0) return nd;
  _0 = 1;
  var r = C5().Buffer, t = r.isEncoding || function(m) {
    switch (m = "" + m, m && m.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function e(m) {
    if (!m) return "utf8";
    for (var T; ; )
      switch (m) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return m;
        default:
          if (T) return;
          m = ("" + m).toLowerCase(), T = !0;
      }
  }
  function n(m) {
    var T = e(m);
    if (typeof T != "string" && (r.isEncoding === t || !t(m))) throw new Error("Unknown encoding: " + m);
    return T || m;
  }
  nd.StringDecoder = i;
  function i(m) {
    this.encoding = n(m);
    var T;
    switch (this.encoding) {
      case "utf16le":
        this.text = g, this.end = y, T = 4;
        break;
      case "utf8":
        this.fillLast = l, T = 4;
        break;
      case "base64":
        this.text = w, this.end = b, T = 3;
        break;
      default:
        this.write = _, this.end = C;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(T);
  }
  i.prototype.write = function(m) {
    if (m.length === 0) return "";
    var T, S;
    if (this.lastNeed) {
      if (T = this.fillLast(m), T === void 0) return "";
      S = this.lastNeed, this.lastNeed = 0;
    } else
      S = 0;
    return S < m.length ? T ? T + this.text(m, S) : this.text(m, S) : T || "";
  }, i.prototype.end = d, i.prototype.text = c, i.prototype.fillLast = function(m) {
    if (this.lastNeed <= m.length)
      return m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    m.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, m.length), this.lastNeed -= m.length;
  };
  function o(m) {
    return m <= 127 ? 0 : m >> 5 === 6 ? 2 : m >> 4 === 14 ? 3 : m >> 3 === 30 ? 4 : m >> 6 === 2 ? -1 : -2;
  }
  function s(m, T, S) {
    var A = T.length - 1;
    if (A < S) return 0;
    var x = o(T[A]);
    return x >= 0 ? (x > 0 && (m.lastNeed = x - 1), x) : --A < S || x === -2 ? 0 : (x = o(T[A]), x >= 0 ? (x > 0 && (m.lastNeed = x - 2), x) : --A < S || x === -2 ? 0 : (x = o(T[A]), x >= 0 ? (x > 0 && (x === 2 ? x = 0 : m.lastNeed = x - 3), x) : 0));
  }
  function u(m, T, S) {
    if ((T[0] & 192) !== 128)
      return m.lastNeed = 0, "";
    if (m.lastNeed > 1 && T.length > 1) {
      if ((T[1] & 192) !== 128)
        return m.lastNeed = 1, "";
      if (m.lastNeed > 2 && T.length > 2 && (T[2] & 192) !== 128)
        return m.lastNeed = 2, "";
    }
  }
  function l(m) {
    var T = this.lastTotal - this.lastNeed, S = u(this, m);
    if (S !== void 0) return S;
    if (this.lastNeed <= m.length)
      return m.copy(this.lastChar, T, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    m.copy(this.lastChar, T, 0, m.length), this.lastNeed -= m.length;
  }
  function c(m, T) {
    var S = s(this, m, T);
    if (!this.lastNeed) return m.toString("utf8", T);
    this.lastTotal = S;
    var A = m.length - (S - this.lastNeed);
    return m.copy(this.lastChar, 0, A), m.toString("utf8", T, A);
  }
  function d(m) {
    var T = m && m.length ? this.write(m) : "";
    return this.lastNeed ? T + "" : T;
  }
  function g(m, T) {
    if ((m.length - T) % 2 === 0) {
      var S = m.toString("utf16le", T);
      if (S) {
        var A = S.charCodeAt(S.length - 1);
        if (A >= 55296 && A <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = m[m.length - 2], this.lastChar[1] = m[m.length - 1], S.slice(0, -1);
      }
      return S;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = m[m.length - 1], m.toString("utf16le", T, m.length - 1);
  }
  function y(m) {
    var T = m && m.length ? this.write(m) : "";
    if (this.lastNeed) {
      var S = this.lastTotal - this.lastNeed;
      return T + this.lastChar.toString("utf16le", 0, S);
    }
    return T;
  }
  function w(m, T) {
    var S = (m.length - T) % 3;
    return S === 0 ? m.toString("base64", T) : (this.lastNeed = 3 - S, this.lastTotal = 3, S === 1 ? this.lastChar[0] = m[m.length - 1] : (this.lastChar[0] = m[m.length - 2], this.lastChar[1] = m[m.length - 1]), m.toString("base64", T, m.length - S));
  }
  function b(m) {
    var T = m && m.length ? this.write(m) : "";
    return this.lastNeed ? T + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : T;
  }
  function _(m) {
    return m.toString(this.encoding);
  }
  function C(m) {
    return m && m.length ? this.write(m) : "";
  }
  return nd;
}
var rd, b0;
function Op() {
  if (b0) return rd;
  b0 = 1;
  var r = Eo().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(o) {
    var s = !1;
    return function() {
      if (!s) {
        s = !0;
        for (var u = arguments.length, l = new Array(u), c = 0; c < u; c++)
          l[c] = arguments[c];
        o.apply(this, l);
      }
    };
  }
  function e() {
  }
  function n(o) {
    return o.setHeader && typeof o.abort == "function";
  }
  function i(o, s, u) {
    if (typeof s == "function") return i(o, null, s);
    s || (s = {}), u = t(u || e);
    var l = s.readable || s.readable !== !1 && o.readable, c = s.writable || s.writable !== !1 && o.writable, d = function() {
      o.writable || y();
    }, g = o._writableState && o._writableState.finished, y = function() {
      c = !1, g = !0, l || u.call(o);
    }, w = o._readableState && o._readableState.endEmitted, b = function() {
      l = !1, w = !0, c || u.call(o);
    }, _ = function(S) {
      u.call(o, S);
    }, C = function() {
      var S;
      if (l && !w)
        return (!o._readableState || !o._readableState.ended) && (S = new r()), u.call(o, S);
      if (c && !g)
        return (!o._writableState || !o._writableState.ended) && (S = new r()), u.call(o, S);
    }, m = function() {
      o.req.on("finish", y);
    };
    return n(o) ? (o.on("complete", y), o.on("abort", C), o.req ? m() : o.on("request", m)) : c && !o._writableState && (o.on("end", d), o.on("close", d)), o.on("end", b), o.on("finish", y), s.error !== !1 && o.on("error", _), o.on("close", C), function() {
      o.removeListener("complete", y), o.removeListener("abort", C), o.removeListener("request", m), o.req && o.req.removeListener("finish", y), o.removeListener("end", d), o.removeListener("close", d), o.removeListener("finish", y), o.removeListener("end", b), o.removeListener("error", _), o.removeListener("close", C);
    };
  }
  return rd = i, rd;
}
var id, T0;
function S5() {
  if (T0) return id;
  T0 = 1;
  var r;
  function t(S, A, x) {
    return A = e(A), A in S ? Object.defineProperty(S, A, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : S[A] = x, S;
  }
  function e(S) {
    var A = n(S, "string");
    return typeof A == "symbol" ? A : String(A);
  }
  function n(S, A) {
    if (typeof S != "object" || S === null) return S;
    var x = S[Symbol.toPrimitive];
    if (x !== void 0) {
      var D = x.call(S, A);
      if (typeof D != "object") return D;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (A === "string" ? String : Number)(S);
  }
  var i = Op(), o = Symbol("lastResolve"), s = Symbol("lastReject"), u = Symbol("error"), l = Symbol("ended"), c = Symbol("lastPromise"), d = Symbol("handlePromise"), g = Symbol("stream");
  function y(S, A) {
    return {
      value: S,
      done: A
    };
  }
  function w(S) {
    var A = S[o];
    if (A !== null) {
      var x = S[g].read();
      x !== null && (S[c] = null, S[o] = null, S[s] = null, A(y(x, !1)));
    }
  }
  function b(S) {
    process.nextTick(w, S);
  }
  function _(S, A) {
    return function(x, D) {
      S.then(function() {
        if (A[l]) {
          x(y(void 0, !0));
          return;
        }
        A[d](x, D);
      }, D);
    };
  }
  var C = Object.getPrototypeOf(function() {
  }), m = Object.setPrototypeOf((r = {
    get stream() {
      return this[g];
    },
    next: function() {
      var A = this, x = this[u];
      if (x !== null)
        return Promise.reject(x);
      if (this[l])
        return Promise.resolve(y(void 0, !0));
      if (this[g].destroyed)
        return new Promise(function(k, H) {
          process.nextTick(function() {
            A[u] ? H(A[u]) : k(y(void 0, !0));
          });
        });
      var D = this[c], U;
      if (D)
        U = new Promise(_(D, this));
      else {
        var O = this[g].read();
        if (O !== null)
          return Promise.resolve(y(O, !1));
        U = new Promise(this[d]);
      }
      return this[c] = U, U;
    }
  }, t(r, Symbol.asyncIterator, function() {
    return this;
  }), t(r, "return", function() {
    var A = this;
    return new Promise(function(x, D) {
      A[g].destroy(null, function(U) {
        if (U) {
          D(U);
          return;
        }
        x(y(void 0, !0));
      });
    });
  }), r), C), T = function(A) {
    var x, D = Object.create(m, (x = {}, t(x, g, {
      value: A,
      writable: !0
    }), t(x, o, {
      value: null,
      writable: !0
    }), t(x, s, {
      value: null,
      writable: !0
    }), t(x, u, {
      value: null,
      writable: !0
    }), t(x, l, {
      value: A._readableState.endEmitted,
      writable: !0
    }), t(x, d, {
      value: function(O, k) {
        var H = D[g].read();
        H ? (D[c] = null, D[o] = null, D[s] = null, O(y(H, !1))) : (D[o] = O, D[s] = k);
      },
      writable: !0
    }), x));
    return D[c] = null, i(A, function(U) {
      if (U && U.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var O = D[s];
        O !== null && (D[c] = null, D[o] = null, D[s] = null, O(U)), D[u] = U;
        return;
      }
      var k = D[o];
      k !== null && (D[c] = null, D[o] = null, D[s] = null, k(y(void 0, !0))), D[l] = !0;
    }), A.on("readable", b.bind(null, D)), D;
  };
  return id = T, id;
}
var od, C0;
function E5() {
  return C0 || (C0 = 1, od = function() {
    throw new Error("Readable.from is not available in the browser");
  }), od;
}
var sd, S0;
function DC() {
  if (S0) return sd;
  S0 = 1, sd = k;
  var r;
  k.ReadableState = O, ep.EventEmitter;
  var t = function(q, de) {
    return q.listeners(de).length;
  }, e = OC(), n = ru.Buffer, i = (typeof qn < "u" ? qn : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(F) {
    return n.from(F);
  }
  function s(F) {
    return n.isBuffer(F) || F instanceof i;
  }
  var u = Jn, l;
  u && u.debuglog ? l = u.debuglog("stream") : l = function() {
  };
  var c = T5(), d = LC(), g = NC(), y = g.getHighWaterMark, w = Eo().codes, b = w.ERR_INVALID_ARG_TYPE, _ = w.ERR_STREAM_PUSH_AFTER_EOF, C = w.ERR_METHOD_NOT_IMPLEMENTED, m = w.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, T, S, A;
  Is()(k, e);
  var x = d.errorOrDestroy, D = ["error", "close", "destroy", "pause", "resume"];
  function U(F, q, de) {
    if (typeof F.prependListener == "function") return F.prependListener(q, de);
    !F._events || !F._events[q] ? F.on(q, de) : Array.isArray(F._events[q]) ? F._events[q].unshift(de) : F._events[q] = [de, F._events[q]];
  }
  function O(F, q, de) {
    r = r || yo(), F = F || {}, typeof de != "boolean" && (de = q instanceof r), this.objectMode = !!F.objectMode, de && (this.objectMode = this.objectMode || !!F.readableObjectMode), this.highWaterMark = y(this, F, "readableHighWaterMark", de), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = F.emitClose !== !1, this.autoDestroy = !!F.autoDestroy, this.destroyed = !1, this.defaultEncoding = F.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, F.encoding && (T || (T = w0().StringDecoder), this.decoder = new T(F.encoding), this.encoding = F.encoding);
  }
  function k(F) {
    if (r = r || yo(), !(this instanceof k)) return new k(F);
    var q = this instanceof r;
    this._readableState = new O(F, this, q), this.readable = !0, F && (typeof F.read == "function" && (this._read = F.read), typeof F.destroy == "function" && (this._destroy = F.destroy)), e.call(this);
  }
  Object.defineProperty(k.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(q) {
      this._readableState && (this._readableState.destroyed = q);
    }
  }), k.prototype.destroy = d.destroy, k.prototype._undestroy = d.undestroy, k.prototype._destroy = function(F, q) {
    q(F);
  }, k.prototype.push = function(F, q) {
    var de = this._readableState, ye;
    return de.objectMode ? ye = !0 : typeof F == "string" && (q = q || de.defaultEncoding, q !== de.encoding && (F = n.from(F, q), q = ""), ye = !0), H(this, F, q, !1, ye);
  }, k.prototype.unshift = function(F) {
    return H(this, F, null, !0, !1);
  };
  function H(F, q, de, ye, nt) {
    l("readableAddChunk", q);
    var $e = F._readableState;
    if (q === null)
      $e.reading = !1, P(F, $e);
    else {
      var Ve;
      if (nt || (Ve = N($e, q)), Ve)
        x(F, Ve);
      else if ($e.objectMode || q && q.length > 0)
        if (typeof q != "string" && !$e.objectMode && Object.getPrototypeOf(q) !== n.prototype && (q = o(q)), ye)
          $e.endEmitted ? x(F, new m()) : V(F, $e, q, !0);
        else if ($e.ended)
          x(F, new _());
        else {
          if ($e.destroyed)
            return !1;
          $e.reading = !1, $e.decoder && !de ? (q = $e.decoder.write(q), $e.objectMode || q.length !== 0 ? V(F, $e, q, !1) : W(F, $e)) : V(F, $e, q, !1);
        }
      else ye || ($e.reading = !1, W(F, $e));
    }
    return !$e.ended && ($e.length < $e.highWaterMark || $e.length === 0);
  }
  function V(F, q, de, ye) {
    q.flowing && q.length === 0 && !q.sync ? (q.awaitDrain = 0, F.emit("data", de)) : (q.length += q.objectMode ? 1 : de.length, ye ? q.buffer.unshift(de) : q.buffer.push(de), q.needReadable && I(F)), W(F, q);
  }
  function N(F, q) {
    var de;
    return !s(q) && typeof q != "string" && q !== void 0 && !F.objectMode && (de = new b("chunk", ["string", "Buffer", "Uint8Array"], q)), de;
  }
  k.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, k.prototype.setEncoding = function(F) {
    T || (T = w0().StringDecoder);
    var q = new T(F);
    this._readableState.decoder = q, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var de = this._readableState.buffer.head, ye = ""; de !== null; )
      ye += q.write(de.data), de = de.next;
    return this._readableState.buffer.clear(), ye !== "" && this._readableState.buffer.push(ye), this._readableState.length = ye.length, this;
  };
  var $ = 1073741824;
  function j(F) {
    return F >= $ ? F = $ : (F--, F |= F >>> 1, F |= F >>> 2, F |= F >>> 4, F |= F >>> 8, F |= F >>> 16, F++), F;
  }
  function K(F, q) {
    return F <= 0 || q.length === 0 && q.ended ? 0 : q.objectMode ? 1 : F !== F ? q.flowing && q.length ? q.buffer.head.data.length : q.length : (F > q.highWaterMark && (q.highWaterMark = j(F)), F <= q.length ? F : q.ended ? q.length : (q.needReadable = !0, 0));
  }
  k.prototype.read = function(F) {
    l("read", F), F = parseInt(F, 10);
    var q = this._readableState, de = F;
    if (F !== 0 && (q.emittedReadable = !1), F === 0 && q.needReadable && ((q.highWaterMark !== 0 ? q.length >= q.highWaterMark : q.length > 0) || q.ended))
      return l("read: emitReadable", q.length, q.ended), q.length === 0 && q.ended ? ie(this) : I(this), null;
    if (F = K(F, q), F === 0 && q.ended)
      return q.length === 0 && ie(this), null;
    var ye = q.needReadable;
    l("need readable", ye), (q.length === 0 || q.length - F < q.highWaterMark) && (ye = !0, l("length less than watermark", ye)), q.ended || q.reading ? (ye = !1, l("reading or ended", ye)) : ye && (l("do read"), q.reading = !0, q.sync = !0, q.length === 0 && (q.needReadable = !0), this._read(q.highWaterMark), q.sync = !1, q.reading || (F = K(de, q)));
    var nt;
    return F > 0 ? nt = Z(F, q) : nt = null, nt === null ? (q.needReadable = q.length <= q.highWaterMark, F = 0) : (q.length -= F, q.awaitDrain = 0), q.length === 0 && (q.ended || (q.needReadable = !0), de !== F && q.ended && ie(this)), nt !== null && this.emit("data", nt), nt;
  };
  function P(F, q) {
    if (l("onEofChunk"), !q.ended) {
      if (q.decoder) {
        var de = q.decoder.end();
        de && de.length && (q.buffer.push(de), q.length += q.objectMode ? 1 : de.length);
      }
      q.ended = !0, q.sync ? I(F) : (q.needReadable = !1, q.emittedReadable || (q.emittedReadable = !0, B(F)));
    }
  }
  function I(F) {
    var q = F._readableState;
    l("emitReadable", q.needReadable, q.emittedReadable), q.needReadable = !1, q.emittedReadable || (l("emitReadable", q.flowing), q.emittedReadable = !0, process.nextTick(B, F));
  }
  function B(F) {
    var q = F._readableState;
    l("emitReadable_", q.destroyed, q.length, q.ended), !q.destroyed && (q.length || q.ended) && (F.emit("readable"), q.emittedReadable = !1), q.needReadable = !q.flowing && !q.ended && q.length <= q.highWaterMark, Y(F);
  }
  function W(F, q) {
    q.readingMore || (q.readingMore = !0, process.nextTick(z, F, q));
  }
  function z(F, q) {
    for (; !q.reading && !q.ended && (q.length < q.highWaterMark || q.flowing && q.length === 0); ) {
      var de = q.length;
      if (l("maybeReadMore read 0"), F.read(0), de === q.length)
        break;
    }
    q.readingMore = !1;
  }
  k.prototype._read = function(F) {
    x(this, new C("_read()"));
  }, k.prototype.pipe = function(F, q) {
    var de = this, ye = this._readableState;
    switch (ye.pipesCount) {
      case 0:
        ye.pipes = F;
        break;
      case 1:
        ye.pipes = [ye.pipes, F];
        break;
      default:
        ye.pipes.push(F);
        break;
    }
    ye.pipesCount += 1, l("pipe count=%d opts=%j", ye.pipesCount, q);
    var nt = (!q || q.end !== !1) && F !== process.stdout && F !== process.stderr, $e = nt ? Sn : zr;
    ye.endEmitted ? process.nextTick($e) : de.once("end", $e), F.on("unpipe", Ve);
    function Ve(fn, Qt) {
      l("onunpipe"), fn === de && Qt && Qt.hasUnpiped === !1 && (Qt.hasUnpiped = !0, jt());
    }
    function Sn() {
      l("onend"), F.end();
    }
    var Si = ee(de);
    F.on("drain", Si);
    var yr = !1;
    function jt() {
      l("cleanup"), F.removeListener("close", Ro), F.removeListener("finish", Yn), F.removeListener("drain", Si), F.removeListener("error", _r), F.removeListener("unpipe", Ve), de.removeListener("end", Sn), de.removeListener("end", zr), de.removeListener("data", vr), yr = !0, ye.awaitDrain && (!F._writableState || F._writableState.needDrain) && Si();
    }
    de.on("data", vr);
    function vr(fn) {
      l("ondata");
      var Qt = F.write(fn);
      l("dest.write", Qt), Qt === !1 && ((ye.pipesCount === 1 && ye.pipes === F || ye.pipesCount > 1 && Ce(ye.pipes, F) !== -1) && !yr && (l("false write response, pause", ye.awaitDrain), ye.awaitDrain++), de.pause());
    }
    function _r(fn) {
      l("onerror", fn), zr(), F.removeListener("error", _r), t(F, "error") === 0 && x(F, fn);
    }
    U(F, "error", _r);
    function Ro() {
      F.removeListener("finish", Yn), zr();
    }
    F.once("close", Ro);
    function Yn() {
      l("onfinish"), F.removeListener("close", Ro), zr();
    }
    F.once("finish", Yn);
    function zr() {
      l("unpipe"), de.unpipe(F);
    }
    return F.emit("pipe", de), ye.flowing || (l("pipe resume"), de.resume()), F;
  };
  function ee(F) {
    return function() {
      var de = F._readableState;
      l("pipeOnDrain", de.awaitDrain), de.awaitDrain && de.awaitDrain--, de.awaitDrain === 0 && t(F, "data") && (de.flowing = !0, Y(F));
    };
  }
  k.prototype.unpipe = function(F) {
    var q = this._readableState, de = {
      hasUnpiped: !1
    };
    if (q.pipesCount === 0) return this;
    if (q.pipesCount === 1)
      return F && F !== q.pipes ? this : (F || (F = q.pipes), q.pipes = null, q.pipesCount = 0, q.flowing = !1, F && F.emit("unpipe", this, de), this);
    if (!F) {
      var ye = q.pipes, nt = q.pipesCount;
      q.pipes = null, q.pipesCount = 0, q.flowing = !1;
      for (var $e = 0; $e < nt; $e++) ye[$e].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Ve = Ce(q.pipes, F);
    return Ve === -1 ? this : (q.pipes.splice(Ve, 1), q.pipesCount -= 1, q.pipesCount === 1 && (q.pipes = q.pipes[0]), F.emit("unpipe", this, de), this);
  }, k.prototype.on = function(F, q) {
    var de = e.prototype.on.call(this, F, q), ye = this._readableState;
    return F === "data" ? (ye.readableListening = this.listenerCount("readable") > 0, ye.flowing !== !1 && this.resume()) : F === "readable" && !ye.endEmitted && !ye.readableListening && (ye.readableListening = ye.needReadable = !0, ye.flowing = !1, ye.emittedReadable = !1, l("on readable", ye.length, ye.reading), ye.length ? I(this) : ye.reading || process.nextTick(ce, this)), de;
  }, k.prototype.addListener = k.prototype.on, k.prototype.removeListener = function(F, q) {
    var de = e.prototype.removeListener.call(this, F, q);
    return F === "readable" && process.nextTick(ne, this), de;
  }, k.prototype.removeAllListeners = function(F) {
    var q = e.prototype.removeAllListeners.apply(this, arguments);
    return (F === "readable" || F === void 0) && process.nextTick(ne, this), q;
  };
  function ne(F) {
    var q = F._readableState;
    q.readableListening = F.listenerCount("readable") > 0, q.resumeScheduled && !q.paused ? q.flowing = !0 : F.listenerCount("data") > 0 && F.resume();
  }
  function ce(F) {
    l("readable nexttick read 0"), F.read(0);
  }
  k.prototype.resume = function() {
    var F = this._readableState;
    return F.flowing || (l("resume"), F.flowing = !F.readableListening, te(this, F)), F.paused = !1, this;
  };
  function te(F, q) {
    q.resumeScheduled || (q.resumeScheduled = !0, process.nextTick(fe, F, q));
  }
  function fe(F, q) {
    l("resume", q.reading), q.reading || F.read(0), q.resumeScheduled = !1, F.emit("resume"), Y(F), q.flowing && !q.reading && F.read(0);
  }
  k.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Y(F) {
    var q = F._readableState;
    for (l("flow", q.flowing); q.flowing && F.read() !== null; ) ;
  }
  k.prototype.wrap = function(F) {
    var q = this, de = this._readableState, ye = !1;
    F.on("end", function() {
      if (l("wrapped end"), de.decoder && !de.ended) {
        var Ve = de.decoder.end();
        Ve && Ve.length && q.push(Ve);
      }
      q.push(null);
    }), F.on("data", function(Ve) {
      if (l("wrapped data"), de.decoder && (Ve = de.decoder.write(Ve)), !(de.objectMode && Ve == null) && !(!de.objectMode && (!Ve || !Ve.length))) {
        var Sn = q.push(Ve);
        Sn || (ye = !0, F.pause());
      }
    });
    for (var nt in F)
      this[nt] === void 0 && typeof F[nt] == "function" && (this[nt] = /* @__PURE__ */ function(Sn) {
        return function() {
          return F[Sn].apply(F, arguments);
        };
      }(nt));
    for (var $e = 0; $e < D.length; $e++)
      F.on(D[$e], this.emit.bind(this, D[$e]));
    return this._read = function(Ve) {
      l("wrapped _read", Ve), ye && (ye = !1, F.resume());
    }, this;
  }, typeof Symbol == "function" && (k.prototype[Symbol.asyncIterator] = function() {
    return S === void 0 && (S = S5()), S(this);
  }), Object.defineProperty(k.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(k.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(k.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(q) {
      this._readableState && (this._readableState.flowing = q);
    }
  }), k._fromList = Z, Object.defineProperty(k.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Z(F, q) {
    if (q.length === 0) return null;
    var de;
    return q.objectMode ? de = q.buffer.shift() : !F || F >= q.length ? (q.decoder ? de = q.buffer.join("") : q.buffer.length === 1 ? de = q.buffer.first() : de = q.buffer.concat(q.length), q.buffer.clear()) : de = q.buffer.consume(F, q.decoder), de;
  }
  function ie(F) {
    var q = F._readableState;
    l("endReadable", q.endEmitted), q.endEmitted || (q.ended = !0, process.nextTick(me, q, F));
  }
  function me(F, q) {
    if (l("endReadableNT", F.endEmitted, F.length), !F.endEmitted && F.length === 0 && (F.endEmitted = !0, q.readable = !1, q.emit("end"), F.autoDestroy)) {
      var de = q._writableState;
      (!de || de.autoDestroy && de.finished) && q.destroy();
    }
  }
  typeof Symbol == "function" && (k.from = function(F, q) {
    return A === void 0 && (A = E5()), A(k, F, q);
  });
  function Ce(F, q) {
    for (var de = 0, ye = F.length; de < ye; de++)
      if (F[de] === q) return de;
    return -1;
  }
  return sd;
}
var ad, E0;
function yo() {
  if (E0) return ad;
  E0 = 1;
  var r = Object.keys || function(c) {
    var d = [];
    for (var g in c) d.push(g);
    return d;
  };
  ad = s;
  var t = DC(), e = Mu();
  Is()(s, t);
  for (var n = r(e.prototype), i = 0; i < n.length; i++) {
    var o = n[i];
    s.prototype[o] || (s.prototype[o] = e.prototype[o]);
  }
  function s(c) {
    if (!(this instanceof s)) return new s(c);
    t.call(this, c), e.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(s.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(s.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(s.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || process.nextTick(l, this);
  }
  function l(c) {
    c.end();
  }
  return Object.defineProperty(s.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), ad;
}
var ld, A0;
function Mu() {
  if (A0) return ld;
  A0 = 1, ld = O;
  function r(Y) {
    var Z = this;
    this.next = null, this.entry = null, this.finish = function() {
      fe(Z, Y);
    };
  }
  var t;
  O.WritableState = D;
  var e = {
    deprecate: b5()
  }, n = OC(), i = ru.Buffer, o = (typeof qn < "u" ? qn : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(Y) {
    return i.from(Y);
  }
  function u(Y) {
    return i.isBuffer(Y) || Y instanceof o;
  }
  var l = LC(), c = NC(), d = c.getHighWaterMark, g = Eo().codes, y = g.ERR_INVALID_ARG_TYPE, w = g.ERR_METHOD_NOT_IMPLEMENTED, b = g.ERR_MULTIPLE_CALLBACK, _ = g.ERR_STREAM_CANNOT_PIPE, C = g.ERR_STREAM_DESTROYED, m = g.ERR_STREAM_NULL_VALUES, T = g.ERR_STREAM_WRITE_AFTER_END, S = g.ERR_UNKNOWN_ENCODING, A = l.errorOrDestroy;
  Is()(O, n);
  function x() {
  }
  function D(Y, Z, ie) {
    t = t || yo(), Y = Y || {}, typeof ie != "boolean" && (ie = Z instanceof t), this.objectMode = !!Y.objectMode, ie && (this.objectMode = this.objectMode || !!Y.writableObjectMode), this.highWaterMark = d(this, Y, "writableHighWaterMark", ie), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var me = Y.decodeStrings === !1;
    this.decodeStrings = !me, this.defaultEncoding = Y.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ce) {
      P(Z, Ce);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Y.emitClose !== !1, this.autoDestroy = !!Y.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new r(this);
  }
  D.prototype.getBuffer = function() {
    for (var Z = this.bufferedRequest, ie = []; Z; )
      ie.push(Z), Z = Z.next;
    return ie;
  }, function() {
    try {
      Object.defineProperty(D.prototype, "buffer", {
        get: e.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var U;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (U = Function.prototype[Symbol.hasInstance], Object.defineProperty(O, Symbol.hasInstance, {
    value: function(Z) {
      return U.call(this, Z) ? !0 : this !== O ? !1 : Z && Z._writableState instanceof D;
    }
  })) : U = function(Z) {
    return Z instanceof this;
  };
  function O(Y) {
    t = t || yo();
    var Z = this instanceof t;
    if (!Z && !U.call(O, this)) return new O(Y);
    this._writableState = new D(Y, this, Z), this.writable = !0, Y && (typeof Y.write == "function" && (this._write = Y.write), typeof Y.writev == "function" && (this._writev = Y.writev), typeof Y.destroy == "function" && (this._destroy = Y.destroy), typeof Y.final == "function" && (this._final = Y.final)), n.call(this);
  }
  O.prototype.pipe = function() {
    A(this, new _());
  };
  function k(Y, Z) {
    var ie = new T();
    A(Y, ie), process.nextTick(Z, ie);
  }
  function H(Y, Z, ie, me) {
    var Ce;
    return ie === null ? Ce = new m() : typeof ie != "string" && !Z.objectMode && (Ce = new y("chunk", ["string", "Buffer"], ie)), Ce ? (A(Y, Ce), process.nextTick(me, Ce), !1) : !0;
  }
  O.prototype.write = function(Y, Z, ie) {
    var me = this._writableState, Ce = !1, F = !me.objectMode && u(Y);
    return F && !i.isBuffer(Y) && (Y = s(Y)), typeof Z == "function" && (ie = Z, Z = null), F ? Z = "buffer" : Z || (Z = me.defaultEncoding), typeof ie != "function" && (ie = x), me.ending ? k(this, ie) : (F || H(this, me, Y, ie)) && (me.pendingcb++, Ce = N(this, me, F, Y, Z, ie)), Ce;
  }, O.prototype.cork = function() {
    this._writableState.corked++;
  }, O.prototype.uncork = function() {
    var Y = this._writableState;
    Y.corked && (Y.corked--, !Y.writing && !Y.corked && !Y.bufferProcessing && Y.bufferedRequest && W(this, Y));
  }, O.prototype.setDefaultEncoding = function(Z) {
    if (typeof Z == "string" && (Z = Z.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Z + "").toLowerCase()) > -1)) throw new S(Z);
    return this._writableState.defaultEncoding = Z, this;
  }, Object.defineProperty(O.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function V(Y, Z, ie) {
    return !Y.objectMode && Y.decodeStrings !== !1 && typeof Z == "string" && (Z = i.from(Z, ie)), Z;
  }
  Object.defineProperty(O.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function N(Y, Z, ie, me, Ce, F) {
    if (!ie) {
      var q = V(Z, me, Ce);
      me !== q && (ie = !0, Ce = "buffer", me = q);
    }
    var de = Z.objectMode ? 1 : me.length;
    Z.length += de;
    var ye = Z.length < Z.highWaterMark;
    if (ye || (Z.needDrain = !0), Z.writing || Z.corked) {
      var nt = Z.lastBufferedRequest;
      Z.lastBufferedRequest = {
        chunk: me,
        encoding: Ce,
        isBuf: ie,
        callback: F,
        next: null
      }, nt ? nt.next = Z.lastBufferedRequest : Z.bufferedRequest = Z.lastBufferedRequest, Z.bufferedRequestCount += 1;
    } else
      $(Y, Z, !1, de, me, Ce, F);
    return ye;
  }
  function $(Y, Z, ie, me, Ce, F, q) {
    Z.writelen = me, Z.writecb = q, Z.writing = !0, Z.sync = !0, Z.destroyed ? Z.onwrite(new C("write")) : ie ? Y._writev(Ce, Z.onwrite) : Y._write(Ce, F, Z.onwrite), Z.sync = !1;
  }
  function j(Y, Z, ie, me, Ce) {
    --Z.pendingcb, ie ? (process.nextTick(Ce, me), process.nextTick(ce, Y, Z), Y._writableState.errorEmitted = !0, A(Y, me)) : (Ce(me), Y._writableState.errorEmitted = !0, A(Y, me), ce(Y, Z));
  }
  function K(Y) {
    Y.writing = !1, Y.writecb = null, Y.length -= Y.writelen, Y.writelen = 0;
  }
  function P(Y, Z) {
    var ie = Y._writableState, me = ie.sync, Ce = ie.writecb;
    if (typeof Ce != "function") throw new b();
    if (K(ie), Z) j(Y, ie, me, Z, Ce);
    else {
      var F = z(ie) || Y.destroyed;
      !F && !ie.corked && !ie.bufferProcessing && ie.bufferedRequest && W(Y, ie), me ? process.nextTick(I, Y, ie, F, Ce) : I(Y, ie, F, Ce);
    }
  }
  function I(Y, Z, ie, me) {
    ie || B(Y, Z), Z.pendingcb--, me(), ce(Y, Z);
  }
  function B(Y, Z) {
    Z.length === 0 && Z.needDrain && (Z.needDrain = !1, Y.emit("drain"));
  }
  function W(Y, Z) {
    Z.bufferProcessing = !0;
    var ie = Z.bufferedRequest;
    if (Y._writev && ie && ie.next) {
      var me = Z.bufferedRequestCount, Ce = new Array(me), F = Z.corkedRequestsFree;
      F.entry = ie;
      for (var q = 0, de = !0; ie; )
        Ce[q] = ie, ie.isBuf || (de = !1), ie = ie.next, q += 1;
      Ce.allBuffers = de, $(Y, Z, !0, Z.length, Ce, "", F.finish), Z.pendingcb++, Z.lastBufferedRequest = null, F.next ? (Z.corkedRequestsFree = F.next, F.next = null) : Z.corkedRequestsFree = new r(Z), Z.bufferedRequestCount = 0;
    } else {
      for (; ie; ) {
        var ye = ie.chunk, nt = ie.encoding, $e = ie.callback, Ve = Z.objectMode ? 1 : ye.length;
        if ($(Y, Z, !1, Ve, ye, nt, $e), ie = ie.next, Z.bufferedRequestCount--, Z.writing)
          break;
      }
      ie === null && (Z.lastBufferedRequest = null);
    }
    Z.bufferedRequest = ie, Z.bufferProcessing = !1;
  }
  O.prototype._write = function(Y, Z, ie) {
    ie(new w("_write()"));
  }, O.prototype._writev = null, O.prototype.end = function(Y, Z, ie) {
    var me = this._writableState;
    return typeof Y == "function" ? (ie = Y, Y = null, Z = null) : typeof Z == "function" && (ie = Z, Z = null), Y != null && this.write(Y, Z), me.corked && (me.corked = 1, this.uncork()), me.ending || te(this, me, ie), this;
  }, Object.defineProperty(O.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function z(Y) {
    return Y.ending && Y.length === 0 && Y.bufferedRequest === null && !Y.finished && !Y.writing;
  }
  function ee(Y, Z) {
    Y._final(function(ie) {
      Z.pendingcb--, ie && A(Y, ie), Z.prefinished = !0, Y.emit("prefinish"), ce(Y, Z);
    });
  }
  function ne(Y, Z) {
    !Z.prefinished && !Z.finalCalled && (typeof Y._final == "function" && !Z.destroyed ? (Z.pendingcb++, Z.finalCalled = !0, process.nextTick(ee, Y, Z)) : (Z.prefinished = !0, Y.emit("prefinish")));
  }
  function ce(Y, Z) {
    var ie = z(Z);
    if (ie && (ne(Y, Z), Z.pendingcb === 0 && (Z.finished = !0, Y.emit("finish"), Z.autoDestroy))) {
      var me = Y._readableState;
      (!me || me.autoDestroy && me.endEmitted) && Y.destroy();
    }
    return ie;
  }
  function te(Y, Z, ie) {
    Z.ending = !0, ce(Y, Z), ie && (Z.finished ? process.nextTick(ie) : Y.once("finish", ie)), Z.ended = !0, Y.writable = !1;
  }
  function fe(Y, Z, ie) {
    var me = Y.entry;
    for (Y.entry = null; me; ) {
      var Ce = me.callback;
      Z.pendingcb--, Ce(ie), me = me.next;
    }
    Z.corkedRequestsFree.next = Y;
  }
  return Object.defineProperty(O.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Z) {
      this._writableState && (this._writableState.destroyed = Z);
    }
  }), O.prototype.destroy = l.destroy, O.prototype._undestroy = l.undestroy, O.prototype._destroy = function(Y, Z) {
    Z(Y);
  }, ld;
}
var x0;
function FC() {
  if (x0) return Yf.exports;
  x0 = 1;
  var r = Jn, t = Mu(), e = bt(), n = e.LEVEL, i = Yf.exports = function() {
    var s = this, u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t.call(this, { objectMode: !0, highWaterMark: u.highWaterMark }), this.format = u.format, this.level = u.level, this.handleExceptions = u.handleExceptions, this.handleRejections = u.handleRejections, this.silent = u.silent, u.log && (this.log = u.log), u.logv && (this.logv = u.logv), u.close && (this.close = u.close), this.once("pipe", function(l) {
      s.levels = l.levels, s.parent = l;
    }), this.once("unpipe", function(l) {
      l === s.parent && (s.parent = null, s.close && s.close());
    });
  };
  return r.inherits(i, t), i.prototype._write = function(s, u, l) {
    if (this.silent || s.exception === !0 && !this.handleExceptions)
      return l(null);
    var c = this.level || this.parent && this.parent.level;
    if (!c || this.levels[c] >= this.levels[s[n]]) {
      if (s && !this.format)
        return this.log(s, l);
      var d = void 0, g = void 0;
      try {
        g = this.format.transform(Object.assign({}, s), this.format.options);
      } catch (y) {
        d = y;
      }
      if (d || !g) {
        if (l(), d) throw d;
        return;
      }
      return this.log(g, l);
    }
    return this._writableState.sync = !1, l(null);
  }, i.prototype._writev = function(s, u) {
    if (this.logv) {
      var l = s.filter(this._accept, this);
      return l.length ? this.logv(l, u) : u(null);
    }
    for (var c = 0; c < s.length; c++)
      if (this._accept(s[c])) {
        if (s[c].chunk && !this.format) {
          this.log(s[c].chunk, s[c].callback);
          continue;
        }
        var d = void 0, g = void 0;
        try {
          g = this.format.transform(Object.assign({}, s[c].chunk), this.format.options);
        } catch (y) {
          d = y;
        }
        if (d || !g) {
          if (s[c].callback(), d)
            throw u(null), d;
        } else
          this.log(g, s[c].callback);
      }
    return u(null);
  }, i.prototype._accept = function(s) {
    var u = s.chunk;
    if (this.silent)
      return !1;
    var l = this.level || this.parent && this.parent.level;
    return !!((u.exception === !0 || !l || this.levels[l] >= this.levels[u[n]]) && (this.handleExceptions || u.exception !== !0));
  }, i.prototype._nop = function() {
  }, Yf.exports;
}
var ud = { exports: {} }, R0;
function A5() {
  if (R0) return ud.exports;
  R0 = 1;
  var r = Jn, t = bt(), e = t.LEVEL, n = FC(), i = ud.exports = function() {
    var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (n.call(this, s), !s.transport || typeof s.transport.log != "function")
      throw new Error("Invalid transport, must be an object with a log method.");
    this.transport = s.transport, this.level = this.level || s.transport.level, this.handleExceptions = this.handleExceptions || s.transport.handleExceptions, this._deprecated();
    function u(l) {
      this.emit("error", l, this.transport);
    }
    this.transport.__winstonError || (this.transport.__winstonError = u.bind(this), this.transport.on("error", this.transport.__winstonError));
  };
  return r.inherits(i, n), i.prototype._write = function(s, u, l) {
    if (this.silent || s.exception === !0 && !this.handleExceptions)
      return l(null);
    (!this.level || this.levels[this.level] >= this.levels[s[e]]) && this.transport.log(s[e], s.message, s, this._nop), l(null);
  }, i.prototype._writev = function(s, u) {
    for (var l = 0; l < s.length; l++)
      this._accept(s[l]) && (this.transport.log(s[l].chunk[e], s[l].chunk.message, s[l].chunk, this._nop), s[l].callback());
    return u(null);
  }, i.prototype._deprecated = function() {
    console.error([this.transport.name + " is a legacy winston transport. Consider upgrading: ", "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"].join(`
`));
  }, i.prototype.close = function() {
    this.transport.close && this.transport.close(), this.transport.__winstonError && (this.transport.removeListener("error", this.transport.__winstonError), this.transport.__winstonError = null);
  }, ud.exports;
}
var I0;
function Ms() {
  return I0 || (I0 = 1, Ba.exports = FC(), Ba.exports.LegacyTransportStream = A5()), Ba.exports;
}
var cd, M0;
function x5() {
  if (M0) return cd;
  M0 = 1;
  function r(T) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
      return typeof S;
    } : function(S) {
      return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
    }, r(T);
  }
  function t(T, S) {
    if (!(T instanceof S)) throw new TypeError("Cannot call a class as a function");
  }
  function e(T, S) {
    for (var A = 0; A < S.length; A++) {
      var x = S[A];
      x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(T, i(x.key), x);
    }
  }
  function n(T, S, A) {
    return S && e(T.prototype, S), Object.defineProperty(T, "prototype", { writable: !1 }), T;
  }
  function i(T) {
    var S = o(T, "string");
    return r(S) == "symbol" ? S : S + "";
  }
  function o(T, S) {
    if (r(T) != "object" || !T) return T;
    var A = T[Symbol.toPrimitive];
    if (A !== void 0) {
      var x = A.call(T, S);
      if (r(x) != "object") return x;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(T);
  }
  function s(T, S, A) {
    return S = d(S), u(T, c() ? Reflect.construct(S, A || [], d(T).constructor) : S.apply(T, A));
  }
  function u(T, S) {
    if (S && (r(S) == "object" || typeof S == "function")) return S;
    if (S !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return l(T);
  }
  function l(T) {
    if (T === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return T;
  }
  function c() {
    try {
      var T = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (c = function() {
      return !!T;
    })();
  }
  function d(T) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(S) {
      return S.__proto__ || Object.getPrototypeOf(S);
    }, d(T);
  }
  function g(T, S) {
    if (typeof S != "function" && S !== null) throw new TypeError("Super expression must either be null or a function");
    T.prototype = Object.create(S && S.prototype, { constructor: { value: T, writable: !0, configurable: !0 } }), Object.defineProperty(T, "prototype", { writable: !1 }), S && y(T, S);
  }
  function y(T, S) {
    return y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(A, x) {
      return A.__proto__ = x, A;
    }, y(T, S);
  }
  var w = gr, b = bt(), _ = b.LEVEL, C = b.MESSAGE, m = Ms();
  return cd = /* @__PURE__ */ function(T) {
    function S() {
      var A, x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return t(this, S), A = s(this, S, [x]), A.name = x.name || "console", A.stderrLevels = A._stringArrayToSet(x.stderrLevels), A.consoleWarnLevels = A._stringArrayToSet(x.consoleWarnLevels), A.eol = typeof x.eol == "string" ? x.eol : w.EOL, A.forceConsole = x.forceConsole || !1, A._consoleLog = console.log.bind(console), A._consoleWarn = console.warn.bind(console), A._consoleError = console.error.bind(console), A.setMaxListeners(30), A;
    }
    return g(S, T), n(S, [{
      key: "log",
      value: function(x, D) {
        var U = this;
        if (setImmediate(function() {
          return U.emit("logged", x);
        }), this.stderrLevels[x[_]]) {
          console._stderr && !this.forceConsole ? console._stderr.write("".concat(x[C]).concat(this.eol)) : this._consoleError(x[C]), D && D();
          return;
        } else if (this.consoleWarnLevels[x[_]]) {
          console._stderr && !this.forceConsole ? console._stderr.write("".concat(x[C]).concat(this.eol)) : this._consoleWarn(x[C]), D && D();
          return;
        }
        console._stdout && !this.forceConsole ? console._stdout.write("".concat(x[C]).concat(this.eol)) : this._consoleLog(x[C]), D && D();
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
    }, {
      key: "_stringArrayToSet",
      value: function(x, D) {
        if (!x) return {};
        if (D = D || "Cannot make set from type other than Array of string elements", !Array.isArray(x))
          throw new Error(D);
        return x.reduce(function(U, O) {
          if (typeof O != "string")
            throw new Error(D);
          return U[O] = !0, U;
        }, {});
      }
    }]);
  }(m), cd;
}
var Ga = { exports: {} }, Wa = { exports: {} }, Ka = { exports: {} }, k0;
function Lp() {
  return k0 || (k0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = e;
    function e(n) {
      return n && typeof n.length == "number" && n.length >= 0 && n.length % 1 === 0;
    }
    r.exports = t.default;
  }(Ka, Ka.exports)), Ka.exports;
}
var Un = {}, Ja = { exports: {} }, za = { exports: {} }, P0;
function R5() {
  return P0 || (P0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = function(e) {
      return function(...n) {
        var i = n.pop();
        return e.call(this, n, i);
      };
    }, r.exports = t.default;
  }(za, za.exports)), za.exports;
}
var or = {}, O0;
function I5() {
  if (O0) return or;
  O0 = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.fallback = n, or.wrap = i;
  var r = or.hasQueueMicrotask = typeof queueMicrotask == "function" && queueMicrotask, t = or.hasSetImmediate = typeof setImmediate == "function" && setImmediate, e = or.hasNextTick = typeof process == "object" && typeof process.nextTick == "function";
  function n(s) {
    setTimeout(s, 0);
  }
  function i(s) {
    return (u, ...l) => s(() => u(...l));
  }
  var o;
  return r ? o = queueMicrotask : t ? o = setImmediate : e ? o = process.nextTick : o = n, or.default = i(o), or;
}
var L0;
function M5() {
  return L0 || (L0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = l;
    var e = R5(), n = u(e), i = I5(), o = u(i), s = Ao();
    function u(g) {
      return g && g.__esModule ? g : { default: g };
    }
    function l(g) {
      return (0, s.isAsync)(g) ? function(...y) {
        const w = y.pop(), b = g.apply(this, y);
        return c(b, w);
      } : (0, n.default)(function(y, w) {
        var b;
        try {
          b = g.apply(this, y);
        } catch (_) {
          return w(_);
        }
        if (b && typeof b.then == "function")
          return c(b, w);
        w(null, b);
      });
    }
    function c(g, y) {
      return g.then((w) => {
        d(y, null, w);
      }, (w) => {
        d(y, w && (w instanceof Error || w.message) ? w : new Error(w));
      });
    }
    function d(g, y, w) {
      try {
        g(y, w);
      } catch (b) {
        (0, o.default)((_) => {
          throw _;
        }, b);
      }
    }
    r.exports = t.default;
  }(Ja, Ja.exports)), Ja.exports;
}
var N0;
function Ao() {
  if (N0) return Un;
  N0 = 1, Object.defineProperty(Un, "__esModule", {
    value: !0
  }), Un.isAsyncIterable = Un.isAsyncGenerator = Un.isAsync = void 0;
  var r = M5(), t = e(r);
  function e(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u) {
    return u[Symbol.toStringTag] === "AsyncFunction";
  }
  function i(u) {
    return u[Symbol.toStringTag] === "AsyncGenerator";
  }
  function o(u) {
    return typeof u[Symbol.asyncIterator] == "function";
  }
  function s(u) {
    if (typeof u != "function") throw new Error("expected a function");
    return n(u) ? (0, t.default)(u) : u;
  }
  return Un.default = s, Un.isAsync = n, Un.isAsyncGenerator = i, Un.isAsyncIterable = o, Un;
}
var Ya = { exports: {} }, D0;
function ks() {
  return D0 || (D0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = e;
    function e(n, i) {
      if (i || (i = n.length), !i) throw new Error("arity is undefined");
      function o(...s) {
        return typeof s[i - 1] == "function" ? n.apply(this, s) : new Promise((u, l) => {
          s[i - 1] = (c, ...d) => {
            if (c) return l(c);
            u(d.length > 1 ? d : d[0]);
          }, n.apply(this, s);
        });
      }
      return o;
    }
    r.exports = t.default;
  }(Ya, Ya.exports)), Ya.exports;
}
var F0;
function k5() {
  return F0 || (F0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var e = Lp(), n = l(e), i = Ao(), o = l(i), s = ks(), u = l(s);
    function l(c) {
      return c && c.__esModule ? c : { default: c };
    }
    t.default = (0, u.default)((c, d, g) => {
      var y = (0, n.default)(d) ? [] : {};
      c(d, (w, b, _) => {
        (0, o.default)(w)((C, ...m) => {
          m.length < 2 && ([m] = m), y[b] = m, _(C);
        });
      }, (w) => g(w, y));
    }, 3), r.exports = t.default;
  }(Wa, Wa.exports)), Wa.exports;
}
var Za = { exports: {} }, ja = { exports: {} }, Qa = { exports: {} }, Xa = { exports: {} }, $0;
function $C() {
  return $0 || ($0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = e;
    function e(n) {
      function i(...o) {
        if (n !== null) {
          var s = n;
          n = null, s.apply(this, o);
        }
      }
      return Object.assign(i, n), i;
    }
    r.exports = t.default;
  }(Xa, Xa.exports)), Xa.exports;
}
var el = { exports: {} }, tl = { exports: {} }, U0;
function P5() {
  return U0 || (U0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = function(e) {
      return e[Symbol.iterator] && e[Symbol.iterator]();
    }, r.exports = t.default;
  }(tl, tl.exports)), tl.exports;
}
var q0;
function O5() {
  return q0 || (q0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = d;
    var e = Lp(), n = s(e), i = P5(), o = s(i);
    function s(g) {
      return g && g.__esModule ? g : { default: g };
    }
    function u(g) {
      var y = -1, w = g.length;
      return function() {
        return ++y < w ? { value: g[y], key: y } : null;
      };
    }
    function l(g) {
      var y = -1;
      return function() {
        var b = g.next();
        return b.done ? null : (y++, { value: b.value, key: y });
      };
    }
    function c(g) {
      var y = g ? Object.keys(g) : [], w = -1, b = y.length;
      return function _() {
        var C = y[++w];
        return C === "__proto__" ? _() : w < b ? { value: g[C], key: C } : null;
      };
    }
    function d(g) {
      if ((0, n.default)(g))
        return u(g);
      var y = (0, o.default)(g);
      return y ? l(y) : c(g);
    }
    r.exports = t.default;
  }(el, el.exports)), el.exports;
}
var nl = { exports: {} }, B0;
function UC() {
  return B0 || (B0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = e;
    function e(n) {
      return function(...i) {
        if (n === null) throw new Error("Callback was already called.");
        var o = n;
        n = null, o.apply(this, i);
      };
    }
    r.exports = t.default;
  }(nl, nl.exports)), nl.exports;
}
var rl = { exports: {} }, il = { exports: {} }, V0;
function Np() {
  return V0 || (V0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    const e = {};
    t.default = e, r.exports = t.default;
  }(il, il.exports)), il.exports;
}
var H0;
function L5() {
  return H0 || (H0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = o;
    var e = Np(), n = i(e);
    function i(s) {
      return s && s.__esModule ? s : { default: s };
    }
    function o(s, u, l, c) {
      let d = !1, g = !1, y = !1, w = 0, b = 0;
      function _() {
        w >= u || y || d || (y = !0, s.next().then(({ value: T, done: S }) => {
          if (!(g || d)) {
            if (y = !1, S) {
              d = !0, w <= 0 && c(null);
              return;
            }
            w++, l(T, b, C), b++, _();
          }
        }).catch(m));
      }
      function C(T, S) {
        if (w -= 1, !g) {
          if (T) return m(T);
          if (T === !1) {
            d = !0, g = !0;
            return;
          }
          if (S === n.default || d && w <= 0)
            return d = !0, c(null);
          _();
        }
      }
      function m(T) {
        g || (y = !1, d = !0, c(T));
      }
      _();
    }
    r.exports = t.default;
  }(rl, rl.exports)), rl.exports;
}
var G0;
function N5() {
  return G0 || (G0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var e = $C(), n = w(e), i = O5(), o = w(i), s = UC(), u = w(s), l = Ao(), c = L5(), d = w(c), g = Np(), y = w(g);
    function w(b) {
      return b && b.__esModule ? b : { default: b };
    }
    t.default = (b) => (_, C, m) => {
      if (m = (0, n.default)(m), b <= 0)
        throw new RangeError("concurrency limit cannot be less than 1");
      if (!_)
        return m(null);
      if ((0, l.isAsyncGenerator)(_))
        return (0, d.default)(_, b, C, m);
      if ((0, l.isAsyncIterable)(_))
        return (0, d.default)(_[Symbol.asyncIterator](), b, C, m);
      var T = (0, o.default)(_), S = !1, A = !1, x = 0, D = !1;
      function U(k, H) {
        if (!A)
          if (x -= 1, k)
            S = !0, m(k);
          else if (k === !1)
            S = !0, A = !0;
          else {
            if (H === y.default || S && x <= 0)
              return S = !0, m(null);
            D || O();
          }
      }
      function O() {
        for (D = !0; x < b && !S; ) {
          var k = T();
          if (k === null) {
            S = !0, x <= 0 && m(null);
            return;
          }
          x += 1, C(k.value, k.key, (0, u.default)(U));
        }
        D = !1;
      }
      O();
    }, r.exports = t.default;
  }(Qa, Qa.exports)), Qa.exports;
}
var W0;
function qC() {
  return W0 || (W0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var e = N5(), n = l(e), i = Ao(), o = l(i), s = ks(), u = l(s);
    function l(d) {
      return d && d.__esModule ? d : { default: d };
    }
    function c(d, g, y, w) {
      return (0, n.default)(g)(d, (0, o.default)(y), w);
    }
    t.default = (0, u.default)(c, 4), r.exports = t.default;
  }(ja, ja.exports)), ja.exports;
}
var K0;
function D5() {
  return K0 || (K0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var e = qC(), n = s(e), i = ks(), o = s(i);
    function s(l) {
      return l && l.__esModule ? l : { default: l };
    }
    function u(l, c, d) {
      return (0, n.default)(l, 1, c, d);
    }
    t.default = (0, o.default)(u, 3), r.exports = t.default;
  }(Za, Za.exports)), Za.exports;
}
var J0;
function F5() {
  return J0 || (J0 = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = u;
    var e = k5(), n = s(e), i = D5(), o = s(i);
    function s(l) {
      return l && l.__esModule ? l : { default: l };
    }
    function u(l, c) {
      return (0, n.default)(o.default, l, c);
    }
    r.exports = t.default;
  }(Ga, Ga.exports)), Ga.exports;
}
var ol = { exports: {} }, fd, z0;
function BC() {
  if (z0) return fd;
  z0 = 1, fd = u;
  var r = Eo().codes, t = r.ERR_METHOD_NOT_IMPLEMENTED, e = r.ERR_MULTIPLE_CALLBACK, n = r.ERR_TRANSFORM_ALREADY_TRANSFORMING, i = r.ERR_TRANSFORM_WITH_LENGTH_0, o = yo();
  Is()(u, o);
  function s(d, g) {
    var y = this._transformState;
    y.transforming = !1;
    var w = y.writecb;
    if (w === null)
      return this.emit("error", new e());
    y.writechunk = null, y.writecb = null, g != null && this.push(g), w(d);
    var b = this._readableState;
    b.reading = !1, (b.needReadable || b.length < b.highWaterMark) && this._read(b.highWaterMark);
  }
  function u(d) {
    if (!(this instanceof u)) return new u(d);
    o.call(this, d), this._transformState = {
      afterTransform: s.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, d && (typeof d.transform == "function" && (this._transform = d.transform), typeof d.flush == "function" && (this._flush = d.flush)), this.on("prefinish", l);
  }
  function l() {
    var d = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(g, y) {
      c(d, g, y);
    }) : c(this, null, null);
  }
  u.prototype.push = function(d, g) {
    return this._transformState.needTransform = !1, o.prototype.push.call(this, d, g);
  }, u.prototype._transform = function(d, g, y) {
    y(new t("_transform()"));
  }, u.prototype._write = function(d, g, y) {
    var w = this._transformState;
    if (w.writecb = y, w.writechunk = d, w.writeencoding = g, !w.transforming) {
      var b = this._readableState;
      (w.needTransform || b.needReadable || b.length < b.highWaterMark) && this._read(b.highWaterMark);
    }
  }, u.prototype._read = function(d) {
    var g = this._transformState;
    g.writechunk !== null && !g.transforming ? (g.transforming = !0, this._transform(g.writechunk, g.writeencoding, g.afterTransform)) : g.needTransform = !0;
  }, u.prototype._destroy = function(d, g) {
    o.prototype._destroy.call(this, d, function(y) {
      g(y);
    });
  };
  function c(d, g, y) {
    if (g) return d.emit("error", g);
    if (y != null && d.push(y), d._writableState.length) throw new i();
    if (d._transformState.transforming) throw new n();
    return d.push(null);
  }
  return fd;
}
var dd, Y0;
function $5() {
  if (Y0) return dd;
  Y0 = 1, dd = t;
  var r = BC();
  Is()(t, r);
  function t(e) {
    if (!(this instanceof t)) return new t(e);
    r.call(this, e);
  }
  return t.prototype._transform = function(e, n, i) {
    i(null, e);
  }, dd;
}
var hd, Z0;
function U5() {
  if (Z0) return hd;
  Z0 = 1;
  var r;
  function t(y) {
    var w = !1;
    return function() {
      w || (w = !0, y.apply(void 0, arguments));
    };
  }
  var e = Eo().codes, n = e.ERR_MISSING_ARGS, i = e.ERR_STREAM_DESTROYED;
  function o(y) {
    if (y) throw y;
  }
  function s(y) {
    return y.setHeader && typeof y.abort == "function";
  }
  function u(y, w, b, _) {
    _ = t(_);
    var C = !1;
    y.on("close", function() {
      C = !0;
    }), r === void 0 && (r = Op()), r(y, {
      readable: w,
      writable: b
    }, function(T) {
      if (T) return _(T);
      C = !0, _();
    });
    var m = !1;
    return function(T) {
      if (!C && !m) {
        if (m = !0, s(y)) return y.abort();
        if (typeof y.destroy == "function") return y.destroy();
        _(T || new i("pipe"));
      }
    };
  }
  function l(y) {
    y();
  }
  function c(y, w) {
    return y.pipe(w);
  }
  function d(y) {
    return !y.length || typeof y[y.length - 1] != "function" ? o : y.pop();
  }
  function g() {
    for (var y = arguments.length, w = new Array(y), b = 0; b < y; b++)
      w[b] = arguments[b];
    var _ = d(w);
    if (Array.isArray(w[0]) && (w = w[0]), w.length < 2)
      throw new n("streams");
    var C, m = w.map(function(T, S) {
      var A = S < w.length - 1, x = S > 0;
      return u(T, A, x, function(D) {
        C || (C = D), D && m.forEach(l), !A && (m.forEach(l), _(C));
      });
    });
    return w.reduce(c);
  }
  return hd = g, hd;
}
var j0;
function xo() {
  return j0 || (j0 = 1, function(r, t) {
    t = r.exports = DC(), t.Stream = t, t.Readable = t, t.Writable = Mu(), t.Duplex = yo(), t.Transform = BC(), t.PassThrough = $5(), t.finished = Op(), t.pipeline = U5();
  }(ol, ol.exports)), ol.exports;
}
var sl = { exports: {} }, pd, Q0;
function VC() {
  if (Q0) return pd;
  Q0 = 1;
  var r = [], t = [], e = function() {
  };
  function n(y) {
    return ~r.indexOf(y) ? !1 : (r.push(y), !0);
  }
  function i(y) {
    e = y;
  }
  function o(y) {
    for (var w = [], b = 0; b < r.length; b++) {
      if (r[b].async) {
        w.push(r[b]);
        continue;
      }
      if (r[b](y)) return !0;
    }
    return w.length ? new Promise(function(C) {
      Promise.all(
        w.map(function(T) {
          return T(y);
        })
      ).then(function(T) {
        C(T.some(Boolean));
      });
    }) : !1;
  }
  function s(y) {
    return ~t.indexOf(y) ? !1 : (t.push(y), !0);
  }
  function u() {
    e.apply(e, arguments);
  }
  function l(y) {
    for (var w = 0; w < t.length; w++)
      y = t[w].apply(t[w], arguments);
    return y;
  }
  function c(y, w) {
    var b = Object.prototype.hasOwnProperty;
    for (var _ in w)
      b.call(w, _) && (y[_] = w[_]);
    return y;
  }
  function d(y) {
    return y.enabled = !1, y.modify = s, y.set = i, y.use = n, c(function() {
      return !1;
    }, y);
  }
  function g(y) {
    function w() {
      var b = Array.prototype.slice.call(arguments, 0);
      return u.call(u, y, l(b, y)), !0;
    }
    return y.enabled = !0, y.modify = s, y.set = i, y.use = n, c(w, y);
  }
  return pd = function(w) {
    return w.introduce = c, w.enabled = o, w.process = l, w.modify = s, w.write = u, w.nope = d, w.yep = g, w.set = i, w.use = n, w;
  }, pd;
}
var md, X0;
function q5() {
  if (X0) return md;
  X0 = 1;
  var r = VC(), t = r(function e(n, i) {
    return i = i || {}, i.namespace = n, i.prod = !0, i.dev = !1, i.force || e.force ? e.yep(i) : e.nope(i);
  });
  return md = t, md;
}
var gd = { exports: {} }, yd = { exports: {} }, vd, ew;
function B5() {
  return ew || (ew = 1, vd = function(t) {
    return !t || typeof t == "string" ? !1 : t instanceof Array || Array.isArray(t) || t.length >= 0 && (t.splice instanceof Function || Object.getOwnPropertyDescriptor(t, t.length - 1) && t.constructor.name !== "String");
  }), vd;
}
var tw;
function V5() {
  if (tw) return yd.exports;
  tw = 1;
  var r = B5(), t = Array.prototype.concat, e = Array.prototype.slice, n = yd.exports = function(o) {
    for (var s = [], u = 0, l = o.length; u < l; u++) {
      var c = o[u];
      r(c) ? s = t.call(s, e.call(c)) : s.push(c);
    }
    return s;
  };
  return n.wrap = function(i) {
    return function() {
      return i(n(arguments));
    };
  }, yd.exports;
}
var nw;
function H5() {
  if (nw) return gd.exports;
  nw = 1;
  var r = Nk(), t = V5(), e = Object.hasOwnProperty, n = /* @__PURE__ */ Object.create(null);
  for (var i in r)
    e.call(r, i) && (n[r[i]] = i);
  var o = gd.exports = {
    to: {},
    get: {}
  };
  o.get = function(l) {
    var c = l.substring(0, 3).toLowerCase(), d, g;
    switch (c) {
      case "hsl":
        d = o.get.hsl(l), g = "hsl";
        break;
      case "hwb":
        d = o.get.hwb(l), g = "hwb";
        break;
      default:
        d = o.get.rgb(l), g = "rgb";
        break;
    }
    return d ? { model: g, value: d } : null;
  }, o.get.rgb = function(l) {
    if (!l)
      return null;
    var c = /^#([a-f0-9]{3,4})$/i, d = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i, g = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, y = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, w = /^(\w+)$/, b = [0, 0, 0, 1], _, C, m;
    if (_ = l.match(d)) {
      for (m = _[2], _ = _[1], C = 0; C < 3; C++) {
        var T = C * 2;
        b[C] = parseInt(_.slice(T, T + 2), 16);
      }
      m && (b[3] = parseInt(m, 16) / 255);
    } else if (_ = l.match(c)) {
      for (_ = _[1], m = _[3], C = 0; C < 3; C++)
        b[C] = parseInt(_[C] + _[C], 16);
      m && (b[3] = parseInt(m + m, 16) / 255);
    } else if (_ = l.match(g)) {
      for (C = 0; C < 3; C++)
        b[C] = parseInt(_[C + 1], 0);
      _[4] && (_[5] ? b[3] = parseFloat(_[4]) * 0.01 : b[3] = parseFloat(_[4]));
    } else if (_ = l.match(y)) {
      for (C = 0; C < 3; C++)
        b[C] = Math.round(parseFloat(_[C + 1]) * 2.55);
      _[4] && (_[5] ? b[3] = parseFloat(_[4]) * 0.01 : b[3] = parseFloat(_[4]));
    } else return (_ = l.match(w)) ? _[1] === "transparent" ? [0, 0, 0, 0] : e.call(r, _[1]) ? (b = r[_[1]], b[3] = 1, b) : null : null;
    for (C = 0; C < 3; C++)
      b[C] = s(b[C], 0, 255);
    return b[3] = s(b[3], 0, 1), b;
  }, o.get.hsl = function(l) {
    if (!l)
      return null;
    var c = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, d = l.match(c);
    if (d) {
      var g = parseFloat(d[4]), y = (parseFloat(d[1]) % 360 + 360) % 360, w = s(parseFloat(d[2]), 0, 100), b = s(parseFloat(d[3]), 0, 100), _ = s(isNaN(g) ? 1 : g, 0, 1);
      return [y, w, b, _];
    }
    return null;
  }, o.get.hwb = function(l) {
    if (!l)
      return null;
    var c = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, d = l.match(c);
    if (d) {
      var g = parseFloat(d[4]), y = (parseFloat(d[1]) % 360 + 360) % 360, w = s(parseFloat(d[2]), 0, 100), b = s(parseFloat(d[3]), 0, 100), _ = s(isNaN(g) ? 1 : g, 0, 1);
      return [y, w, b, _];
    }
    return null;
  }, o.to.hex = function() {
    var l = t(arguments);
    return "#" + u(l[0]) + u(l[1]) + u(l[2]) + (l[3] < 1 ? u(Math.round(l[3] * 255)) : "");
  }, o.to.rgb = function() {
    var l = t(arguments);
    return l.length < 4 || l[3] === 1 ? "rgb(" + Math.round(l[0]) + ", " + Math.round(l[1]) + ", " + Math.round(l[2]) + ")" : "rgba(" + Math.round(l[0]) + ", " + Math.round(l[1]) + ", " + Math.round(l[2]) + ", " + l[3] + ")";
  }, o.to.rgb.percent = function() {
    var l = t(arguments), c = Math.round(l[0] / 255 * 100), d = Math.round(l[1] / 255 * 100), g = Math.round(l[2] / 255 * 100);
    return l.length < 4 || l[3] === 1 ? "rgb(" + c + "%, " + d + "%, " + g + "%)" : "rgba(" + c + "%, " + d + "%, " + g + "%, " + l[3] + ")";
  }, o.to.hsl = function() {
    var l = t(arguments);
    return l.length < 4 || l[3] === 1 ? "hsl(" + l[0] + ", " + l[1] + "%, " + l[2] + "%)" : "hsla(" + l[0] + ", " + l[1] + "%, " + l[2] + "%, " + l[3] + ")";
  }, o.to.hwb = function() {
    var l = t(arguments), c = "";
    return l.length >= 4 && l[3] !== 1 && (c = ", " + l[3]), "hwb(" + l[0] + ", " + l[1] + "%, " + l[2] + "%" + c + ")";
  }, o.to.keyword = function(l) {
    return n[l.slice(0, 3)];
  };
  function s(l, c, d) {
    return Math.min(Math.max(c, l), d);
  }
  function u(l) {
    var c = Math.round(l).toString(16).toUpperCase();
    return c.length < 2 ? "0" + c : c;
  }
  return gd.exports;
}
var _d = { exports: {} }, wd, rw;
function G5() {
  return rw || (rw = 1, wd = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), wd;
}
var iw;
function HC() {
  if (iw) return _d.exports;
  iw = 1;
  var r = G5(), t = {};
  for (var e in r)
    r.hasOwnProperty(e) && (t[r[e]] = e);
  var n = _d.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (var i in n)
    if (n.hasOwnProperty(i)) {
      if (!("channels" in n[i]))
        throw new Error("missing channels property: " + i);
      if (!("labels" in n[i]))
        throw new Error("missing channel labels property: " + i);
      if (n[i].labels.length !== n[i].channels)
        throw new Error("channel and label counts mismatch: " + i);
      var o = n[i].channels, s = n[i].labels;
      delete n[i].channels, delete n[i].labels, Object.defineProperty(n[i], "channels", { value: o }), Object.defineProperty(n[i], "labels", { value: s });
    }
  n.rgb.hsl = function(l) {
    var c = l[0] / 255, d = l[1] / 255, g = l[2] / 255, y = Math.min(c, d, g), w = Math.max(c, d, g), b = w - y, _, C, m;
    return w === y ? _ = 0 : c === w ? _ = (d - g) / b : d === w ? _ = 2 + (g - c) / b : g === w && (_ = 4 + (c - d) / b), _ = Math.min(_ * 60, 360), _ < 0 && (_ += 360), m = (y + w) / 2, w === y ? C = 0 : m <= 0.5 ? C = b / (w + y) : C = b / (2 - w - y), [_, C * 100, m * 100];
  }, n.rgb.hsv = function(l) {
    var c, d, g, y, w, b = l[0] / 255, _ = l[1] / 255, C = l[2] / 255, m = Math.max(b, _, C), T = m - Math.min(b, _, C), S = function(A) {
      return (m - A) / 6 / T + 1 / 2;
    };
    return T === 0 ? y = w = 0 : (w = T / m, c = S(b), d = S(_), g = S(C), b === m ? y = g - d : _ === m ? y = 1 / 3 + c - g : C === m && (y = 2 / 3 + d - c), y < 0 ? y += 1 : y > 1 && (y -= 1)), [
      y * 360,
      w * 100,
      m * 100
    ];
  }, n.rgb.hwb = function(l) {
    var c = l[0], d = l[1], g = l[2], y = n.rgb.hsl(l)[0], w = 1 / 255 * Math.min(c, Math.min(d, g));
    return g = 1 - 1 / 255 * Math.max(c, Math.max(d, g)), [y, w * 100, g * 100];
  }, n.rgb.cmyk = function(l) {
    var c = l[0] / 255, d = l[1] / 255, g = l[2] / 255, y, w, b, _;
    return _ = Math.min(1 - c, 1 - d, 1 - g), y = (1 - c - _) / (1 - _) || 0, w = (1 - d - _) / (1 - _) || 0, b = (1 - g - _) / (1 - _) || 0, [y * 100, w * 100, b * 100, _ * 100];
  };
  function u(l, c) {
    return Math.pow(l[0] - c[0], 2) + Math.pow(l[1] - c[1], 2) + Math.pow(l[2] - c[2], 2);
  }
  return n.rgb.keyword = function(l) {
    var c = t[l];
    if (c)
      return c;
    var d = 1 / 0, g;
    for (var y in r)
      if (r.hasOwnProperty(y)) {
        var w = r[y], b = u(l, w);
        b < d && (d = b, g = y);
      }
    return g;
  }, n.keyword.rgb = function(l) {
    return r[l];
  }, n.rgb.xyz = function(l) {
    var c = l[0] / 255, d = l[1] / 255, g = l[2] / 255;
    c = c > 0.04045 ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92, d = d > 0.04045 ? Math.pow((d + 0.055) / 1.055, 2.4) : d / 12.92, g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    var y = c * 0.4124 + d * 0.3576 + g * 0.1805, w = c * 0.2126 + d * 0.7152 + g * 0.0722, b = c * 0.0193 + d * 0.1192 + g * 0.9505;
    return [y * 100, w * 100, b * 100];
  }, n.rgb.lab = function(l) {
    var c = n.rgb.xyz(l), d = c[0], g = c[1], y = c[2], w, b, _;
    return d /= 95.047, g /= 100, y /= 108.883, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, g = g > 8856e-6 ? Math.pow(g, 1 / 3) : 7.787 * g + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, w = 116 * g - 16, b = 500 * (d - g), _ = 200 * (g - y), [w, b, _];
  }, n.hsl.rgb = function(l) {
    var c = l[0] / 360, d = l[1] / 100, g = l[2] / 100, y, w, b, _, C;
    if (d === 0)
      return C = g * 255, [C, C, C];
    g < 0.5 ? w = g * (1 + d) : w = g + d - g * d, y = 2 * g - w, _ = [0, 0, 0];
    for (var m = 0; m < 3; m++)
      b = c + 1 / 3 * -(m - 1), b < 0 && b++, b > 1 && b--, 6 * b < 1 ? C = y + (w - y) * 6 * b : 2 * b < 1 ? C = w : 3 * b < 2 ? C = y + (w - y) * (2 / 3 - b) * 6 : C = y, _[m] = C * 255;
    return _;
  }, n.hsl.hsv = function(l) {
    var c = l[0], d = l[1] / 100, g = l[2] / 100, y = d, w = Math.max(g, 0.01), b, _;
    return g *= 2, d *= g <= 1 ? g : 2 - g, y *= w <= 1 ? w : 2 - w, _ = (g + d) / 2, b = g === 0 ? 2 * y / (w + y) : 2 * d / (g + d), [c, b * 100, _ * 100];
  }, n.hsv.rgb = function(l) {
    var c = l[0] / 60, d = l[1] / 100, g = l[2] / 100, y = Math.floor(c) % 6, w = c - Math.floor(c), b = 255 * g * (1 - d), _ = 255 * g * (1 - d * w), C = 255 * g * (1 - d * (1 - w));
    switch (g *= 255, y) {
      case 0:
        return [g, C, b];
      case 1:
        return [_, g, b];
      case 2:
        return [b, g, C];
      case 3:
        return [b, _, g];
      case 4:
        return [C, b, g];
      case 5:
        return [g, b, _];
    }
  }, n.hsv.hsl = function(l) {
    var c = l[0], d = l[1] / 100, g = l[2] / 100, y = Math.max(g, 0.01), w, b, _;
    return _ = (2 - d) * g, w = (2 - d) * y, b = d * y, b /= w <= 1 ? w : 2 - w, b = b || 0, _ /= 2, [c, b * 100, _ * 100];
  }, n.hwb.rgb = function(l) {
    var c = l[0] / 360, d = l[1] / 100, g = l[2] / 100, y = d + g, w, b, _, C;
    y > 1 && (d /= y, g /= y), w = Math.floor(6 * c), b = 1 - g, _ = 6 * c - w, (w & 1) !== 0 && (_ = 1 - _), C = d + _ * (b - d);
    var m, T, S;
    switch (w) {
      default:
      case 6:
      case 0:
        m = b, T = C, S = d;
        break;
      case 1:
        m = C, T = b, S = d;
        break;
      case 2:
        m = d, T = b, S = C;
        break;
      case 3:
        m = d, T = C, S = b;
        break;
      case 4:
        m = C, T = d, S = b;
        break;
      case 5:
        m = b, T = d, S = C;
        break;
    }
    return [m * 255, T * 255, S * 255];
  }, n.cmyk.rgb = function(l) {
    var c = l[0] / 100, d = l[1] / 100, g = l[2] / 100, y = l[3] / 100, w, b, _;
    return w = 1 - Math.min(1, c * (1 - y) + y), b = 1 - Math.min(1, d * (1 - y) + y), _ = 1 - Math.min(1, g * (1 - y) + y), [w * 255, b * 255, _ * 255];
  }, n.xyz.rgb = function(l) {
    var c = l[0] / 100, d = l[1] / 100, g = l[2] / 100, y, w, b;
    return y = c * 3.2406 + d * -1.5372 + g * -0.4986, w = c * -0.9689 + d * 1.8758 + g * 0.0415, b = c * 0.0557 + d * -0.204 + g * 1.057, y = y > 31308e-7 ? 1.055 * Math.pow(y, 1 / 2.4) - 0.055 : y * 12.92, w = w > 31308e-7 ? 1.055 * Math.pow(w, 1 / 2.4) - 0.055 : w * 12.92, b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92, y = Math.min(Math.max(0, y), 1), w = Math.min(Math.max(0, w), 1), b = Math.min(Math.max(0, b), 1), [y * 255, w * 255, b * 255];
  }, n.xyz.lab = function(l) {
    var c = l[0], d = l[1], g = l[2], y, w, b;
    return c /= 95.047, d /= 100, g /= 108.883, c = c > 8856e-6 ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116, d = d > 8856e-6 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, g = g > 8856e-6 ? Math.pow(g, 1 / 3) : 7.787 * g + 16 / 116, y = 116 * d - 16, w = 500 * (c - d), b = 200 * (d - g), [y, w, b];
  }, n.lab.xyz = function(l) {
    var c = l[0], d = l[1], g = l[2], y, w, b;
    w = (c + 16) / 116, y = d / 500 + w, b = w - g / 200;
    var _ = Math.pow(w, 3), C = Math.pow(y, 3), m = Math.pow(b, 3);
    return w = _ > 8856e-6 ? _ : (w - 16 / 116) / 7.787, y = C > 8856e-6 ? C : (y - 16 / 116) / 7.787, b = m > 8856e-6 ? m : (b - 16 / 116) / 7.787, y *= 95.047, w *= 100, b *= 108.883, [y, w, b];
  }, n.lab.lch = function(l) {
    var c = l[0], d = l[1], g = l[2], y, w, b;
    return y = Math.atan2(g, d), w = y * 360 / 2 / Math.PI, w < 0 && (w += 360), b = Math.sqrt(d * d + g * g), [c, b, w];
  }, n.lch.lab = function(l) {
    var c = l[0], d = l[1], g = l[2], y, w, b;
    return b = g / 360 * 2 * Math.PI, y = d * Math.cos(b), w = d * Math.sin(b), [c, y, w];
  }, n.rgb.ansi16 = function(l) {
    var c = l[0], d = l[1], g = l[2], y = 1 in arguments ? arguments[1] : n.rgb.hsv(l)[2];
    if (y = Math.round(y / 50), y === 0)
      return 30;
    var w = 30 + (Math.round(g / 255) << 2 | Math.round(d / 255) << 1 | Math.round(c / 255));
    return y === 2 && (w += 60), w;
  }, n.hsv.ansi16 = function(l) {
    return n.rgb.ansi16(n.hsv.rgb(l), l[2]);
  }, n.rgb.ansi256 = function(l) {
    var c = l[0], d = l[1], g = l[2];
    if (c === d && d === g)
      return c < 8 ? 16 : c > 248 ? 231 : Math.round((c - 8) / 247 * 24) + 232;
    var y = 16 + 36 * Math.round(c / 255 * 5) + 6 * Math.round(d / 255 * 5) + Math.round(g / 255 * 5);
    return y;
  }, n.ansi16.rgb = function(l) {
    var c = l % 10;
    if (c === 0 || c === 7)
      return l > 50 && (c += 3.5), c = c / 10.5 * 255, [c, c, c];
    var d = (~~(l > 50) + 1) * 0.5, g = (c & 1) * d * 255, y = (c >> 1 & 1) * d * 255, w = (c >> 2 & 1) * d * 255;
    return [g, y, w];
  }, n.ansi256.rgb = function(l) {
    if (l >= 232) {
      var c = (l - 232) * 10 + 8;
      return [c, c, c];
    }
    l -= 16;
    var d, g = Math.floor(l / 36) / 5 * 255, y = Math.floor((d = l % 36) / 6) / 5 * 255, w = d % 6 / 5 * 255;
    return [g, y, w];
  }, n.rgb.hex = function(l) {
    var c = ((Math.round(l[0]) & 255) << 16) + ((Math.round(l[1]) & 255) << 8) + (Math.round(l[2]) & 255), d = c.toString(16).toUpperCase();
    return "000000".substring(d.length) + d;
  }, n.hex.rgb = function(l) {
    var c = l.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!c)
      return [0, 0, 0];
    var d = c[0];
    c[0].length === 3 && (d = d.split("").map(function(_) {
      return _ + _;
    }).join(""));
    var g = parseInt(d, 16), y = g >> 16 & 255, w = g >> 8 & 255, b = g & 255;
    return [y, w, b];
  }, n.rgb.hcg = function(l) {
    var c = l[0] / 255, d = l[1] / 255, g = l[2] / 255, y = Math.max(Math.max(c, d), g), w = Math.min(Math.min(c, d), g), b = y - w, _, C;
    return b < 1 ? _ = w / (1 - b) : _ = 0, b <= 0 ? C = 0 : y === c ? C = (d - g) / b % 6 : y === d ? C = 2 + (g - c) / b : C = 4 + (c - d) / b + 4, C /= 6, C %= 1, [C * 360, b * 100, _ * 100];
  }, n.hsl.hcg = function(l) {
    var c = l[1] / 100, d = l[2] / 100, g = 1, y = 0;
    return d < 0.5 ? g = 2 * c * d : g = 2 * c * (1 - d), g < 1 && (y = (d - 0.5 * g) / (1 - g)), [l[0], g * 100, y * 100];
  }, n.hsv.hcg = function(l) {
    var c = l[1] / 100, d = l[2] / 100, g = c * d, y = 0;
    return g < 1 && (y = (d - g) / (1 - g)), [l[0], g * 100, y * 100];
  }, n.hcg.rgb = function(l) {
    var c = l[0] / 360, d = l[1] / 100, g = l[2] / 100;
    if (d === 0)
      return [g * 255, g * 255, g * 255];
    var y = [0, 0, 0], w = c % 1 * 6, b = w % 1, _ = 1 - b, C = 0;
    switch (Math.floor(w)) {
      case 0:
        y[0] = 1, y[1] = b, y[2] = 0;
        break;
      case 1:
        y[0] = _, y[1] = 1, y[2] = 0;
        break;
      case 2:
        y[0] = 0, y[1] = 1, y[2] = b;
        break;
      case 3:
        y[0] = 0, y[1] = _, y[2] = 1;
        break;
      case 4:
        y[0] = b, y[1] = 0, y[2] = 1;
        break;
      default:
        y[0] = 1, y[1] = 0, y[2] = _;
    }
    return C = (1 - d) * g, [
      (d * y[0] + C) * 255,
      (d * y[1] + C) * 255,
      (d * y[2] + C) * 255
    ];
  }, n.hcg.hsv = function(l) {
    var c = l[1] / 100, d = l[2] / 100, g = c + d * (1 - c), y = 0;
    return g > 0 && (y = c / g), [l[0], y * 100, g * 100];
  }, n.hcg.hsl = function(l) {
    var c = l[1] / 100, d = l[2] / 100, g = d * (1 - c) + 0.5 * c, y = 0;
    return g > 0 && g < 0.5 ? y = c / (2 * g) : g >= 0.5 && g < 1 && (y = c / (2 * (1 - g))), [l[0], y * 100, g * 100];
  }, n.hcg.hwb = function(l) {
    var c = l[1] / 100, d = l[2] / 100, g = c + d * (1 - c);
    return [l[0], (g - c) * 100, (1 - g) * 100];
  }, n.hwb.hcg = function(l) {
    var c = l[1] / 100, d = l[2] / 100, g = 1 - d, y = g - c, w = 0;
    return y < 1 && (w = (g - y) / (1 - y)), [l[0], y * 100, w * 100];
  }, n.apple.rgb = function(l) {
    return [l[0] / 65535 * 255, l[1] / 65535 * 255, l[2] / 65535 * 255];
  }, n.rgb.apple = function(l) {
    return [l[0] / 255 * 65535, l[1] / 255 * 65535, l[2] / 255 * 65535];
  }, n.gray.rgb = function(l) {
    return [l[0] / 100 * 255, l[0] / 100 * 255, l[0] / 100 * 255];
  }, n.gray.hsl = n.gray.hsv = function(l) {
    return [0, 0, l[0]];
  }, n.gray.hwb = function(l) {
    return [0, 100, l[0]];
  }, n.gray.cmyk = function(l) {
    return [0, 0, 0, l[0]];
  }, n.gray.lab = function(l) {
    return [l[0], 0, 0];
  }, n.gray.hex = function(l) {
    var c = Math.round(l[0] / 100 * 255) & 255, d = (c << 16) + (c << 8) + c, g = d.toString(16).toUpperCase();
    return "000000".substring(g.length) + g;
  }, n.rgb.gray = function(l) {
    var c = (l[0] + l[1] + l[2]) / 3;
    return [c / 255 * 100];
  }, _d.exports;
}
var bd, ow;
function W5() {
  if (ow) return bd;
  ow = 1;
  var r = HC();
  function t() {
    for (var o = {}, s = Object.keys(r), u = s.length, l = 0; l < u; l++)
      o[s[l]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return o;
  }
  function e(o) {
    var s = t(), u = [o];
    for (s[o].distance = 0; u.length; )
      for (var l = u.pop(), c = Object.keys(r[l]), d = c.length, g = 0; g < d; g++) {
        var y = c[g], w = s[y];
        w.distance === -1 && (w.distance = s[l].distance + 1, w.parent = l, u.unshift(y));
      }
    return s;
  }
  function n(o, s) {
    return function(u) {
      return s(o(u));
    };
  }
  function i(o, s) {
    for (var u = [s[o].parent, o], l = r[s[o].parent][o], c = s[o].parent; s[c].parent; )
      u.unshift(s[c].parent), l = n(r[s[c].parent][c], l), c = s[c].parent;
    return l.conversion = u, l;
  }
  return bd = function(o) {
    for (var s = e(o), u = {}, l = Object.keys(s), c = l.length, d = 0; d < c; d++) {
      var g = l[d], y = s[g];
      y.parent !== null && (u[g] = i(g, s));
    }
    return u;
  }, bd;
}
var Td, sw;
function K5() {
  if (sw) return Td;
  sw = 1;
  var r = HC(), t = W5(), e = {}, n = Object.keys(r);
  function i(s) {
    var u = function(l) {
      return l == null ? l : (arguments.length > 1 && (l = Array.prototype.slice.call(arguments)), s(l));
    };
    return "conversion" in s && (u.conversion = s.conversion), u;
  }
  function o(s) {
    var u = function(l) {
      if (l == null)
        return l;
      arguments.length > 1 && (l = Array.prototype.slice.call(arguments));
      var c = s(l);
      if (typeof c == "object")
        for (var d = c.length, g = 0; g < d; g++)
          c[g] = Math.round(c[g]);
      return c;
    };
    return "conversion" in s && (u.conversion = s.conversion), u;
  }
  return n.forEach(function(s) {
    e[s] = {}, Object.defineProperty(e[s], "channels", { value: r[s].channels }), Object.defineProperty(e[s], "labels", { value: r[s].labels });
    var u = t(s), l = Object.keys(u);
    l.forEach(function(c) {
      var d = u[c];
      e[s][c] = o(d), e[s][c].raw = i(d);
    });
  }), Td = e, Td;
}
var Cd, aw;
function J5() {
  if (aw) return Cd;
  aw = 1;
  var r = H5(), t = K5(), e = [].slice, n = [
    // to be honest, I don't really feel like keyword belongs in color convert, but eh.
    "keyword",
    // gray conflicts with some method names, and has its own method defined.
    "gray",
    // shouldn't really be in color-convert either...
    "hex"
  ], i = {};
  Object.keys(t).forEach(function(w) {
    i[e.call(t[w].labels).sort().join("")] = w;
  });
  var o = {};
  function s(w, b) {
    if (!(this instanceof s))
      return new s(w, b);
    if (b && b in n && (b = null), b && !(b in t))
      throw new Error("Unknown model: " + b);
    var _, C;
    if (w == null)
      this.model = "rgb", this.color = [0, 0, 0], this.valpha = 1;
    else if (w instanceof s)
      this.model = w.model, this.color = w.color.slice(), this.valpha = w.valpha;
    else if (typeof w == "string") {
      var m = r.get(w);
      if (m === null)
        throw new Error("Unable to parse color from string: " + w);
      this.model = m.model, C = t[this.model].channels, this.color = m.value.slice(0, C), this.valpha = typeof m.value[C] == "number" ? m.value[C] : 1;
    } else if (w.length) {
      this.model = b || "rgb", C = t[this.model].channels;
      var T = e.call(w, 0, C);
      this.color = y(T, C), this.valpha = typeof w[C] == "number" ? w[C] : 1;
    } else if (typeof w == "number")
      w &= 16777215, this.model = "rgb", this.color = [
        w >> 16 & 255,
        w >> 8 & 255,
        w & 255
      ], this.valpha = 1;
    else {
      this.valpha = 1;
      var S = Object.keys(w);
      "alpha" in w && (S.splice(S.indexOf("alpha"), 1), this.valpha = typeof w.alpha == "number" ? w.alpha : 0);
      var A = S.sort().join("");
      if (!(A in i))
        throw new Error("Unable to parse color from object: " + JSON.stringify(w));
      this.model = i[A];
      var x = t[this.model].labels, D = [];
      for (_ = 0; _ < x.length; _++)
        D.push(w[x[_]]);
      this.color = y(D);
    }
    if (o[this.model])
      for (C = t[this.model].channels, _ = 0; _ < C; _++) {
        var U = o[this.model][_];
        U && (this.color[_] = U(this.color[_]));
      }
    this.valpha = Math.max(0, Math.min(1, this.valpha)), Object.freeze && Object.freeze(this);
  }
  s.prototype = {
    toString: function() {
      return this.string();
    },
    toJSON: function() {
      return this[this.model]();
    },
    string: function(w) {
      var b = this.model in r.to ? this : this.rgb();
      b = b.round(typeof w == "number" ? w : 1);
      var _ = b.valpha === 1 ? b.color : b.color.concat(this.valpha);
      return r.to[b.model](_);
    },
    percentString: function(w) {
      var b = this.rgb().round(typeof w == "number" ? w : 1), _ = b.valpha === 1 ? b.color : b.color.concat(this.valpha);
      return r.to.rgb.percent(_);
    },
    array: function() {
      return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
    },
    object: function() {
      for (var w = {}, b = t[this.model].channels, _ = t[this.model].labels, C = 0; C < b; C++)
        w[_[C]] = this.color[C];
      return this.valpha !== 1 && (w.alpha = this.valpha), w;
    },
    unitArray: function() {
      var w = this.rgb().color;
      return w[0] /= 255, w[1] /= 255, w[2] /= 255, this.valpha !== 1 && w.push(this.valpha), w;
    },
    unitObject: function() {
      var w = this.rgb().object();
      return w.r /= 255, w.g /= 255, w.b /= 255, this.valpha !== 1 && (w.alpha = this.valpha), w;
    },
    round: function(w) {
      return w = Math.max(w || 0, 0), new s(this.color.map(l(w)).concat(this.valpha), this.model);
    },
    alpha: function(w) {
      return arguments.length ? new s(this.color.concat(Math.max(0, Math.min(1, w))), this.model) : this.valpha;
    },
    // rgb
    red: c("rgb", 0, d(255)),
    green: c("rgb", 1, d(255)),
    blue: c("rgb", 2, d(255)),
    hue: c(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(w) {
      return (w % 360 + 360) % 360;
    }),
    // eslint-disable-line brace-style
    saturationl: c("hsl", 1, d(100)),
    lightness: c("hsl", 2, d(100)),
    saturationv: c("hsv", 1, d(100)),
    value: c("hsv", 2, d(100)),
    chroma: c("hcg", 1, d(100)),
    gray: c("hcg", 2, d(100)),
    white: c("hwb", 1, d(100)),
    wblack: c("hwb", 2, d(100)),
    cyan: c("cmyk", 0, d(100)),
    magenta: c("cmyk", 1, d(100)),
    yellow: c("cmyk", 2, d(100)),
    black: c("cmyk", 3, d(100)),
    x: c("xyz", 0, d(100)),
    y: c("xyz", 1, d(100)),
    z: c("xyz", 2, d(100)),
    l: c("lab", 0, d(100)),
    a: c("lab", 1),
    b: c("lab", 2),
    keyword: function(w) {
      return arguments.length ? new s(w) : t[this.model].keyword(this.color);
    },
    hex: function(w) {
      return arguments.length ? new s(w) : r.to.hex(this.rgb().round().color);
    },
    rgbNumber: function() {
      var w = this.rgb().color;
      return (w[0] & 255) << 16 | (w[1] & 255) << 8 | w[2] & 255;
    },
    luminosity: function() {
      for (var w = this.rgb().color, b = [], _ = 0; _ < w.length; _++) {
        var C = w[_] / 255;
        b[_] = C <= 0.03928 ? C / 12.92 : Math.pow((C + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * b[0] + 0.7152 * b[1] + 0.0722 * b[2];
    },
    contrast: function(w) {
      var b = this.luminosity(), _ = w.luminosity();
      return b > _ ? (b + 0.05) / (_ + 0.05) : (_ + 0.05) / (b + 0.05);
    },
    level: function(w) {
      var b = this.contrast(w);
      return b >= 7.1 ? "AAA" : b >= 4.5 ? "AA" : "";
    },
    isDark: function() {
      var w = this.rgb().color, b = (w[0] * 299 + w[1] * 587 + w[2] * 114) / 1e3;
      return b < 128;
    },
    isLight: function() {
      return !this.isDark();
    },
    negate: function() {
      for (var w = this.rgb(), b = 0; b < 3; b++)
        w.color[b] = 255 - w.color[b];
      return w;
    },
    lighten: function(w) {
      var b = this.hsl();
      return b.color[2] += b.color[2] * w, b;
    },
    darken: function(w) {
      var b = this.hsl();
      return b.color[2] -= b.color[2] * w, b;
    },
    saturate: function(w) {
      var b = this.hsl();
      return b.color[1] += b.color[1] * w, b;
    },
    desaturate: function(w) {
      var b = this.hsl();
      return b.color[1] -= b.color[1] * w, b;
    },
    whiten: function(w) {
      var b = this.hwb();
      return b.color[1] += b.color[1] * w, b;
    },
    blacken: function(w) {
      var b = this.hwb();
      return b.color[2] += b.color[2] * w, b;
    },
    grayscale: function() {
      var w = this.rgb().color, b = w[0] * 0.3 + w[1] * 0.59 + w[2] * 0.11;
      return s.rgb(b, b, b);
    },
    fade: function(w) {
      return this.alpha(this.valpha - this.valpha * w);
    },
    opaquer: function(w) {
      return this.alpha(this.valpha + this.valpha * w);
    },
    rotate: function(w) {
      var b = this.hsl(), _ = b.color[0];
      return _ = (_ + w) % 360, _ = _ < 0 ? 360 + _ : _, b.color[0] = _, b;
    },
    mix: function(w, b) {
      if (!w || !w.rgb)
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof w);
      var _ = w.rgb(), C = this.rgb(), m = b === void 0 ? 0.5 : b, T = 2 * m - 1, S = _.alpha() - C.alpha(), A = ((T * S === -1 ? T : (T + S) / (1 + T * S)) + 1) / 2, x = 1 - A;
      return s.rgb(
        A * _.red() + x * C.red(),
        A * _.green() + x * C.green(),
        A * _.blue() + x * C.blue(),
        _.alpha() * m + C.alpha() * (1 - m)
      );
    }
  }, Object.keys(t).forEach(function(w) {
    if (n.indexOf(w) === -1) {
      var b = t[w].channels;
      s.prototype[w] = function() {
        if (this.model === w)
          return new s(this);
        if (arguments.length)
          return new s(arguments, w);
        var _ = typeof arguments[b] == "number" ? b : this.valpha;
        return new s(g(t[this.model][w].raw(this.color)).concat(_), w);
      }, s[w] = function(_) {
        return typeof _ == "number" && (_ = y(e.call(arguments), b)), new s(_, w);
      };
    }
  });
  function u(w, b) {
    return Number(w.toFixed(b));
  }
  function l(w) {
    return function(b) {
      return u(b, w);
    };
  }
  function c(w, b, _) {
    return w = Array.isArray(w) ? w : [w], w.forEach(function(C) {
      (o[C] || (o[C] = []))[b] = _;
    }), w = w[0], function(C) {
      var m;
      return arguments.length ? (_ && (C = _(C)), m = this[w](), m.color[b] = C, m) : (m = this[w]().color[b], _ && (m = _(m)), m);
    };
  }
  function d(w) {
    return function(b) {
      return Math.max(0, Math.min(w, b));
    };
  }
  function g(w) {
    return Array.isArray(w) ? w : [w];
  }
  function y(w, b) {
    for (var _ = 0; _ < b; _++)
      typeof w[_] != "number" && (w[_] = 0);
    return w;
  }
  return Cd = s, Cd;
}
var Sd, lw;
function z5() {
  return lw || (lw = 1, Sd = function(t) {
    for (var e = 0, n = 0; e < t.length; n = t.charCodeAt(e++) + ((n << 5) - n)) ;
    var i = Math.floor(
      Math.abs(
        Math.sin(n) * 1e4 % 1 * 16777216
      )
    ).toString(16);
    return "#" + Array(6 - i.length + 1).join("0") + i;
  }), Sd;
}
var Ed, uw;
function Y5() {
  if (uw) return Ed;
  uw = 1;
  var r = J5(), t = z5();
  return Ed = function(n, i) {
    var o = n.split(i || ":"), s = t(o[0]);
    if (!o.length) return s;
    for (var u = 0, l = o.length - 1; u < l; u++)
      s = r(s).mix(r(t(o[u + 1]))).saturate(1).hex();
    return s;
  }, Ed;
}
var Ad, cw;
function Z5() {
  if (cw) return Ad;
  cw = 1;
  var r = Y5();
  return Ad = function(e, n) {
    var i = n.namespace;
    if (n.colors === !1)
      return e[0] = i + ": " + e[0], e;
    var o = r(i);
    return e[0] = "%c" + i + ":%c " + e[0], e.splice(1, 0, "color:" + o, "color:inherit"), e;
  }, Ad;
}
var xd, fw;
function j5() {
  return fw || (fw = 1, xd = function(t, e) {
    if (!e) return !1;
    for (var n = e.split(/[\s,]+/), i = 0; i < n.length; i++) {
      if (e = n[i].replace("*", ".*?"), e.charAt(0) === "-") {
        if (new RegExp("^" + e.substr(1) + "$").test(t))
          return !1;
        continue;
      }
      if (new RegExp("^" + e + "$").test(t))
        return !0;
    }
    return !1;
  }), xd;
}
var Rd, dw;
function GC() {
  if (dw) return Rd;
  dw = 1;
  var r = j5();
  return Rd = function(e) {
    return function(i) {
      try {
        return r(i, e());
      } catch {
      }
      return !1;
    };
  }, Rd;
}
var Id, hw;
function Q5() {
  if (hw) return Id;
  hw = 1;
  var r = GC();
  return Id = r(function() {
    return localStorage.getItem("debug") || localStorage.getItem("diagnostics");
  }), Id;
}
var Md, pw;
function X5() {
  if (pw) return Md;
  pw = 1;
  var r = GC();
  return Md = r(function() {
    return /(debug|diagnostics)=([^&]+)/i.exec(window.location.hash)[2];
  }), Md;
}
var kd, mw;
function eH() {
  return mw || (mw = 1, kd = function(r, t) {
    try {
      Function.prototype.apply.call(console.log, console, t);
    } catch {
    }
  }), kd;
}
var Pd, gw;
function tH() {
  if (gw) return Pd;
  gw = 1;
  var r = VC(), t = r(function e(n, i) {
    return i = i || {}, i.namespace = n, i.prod = !1, i.dev = !0, !e.enabled(n) && !(i.force || e.force) ? e.nope(i) : e.yep(i);
  });
  return t.modify(Z5()), t.use(Q5()), t.use(X5()), t.set(eH()), Pd = t, Pd;
}
var yw;
function ku() {
  return yw || (yw = 1, process.env.NODE_ENV === "production" ? sl.exports = q5() : sl.exports = tH()), sl.exports;
}
var Od, vw;
function nH() {
  if (vw) return Od;
  vw = 1;
  var r = uo, t = uP, e = t.StringDecoder, n = xo(), i = n.Stream;
  function o() {
  }
  return Od = function(s, u) {
    var l = Buffer.alloc(65536), c = new e("utf8"), d = new i(), g = "", y = 0, w = 0;
    return s.start === -1 && delete s.start, d.readable = !0, d.destroy = function() {
      d.destroyed = !0, d.emit("end"), d.emit("close");
    }, r.open(s.file, "a+", "0644", function(b, _) {
      if (b) {
        u ? u(b) : d.emit("error", b), d.destroy();
        return;
      }
      (function C() {
        if (d.destroyed) {
          r.close(_, o);
          return;
        }
        return r.read(_, l, 0, l.length, y, function(m, T) {
          if (m) {
            u ? u(m) : d.emit("error", m), d.destroy();
            return;
          }
          if (!T)
            return g && ((s.start == null || w > s.start) && (u ? u(null, g) : d.emit("line", g)), w++, g = ""), setTimeout(C, 1e3);
          var S = c.write(l.slice(0, T));
          u || d.emit("data", S), S = (g + S).split(/\n+/);
          for (var A = S.length - 1, x = 0; x < A; x++)
            (s.start == null || w > s.start) && (u ? u(null, S[x]) : d.emit("line", S[x])), w++;
          return g = S[A], y += T, C();
        });
      })();
    }), u ? d.destroy : d;
  }, Od;
}
var Ld, _w;
function rH() {
  if (_w) return Ld;
  _w = 1;
  function r(H) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
      return typeof V;
    } : function(V) {
      return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V;
    }, r(H);
  }
  function t(H, V) {
    if (!(H instanceof V)) throw new TypeError("Cannot call a class as a function");
  }
  function e(H, V) {
    for (var N = 0; N < V.length; N++) {
      var $ = V[N];
      $.enumerable = $.enumerable || !1, $.configurable = !0, "value" in $ && ($.writable = !0), Object.defineProperty(H, i($.key), $);
    }
  }
  function n(H, V, N) {
    return V && e(H.prototype, V), Object.defineProperty(H, "prototype", { writable: !1 }), H;
  }
  function i(H) {
    var V = o(H, "string");
    return r(V) == "symbol" ? V : V + "";
  }
  function o(H, V) {
    if (r(H) != "object" || !H) return H;
    var N = H[Symbol.toPrimitive];
    if (N !== void 0) {
      var $ = N.call(H, V);
      if (r($) != "object") return $;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(H);
  }
  function s(H, V, N) {
    return V = d(V), u(H, c() ? Reflect.construct(V, N || [], d(H).constructor) : V.apply(H, N));
  }
  function u(H, V) {
    if (V && (r(V) == "object" || typeof V == "function")) return V;
    if (V !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return l(H);
  }
  function l(H) {
    if (H === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return H;
  }
  function c() {
    try {
      var H = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (c = function() {
      return !!H;
    })();
  }
  function d(H) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(V) {
      return V.__proto__ || Object.getPrototypeOf(V);
    }, d(H);
  }
  function g(H, V) {
    if (typeof V != "function" && V !== null) throw new TypeError("Super expression must either be null or a function");
    H.prototype = Object.create(V && V.prototype, { constructor: { value: H, writable: !0, configurable: !0 } }), Object.defineProperty(H, "prototype", { writable: !1 }), V && y(H, V);
  }
  function y(H, V) {
    return y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(N, $) {
      return N.__proto__ = $, N;
    }, y(H, V);
  }
  var w = uo, b = Je, _ = F5(), C = lP, m = bt(), T = m.MESSAGE, S = xo(), A = S.Stream, x = S.PassThrough, D = Ms(), U = ku()("winston:file"), O = gr, k = nH();
  return Ld = /* @__PURE__ */ function(H) {
    function V() {
      var N, $ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t(this, V), N = s(this, V, [$]), N.name = $.name || "file";
      function j(K) {
        for (var P = arguments.length, I = new Array(P > 1 ? P - 1 : 0), B = 1; B < P; B++)
          I[B - 1] = arguments[B];
        I.slice(1).forEach(function(W) {
          if ($[W])
            throw new Error("Cannot set ".concat(W, " and ").concat(K, " together"));
        });
      }
      if (N._stream = new x(), N._stream.setMaxListeners(30), N._onError = N._onError.bind(N), $.filename || $.dirname)
        j("filename or dirname", "stream"), N._basename = N.filename = $.filename ? b.basename($.filename) : "winston.log", N.dirname = $.dirname || b.dirname($.filename), N.options = $.options || {
          flags: "a"
        };
      else if ($.stream)
        console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream"), j("stream", "filename", "maxsize"), N._dest = N._stream.pipe(N._setupStream($.stream)), N.dirname = b.dirname(N._dest.path);
      else
        throw new Error("Cannot log to file without filename or stream.");
      return N.maxsize = $.maxsize || null, N.rotationFormat = $.rotationFormat || !1, N.zippedArchive = $.zippedArchive || !1, N.maxFiles = $.maxFiles || null, N.eol = typeof $.eol == "string" ? $.eol : O.EOL, N.tailable = $.tailable || !1, N.lazy = $.lazy || !1, N._size = 0, N._pendingSize = 0, N._created = 0, N._drain = !1, N._opening = !1, N._ending = !1, N._fileExist = !1, N.dirname && N._createLogDirIfNotExist(N.dirname), N.lazy || N.open(), N;
    }
    return g(V, H), n(V, [{
      key: "finishIfEnding",
      value: function() {
        var $ = this;
        this._ending && (this._opening ? this.once("open", function() {
          $._stream.once("finish", function() {
            return $.emit("finish");
          }), setImmediate(function() {
            return $._stream.end();
          });
        }) : (this._stream.once("finish", function() {
          return $.emit("finish");
        }), setImmediate(function() {
          return $._stream.end();
        })));
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
    }, {
      key: "log",
      value: function($) {
        var j = this, K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        };
        if (this.silent)
          return K(), !0;
        if (this._drain) {
          this._stream.once("drain", function() {
            j._drain = !1, j.log($, K);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", function() {
            j._rotate = !1, j.log($, K);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            this._opening || this.open(), this.once("open", function() {
              j._fileExist = !0, j.log($, K);
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", function() {
              j._opening || j.open(), j.once("open", function() {
                j.log($, K);
              });
            });
            return;
          }
        }
        var P = "".concat($[T]).concat(this.eol), I = Buffer.byteLength(P);
        function B() {
          var z = this;
          if (this._size += I, this._pendingSize -= I, U("logged %s %s", this._size, P), this.emit("logged", $), !this._rotate && !this._opening && this._needsNewFile()) {
            if (this.lazy) {
              this._endStream(function() {
                z.emit("fileclosed");
              });
              return;
            }
            this._rotate = !0, this._endStream(function() {
              return z._rotateFile();
            });
          }
        }
        this._pendingSize += I, this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize) && (this.rotatedWhileOpening = !0);
        var W = this._stream.write(P, B.bind(this));
        return W ? K() : (this._drain = !0, this._stream.once("drain", function() {
          j._drain = !1, K();
        })), U("written", W, this._drain), this.finishIfEnding(), W;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
    }, {
      key: "query",
      value: function($, j) {
        typeof $ == "function" && (j = $, $ = {}), $ = ce($);
        var K = b.join(this.dirname, this.filename), P = "", I = [], B = 0, W = w.createReadStream(K, {
          encoding: "utf8"
        });
        W.on("error", function(te) {
          if (W.readable && W.destroy(), !!j)
            return te.code !== "ENOENT" ? j(te) : j(null, I);
        }), W.on("data", function(te) {
          te = (P + te).split(/\n+/);
          for (var fe = te.length - 1, Y = 0; Y < fe; Y++)
            (!$.start || B >= $.start) && z(te[Y]), B++;
          P = te[fe];
        }), W.on("close", function() {
          P && z(P, !0), $.order === "desc" && (I = I.reverse()), j && j(null, I);
        });
        function z(te, fe) {
          try {
            var Y = JSON.parse(te);
            ne(Y) && ee(Y);
          } catch (Z) {
            fe || W.emit("error", Z);
          }
        }
        function ee(te) {
          if ($.rows && I.length >= $.rows && $.order !== "desc") {
            W.readable && W.destroy();
            return;
          }
          $.fields && (te = $.fields.reduce(function(fe, Y) {
            return fe[Y] = te[Y], fe;
          }, {})), $.order === "desc" && I.length >= $.rows && I.shift(), I.push(te);
        }
        function ne(te) {
          if (te && r(te) === "object") {
            var fe = new Date(te.timestamp);
            if (!($.from && fe < $.from || $.until && fe > $.until || $.level && $.level !== te.level))
              return !0;
          }
        }
        function ce(te) {
          return te = te || {}, te.rows = te.rows || te.limit || 10, te.start = te.start || 0, te.until = te.until || /* @__PURE__ */ new Date(), r(te.until) !== "object" && (te.until = new Date(te.until)), te.from = te.from || te.until - 24 * 60 * 60 * 1e3, r(te.from) !== "object" && (te.from = new Date(te.from)), te.order = te.order || "desc", te;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
    }, {
      key: "stream",
      value: function() {
        var $ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, j = b.join(this.dirname, this.filename), K = new A(), P = {
          file: j,
          start: $.start
        };
        return K.destroy = k(P, function(I, B) {
          if (I)
            return K.emit("error", I);
          try {
            K.emit("data", B), B = JSON.parse(B), K.emit("log", B);
          } catch (W) {
            K.emit("error", W);
          }
        }), K;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
    }, {
      key: "open",
      value: function() {
        var $ = this;
        this.filename && (this._opening || (this._opening = !0, this.stat(function(j, K) {
          if (j)
            return $.emit("error", j);
          U("stat done: %s { size: %s }", $.filename, K), $._size = K, $._dest = $._createStream($._stream), $._opening = !1, $.once("open", function() {
            $._stream.emit("rotate") || ($._rotate = !1);
          });
        })));
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
    }, {
      key: "stat",
      value: function($) {
        var j = this, K = this._getFile(), P = b.join(this.dirname, K);
        w.stat(P, function(I, B) {
          if (I && I.code === "ENOENT")
            return U("ENOENTok", P), j.filename = K, $(null, 0);
          if (I)
            return U("err ".concat(I.code, " ").concat(P)), $(I);
          if (!B || j._needsNewFile(B.size))
            return j._incFile(function() {
              return j.stat($);
            });
          j.filename = K, $(null, B.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
    }, {
      key: "close",
      value: function($) {
        var j = this;
        this._stream && this._stream.end(function() {
          $ && $(), j.emit("flush"), j.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
    }, {
      key: "_needsNewFile",
      value: function($) {
        return $ = $ || this._size, this.maxsize && $ >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
    }, {
      key: "_onError",
      value: function($) {
        this.emit("error", $);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "_setupStream",
      value: function($) {
        return $.on("error", this._onError), $;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "_cleanupStream",
      value: function($) {
        return $.removeListener("error", this._onError), $.destroy(), $;
      }
      /**
       * TODO: add method description.
       */
    }, {
      key: "_rotateFile",
      value: function() {
        var $ = this;
        this._incFile(function() {
          return $.open();
        });
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
    }, {
      key: "_endStream",
      value: function() {
        var $ = this, j = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
        };
        this._dest ? (this._stream.unpipe(this._dest), this._dest.end(function() {
          $._cleanupStream($._dest), j();
        })) : j();
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
    }, {
      key: "_createStream",
      value: function($) {
        var j = this, K = b.join(this.dirname, this.filename);
        U("create stream start", K, this.options);
        var P = w.createWriteStream(K, this.options).on("error", function(I) {
          return U(I);
        }).on("close", function() {
          return U("close", P.path, P.bytesWritten);
        }).on("open", function() {
          U("file open ok", K), j.emit("open", K), $.pipe(P), j.rotatedWhileOpening && (j._stream = new x(), j._stream.setMaxListeners(30), j._rotateFile(), j.rotatedWhileOpening = !1, j._cleanupStream(P), $.end());
        });
        return U("create stream ok", K), P;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
    }, {
      key: "_incFile",
      value: function($) {
        U("_incFile", this.filename);
        var j = b.extname(this._basename), K = b.basename(this._basename, j), P = [];
        this.zippedArchive && P.push(function(I) {
          var B = this._created > 0 && !this.tailable ? this._created : "";
          this._compressFile(b.join(this.dirname, "".concat(K).concat(B).concat(j)), b.join(this.dirname, "".concat(K).concat(B).concat(j, ".gz")), I);
        }.bind(this)), P.push(function(I) {
          this.tailable ? this._checkMaxFilesTailable(j, K, I) : (this._created += 1, this._checkMaxFilesIncrementing(j, K, I));
        }.bind(this)), _(P, $);
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
    }, {
      key: "_getFile",
      value: function() {
        var $ = b.extname(this._basename), j = b.basename(this._basename, $), K = this.rotationFormat ? this.rotationFormat() : this._created;
        return !this.tailable && this._created ? "".concat(j).concat(K).concat($) : "".concat(j).concat($);
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
    }, {
      key: "_checkMaxFilesIncrementing",
      value: function($, j, K) {
        if (!this.maxFiles || this._created < this.maxFiles)
          return setImmediate(K);
        var P = this._created - this.maxFiles, I = P !== 0 ? P : "", B = this.zippedArchive ? ".gz" : "", W = "".concat(j).concat(I).concat($).concat(B), z = b.join(this.dirname, W);
        w.unlink(z, K);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
    }, {
      key: "_checkMaxFilesTailable",
      value: function($, j, K) {
        var P = this, I = [];
        if (this.maxFiles) {
          for (var B = this.zippedArchive ? ".gz" : "", W = this.maxFiles - 1; W > 1; W--)
            I.push(function(z, ee) {
              var ne = this, ce = "".concat(j).concat(z - 1).concat($).concat(B), te = b.join(this.dirname, ce);
              w.exists(te, function(fe) {
                if (!fe)
                  return ee(null);
                ce = "".concat(j).concat(z).concat($).concat(B), w.rename(te, b.join(ne.dirname, ce), ee);
              });
            }.bind(this, W));
          _(I, function() {
            w.rename(b.join(P.dirname, "".concat(j).concat($).concat(B)), b.join(P.dirname, "".concat(j, "1").concat($).concat(B)), K);
          });
        }
      }
      /**
       * Compresses src to dest with gzip and unlinks src
       * @param {string} src - path to source file.
       * @param {string} dest - path to zipped destination file.
       * @param {Function} callback - callback called after file has been compressed.
       * @returns {undefined}
       * @private
       */
    }, {
      key: "_compressFile",
      value: function($, j, K) {
        w.access($, w.F_OK, function(P) {
          if (P)
            return K();
          var I = C.createGzip(), B = w.createReadStream($), W = w.createWriteStream(j);
          W.on("finish", function() {
            w.unlink($, K);
          }), B.pipe(I).pipe(W);
        });
      }
    }, {
      key: "_createLogDirIfNotExist",
      value: function($) {
        w.existsSync($) || w.mkdirSync($, {
          recursive: !0
        });
      }
    }]);
  }(D), Ld;
}
var Nd, ww;
function iH() {
  if (ww) return Nd;
  ww = 1;
  function r(U) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(O) {
      return typeof O;
    } : function(O) {
      return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
    }, r(U);
  }
  function t(U, O) {
    var k = Object.keys(U);
    if (Object.getOwnPropertySymbols) {
      var H = Object.getOwnPropertySymbols(U);
      O && (H = H.filter(function(V) {
        return Object.getOwnPropertyDescriptor(U, V).enumerable;
      })), k.push.apply(k, H);
    }
    return k;
  }
  function e(U) {
    for (var O = 1; O < arguments.length; O++) {
      var k = arguments[O] != null ? arguments[O] : {};
      O % 2 ? t(Object(k), !0).forEach(function(H) {
        n(U, H, k[H]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(U, Object.getOwnPropertyDescriptors(k)) : t(Object(k)).forEach(function(H) {
        Object.defineProperty(U, H, Object.getOwnPropertyDescriptor(k, H));
      });
    }
    return U;
  }
  function n(U, O, k) {
    return (O = u(O)) in U ? Object.defineProperty(U, O, { value: k, enumerable: !0, configurable: !0, writable: !0 }) : U[O] = k, U;
  }
  function i(U, O) {
    if (!(U instanceof O)) throw new TypeError("Cannot call a class as a function");
  }
  function o(U, O) {
    for (var k = 0; k < O.length; k++) {
      var H = O[k];
      H.enumerable = H.enumerable || !1, H.configurable = !0, "value" in H && (H.writable = !0), Object.defineProperty(U, u(H.key), H);
    }
  }
  function s(U, O, k) {
    return O && o(U.prototype, O), Object.defineProperty(U, "prototype", { writable: !1 }), U;
  }
  function u(U) {
    var O = l(U, "string");
    return r(O) == "symbol" ? O : O + "";
  }
  function l(U, O) {
    if (r(U) != "object" || !U) return U;
    var k = U[Symbol.toPrimitive];
    if (k !== void 0) {
      var H = k.call(U, O);
      if (r(H) != "object") return H;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(U);
  }
  function c(U, O, k) {
    return O = w(O), d(U, y() ? Reflect.construct(O, k || [], w(U).constructor) : O.apply(U, k));
  }
  function d(U, O) {
    if (O && (r(O) == "object" || typeof O == "function")) return O;
    if (O !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return g(U);
  }
  function g(U) {
    if (U === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return U;
  }
  function y() {
    try {
      var U = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (y = function() {
      return !!U;
    })();
  }
  function w(U) {
    return w = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(O) {
      return O.__proto__ || Object.getPrototypeOf(O);
    }, w(U);
  }
  function b(U, O) {
    if (typeof O != "function" && O !== null) throw new TypeError("Super expression must either be null or a function");
    U.prototype = Object.create(O && O.prototype, { constructor: { value: U, writable: !0, configurable: !0 } }), Object.defineProperty(U, "prototype", { writable: !1 }), O && _(U, O);
  }
  function _(U, O) {
    return _ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(k, H) {
      return k.__proto__ = H, k;
    }, _(U, O);
  }
  var C = cP, m = fP, T = xo(), S = T.Stream, A = Ms(), x = Rs(), D = x.configure;
  return Nd = /* @__PURE__ */ function(U) {
    function O() {
      var k, H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return i(this, O), k = c(this, O, [H]), k.options = H, k.name = H.name || "http", k.ssl = !!H.ssl, k.host = H.host || "localhost", k.port = H.port, k.auth = H.auth, k.path = H.path || "", k.maximumDepth = H.maximumDepth, k.agent = H.agent, k.headers = H.headers || {}, k.headers["content-type"] = "application/json", k.batch = H.batch || !1, k.batchInterval = H.batchInterval || 5e3, k.batchCount = H.batchCount || 10, k.batchOptions = [], k.batchTimeoutID = -1, k.batchCallback = {}, k.port || (k.port = k.ssl ? 443 : 80), k;
    }
    return b(O, U), s(O, [{
      key: "log",
      value: function(H, V) {
        var N = this;
        this._request(H, null, null, function($, j) {
          j && j.statusCode !== 200 && ($ = new Error("Invalid HTTP Status Code: ".concat(j.statusCode))), $ ? N.emit("warn", $) : N.emit("logged", H);
        }), V && setImmediate(V);
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
    }, {
      key: "query",
      value: function(H, V) {
        typeof H == "function" && (V = H, H = {}), H = {
          method: "query",
          params: this.normalizeQuery(H)
        };
        var N = H.params.auth || null;
        delete H.params.auth;
        var $ = H.params.path || null;
        delete H.params.path, this._request(H, N, $, function(j, K, P) {
          if (K && K.statusCode !== 200 && (j = new Error("Invalid HTTP Status Code: ".concat(K.statusCode))), j)
            return V(j);
          if (typeof P == "string")
            try {
              P = JSON.parse(P);
            } catch (I) {
              return V(I);
            }
          V(null, P);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
    }, {
      key: "stream",
      value: function() {
        var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, V = new S();
        H = {
          method: "stream",
          params: H
        };
        var N = H.params.path || null;
        delete H.params.path;
        var $ = H.params.auth || null;
        delete H.params.auth;
        var j = "", K = this._request(H, $, N);
        return V.destroy = function() {
          return K.destroy();
        }, K.on("data", function(P) {
          P = (j + P).split(/\n+/);
          for (var I = P.length - 1, B = 0; B < I; B++)
            try {
              V.emit("log", JSON.parse(P[B]));
            } catch (W) {
              V.emit("error", W);
            }
          j = P[I];
        }), K.on("error", function(P) {
          return V.emit("error", P);
        }), V;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       * @param {function} callback - Continuation to respond to when complete.
       */
    }, {
      key: "_request",
      value: function(H, V, N, $) {
        H = H || {}, V = V || this.auth, N = N || this.path || "", this.batch ? this._doBatch(H, $, V, N) : this._doRequest(H, $, V, N);
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
    }, {
      key: "_doBatch",
      value: function(H, V, N, $) {
        if (this.batchOptions.push(H), this.batchOptions.length === 1) {
          var j = this;
          this.batchCallback = V, this.batchTimeoutID = setTimeout(function() {
            j.batchTimeoutID = -1, j._doBatchRequest(j.batchCallback, N, $);
          }, this.batchInterval);
        }
        this.batchOptions.length === this.batchCount && this._doBatchRequest(this.batchCallback, N, $);
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
    }, {
      key: "_doBatchRequest",
      value: function(H, V, N) {
        this.batchTimeoutID > 0 && (clearTimeout(this.batchTimeoutID), this.batchTimeoutID = -1);
        var $ = this.batchOptions.slice();
        this.batchOptions = [], this._doRequest($, H, V, N);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
    }, {
      key: "_doRequest",
      value: function(H, V, N, $) {
        var j = Object.assign({}, this.headers);
        N && N.bearer && (j.Authorization = "Bearer ".concat(N.bearer));
        var K = (this.ssl ? m : C).request(e(e({}, this.options), {}, {
          method: "POST",
          host: this.host,
          port: this.port,
          path: "/".concat($.replace(/^\//, "")),
          headers: j,
          auth: N && N.username && N.password ? "".concat(N.username, ":").concat(N.password) : "",
          agent: this.agent
        }));
        K.on("error", V), K.on("response", function(I) {
          return I.on("end", function() {
            return V(null, I);
          }).resume();
        });
        var P = D(e({}, this.maximumDepth && {
          maximumDepth: this.maximumDepth
        }));
        K.end(Buffer.from(P(H, this.options.replacer), "utf8"));
      }
    }]);
  }(A), Nd;
}
var Dd, bw;
function WC() {
  if (bw) return Dd;
  bw = 1;
  const r = (t) => t !== null && typeof t == "object" && typeof t.pipe == "function";
  return r.writable = (t) => r(t) && t.writable !== !1 && typeof t._write == "function" && typeof t._writableState == "object", r.readable = (t) => r(t) && t.readable !== !1 && typeof t._read == "function" && typeof t._readableState == "object", r.duplex = (t) => r.writable(t) && r.readable(t), r.transform = (t) => r.duplex(t) && typeof t._transform == "function", Dd = r, Dd;
}
var Fd, Tw;
function oH() {
  if (Tw) return Fd;
  Tw = 1;
  function r(T) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
      return typeof S;
    } : function(S) {
      return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
    }, r(T);
  }
  function t(T, S) {
    if (!(T instanceof S)) throw new TypeError("Cannot call a class as a function");
  }
  function e(T, S) {
    for (var A = 0; A < S.length; A++) {
      var x = S[A];
      x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(T, i(x.key), x);
    }
  }
  function n(T, S, A) {
    return S && e(T.prototype, S), Object.defineProperty(T, "prototype", { writable: !1 }), T;
  }
  function i(T) {
    var S = o(T, "string");
    return r(S) == "symbol" ? S : S + "";
  }
  function o(T, S) {
    if (r(T) != "object" || !T) return T;
    var A = T[Symbol.toPrimitive];
    if (A !== void 0) {
      var x = A.call(T, S);
      if (r(x) != "object") return x;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(T);
  }
  function s(T, S, A) {
    return S = d(S), u(T, c() ? Reflect.construct(S, A || [], d(T).constructor) : S.apply(T, A));
  }
  function u(T, S) {
    if (S && (r(S) == "object" || typeof S == "function")) return S;
    if (S !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return l(T);
  }
  function l(T) {
    if (T === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return T;
  }
  function c() {
    try {
      var T = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (c = function() {
      return !!T;
    })();
  }
  function d(T) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(S) {
      return S.__proto__ || Object.getPrototypeOf(S);
    }, d(T);
  }
  function g(T, S) {
    if (typeof S != "function" && S !== null) throw new TypeError("Super expression must either be null or a function");
    T.prototype = Object.create(S && S.prototype, { constructor: { value: T, writable: !0, configurable: !0 } }), Object.defineProperty(T, "prototype", { writable: !1 }), S && y(T, S);
  }
  function y(T, S) {
    return y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(A, x) {
      return A.__proto__ = x, A;
    }, y(T, S);
  }
  var w = WC(), b = bt(), _ = b.MESSAGE, C = gr, m = Ms();
  return Fd = /* @__PURE__ */ function(T) {
    function S() {
      var A, x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (t(this, S), A = s(this, S, [x]), !x.stream || !w(x.stream))
        throw new Error("options.stream is required.");
      return A._stream = x.stream, A._stream.setMaxListeners(1 / 0), A.isObjectMode = x.stream._writableState.objectMode, A.eol = typeof x.eol == "string" ? x.eol : C.EOL, A;
    }
    return g(S, T), n(S, [{
      key: "log",
      value: function(x, D) {
        var U = this;
        if (setImmediate(function() {
          return U.emit("logged", x);
        }), this.isObjectMode) {
          this._stream.write(x), D && D();
          return;
        }
        this._stream.write("".concat(x[_]).concat(this.eol)), D && D();
      }
    }]);
  }(m), Fd;
}
var Cw;
function sH() {
  return Cw || (Cw = 1, function(r) {
    Object.defineProperty(r, "Console", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return x5();
      }
    }), Object.defineProperty(r, "File", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return rH();
      }
    }), Object.defineProperty(r, "Http", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return iH();
      }
    }), Object.defineProperty(r, "Stream", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return oH();
      }
    });
  }(zf)), zf;
}
var Vi = {}, Sw;
function Dp() {
  if (Sw) return Vi;
  Sw = 1;
  var r = kC(), t = bt(), e = t.configs;
  return Vi.cli = r.levels(e.cli), Vi.npm = r.levels(e.npm), Vi.syslog = r.levels(e.syslog), Vi.addColors = r.levels, Vi;
}
var al = { exports: {} }, ll = { exports: {} }, Ew;
function aH() {
  return Ew || (Ew = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var e = Lp(), n = C(e), i = Np(), o = C(i), s = qC(), u = C(s), l = $C(), c = C(l), d = UC(), g = C(d), y = Ao(), w = C(y), b = ks(), _ = C(b);
    function C(A) {
      return A && A.__esModule ? A : { default: A };
    }
    function m(A, x, D) {
      D = (0, c.default)(D);
      var U = 0, O = 0, { length: k } = A, H = !1;
      k === 0 && D(null);
      function V(N, $) {
        N === !1 && (H = !0), H !== !0 && (N ? D(N) : (++O === k || $ === o.default) && D(null));
      }
      for (; U < k; U++)
        x(A[U], U, (0, g.default)(V));
    }
    function T(A, x, D) {
      return (0, u.default)(A, 1 / 0, x, D);
    }
    function S(A, x, D) {
      var U = (0, n.default)(A) ? m : T;
      return U(A, (0, w.default)(x), D);
    }
    t.default = (0, _.default)(S, 3), r.exports = t.default;
  }(ll, ll.exports)), ll.exports;
}
var ul = { exports: {} }, Aw;
function lH() {
  return Aw || (Aw = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = e;
    function e(n) {
      return (i, o, s) => n(i, s);
    }
    r.exports = t.default;
  }(ul, ul.exports)), ul.exports;
}
var xw;
function Fp() {
  return xw || (xw = 1, function(r, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var e = aH(), n = d(e), i = lH(), o = d(i), s = Ao(), u = d(s), l = ks(), c = d(l);
    function d(y) {
      return y && y.__esModule ? y : { default: y };
    }
    function g(y, w, b) {
      return (0, n.default)(y, (0, o.default)((0, u.default)(w)), b);
    }
    t.default = (0, c.default)(g, 3), r.exports = t.default;
  }(al, al.exports)), al.exports;
}
var $d, Rw;
function uH() {
  if (Rw) return $d;
  Rw = 1;
  var r = Object.prototype.toString;
  return $d = function(e) {
    if (typeof e.displayName == "string" && e.constructor.name)
      return e.displayName;
    if (typeof e.name == "string" && e.name)
      return e.name;
    if (typeof e == "object" && e.constructor && typeof e.constructor.name == "string") return e.constructor.name;
    var n = e.toString(), i = r.call(e).slice(8, -1);
    return i === "Function" ? n = n.substring(n.indexOf("(") + 1, n.indexOf(")")) : n = i, n || "anonymous";
  }, $d;
}
var Ud, Iw;
function KC() {
  if (Iw) return Ud;
  Iw = 1;
  var r = uH();
  return Ud = function(e) {
    var n = 0, i;
    function o() {
      return n || (n = 1, i = e.apply(this, arguments), e = null), i;
    }
    return o.displayName = r(e), o;
  }, Ud;
}
var qd = {}, Mw;
function JC() {
  return Mw || (Mw = 1, function(r) {
    r.get = function(i) {
      var o = Error.stackTraceLimit;
      Error.stackTraceLimit = 1 / 0;
      var s = {}, u = Error.prepareStackTrace;
      Error.prepareStackTrace = function(c, d) {
        return d;
      }, Error.captureStackTrace(s, i || r.get);
      var l = s.stack;
      return Error.prepareStackTrace = u, Error.stackTraceLimit = o, l;
    }, r.parse = function(i) {
      if (!i.stack)
        return [];
      var o = this, s = i.stack.split(`
`).slice(1);
      return s.map(function(u) {
        if (u.match(/^\s*[-]{4,}$/))
          return o._createParsedCallSite({
            fileName: u,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            native: null
          });
        var l = u.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (l) {
          var c = null, d = null, g = null, y = null, w = null, b = l[5] === "native";
          if (l[1]) {
            g = l[1];
            var _ = g.lastIndexOf(".");
            if (g[_ - 1] == "." && _--, _ > 0) {
              c = g.substr(0, _), d = g.substr(_ + 1);
              var C = c.indexOf(".Module");
              C > 0 && (g = g.substr(C + 1), c = c.substr(0, C));
            }
            y = null;
          }
          d && (y = c, w = d), d === "<anonymous>" && (w = null, g = null);
          var m = {
            fileName: l[2] || null,
            lineNumber: parseInt(l[3], 10) || null,
            functionName: g,
            typeName: y,
            methodName: w,
            columnNumber: parseInt(l[4], 10) || null,
            native: b
          };
          return o._createParsedCallSite(m);
        }
      }).filter(function(u) {
        return !!u;
      });
    };
    function t(i) {
      for (var o in i)
        this[o] = i[o];
    }
    var e = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ], n = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    e.forEach(function(i) {
      t.prototype[i] = null, t.prototype["get" + i[0].toUpperCase() + i.substr(1)] = function() {
        return this[i];
      };
    }), n.forEach(function(i) {
      t.prototype[i] = !1, t.prototype["is" + i[0].toUpperCase() + i.substr(1)] = function() {
        return this[i];
      };
    }), r._createParsedCallSite = function(i) {
      return new t(i);
    };
  }(qd)), qd;
}
var Bd, kw;
function cH() {
  if (kw) return Bd;
  kw = 1;
  function r(_) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
      return typeof C;
    } : function(C) {
      return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
    }, r(_);
  }
  function t(_, C) {
    if (!(_ instanceof C)) throw new TypeError("Cannot call a class as a function");
  }
  function e(_, C) {
    for (var m = 0; m < C.length; m++) {
      var T = C[m];
      T.enumerable = T.enumerable || !1, T.configurable = !0, "value" in T && (T.writable = !0), Object.defineProperty(_, i(T.key), T);
    }
  }
  function n(_, C, m) {
    return C && e(_.prototype, C), Object.defineProperty(_, "prototype", { writable: !1 }), _;
  }
  function i(_) {
    var C = o(_, "string");
    return r(C) == "symbol" ? C : C + "";
  }
  function o(_, C) {
    if (r(_) != "object" || !_) return _;
    var m = _[Symbol.toPrimitive];
    if (m !== void 0) {
      var T = m.call(_, C);
      if (r(T) != "object") return T;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(_);
  }
  function s(_, C, m) {
    return C = d(C), u(_, c() ? Reflect.construct(C, m || [], d(_).constructor) : C.apply(_, m));
  }
  function u(_, C) {
    if (C && (r(C) == "object" || typeof C == "function")) return C;
    if (C !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return l(_);
  }
  function l(_) {
    if (_ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return _;
  }
  function c() {
    try {
      var _ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (c = function() {
      return !!_;
    })();
  }
  function d(_) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(C) {
      return C.__proto__ || Object.getPrototypeOf(C);
    }, d(_);
  }
  function g(_, C) {
    if (typeof C != "function" && C !== null) throw new TypeError("Super expression must either be null or a function");
    _.prototype = Object.create(C && C.prototype, { constructor: { value: _, writable: !0, configurable: !0 } }), Object.defineProperty(_, "prototype", { writable: !1 }), C && y(_, C);
  }
  function y(_, C) {
    return y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, T) {
      return m.__proto__ = T, m;
    }, y(_, C);
  }
  var w = xo(), b = w.Writable;
  return Bd = /* @__PURE__ */ function(_) {
    function C(m) {
      var T;
      if (t(this, C), T = s(this, C, [{
        objectMode: !0
      }]), !m)
        throw new Error("ExceptionStream requires a TransportStream instance.");
      return T.handleExceptions = !0, T.transport = m, T;
    }
    return g(C, _), n(C, [{
      key: "_write",
      value: function(T, S, A) {
        return T.exception ? this.transport.log(T, A) : (A(), !0);
      }
    }]);
  }(b), Bd;
}
var Vd, Pw;
function zC() {
  if (Pw) return Vd;
  Pw = 1;
  function r(y) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
      return typeof w;
    } : function(w) {
      return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
    }, r(y);
  }
  function t(y, w) {
    if (!(y instanceof w)) throw new TypeError("Cannot call a class as a function");
  }
  function e(y, w) {
    for (var b = 0; b < w.length; b++) {
      var _ = w[b];
      _.enumerable = _.enumerable || !1, _.configurable = !0, "value" in _ && (_.writable = !0), Object.defineProperty(y, i(_.key), _);
    }
  }
  function n(y, w, b) {
    return w && e(y.prototype, w), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function i(y) {
    var w = o(y, "string");
    return r(w) == "symbol" ? w : w + "";
  }
  function o(y, w) {
    if (r(y) != "object" || !y) return y;
    var b = y[Symbol.toPrimitive];
    if (b !== void 0) {
      var _ = b.call(y, w);
      if (r(_) != "object") return _;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(y);
  }
  var s = gr, u = Fp(), l = ku()("winston:exception"), c = KC(), d = JC(), g = cH();
  return Vd = /* @__PURE__ */ function() {
    function y(w) {
      if (t(this, y), !w)
        throw new Error("Logger is required to handle exceptions");
      this.logger = w, this.handlers = /* @__PURE__ */ new Map();
    }
    return n(y, [{
      key: "handle",
      value: function() {
        for (var b = this, _ = arguments.length, C = new Array(_), m = 0; m < _; m++)
          C[m] = arguments[m];
        C.forEach(function(T) {
          if (Array.isArray(T))
            return T.forEach(function(S) {
              return b._addHandler(S);
            });
          b._addHandler(T);
        }), this.catcher || (this.catcher = this._uncaughtException.bind(this), process.on("uncaughtException", this.catcher));
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
    }, {
      key: "unhandle",
      value: function() {
        var b = this;
        this.catcher && (process.removeListener("uncaughtException", this.catcher), this.catcher = !1, Array.from(this.handlers.values()).forEach(function(_) {
          return b.logger.unpipe(_);
        }));
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getAllInfo",
      value: function(b) {
        var _ = null;
        return b && (_ = typeof b == "string" ? b : b.message), {
          error: b,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: ["uncaughtException: ".concat(_ || "(no error message)"), b && b.stack || "  No stack trace"].join(`
`),
          stack: b && b.stack,
          exception: !0,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(b)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getProcessInfo",
      value: function() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getOsInfo",
      value: function() {
        return {
          loadavg: s.loadavg(),
          uptime: s.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getTrace",
      value: function(b) {
        var _ = b ? d.parse(b) : d.get();
        return _.map(function(C) {
          return {
            column: C.getColumnNumber(),
            file: C.getFileName(),
            function: C.getFunctionName(),
            line: C.getLineNumber(),
            method: C.getMethodName(),
            native: C.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
    }, {
      key: "_addHandler",
      value: function(b) {
        if (!this.handlers.has(b)) {
          b.handleExceptions = !0;
          var _ = new g(b);
          this.handlers.set(b, _), this.logger.pipe(_);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
    }, {
      key: "_uncaughtException",
      value: function(b) {
        var _ = this.getAllInfo(b), C = this._getExceptionHandlers(), m = typeof this.logger.exitOnError == "function" ? this.logger.exitOnError(b) : this.logger.exitOnError, T;
        !C.length && m && (console.warn("winston: exitOnError cannot be true with no exception handlers."), console.warn("winston: not exiting process."), m = !1);
        function S() {
          l("doExit", m), l("process._exiting", process._exiting), m && !process._exiting && (T && clearTimeout(T), process.exit(1));
        }
        if (!C || C.length === 0)
          return process.nextTick(S);
        u(C, function(A, x) {
          var D = c(x), U = A.transport || A;
          function O(k) {
            return function() {
              l(k), D();
            };
          }
          U._ending = !0, U.once("finish", O("finished")), U.once("error", O("error"));
        }, function() {
          return m && S();
        }), this.logger.log(_), m && (T = setTimeout(S, 3e3));
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
    }, {
      key: "_getExceptionHandlers",
      value: function() {
        return this.logger.transports.filter(function(b) {
          var _ = b.transport || b;
          return _.handleExceptions;
        });
      }
    }]);
  }(), Vd;
}
var Hd, Ow;
function fH() {
  if (Ow) return Hd;
  Ow = 1;
  function r(_) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
      return typeof C;
    } : function(C) {
      return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
    }, r(_);
  }
  function t(_, C) {
    if (!(_ instanceof C)) throw new TypeError("Cannot call a class as a function");
  }
  function e(_, C) {
    for (var m = 0; m < C.length; m++) {
      var T = C[m];
      T.enumerable = T.enumerable || !1, T.configurable = !0, "value" in T && (T.writable = !0), Object.defineProperty(_, i(T.key), T);
    }
  }
  function n(_, C, m) {
    return C && e(_.prototype, C), Object.defineProperty(_, "prototype", { writable: !1 }), _;
  }
  function i(_) {
    var C = o(_, "string");
    return r(C) == "symbol" ? C : C + "";
  }
  function o(_, C) {
    if (r(_) != "object" || !_) return _;
    var m = _[Symbol.toPrimitive];
    if (m !== void 0) {
      var T = m.call(_, C);
      if (r(T) != "object") return T;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(_);
  }
  function s(_, C, m) {
    return C = d(C), u(_, c() ? Reflect.construct(C, m || [], d(_).constructor) : C.apply(_, m));
  }
  function u(_, C) {
    if (C && (r(C) == "object" || typeof C == "function")) return C;
    if (C !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return l(_);
  }
  function l(_) {
    if (_ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return _;
  }
  function c() {
    try {
      var _ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (c = function() {
      return !!_;
    })();
  }
  function d(_) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(C) {
      return C.__proto__ || Object.getPrototypeOf(C);
    }, d(_);
  }
  function g(_, C) {
    if (typeof C != "function" && C !== null) throw new TypeError("Super expression must either be null or a function");
    _.prototype = Object.create(C && C.prototype, { constructor: { value: _, writable: !0, configurable: !0 } }), Object.defineProperty(_, "prototype", { writable: !1 }), C && y(_, C);
  }
  function y(_, C) {
    return y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, T) {
      return m.__proto__ = T, m;
    }, y(_, C);
  }
  var w = xo(), b = w.Writable;
  return Hd = /* @__PURE__ */ function(_) {
    function C(m) {
      var T;
      if (t(this, C), T = s(this, C, [{
        objectMode: !0
      }]), !m)
        throw new Error("RejectionStream requires a TransportStream instance.");
      return T.handleRejections = !0, T.transport = m, T;
    }
    return g(C, _), n(C, [{
      key: "_write",
      value: function(T, S, A) {
        return T.rejection ? this.transport.log(T, A) : (A(), !0);
      }
    }]);
  }(b), Hd;
}
var Gd, Lw;
function YC() {
  if (Lw) return Gd;
  Lw = 1;
  function r(y) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
      return typeof w;
    } : function(w) {
      return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
    }, r(y);
  }
  function t(y, w) {
    if (!(y instanceof w)) throw new TypeError("Cannot call a class as a function");
  }
  function e(y, w) {
    for (var b = 0; b < w.length; b++) {
      var _ = w[b];
      _.enumerable = _.enumerable || !1, _.configurable = !0, "value" in _ && (_.writable = !0), Object.defineProperty(y, i(_.key), _);
    }
  }
  function n(y, w, b) {
    return w && e(y.prototype, w), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function i(y) {
    var w = o(y, "string");
    return r(w) == "symbol" ? w : w + "";
  }
  function o(y, w) {
    if (r(y) != "object" || !y) return y;
    var b = y[Symbol.toPrimitive];
    if (b !== void 0) {
      var _ = b.call(y, w);
      if (r(_) != "object") return _;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(y);
  }
  var s = gr, u = Fp(), l = ku()("winston:rejection"), c = KC(), d = JC(), g = fH();
  return Gd = /* @__PURE__ */ function() {
    function y(w) {
      if (t(this, y), !w)
        throw new Error("Logger is required to handle rejections");
      this.logger = w, this.handlers = /* @__PURE__ */ new Map();
    }
    return n(y, [{
      key: "handle",
      value: function() {
        for (var b = this, _ = arguments.length, C = new Array(_), m = 0; m < _; m++)
          C[m] = arguments[m];
        C.forEach(function(T) {
          if (Array.isArray(T))
            return T.forEach(function(S) {
              return b._addHandler(S);
            });
          b._addHandler(T);
        }), this.catcher || (this.catcher = this._unhandledRejection.bind(this), process.on("unhandledRejection", this.catcher));
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
    }, {
      key: "unhandle",
      value: function() {
        var b = this;
        this.catcher && (process.removeListener("unhandledRejection", this.catcher), this.catcher = !1, Array.from(this.handlers.values()).forEach(function(_) {
          return b.logger.unpipe(_);
        }));
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getAllInfo",
      value: function(b) {
        var _ = null;
        return b && (_ = typeof b == "string" ? b : b.message), {
          error: b,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: ["unhandledRejection: ".concat(_ || "(no error message)"), b && b.stack || "  No stack trace"].join(`
`),
          stack: b && b.stack,
          rejection: !0,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(b)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getProcessInfo",
      value: function() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getOsInfo",
      value: function() {
        return {
          loadavg: s.loadavg(),
          uptime: s.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
    }, {
      key: "getTrace",
      value: function(b) {
        var _ = b ? d.parse(b) : d.get();
        return _.map(function(C) {
          return {
            column: C.getColumnNumber(),
            file: C.getFileName(),
            function: C.getFunctionName(),
            line: C.getLineNumber(),
            method: C.getMethodName(),
            native: C.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
    }, {
      key: "_addHandler",
      value: function(b) {
        if (!this.handlers.has(b)) {
          b.handleRejections = !0;
          var _ = new g(b);
          this.handlers.set(b, _), this.logger.pipe(_);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
    }, {
      key: "_unhandledRejection",
      value: function(b) {
        var _ = this.getAllInfo(b), C = this._getRejectionHandlers(), m = typeof this.logger.exitOnError == "function" ? this.logger.exitOnError(b) : this.logger.exitOnError, T;
        !C.length && m && (console.warn("winston: exitOnError cannot be true with no rejection handlers."), console.warn("winston: not exiting process."), m = !1);
        function S() {
          l("doExit", m), l("process._exiting", process._exiting), m && !process._exiting && (T && clearTimeout(T), process.exit(1));
        }
        if (!C || C.length === 0)
          return process.nextTick(S);
        u(C, function(A, x) {
          var D = c(x), U = A.transport || A;
          function O(k) {
            return function() {
              l(k), D();
            };
          }
          U._ending = !0, U.once("finish", O("finished")), U.once("error", O("error"));
        }, function() {
          return m && S();
        }), this.logger.log(_), m && (T = setTimeout(S, 3e3));
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
    }, {
      key: "_getRejectionHandlers",
      value: function() {
        return this.logger.transports.filter(function(b) {
          var _ = b.transport || b;
          return _.handleRejections;
        });
      }
    }]);
  }(), Gd;
}
var Wd = { exports: {} }, Kd = { exports: {} }, Nw;
function dH() {
  if (Nw) return Kd.exports;
  Nw = 1;
  const r = Jn, t = Mu(), { LEVEL: e } = bt(), n = Kd.exports = function(o = {}) {
    t.call(this, { objectMode: !0, highWaterMark: o.highWaterMark }), this.format = o.format, this.level = o.level, this.handleExceptions = o.handleExceptions, this.handleRejections = o.handleRejections, this.silent = o.silent, o.log && (this.log = o.log), o.logv && (this.logv = o.logv), o.close && (this.close = o.close), this.once("pipe", (s) => {
      this.levels = s.levels, this.parent = s;
    }), this.once("unpipe", (s) => {
      s === this.parent && (this.parent = null, this.close && this.close());
    });
  };
  return r.inherits(n, t), n.prototype._write = function(o, s, u) {
    if (this.silent || o.exception === !0 && !this.handleExceptions)
      return u(null);
    const l = this.level || this.parent && this.parent.level;
    if (!l || this.levels[l] >= this.levels[o[e]]) {
      if (o && !this.format)
        return this.log(o, u);
      let c, d;
      try {
        d = this.format.transform(Object.assign({}, o), this.format.options);
      } catch (g) {
        c = g;
      }
      if (c || !d) {
        if (u(), c) throw c;
        return;
      }
      return this.log(d, u);
    }
    return this._writableState.sync = !1, u(null);
  }, n.prototype._writev = function(o, s) {
    if (this.logv) {
      const u = o.filter(this._accept, this);
      return u.length ? this.logv(u, s) : s(null);
    }
    for (let u = 0; u < o.length; u++) {
      if (!this._accept(o[u])) continue;
      if (o[u].chunk && !this.format) {
        this.log(o[u].chunk, o[u].callback);
        continue;
      }
      let l, c;
      try {
        c = this.format.transform(
          Object.assign({}, o[u].chunk),
          this.format.options
        );
      } catch (d) {
        l = d;
      }
      if (l || !c) {
        if (o[u].callback(), l)
          throw s(null), l;
      } else
        this.log(c, o[u].callback);
    }
    return s(null);
  }, n.prototype._accept = function(o) {
    const s = o.chunk;
    if (this.silent)
      return !1;
    const u = this.level || this.parent && this.parent.level;
    return !!((s.exception === !0 || !u || this.levels[u] >= this.levels[s[e]]) && (this.handleExceptions || s.exception !== !0));
  }, n.prototype._nop = function() {
  }, Kd.exports;
}
var Dw;
function hH() {
  if (Dw) return Wd.exports;
  Dw = 1;
  const r = Jn, { LEVEL: t } = bt(), e = dH(), n = Wd.exports = function(o = {}) {
    if (e.call(this, o), !o.transport || typeof o.transport.log != "function")
      throw new Error("Invalid transport, must be an object with a log method.");
    this.transport = o.transport, this.level = this.level || o.transport.level, this.handleExceptions = this.handleExceptions || o.transport.handleExceptions, this._deprecated();
    function s(u) {
      this.emit("error", u, this.transport);
    }
    this.transport.__winstonError || (this.transport.__winstonError = s.bind(this), this.transport.on("error", this.transport.__winstonError));
  };
  return r.inherits(n, e), n.prototype._write = function(o, s, u) {
    if (this.silent || o.exception === !0 && !this.handleExceptions)
      return u(null);
    (!this.level || this.levels[this.level] >= this.levels[o[t]]) && this.transport.log(o[t], o.message, o, this._nop), u(null);
  }, n.prototype._writev = function(o, s) {
    for (let u = 0; u < o.length; u++)
      this._accept(o[u]) && (this.transport.log(
        o[u].chunk[t],
        o[u].chunk.message,
        o[u].chunk,
        this._nop
      ), o[u].callback());
    return s(null);
  }, n.prototype._deprecated = function() {
    console.error([
      `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
      "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
    ].join(`
`));
  }, n.prototype.close = function() {
    this.transport.close && this.transport.close(), this.transport.__winstonError && (this.transport.removeListener("error", this.transport.__winstonError), this.transport.__winstonError = null);
  }, Wd.exports;
}
var Jd, Fw;
function pH() {
  if (Fw) return Jd;
  Fw = 1;
  function r(u) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, r(u);
  }
  function t(u, l) {
    if (!(u instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function e(u, l) {
    for (var c = 0; c < l.length; c++) {
      var d = l[c];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(u, i(d.key), d);
    }
  }
  function n(u, l, c) {
    return l && e(u.prototype, l), Object.defineProperty(u, "prototype", { writable: !1 }), u;
  }
  function i(u) {
    var l = o(u, "string");
    return r(l) == "symbol" ? l : l + "";
  }
  function o(u, l) {
    if (r(u) != "object" || !u) return u;
    var c = u[Symbol.toPrimitive];
    if (c !== void 0) {
      var d = c.call(u, l);
      if (r(d) != "object") return d;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(u);
  }
  var s = /* @__PURE__ */ function() {
    function u(l) {
      t(this, u);
      var c = $p();
      if (r(l) !== "object" || Array.isArray(l) || !(l instanceof c))
        throw new Error("Logger is required for profiling");
      this.logger = l, this.start = Date.now();
    }
    return n(u, [{
      key: "done",
      value: function() {
        for (var c = arguments.length, d = new Array(c), g = 0; g < c; g++)
          d[g] = arguments[g];
        typeof d[d.length - 1] == "function" && (console.warn("Callback function no longer supported as of winston@3.0.0"), d.pop());
        var y = r(d[d.length - 1]) === "object" ? d.pop() : {};
        return y.level = y.level || "info", y.durationMs = Date.now() - this.start, this.logger.write(y);
      }
    }]);
  }();
  return Jd = s, Jd;
}
var zd, $w;
function mH() {
  if ($w) return zd;
  $w = 1;
  class r extends Error {
    constructor(e) {
      super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${e.toString().split(`
`)[0]}
`), Error.captureStackTrace(this, r);
    }
  }
  return zd = (t) => {
    if (t.length > 2)
      throw new r(t);
    function e(i = {}) {
      this.options = i;
    }
    e.prototype.transform = t;
    function n(i) {
      return new e(i);
    }
    return n.Format = e, n;
  }, zd;
}
var Yd, Uw;
function gH() {
  if (Uw) return Yd;
  Uw = 1;
  const r = mH(), { MESSAGE: t } = bt(), e = Rs();
  function n(i, o) {
    return typeof o == "bigint" ? o.toString() : o;
  }
  return Yd = r((i, o) => {
    const s = e.configure(o);
    return i[t] = s(i, o.replacer || n, o.space), i;
  }), Yd;
}
var Zd, qw;
function $p() {
  if (qw) return Zd;
  qw = 1;
  function r(P, I, B) {
    return (I = o(I)) in P ? Object.defineProperty(P, I, { value: B, enumerable: !0, configurable: !0, writable: !0 }) : P[I] = B, P;
  }
  function t(P) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(I) {
      return typeof I;
    } : function(I) {
      return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I;
    }, t(P);
  }
  function e(P, I) {
    if (!(P instanceof I)) throw new TypeError("Cannot call a class as a function");
  }
  function n(P, I) {
    for (var B = 0; B < I.length; B++) {
      var W = I[B];
      W.enumerable = W.enumerable || !1, W.configurable = !0, "value" in W && (W.writable = !0), Object.defineProperty(P, o(W.key), W);
    }
  }
  function i(P, I, B) {
    return I && n(P.prototype, I), Object.defineProperty(P, "prototype", { writable: !1 }), P;
  }
  function o(P) {
    var I = s(P, "string");
    return t(I) == "symbol" ? I : I + "";
  }
  function s(P, I) {
    if (t(P) != "object" || !P) return P;
    var B = P[Symbol.toPrimitive];
    if (B !== void 0) {
      var W = B.call(P, I);
      if (t(W) != "object") return W;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(P);
  }
  function u(P, I, B) {
    return I = g(I), l(P, d() ? Reflect.construct(I, B || [], g(P).constructor) : I.apply(P, B));
  }
  function l(P, I) {
    if (I && (t(I) == "object" || typeof I == "function")) return I;
    if (I !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return c(P);
  }
  function c(P) {
    if (P === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return P;
  }
  function d() {
    try {
      var P = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (d = function() {
      return !!P;
    })();
  }
  function g(P) {
    return g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(I) {
      return I.__proto__ || Object.getPrototypeOf(I);
    }, g(P);
  }
  function y(P, I) {
    if (typeof I != "function" && I !== null) throw new TypeError("Super expression must either be null or a function");
    P.prototype = Object.create(I && I.prototype, { constructor: { value: P, writable: !0, configurable: !0 } }), Object.defineProperty(P, "prototype", { writable: !1 }), I && w(P, I);
  }
  function w(P, I) {
    return w = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(B, W) {
      return B.__proto__ = W, B;
    }, w(P, I);
  }
  var b = xo(), _ = b.Stream, C = b.Transform, m = Fp(), T = bt(), S = T.LEVEL, A = T.SPLAT, x = WC(), D = zC(), U = YC(), O = hH(), k = pH(), H = PC(), V = H.warn, N = Dp(), $ = /%[scdjifoO%]/g, j = /* @__PURE__ */ function(P) {
    function I(B) {
      var W;
      return e(this, I), W = u(this, I, [{
        objectMode: !0
      }]), W.configure(B), W;
    }
    return y(I, P), i(I, [{
      key: "child",
      value: function(W) {
        var z = this;
        return Object.create(z, {
          write: {
            value: function(ne) {
              var ce = Object.assign({}, W, ne);
              ne instanceof Error && (ce.stack = ne.stack, ce.message = ne.message), z.write(ce);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
    }, {
      key: "configure",
      value: function() {
        var W = this, z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ee = z.silent, ne = z.format, ce = z.defaultMeta, te = z.levels, fe = z.level, Y = fe === void 0 ? "info" : fe, Z = z.exitOnError, ie = Z === void 0 ? !0 : Z, me = z.transports, Ce = z.colors, F = z.emitErrs, q = z.formatters, de = z.padLevels, ye = z.rewriters, nt = z.stripColors, $e = z.exceptionHandlers, Ve = z.rejectionHandlers;
        if (this.transports.length && this.clear(), this.silent = ee, this.format = ne || this.format || gH()(), this.defaultMeta = ce || null, this.levels = te || this.levels || N.npm.levels, this.level = Y, this.exceptions && this.exceptions.unhandle(), this.rejections && this.rejections.unhandle(), this.exceptions = new D(this), this.rejections = new U(this), this.profilers = {}, this.exitOnError = ie, me && (me = Array.isArray(me) ? me : [me], me.forEach(function(Sn) {
          return W.add(Sn);
        })), Ce || F || q || de || ye || nt)
          throw new Error(["{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.", "Use a custom winston.format(function) instead.", "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"].join(`
`));
        $e && this.exceptions.handle($e), Ve && this.rejections.handle(Ve);
      }
    }, {
      key: "isLevelEnabled",
      value: function(W) {
        var z = this, ee = K(this.levels, W);
        if (ee === null)
          return !1;
        var ne = K(this.levels, this.level);
        if (ne === null)
          return !1;
        if (!this.transports || this.transports.length === 0)
          return ne >= ee;
        var ce = this.transports.findIndex(function(te) {
          var fe = K(z.levels, te.level);
          return fe === null && (fe = ne), fe >= ee;
        });
        return ce !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
    }, {
      key: "log",
      value: function(W, z) {
        for (var ee = arguments.length, ne = new Array(ee > 2 ? ee - 2 : 0), ce = 2; ce < ee; ce++)
          ne[ce - 2] = arguments[ce];
        if (arguments.length === 1)
          return W[S] = W.level, this._addDefaultMeta(W), this.write(W), this;
        if (arguments.length === 2)
          return z && t(z) === "object" ? (z[S] = z.level = W, this._addDefaultMeta(z), this.write(z), this) : (z = r(r(r({}, S, W), "level", W), "message", z), this._addDefaultMeta(z), this.write(z), this);
        var te = ne[0];
        if (t(te) === "object" && te !== null) {
          var fe = z && z.match && z.match($);
          if (!fe) {
            var Y = Object.assign({}, this.defaultMeta, te, r(r(r(r({}, S, W), A, ne), "level", W), "message", z));
            return te.message && (Y.message = "".concat(Y.message, " ").concat(te.message)), te.stack && (Y.stack = te.stack), te.cause && (Y.cause = te.cause), this.write(Y), this;
          }
        }
        return this.write(Object.assign({}, this.defaultMeta, r(r(r(r({}, S, W), A, ne), "level", W), "message", z))), this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
    }, {
      key: "_transform",
      value: function(W, z, ee) {
        if (this.silent)
          return ee();
        W[S] || (W[S] = W.level), !this.levels[W[S]] && this.levels[W[S]] !== 0 && console.error("[winston] Unknown logger level: %s", W[S]), this._readableState.pipes || console.error("[winston] Attempt to write logs with no transports, which can increase memory usage: %j", W);
        try {
          this.push(this.format.transform(W, this.format.options));
        } finally {
          this._writableState.sync = !1, ee();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
    }, {
      key: "_final",
      value: function(W) {
        var z = this.transports.slice();
        m(z, function(ee, ne) {
          if (!ee || ee.finished) return setImmediate(ne);
          ee.once("finish", ne), ee.end();
        }, W);
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
    }, {
      key: "add",
      value: function(W) {
        var z = !x(W) || W.log.length > 2 ? new O({
          transport: W
        }) : W;
        if (!z._writableState || !z._writableState.objectMode)
          throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
        return this._onEvent("error", z), this._onEvent("warn", z), this.pipe(z), W.handleExceptions && this.exceptions.handle(), W.handleRejections && this.rejections.handle(), this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
    }, {
      key: "remove",
      value: function(W) {
        if (!W) return this;
        var z = W;
        return (!x(W) || W.log.length > 2) && (z = this.transports.filter(function(ee) {
          return ee.transport === W;
        })[0]), z && this.unpipe(z), this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
    }, {
      key: "clear",
      value: function() {
        return this.unpipe(), this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
    }, {
      key: "close",
      value: function() {
        return this.exceptions.unhandle(), this.rejections.unhandle(), this.clear(), this.emit("close"), this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
    }, {
      key: "setLevels",
      value: function() {
        V.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
    }, {
      key: "query",
      value: function(W, z) {
        typeof W == "function" && (z = W, W = {}), W = W || {};
        var ee = {}, ne = Object.assign({}, W.query || {});
        function ce(fe, Y) {
          W.query && typeof fe.formatQuery == "function" && (W.query = fe.formatQuery(ne)), fe.query(W, function(Z, ie) {
            if (Z)
              return Y(Z);
            typeof fe.formatResults == "function" && (ie = fe.formatResults(ie, W.format)), Y(null, ie);
          });
        }
        function te(fe, Y) {
          ce(fe, function(Z, ie) {
            Y && (ie = Z || ie, ie && (ee[fe.name] = ie), Y()), Y = null;
          });
        }
        m(this.transports.filter(function(fe) {
          return !!fe.query;
        }), te, function() {
          return z(null, ee);
        });
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
    }, {
      key: "stream",
      value: function() {
        var W = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, z = new _(), ee = [];
        return z._streams = ee, z.destroy = function() {
          for (var ne = ee.length; ne--; )
            ee[ne].destroy();
        }, this.transports.filter(function(ne) {
          return !!ne.stream;
        }).forEach(function(ne) {
          var ce = ne.stream(W);
          ce && (ee.push(ce), ce.on("log", function(te) {
            te.transport = te.transport || [], te.transport.push(ne.name), z.emit("log", te);
          }), ce.on("error", function(te) {
            te.transport = te.transport || [], te.transport.push(ne.name), z.emit("error", te);
          }));
        }), z;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
    }, {
      key: "startTimer",
      value: function() {
        return new k(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
    }, {
      key: "profile",
      value: function(W) {
        var z = Date.now();
        if (this.profilers[W]) {
          var ee = this.profilers[W];
          delete this.profilers[W];
          for (var ne = arguments.length, ce = new Array(ne > 1 ? ne - 1 : 0), te = 1; te < ne; te++)
            ce[te - 1] = arguments[te];
          typeof ce[ce.length - 2] == "function" && (console.warn("Callback function no longer supported as of winston@3.0.0"), ce.pop());
          var fe = t(ce[ce.length - 1]) === "object" ? ce.pop() : {};
          return fe.level = fe.level || "info", fe.durationMs = z - ee, fe.message = fe.message || W, this.write(fe);
        }
        return this.profilers[W] = z, this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
    }, {
      key: "handleExceptions",
      value: function() {
        var W;
        console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"), (W = this.exceptions).handle.apply(W, arguments);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
    }, {
      key: "unhandleExceptions",
      value: function() {
        var W;
        console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"), (W = this.exceptions).unhandle.apply(W, arguments);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
    }, {
      key: "cli",
      value: function() {
        throw new Error(["Logger.cli() was removed in winston@3.0.0", "Use a custom winston.formats.cli() instead.", "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"].join(`
`));
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
    }, {
      key: "_onEvent",
      value: function(W, z) {
        function ee(ne) {
          W === "error" && !this.transports.includes(z) && this.add(z), this.emit(W, ne, z);
        }
        z["__winston" + W] || (z["__winston" + W] = ee.bind(this), z.on(W, z["__winston" + W]));
      }
    }, {
      key: "_addDefaultMeta",
      value: function(W) {
        this.defaultMeta && Object.assign(W, this.defaultMeta);
      }
    }]);
  }(C);
  function K(P, I) {
    var B = P[I];
    return !B && B !== 0 ? null : B;
  }
  return Object.defineProperty(j.prototype, "transports", {
    configurable: !1,
    enumerable: !0,
    get: function() {
      var I = this._readableState.pipes;
      return Array.isArray(I) ? I : [I].filter(Boolean);
    }
  }), Zd = j, Zd;
}
var jd, Bw;
function ZC() {
  if (Bw) return jd;
  Bw = 1;
  function r(C) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, r(C);
  }
  function t(C, m, T) {
    return Object.defineProperty(C, "prototype", { writable: !1 }), C;
  }
  function e(C, m) {
    if (!(C instanceof m)) throw new TypeError("Cannot call a class as a function");
  }
  function n(C, m, T) {
    return m = u(m), i(C, s() ? Reflect.construct(m, T || [], u(C).constructor) : m.apply(C, T));
  }
  function i(C, m) {
    if (m && (r(m) == "object" || typeof m == "function")) return m;
    if (m !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return o(C);
  }
  function o(C) {
    if (C === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return C;
  }
  function s() {
    try {
      var C = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (s = function() {
      return !!C;
    })();
  }
  function u(C) {
    return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(m) {
      return m.__proto__ || Object.getPrototypeOf(m);
    }, u(C);
  }
  function l(C, m) {
    if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
    C.prototype = Object.create(m && m.prototype, { constructor: { value: C, writable: !0, configurable: !0 } }), Object.defineProperty(C, "prototype", { writable: !1 }), m && c(C, m);
  }
  function c(C, m) {
    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(T, S) {
      return T.__proto__ = S, T;
    }, c(C, m);
  }
  var d = bt(), g = d.LEVEL, y = Dp(), w = $p(), b = ku()("winston:create-logger");
  function _(C) {
    return "is" + C.charAt(0).toUpperCase() + C.slice(1) + "Enabled";
  }
  return jd = function() {
    var C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    C.levels = C.levels || y.npm.levels;
    var m = /* @__PURE__ */ function(S) {
      function A(x) {
        return e(this, A), n(this, A, [x]);
      }
      return l(A, S), t(A);
    }(w), T = new m(C);
    return Object.keys(C.levels).forEach(function(S) {
      if (b('Define prototype method for "%s"', S), S === "log") {
        console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
        return;
      }
      m.prototype[S] = function() {
        for (var A = this || T, x = arguments.length, D = new Array(x), U = 0; U < x; U++)
          D[U] = arguments[U];
        if (D.length === 1) {
          var O = D[0], k = O && O.message && O || {
            message: O
          };
          return k.level = k[g] = S, A._addDefaultMeta(k), A.write(k), this || T;
        }
        return D.length === 0 ? (A.log(S, ""), A) : A.log.apply(A, [S].concat(D));
      }, m.prototype[_(S)] = function() {
        return (this || T).isLevelEnabled(S);
      };
    }), T;
  }, jd;
}
var Qd, Vw;
function yH() {
  if (Vw) return Qd;
  Vw = 1;
  function r(u) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, r(u);
  }
  function t(u, l) {
    if (!(u instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function e(u, l) {
    for (var c = 0; c < l.length; c++) {
      var d = l[c];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(u, i(d.key), d);
    }
  }
  function n(u, l, c) {
    return l && e(u.prototype, l), Object.defineProperty(u, "prototype", { writable: !1 }), u;
  }
  function i(u) {
    var l = o(u, "string");
    return r(l) == "symbol" ? l : l + "";
  }
  function o(u, l) {
    if (r(u) != "object" || !u) return u;
    var c = u[Symbol.toPrimitive];
    if (c !== void 0) {
      var d = c.call(u, l);
      if (r(d) != "object") return d;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(u);
  }
  var s = ZC();
  return Qd = /* @__PURE__ */ function() {
    function u() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t(this, u), this.loggers = /* @__PURE__ */ new Map(), this.options = l;
    }
    return n(u, [{
      key: "add",
      value: function(c, d) {
        var g = this;
        if (!this.loggers.has(c)) {
          d = Object.assign({}, d || this.options);
          var y = d.transports || this.options.transports;
          y ? d.transports = Array.isArray(y) ? y.slice() : [y] : d.transports = [];
          var w = s(d);
          w.on("close", function() {
            return g._delete(c);
          }), this.loggers.set(c, w);
        }
        return this.loggers.get(c);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
    }, {
      key: "get",
      value: function(c, d) {
        return this.add(c, d);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
    }, {
      key: "has",
      value: function(c) {
        return !!this.loggers.has(c);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
    }, {
      key: "close",
      value: function(c) {
        var d = this;
        if (c)
          return this._removeLogger(c);
        this.loggers.forEach(function(g, y) {
          return d._removeLogger(y);
        });
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
    }, {
      key: "_removeLogger",
      value: function(c) {
        if (this.loggers.has(c)) {
          var d = this.loggers.get(c);
          d.close(), this._delete(c);
        }
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
    }, {
      key: "_delete",
      value: function(c) {
        this.loggers.delete(c);
      }
    }]);
  }(), Qd;
}
var Hw;
function vH() {
  return Hw || (Hw = 1, function(r) {
    var t = kC(), e = PC(), n = e.warn;
    r.version = w5.version, r.transports = sH(), r.config = Dp(), r.addColors = t.levels, r.format = t.format, r.createLogger = ZC(), r.Logger = $p(), r.ExceptionHandler = zC(), r.RejectionHandler = YC(), r.Container = yH(), r.Transport = Ms(), r.loggers = new r.Container();
    var i = r.createLogger();
    Object.keys(r.config.npm.levels).concat(["log", "query", "stream", "add", "remove", "clear", "profile", "startTimer", "handleExceptions", "unhandleExceptions", "handleRejections", "unhandleRejections", "configure", "child"]).forEach(function(o) {
      return r[o] = function() {
        return i[o].apply(i, arguments);
      };
    }), Object.defineProperty(r, "level", {
      get: function() {
        return i.level;
      },
      set: function(s) {
        i.level = s;
      }
    }), Object.defineProperty(r, "exceptions", {
      get: function() {
        return i.exceptions;
      }
    }), Object.defineProperty(r, "rejections", {
      get: function() {
        return i.rejections;
      }
    }), ["exitOnError"].forEach(function(o) {
      Object.defineProperty(r, o, {
        get: function() {
          return i[o];
        },
        set: function(u) {
          i[o] = u;
        }
      });
    }), Object.defineProperty(r, "default", {
      get: function() {
        return {
          exceptionHandlers: i.exceptionHandlers,
          rejectionHandlers: i.rejectionHandlers,
          transports: i.transports
        };
      }
    }), n.deprecated(r, "setLevels"), n.forFunctions(r, "useFormat", ["cli"]), n.forProperties(r, "useFormat", ["padLevels", "stripColors"]), n.forFunctions(r, "deprecated", ["addRewriter", "addFilter", "clone", "extend"]), n.forProperties(r, "deprecated", ["emitErrs", "levelLength"]);
  }(vf)), vf;
}
var _H = vH();
const Hi = /* @__PURE__ */ jh(_H), Gw = Object.keys(oe);
function Up(r) {
  const t = Je.join(CV || Je.join(nu(), ".cache"), "amp", "logs"), e = r?.logFile || Je.join(t, "cli.log"), n = r?.logLevel || "info";
  Gw.includes(n) || console.warn(`Invalid log level: ${n}. Using 'info' instead.`);
  try {
    uo.mkdirSync(Je.dirname(e), { recursive: !0 });
  } catch (o) {
    console.error(`Failed to create log directory: ${o}`);
  }
  const i = Hi.createLogger({
    level: Gw.includes(n) ? n : "info",
    format: Hi.format.combine(
      Hi.format.timestamp(),
      Hi.format.json(),
      Hi.format.errors({ stack: !0 })
    ),
    transports: [new Hi.transports.File({ filename: e })]
  });
  Dk({
    error: i.error.bind(i),
    warn: i.warn.bind(i),
    info: i.info.bind(i),
    debug: i.debug.bind(i),
    audit: (o, ...s) => i.info(o, { audit: !0, ...s[0] })
  });
}
const Xd = _b(eP.exec);
async function wH(r) {
  const t = {
    displayName: _V.basename(r)
  };
  if (r.scheme !== "file")
    return t;
  t.fsPath = r.fsPath;
  try {
    if (!await Jk.access(jk.join(r.fsPath, ".git")).then(() => !0).catch(() => !1))
      return t;
    const { stdout: n } = await Xd("git remote get-url origin", {
      cwd: r.fsPath
    }).catch(() => ({
      stdout: ""
    }));
    if (!n.trim())
      return t;
    const { stdout: i } = await Xd("git symbolic-ref HEAD", {
      cwd: r.fsPath
    }).catch(() => ({
      stdout: ""
    })), { stdout: o } = await Xd("git rev-parse HEAD", { cwd: r.fsPath }).catch(
      () => ({
        stdout: ""
      })
    );
    return {
      ...t,
      repository: {
        type: "git",
        url: bH(n.trim()),
        ref: i.trim() ?? void 0,
        sha: o.trim() ?? void 0
      }
    };
  } catch (e) {
    return oe.error("Error getting repository info:", e, { dir: r.fsPath }), t;
  }
}
function bH(r) {
  const t = ["github.com", "gitlab.com", "bitbucket.org"], e = r.replace(/\.git$/, "");
  let n = null, i = null;
  const o = e.match(/^git@([^:]+)[:|/](.+)$/);
  if (o && o[1] && o[2] && (n = o[1], i = o[2]), !n || !i) {
    const s = e.match(/^https?:\/\/([^/]+)\/(.+)$/);
    s && s[1] && s[2] && (n = s[1], i = s[2]);
  }
  if (!n || !i) {
    const s = e.match(/^([^:]+):(.+)$/);
    s && s[1] && s[2] && (n = s[1], i = s[2]);
  }
  return n && i && t.includes(n) ? `https://${n}/${i}` : r;
}
let eh;
function TH() {
  if (!eh) {
    const t = !(typeof process < "u" && process.versions && process.versions.node);
    let e = "linux";
    if (typeof navigator < "u") {
      const n = navigator.platform.toLowerCase();
      n.includes("mac") || n.includes("ios") ? e = "darwin" : n.includes("win") && (e = "windows");
    } else typeof process < "u" && (process.platform === "darwin" ? e = "darwin" : process.platform === "win32" && (e = "windows"));
    eh = {
      webBrowser: t,
      os: e,
      client: gb().name,
      ctrlCmdKeyShort: e === "darwin" ? "" : "",
      ctrlCmdKey: e === "darwin" ? "" : "Ctrl"
    };
  }
  return eh;
}
function CH() {
  const r = gb(), t = TH();
  return {
    os: t.os,
    webBrowser: t.webBrowser,
    client: r.name,
    clientVersion: r.version,
    clientType: r.type
  };
}
async function SH() {
  return {
    trees: await Promise.all([process.cwd()].map((r) => wH(Mp.file(r)))),
    platform: CH(),
    interactive: !0
  };
}
const jC = {
  url: {
    value: "https://ampcode.com",
    visible: !1,
    description: "The Amp server URL to connect to"
  },
  "anthropic.thinking.enabled": {
    value: !1,
    visible: !1,
    description: "Enable Claude thinking process output for debugging"
  },
  "notifications.enabled": {
    value: !0,
    visible: !0,
    description: "Enable system sound notifications when agent completes tasks"
  },
  "todos.enabled": {
    value: !1,
    visible: !1,
    description: "Enable TODO tracking and management features"
  },
  mcpServers: {
    value: {
      filesystem: {
        command: "npx",
        args: ["@modelcontextprotocol/server-filesystem", "/path/to/allowed/dir"]
      }
    },
    visible: !0,
    description: "Model Context Protocol servers to connect to for additional tools"
  },
  "mcp.disable": {
    value: [],
    visible: !0,
    description: "Array of MCP server names to disable"
  },
  "tools.disable": {
    value: ["browser_navigate"],
    visible: !0,
    description: "Array of tool names to disable"
  },
  "connections.disable": {
    value: [],
    visible: !1,
    description: "Array of connection types to disable"
  },
  "commands.allowlist": {
    value: ["git status", "ls -la", "npm run build"],
    visible: !0,
    description: "Array of shell commands that can be executed without confirmation"
  },
  submitOnEnter: {
    value: !0,
    visible: !1,
    description: "Whether to submit messages on Enter (true) or require Ctrl+Enter (false)"
  },
  "terminal.commands.environment": {
    value: "vscode-terminal",
    visible: !1,
    description: "Terminal environment for executing commands (vscode-terminal or node-spawn)"
  },
  "terminal.commands.hide": {
    value: !1,
    visible: !1,
    description: "Hide terminal command output from the user"
  },
  "terminal.commands.node-spawn.load-profile": {
    value: "daily",
    visible: !1,
    description: "How often to load shell profile in node-spawn mode (always, daily, never)"
  },
  "tab.enabled": {
    value: !0,
    visible: !1,
    description: "Enable tab completion features"
  },
  "tab.verboseLogs": {
    value: !1,
    visible: !1,
    description: "Enable verbose logging for tab completion"
  },
  debugLogs: {
    value: !1,
    visible: !1,
    description: "Enable debug logging output"
  },
  hooks: {
    value: [],
    visible: !1,
    description: "Custom hooks for extending Amp functionality"
  }
}, EH = Object.fromEntries(
  Object.entries(jC).filter(([, r]) => r.visible).map(([r, t]) => [`amp.${r}`, t.value])
), cl = {
  examples: [
    {
      description: "Start an interactive session:",
      command: "amp"
    },
    {
      description: "Run a command in a non-interactive session:",
      command: 'echo "commit all my unstaged changes" | amp'
    },
    {
      description: "Run from a prompt file in a non-interactive session and store output in a file:",
      command: "amp < prompt.txt > output.txt"
    }
  ],
  configuration: {
    description: `Amp can be configured using a JSON settings file located at ${xs}. All settings use the "amp." prefix.`,
    sampleConfig: JSON.stringify(EH, null, 2),
    keyDescriptions: Object.entries(jC).filter(([, r]) => r.visible).map(([r, t]) => ({
      key: `amp.${r}`,
      description: t.description
    }))
  }
};
class AH {
  cache = /* @__PURE__ */ new Map();
  maxSize;
  constructor(t = 100) {
    this.maxSize = t;
  }
  get(t) {
    const e = this.cache.get(t);
    return e !== void 0 && (this.cache.delete(t), this.cache.set(t, e)), e;
  }
  set(t, e) {
    if (this.cache.has(t))
      this.cache.delete(t);
    else if (this.cache.size >= this.maxSize) {
      const n = this.cache.keys().next().value;
      n !== void 0 && this.cache.delete(n);
    }
    this.cache.set(t, e);
  }
  has(t) {
    return this.cache.has(t);
  }
  clear() {
    this.cache.clear();
  }
  get size() {
    return this.cache.size;
  }
}
class Ww {
  process = null;
  messageId = 0;
  pendingRequests = /* @__PURE__ */ new Map();
  queryCache = new AH(50);
  constructor() {
  }
  async start() {
    const t = Je.join(import.meta.dirname, "fuzzy-server.js");
    if (this.process = tu("node", [t], {
      stdio: ["pipe", "pipe", "inherit"]
    }), !this.process.stdout)
      throw new Error("Failed to create fuzzy server process");
    let e = "";
    this.process.stdout.on("data", (n) => {
      e += n.toString();
      const i = e.split(`
`);
      e = i.pop() || "";
      for (const o of i)
        if (o.trim())
          try {
            const s = JSON.parse(o), u = this.pendingRequests.get(s.id);
            u && (this.pendingRequests.delete(s.id), u.resolve(s));
          } catch (s) {
            oe.error("Failed to parse fuzzy server response", s);
          }
    }), this.process.on("error", (n) => {
      oe.error("Fuzzy server process error", n);
    }), this.process.on("exit", (n) => {
      oe.debug("Fuzzy server process exited", { code: n });
    });
  }
  async sendMessage(t) {
    if (!this.process?.stdin)
      throw new Error("Fuzzy server not started");
    const e = ++this.messageId;
    return new Promise((n, i) => {
      this.pendingRequests.set(e, { resolve: n, reject: i }), this.process.stdin.write(JSON.stringify({ ...t, id: e }) + `
`);
    });
  }
  async addFiles(t) {
    await this.sendMessage({
      type: "index:add",
      files: t
    }), this.queryCache.clear();
  }
  async removeFiles(t) {
    await this.sendMessage({
      type: "index:remove",
      files: t
    }), this.queryCache.clear();
  }
  async query(t) {
    oe.debug("Processing completion for pattern", { pattern: t });
    const e = this.queryCache.get(t);
    if (e)
      return e;
    const i = (await this.sendMessage({
      type: "query",
      text: t
    })).results || [];
    return this.queryCache.set(t, i), i;
  }
  dispose() {
    this.process && (this.process.kill(), this.process = null);
  }
}
async function xH(r, t) {
  const e = gr.homedir();
  if (Je.resolve(t) === Je.resolve(e)) {
    oe.debug("Skipping indexing for home directory");
    return;
  }
  return new Promise((n, i) => {
    const o = tu("rg", ["--files"], {
      cwd: t,
      stdio: ["ignore", "pipe", "inherit"]
    });
    if (!o.stdout) {
      i(new Error("Failed to start ripgrep process"));
      return;
    }
    let s = "";
    const u = [];
    o.stdout.on("data", (l) => {
      s += l.toString();
      const c = s.split(`
`);
      s = c.pop() || "";
      for (const d of c)
        d.trim() && u.push(d.trim());
    }), o.on("error", (l) => {
      oe.error("Ripgrep process error", l), i(l);
    }), o.on("exit", async (l) => {
      if (l === 0)
        try {
          await r.addFiles(u), oe.debug(`Indexed ${u.length} files`), n();
        } catch (c) {
          i(c);
        }
      else
        i(new Error(`Ripgrep exited with code ${l}`));
    });
  });
}
function RH(r, t) {
  const e = gr.homedir();
  if (Je.resolve(t) === Je.resolve(e))
    return oe.debug("Skipping file watching for home directory"), { dispose: () => {
    } };
  const n = [], i = /* @__PURE__ */ new Set();
  let o = null;
  const s = async () => {
    if (i.size === 0) return;
    const c = Array.from(i);
    i.clear();
    const d = [], g = [];
    for (const y of c) {
      const w = Je.join(t, y);
      try {
        (await uo.promises.stat(w)).isFile() && d.push(y);
      } catch {
        g.push(y);
      }
    }
    try {
      d.length > 0 && (await r.addFiles(d), oe.debug(`Added ${d.length} files to index`)), g.length > 0 && (await r.removeFiles(g), oe.debug(`Removed ${g.length} files from index`));
    } catch (y) {
      oe.error("Failed to update fuzzy server index", y);
    }
  }, u = () => {
    o && clearTimeout(o), o = setTimeout(s, 100);
  };
  return ((c) => {
    try {
      const d = uo.watch(c, { recursive: !0 }, (g, y) => {
        if (!y) return;
        if (oe.debug("File system event", { eventType: g, filename: y, dirPath: c }), g !== "rename") {
          oe.debug("Ignoring change event", { eventType: g, filename: y });
          return;
        }
        if (y.includes("/.") || y.startsWith(".")) return;
        const w = Je.relative(t, Je.join(c, y));
        w.startsWith("..") || (i.add(w), u());
      });
      n.push(d), d.on("error", (g) => {
        oe.error(`File watcher error for ${c}`, g);
      });
    } catch (d) {
      oe.error(`Failed to watch directory ${c}`, d);
    }
  })(t), {
    dispose: () => {
      o && clearTimeout(o);
      for (const c of n)
        c.close();
      n.length = 0;
    }
  };
}
const IH = Je.join(Zl || Je.join(nu(), ".local/share"), "amp"), MH = Je.join(IH, "history.json"), kH = 1e3;
class PH {
  history = [];
  index = -1;
  loaded = !1;
  historyFile;
  maxSize;
  constructor(t) {
    this.historyFile = t?.historyFile || MH, this.maxSize = t?.maxSize || kH, this.ensureLoaded();
  }
  async ensureLoaded() {
    if (!this.loaded) {
      try {
        const t = await li(this.historyFile, "utf-8");
        try {
          this.history = JSON.parse(t), oe.info("Loaded history from file", {
            file: this.historyFile,
            size: this.history.length
          });
        } catch {
          this.history = [];
        }
      } catch {
        this.history = [];
      }
      this.loaded = !0;
    }
  }
  async add(t) {
    if (await this.ensureLoaded(), !(!t.trim() || this.history.length > 0 && this.history[this.history.length - 1] === t)) {
      this.history.push(t), this.history.length > this.maxSize && (this.history = this.history.slice(this.history.length - this.maxSize));
      try {
        await Qh(Je.dirname(this.historyFile), { recursive: !0 }), await Xh(this.historyFile, JSON.stringify(this.history), "utf-8");
      } catch (e) {
        oe.error(
          `Failed to save history: ${e instanceof Error ? e.message : String(e)}`
        );
      }
      this.reset();
    }
  }
  previous() {
    return this.history.length === 0 ? null : this.index === 0 ? this.history[0] || null : (this.index === -1 ? this.index = this.history.length - 1 : this.index--, this.history[this.index] || null);
  }
  next() {
    return this.history.length === 0 || this.index === -1 ? null : (this.index++, this.index >= this.history.length ? (this.index = -1, null) : this.history[this.index] || null);
  }
  reset() {
    this.index = -1;
  }
}
const OH = Buffer.from([1]), LH = Buffer.from([2]), QC = Buffer.from([3]), XC = Buffer.from([4]), NH = Buffer.from([5]), DH = Buffer.from([6]), FH = Buffer.from([8]), $H = Buffer.from([11]), UH = Buffer.from([12]), qH = Buffer.from([14]), BH = Buffer.from([16]), VH = Buffer.from([21]), HH = Buffer.from([23]), GH = Buffer.from([25]), WH = Buffer.from([7]), KH = Buffer.from([15]), JH = Buffer.from([17]), zH = Buffer.from([18]), YH = Buffer.from([19]), ZH = Buffer.from([20]), jH = Buffer.from([22]), QH = Buffer.from([24]), XH = Buffer.from([26]), eS = Buffer.from([27]), eG = Buffer.from([13]), tG = Buffer.from([10]), nG = Buffer.from([127]), rG = Buffer.from([9]), iG = Buffer.from([27, 91, 90]), oG = Buffer.from([27, 91, 65]), sG = Buffer.from([27, 91, 66]), aG = Buffer.from([27, 91, 67]), lG = Buffer.from([27, 91, 68]), uG = Buffer.from([27, 91, 53, 126]), cG = Buffer.from([27, 91, 54, 126]), fG = Buffer.from([27, 91, 72]), dG = Buffer.from([27, 91, 70]), hG = Buffer.from([27, 91, 49, 126]), pG = Buffer.from([27, 91, 52, 126]), mG = Buffer.from([27, 91, 51, 126]), gG = Buffer.from([27, 102]), yG = Buffer.from([27, 98]), vG = Buffer.from([27, 100]), _G = Buffer.from([27, 127]), wG = Buffer.from([27, 91, 50, 55, 59, 50, 59, 49, 51, 126]), tS = Buffer.from([27, 91, 50, 55, 59, 53, 59, 49, 51, 126]), nS = Buffer.from([27, 91, 50, 55, 59, 56, 59, 49, 51, 126]), Ne = {
  ESC: Buffer.from([27, 91, 50, 55, 117]),
  // CSI 27 u (Escape key)
  // Control keys
  CTRL_A: Buffer.from([27, 91, 57, 55, 59, 53, 117]),
  // CSI 97;5 u ('a')
  CTRL_B: Buffer.from([27, 91, 57, 56, 59, 53, 117]),
  // CSI 98;5 u ('b')
  CTRL_C: Buffer.from([27, 91, 57, 57, 59, 53, 117]),
  // CSI 99;5 u ('c')
  CTRL_D: Buffer.from([27, 91, 49, 48, 48, 59, 53, 117]),
  // CSI 100;5 u ('d')
  CTRL_E: Buffer.from([27, 91, 49, 48, 49, 59, 53, 117]),
  // CSI 101;5 u ('e')
  CTRL_F: Buffer.from([27, 91, 49, 48, 50, 59, 53, 117]),
  // CSI 102;5 u ('f')
  CTRL_H: Buffer.from([27, 91, 49, 48, 52, 59, 53, 117]),
  // CSI 104;5 u ('h')
  CTRL_K: Buffer.from([27, 91, 49, 48, 55, 59, 53, 117]),
  // CSI 107;5 u ('k')
  CTRL_L: Buffer.from([27, 91, 49, 48, 56, 59, 53, 117]),
  // CSI 108;5 u ('l')
  CTRL_N: Buffer.from([27, 91, 49, 49, 48, 59, 53, 117]),
  // CSI 110;5 u ('n')
  CTRL_P: Buffer.from([27, 91, 49, 49, 50, 59, 53, 117]),
  // CSI 112;5 u ('p')
  CTRL_U: Buffer.from([27, 91, 49, 49, 55, 59, 53, 117]),
  // CSI 117;5 u ('u')
  CTRL_W: Buffer.from([27, 91, 49, 49, 57, 59, 53, 117]),
  // CSI 119;5 u ('w')
  CTRL_Y: Buffer.from([27, 91, 49, 50, 49, 59, 53, 117]),
  // CSI 121;5 u ('y')
  // Unsupported control characters (explicitly ignored)
  CTRL_G: Buffer.from([27, 91, 49, 48, 51, 59, 53, 117]),
  // CSI 103;5 u ('g')
  CTRL_O: Buffer.from([27, 91, 49, 49, 49, 59, 53, 117]),
  // CSI 111;5 u ('o')
  CTRL_Q: Buffer.from([27, 91, 49, 49, 51, 59, 53, 117]),
  // CSI 113;5 u ('q')
  CTRL_R: Buffer.from([27, 91, 49, 49, 52, 59, 53, 117]),
  // CSI 114;5 u ('r')
  CTRL_S: Buffer.from([27, 91, 49, 49, 53, 59, 53, 117]),
  // CSI 115;5 u ('s')
  CTRL_T: Buffer.from([27, 91, 49, 49, 54, 59, 53, 117]),
  // CSI 116;5 u ('t')
  CTRL_V: Buffer.from([27, 91, 49, 49, 56, 59, 53, 117]),
  // CSI 118;5 u ('v')
  CTRL_X: Buffer.from([27, 91, 49, 50, 48, 59, 53, 117]),
  // CSI 120;5 u ('x')
  CTRL_Z: Buffer.from([27, 91, 49, 50, 50, 59, 53, 117]),
  // CSI 122;5 u ('z')
  // Alt/Meta combinations (primarily for macOS)
  ALT_B: Buffer.from([27, 91, 57, 56, 59, 51, 117]),
  // CSI 98;3 u ('b' with Alt)
  ALT_F: Buffer.from([27, 91, 49, 48, 50, 59, 51, 117]),
  // CSI 102;3 u ('f' with Alt)
  ALT_D: Buffer.from([27, 91, 49, 48, 48, 59, 51, 117]),
  // CSI 100;3 u ('d' with Alt)
  ALT_BACKSPACE: Buffer.from([27, 91, 49, 50, 55, 59, 51, 117]),
  // CSI 127;3 u (Backspace with Alt)
  SHIFT_BACKSPACE: Buffer.from([27, 91, 49, 50, 55, 59, 50, 117]),
  // CSI 127;2 u (Backspace with Shift)
  SHIFT_TAB: Buffer.from([27, 91, 57, 59, 50, 117]),
  // CSI 9;2 u (Tab with Shift)
  // Special keys
  SHIFT_ENTER: Buffer.from([27, 91, 49, 51, 59, 50, 117]),
  // CSI 13;2 u
  CTRL_ENTER: Buffer.from([27, 91, 49, 51, 59, 53, 117]),
  // CSI 13;5 u
  PAGE_UP: Buffer.from([27, 91, 53, 117]),
  // CSI 5 u
  PAGE_DOWN: Buffer.from([27, 91, 54, 117]),
  // CSI 6 u
  HOME: Buffer.from([27, 91, 72, 117]),
  // CSI H u
  END: Buffer.from([27, 91, 70, 117]),
  // CSI F u
  DEL: Buffer.from([27, 91, 81, 117]),
  // CSI Q u (Delete key)
  enable() {
    process.stderr.write("\x1B[=1u");
  },
  disable() {
    process.stderr.write("\x1B[=0u"), process.stderr.write("\x1B[<u");
  }
};
var fl = { exports: {} }, Kw;
function bG() {
  if (Kw) return fl.exports;
  Kw = 1;
  const r = 55296, t = 56319, e = 56320, n = 127462, i = 127487, o = 127995, s = 127999, u = 65024, l = 65039, c = 8400, d = 8447, g = 8205, y = [
    776,
    // (  ) COMBINING DIAERESIS
    2359,
    // (  ) DEVANAGARI LETTER SSA
    2359,
    // (  ) DEVANAGARI LETTER SSA
    2367,
    // (  ) DEVANAGARI VOWEL SIGN I
    2367,
    // (  ) DEVANAGARI VOWEL SIGN I
    2984,
    // (  ) TAMIL LETTER NA
    3007,
    // (  ) TAMIL VOWEL SIGN I
    3021,
    // ( ) TAMIL SIGN VIRAMA
    3633,
    // (  ) THAI CHARACTER MAI HAN-AKAT
    3635,
    // (  ) THAI CHARACTER SARA AM
    3648,
    // (  ) THAI CHARACTER SARA E
    3657,
    // (  ) THAI CHARACTER MAI THO
    4352,
    // (  ) HANGUL CHOSEONG KIYEOK
    4449,
    // (  ) HANGUL JUNGSEONG A
    4520
    // (  ) HANGUL JONGSEONG KIYEOK
  ];
  function w(k) {
    if (typeof k != "string")
      throw new Error("string cannot be undefined or null");
    const H = [];
    let V = 0, N = 0;
    for (; V < k.length; ) {
      if (N += b(V + N, k), A(k[V + N]) && N++, T(k[V + N]) && N++, S(k[V + N]) && N++, x(k[V + N])) {
        N++;
        continue;
      }
      H.push(k.substring(V, V + N)), V += N, N = 0;
    }
    return H;
  }
  function b(k, H) {
    const V = H[k];
    if (!_(V) || k === H.length - 1)
      return 1;
    const N = V + H[k + 1];
    let $ = H.substring(k + 2, k + 5);
    return C(N) && C($) || m($) ? 4 : 2;
  }
  function _(k) {
    return k && U(k[0].charCodeAt(0), r, t);
  }
  function C(k) {
    return U(D(k), n, i);
  }
  function m(k) {
    return U(D(k), o, s);
  }
  function T(k) {
    return typeof k == "string" && U(k.charCodeAt(0), u, l);
  }
  function S(k) {
    return typeof k == "string" && U(k.charCodeAt(0), c, d);
  }
  function A(k) {
    return typeof k == "string" && y.indexOf(k.charCodeAt(0)) !== -1;
  }
  function x(k) {
    return typeof k == "string" && k.charCodeAt(0) === g;
  }
  function D(k) {
    const H = k.charCodeAt(0) - r, V = k.charCodeAt(1) - e;
    return (H << 10) + V + 65536;
  }
  function U(k, H, V) {
    return k >= H && k <= V;
  }
  function O(k, H, V) {
    const N = w(k);
    if (H === void 0)
      return k;
    if (H >= N.length)
      return "";
    const $ = N.length - H;
    let K = H + (V === void 0 ? $ : V);
    return K > H + $ && (K = void 0), N.slice(H, K).join("");
  }
  return fl.exports = w, fl.exports.substr = O, fl.exports;
}
var TG = bG();
const Te = /* @__PURE__ */ jh(TG);
function Wh(r, t) {
  return r.length > t.length ? !1 : Buffer.from(Uint8Array.prototype.slice.call(t, 0, r.length)).equals(r);
}
function ge(r) {
  return Array.from(r).map((t) => t.toString(16).padStart(2, "0")).join("");
}
function CG(r) {
  const t = r.stdin || process.stdin, e = r.stdout || process.stdout, n = r.stderr || process.stderr, i = r.prompt || "", o = r.history, s = e.columns || 80, u = e.rows || 24, l = {
    lines: [""],
    cursorLine: 0,
    cursorColumn: 0,
    deletedText: [],
    state: "off",
    screenColumns: s,
    screenRows: u,
    lastChar: null,
    isProcessingPaste: !1,
    status: { left: "", right: "" },
    completions: [],
    selectedCompletionIndex: 0,
    isNavigatingHistory: !1,
    currentHistoryContent: null,
    lastCompletionQuery: null
  }, c = ah(t, "data").pipe(
    at((C) => ({
      type: "input",
      data: C
    }))
  ), d = ah(e, "resize").pipe(
    at(() => ({ type: "resize" }))
  ), g = new pr(), y = SG({
    stdout: e,
    stderr: n,
    state: l,
    prompt: i,
    printer: r.printer,
    complete: (C) => r.complete(C).then((m) => {
      g.next({ type: "complete", candidates: m });
    }),
    onSubmit: (C) => {
      o && C.trim() && (o.add(C), o.reset()), g.next({ type: "submit", message: C });
    },
    // Pass the triggerEvent function to allow handlers to trigger events
    triggerEvent: (C) => g.next(C),
    history: o
  }), w = new pr();
  function b(C) {
    l.state = C, w.next({ type: "line-editor-state", state: C });
  }
  const _ = Rl(c, d, g).pipe(
    at((C) => {
      if (C.type === "accept-message") {
        if (l.state !== "off")
          throw new Error(`can't accept message when in ${l.state} state`);
        b("message"), i && (n.write("\r"), n.write(i), n.write(`
\r`), Fr(n, l), n.write("\x1B[1F"), n.write(`\x1B[${i.length + 1}G`));
      } else if (C.type === "resize")
        l.screenColumns = e.columns || s, l.screenRows = e.rows || u, oe.debug("Terminal resized", {
          columns: l.screenColumns,
          rows: l.screenRows
        });
      else if (C.type === "submit")
        w.next(C), b("off");
      else if (C.type === "complete")
        aP(C.candidates, l.completions) || (l.selectedCompletionIndex = 0), l.completions = C.candidates, l.status.left = ob(
          n,
          r.printer,
          C.candidates,
          l.selectedCompletionIndex
        ), ps(n, l, i, () => {
          Fr(n, l);
        });
      else if (C.type === "cycle-completion")
        l.completions.length > 0 && (C.direction === "forward" ? l.selectedCompletionIndex = (l.selectedCompletionIndex + 1) % l.completions.length : l.selectedCompletionIndex = (l.selectedCompletionIndex - 1 + l.completions.length) % l.completions.length, l.status.left = ob(
          n,
          r.printer,
          l.completions,
          l.selectedCompletionIndex
        ), ps(n, l, i, () => {
          Fr(n, l);
        }));
      else if (C.type === "input") {
        let m = C.data;
        if (l.state === "off" || l.state === "submitting" || m.length === 0)
          return;
        const T = C.data.length > 1 && !C.data.equals(tS) && !C.data.equals(Ne.CTRL_ENTER) && !C.data.equals(nS);
        for (l.isProcessingPaste = T; m.length > 0; ) {
          if ((m.equals(XC) || m.equals(Ne.CTRL_D)) && l.lines.length === 1 && l.lines[0] === "") {
            n.write("\r"), n.write("\x1B[K"), l.lines = [""], l.cursorLine = 0, l.cursorColumn = 0, l.status.left = "", l.lastCompletionQuery = null, b("closed"), w.next({ type: "exit" });
            return;
          }
          if (m.equals(eS) || m.equals(Ne.ESC) || m.equals(QC) || m.equals(Ne.CTRL_C)) {
            if (l.lines.length === 1 && l.lines[0] === "")
              l.status.left = "Press Ctrl+D to exit", hr(n, l, i, 0);
            else if (l.isNavigatingHistory && l.currentHistoryContent !== null)
              wi(n, l, i, l.currentHistoryContent), l.isNavigatingHistory = !1, l.currentHistoryContent = null, o && o.reset();
            else {
              n.write("\r");
              for (let A = 0; A < l.lines.length - l.cursorLine; A++)
                n.write("\x1B[1B");
              for (let A = 0; A < l.lines.length; A++)
                n.write("\x1B[K"), n.write("\x1B[1F");
              n.write("\x1B[K"), n.write(i), l.lines = [""], l.cursorLine = 0, l.cursorColumn = 0, l.status.left = "", l.lastCompletionQuery = null;
            }
            break;
          }
          m = y.process(m);
        }
        l.isProcessingPaste = !1;
      }
    })
  );
  return {
    get content() {
      return l.lines.join(`
`);
    },
    get lines() {
      return [...l.lines];
    },
    get cursorLine() {
      return l.cursorLine;
    },
    get cursorColumn() {
      return l.cursorColumn;
    },
    acceptMessage() {
      if (l.state !== "off" && l.state !== "submitting")
        throw new Error(`can't accept message when in ${l.state} state`);
      Yb().then(() => {
        g.next({ type: "accept-message" });
      });
    },
    setRightStatus(C) {
      l.status.right !== C && (l.status.right = C, l.state === "message" && ps(n, l, i, () => {
        Fr(n, l);
      }));
    },
    observable: new It((C) => {
      const m = w.subscribe((S) => {
        C.next(S);
      }), T = _.subscribe({});
      try {
        t.setRawMode(!0);
      } catch (S) {
        oe.error("Error setting raw mode:", S);
      }
      return g.next({ type: "resize" }), w.next({ type: "line-editor-state", state: "off" }), () => {
        m.unsubscribe(), T.unsubscribe();
        try {
          t.setRawMode(!1);
        } catch (S) {
          oe.error("Error resetting raw mode:", S);
        }
        b("closed"), t.unref();
      };
    })
  };
}
function SG({
  stdout: r,
  stderr: t,
  state: e,
  prompt: n,
  printer: i,
  onSubmit: o,
  complete: s,
  triggerEvent: u,
  history: l
}) {
  const c = {}, d = () => {
  }, g = EG(o);
  c[ge(eG)] = g, c[ge(tS)] = g, c[ge(Ne.CTRL_ENTER)] = g, c[ge(nS)] = g, c[ge(OH)] = Jw, c[ge(Ne.CTRL_A)] = Jw, c[ge(NH)] = Yw, c[ge(Ne.CTRL_E)] = Yw;
  const y = (_, C, m, T) => {
    AG(_, C, m, T, l);
  }, w = (_, C, m, T) => {
    xG(_, C, m, T, l);
  };
  c[ge(oG)] = y, c[ge(BH)] = y, c[ge(Ne.CTRL_P)] = y, c[ge(sG)] = w, c[ge(qH)] = w, c[ge(Ne.CTRL_N)] = w, c[ge(aG)] = th, c[ge(DH)] = th, c[ge(Ne.CTRL_F)] = th, c[ge(lG)] = nh, c[ge(LH)] = nh, c[ge(Ne.CTRL_B)] = nh, c[ge(nG)] = dl, c[ge(FH)] = dl, c[ge(Ne.CTRL_H)] = dl, c[ge(Ne.SHIFT_BACKSPACE)] = dl, c[ge(VH)] = Zw, c[ge(Ne.CTRL_U)] = Zw, c[ge($H)] = jw, c[ge(Ne.CTRL_K)] = jw, c[ge(HH)] = hl, c[ge(Ne.CTRL_W)] = hl, c[ge(_G)] = hl, c[ge(Ne.ALT_BACKSPACE)] = hl, c[ge(GH)] = eb, c[ge(Ne.CTRL_Y)] = eb, c[ge(UH)] = tb, c[ge(Ne.CTRL_L)] = tb, c[ge(wG)] = hs, c[ge(Ne.SHIFT_ENTER)] = hs, c[ge(tG)] = hs, l && (c[ge(uG)] = Qw(l), c[ge(cG)] = Xw(l), c[ge(Ne.PAGE_UP)] = Qw(l), c[ge(Ne.PAGE_DOWN)] = Xw(l)), c[ge(fG)] = rh, c[ge(hG)] = rh, c[ge(Ne.HOME)] = rh, c[ge(dG)] = ih, c[ge(pG)] = ih, c[ge(Ne.END)] = ih, c[ge(gG)] = nb, c[ge(Ne.ALT_F)] = nb, c[ge(yG)] = rb, c[ge(Ne.ALT_B)] = rb, c[ge(XC)] = pl, c[ge(Ne.CTRL_D)] = pl, c[ge(vG)] = zw, c[ge(Ne.ALT_D)] = zw, c[ge(mG)] = pl, c[ge(Ne.DEL)] = pl, c[ge(rG)] = RG(u), c[ge(iG)] = ib(u), c[ge(Ne.SHIFT_TAB)] = ib(u), c[ge(WH)] = d, c[ge(Ne.CTRL_G)] = d, c[ge(KH)] = d, c[ge(Ne.CTRL_O)] = d, c[ge(JH)] = d, c[ge(Ne.CTRL_Q)] = d, c[ge(zH)] = d, c[ge(Ne.CTRL_R)] = d, c[ge(YH)] = d, c[ge(Ne.CTRL_S)] = d, c[ge(ZH)] = d, c[ge(Ne.CTRL_T)] = d, c[ge(jH)] = d, c[ge(Ne.CTRL_V)] = d, c[ge(QH)] = d, c[ge(Ne.CTRL_X)] = d, c[ge(XH)] = d, c[ge(Ne.CTRL_Z)] = d;
  function b(_) {
    if (_.length === 0) return _;
    for (const [k, H] of Object.entries(c)) {
      const V = Buffer.from(k, "hex");
      if (Wh(V, _))
        return H(r, t, e, n), e.state === "message" && sb(t, e, s, n), e.lastChar = null, Buffer.from(Uint8Array.prototype.slice.call(_, V.length));
    }
    if (_.length >= 3 && _[0] === 27 && _[1] === 91) {
      for (let k = 2; k < _.length; k++)
        if (_[k] === 117)
          return e.lastChar = null, Buffer.from(Uint8Array.prototype.slice.call(_, k + 1));
    }
    let C = 1;
    const m = _[0];
    (m & 224) === 192 ? C = 2 : (m & 240) === 224 ? C = 3 : (m & 248) === 240 && (C = 4);
    const T = Buffer.from(Uint8Array.prototype.slice.call(_, 0, C)), S = e.lines[e.cursorLine], A = Te.substr(S, e.cursorColumn), x = T.toString("utf8"), D = e.screenColumns - n.length - 1, U = Te.substr(S, 0, e.cursorColumn), O = U.length + x.length + A.length;
    if (A.length === 0 && U.length === D && x === " ")
      e.lines.splice(e.cursorLine + 1, 0, ""), e.cursorLine++, e.lines[e.cursorLine] = "", t.write(`
\r`), t.write("\x1B[K"), t.write(n), e.cursorColumn = 0, hr(t, e, n, e.cursorLine);
    else if (S.length == D && S[S.length - 1] === " " && e.cursorColumn < S.length) {
      const k = Te.substr(S, 0, Te(S).length - 1);
      e.lines[e.cursorLine] = Te.substr(k, 0, e.cursorColumn) + x + Te.substr(k, e.cursorColumn), t.write("\r"), t.write("\x1B[K"), t.write(n + e.lines[e.cursorLine]), e.cursorColumn++, t.write(`\x1B[${e.cursorColumn + 1}G`);
    } else if (O > D) {
      const k = S.lastIndexOf(" "), H = e.cursorColumn;
      if (k !== -1) {
        const V = Te.substr(S, 0, k + 1);
        if (k >= H) {
          const N = Te.substr(V, 0, H) + x + Te.substr(V, H), $ = Te.substr(S, k + 1);
          e.cursorColumn = H + x.length, e.lines[e.cursorLine] = N, e.lines.splice(e.cursorLine + 1, 0, $), hr(t, e, n, e.cursorLine);
        } else {
          const N = V;
          t.write(`\x1B[${n.length + V.length + 1}G`), t.write("\x1B[K");
          const $ = Te.substr(
            S,
            k + 1,
            H - (k + 1)
          ), j = $ + x + A;
          e.lines[e.cursorLine] = N, e.lines.splice(e.cursorLine + 1, 0, j), e.cursorColumn = $.length + x.length, e.cursorLine++, t.write(`
\r`), t.write("\x1B[K"), t.write(n), t.write(j);
          const K = Te.substr(j, 0, e.cursorColumn), P = st(K);
          t.write(`\x1B[${n.length + P + 1}G`), hr(t, e, n, e.cursorLine);
        }
      } else
        t.write("\x07");
    } else {
      e.lines[e.cursorLine] = U + x + A, t.write(`\x1B[${n.length + 1}G`), t.write("\x1B[K"), t.write(U + x + A), e.cursorColumn += 1;
      const k = st(U + x);
      t.write(`\x1B[${k + n.length + 1}G`);
    }
    return sb(t, e, s, n), e.lastChar = x, Buffer.from(Uint8Array.prototype.slice.call(_, C));
  }
  return { process: b };
}
function Jw(r, t, e, n) {
  e.cursorColumn = 0, t.write(`\x1B[${n.length}G`);
}
function Pu(r, t, e, n, i) {
  e.write("\r"), r < n.cursorLine ? e.write(`\x1B[${n.cursorLine - r}F`) : r > n.cursorLine && e.write(`\x1B[${r - n.cursorLine}B`), i && e.write(i);
  const o = i ? i.length : 0, s = n.lines[r], u = Te.substr(s, 0, t), c = st(u) + o + 1;
  c > 1 + o && e.write(`\x1B[${c}G`);
}
function rS(r, t) {
  const n = Te.substr(r, 0, t).match(/\S+\s*$/);
  if (!n) return 0;
  const i = Te(n[0]).length;
  return t - i;
}
function iS(r, t) {
  const n = Te.substr(r, t).match(/^\s*\S+/);
  if (!n) return Te(r).length;
  const i = Te(n[0]).length;
  return t + i;
}
function zw(r, t, e, n) {
  const i = e.lines[e.cursorLine];
  if (e.cursorColumn < i.length) {
    const o = iS(i, e.cursorColumn), s = Te.substr(
      i,
      e.cursorColumn,
      o - e.cursorColumn
    );
    e.deletedText.unshift(s), e.deletedText.length > 10 && e.deletedText.pop(), e.lines[e.cursorLine] = Te.substr(i, 0, e.cursorColumn) + Te.substr(i, o), t.write("\x1B[K"), t.write(Te.substr(i, o));
    const u = Te.substr(i, 0, e.cursorColumn), l = st(u);
    t.write(`\x1B[${n.length + l + 1}G`);
  }
}
function EG(r) {
  return (t, e, n, i) => {
    if (n.isProcessingPaste) {
      hs(t, e, n, i);
      return;
    }
    const o = Ou(n);
    if (o !== null) {
      const u = n.lines[n.cursorLine];
      let l = o.replacement;
      if (n.completions.length > 0) {
        const y = n.selectedCompletionIndex % n.completions.length;
        l = n.completions[y];
      }
      n.lines[n.cursorLine] = Te.substr(u, 0, o.wordStartPos) + l + Te.substr(u, o.wordEndPos), n.cursorColumn = o.wordStartPos + l.length, n.status.left = "", n.completions = [], n.lastCompletionQuery = null, n.state = "message", e.write("\r"), e.write("\x1B[K"), e.write(i + n.lines[n.cursorLine]);
      const c = n.lines[n.cursorLine], d = Te.substr(c, 0, n.cursorColumn), g = st(d);
      e.write(`\x1B[${i.length + g + 1}G`), ps(e, n, i, () => {
        Fr(e, n);
      });
      return;
    }
    if (n.lastChar === "\\") {
      const u = n.lines[n.cursorLine];
      n.lines[n.cursorLine] = Te.substr(u, 0, n.cursorColumn - 1), e.write("\x1B[1D"), e.write("\x1B[K"), n.cursorColumn--, hs(t, e, n, i);
      return;
    }
    const s = n.lines.join(`
`);
    if (s.trim() !== "") {
      n.cursorLine > 0 && e.write(`\x1B[${n.cursorLine}F`), e.write("\r"), e.write("\x1B[0J");
      for (const u of n.lines)
        e.write("\r"), t.write(`${i}${u}
`);
      e.write("\r"), t.write(`
`), n.state = "submitting", n.lines = [""], n.cursorLine = 0, n.cursorColumn = 0, n.status.left = "", n.lastCompletionQuery = null, r(s);
    }
  };
}
function Yw(r, t, e, n) {
  const i = e.lines[e.cursorLine], o = Te(i).length;
  e.cursorColumn = o, t.write("\r"), n && t.write(n);
  const s = n ? n.length : 0, u = st(i);
  t.write(`\x1B[${u + s + 1}G`);
}
function AG(r, t, e, n, i) {
  if (e.cursorLine === 0 && i) {
    if (!e.isNavigatingHistory) {
      const s = e.lines.join(`
`);
      e.currentHistoryContent = s, e.isNavigatingHistory = !0;
    }
    const o = i.previous();
    o !== null ? wi(t, e, n, o) : t.write("\x07");
  } else if (e.cursorLine > 0) {
    const o = e.cursorLine - 1, s = Math.min(e.cursorColumn, e.lines[o].length);
    Pu(o, s, t, e, n), e.cursorLine = o, e.cursorColumn = s;
  }
}
function xG(r, t, e, n, i) {
  if (e.cursorLine === e.lines.length - 1 && i && e.isNavigatingHistory) {
    const s = i.next();
    s !== null ? wi(t, e, n, s) : e.currentHistoryContent !== null ? (wi(t, e, n, e.currentHistoryContent), e.isNavigatingHistory = !1, e.currentHistoryContent = null, i.reset()) : t.write("\x07");
  } else if (e.cursorLine < e.lines.length - 1) {
    const s = e.cursorLine + 1, u = Math.min(e.cursorColumn, e.lines[s].length);
    Pu(s, u, t, e, n), e.cursorLine = s, e.cursorColumn = u;
  }
}
function th(r, t, e, n) {
  if (e.cursorColumn < e.lines[e.cursorLine].length) {
    const i = e.lines[e.cursorLine], o = Te.substr(i, 0, e.cursorColumn), s = Te.substr(i, 0, e.cursorColumn + 1), u = st(s) - st(o);
    e.cursorColumn++, t.write(`\x1B[${u}C`);
  } else e.cursorLine < e.lines.length - 1 && (e.cursorLine++, e.cursorColumn = 0, t.write("\x1B[1B\r"), n && t.write(n));
}
function nh(r, t, e, n) {
  if (e.cursorColumn > 0) {
    const i = e.lines[e.cursorLine], o = Te.substr(i, 0, e.cursorColumn), s = Te.substr(i, 0, e.cursorColumn - 1), u = st(o) - st(s);
    e.cursorColumn--, t.write(`\x1B[${u}D`);
  } else if (e.cursorLine > 0) {
    e.cursorLine--, e.cursorColumn = e.lines[e.cursorLine].length, t.write("\x1B[1F\r"), n && t.write(n);
    const i = n ? n.length : 0, o = e.lines[e.cursorLine], s = Te.substr(o, 0, e.cursorColumn), u = st(s);
    t.write(`\x1B[${u + i + 1}G`);
  }
}
function dl(r, t, e, n) {
  const i = e.screenColumns - n.length - 1;
  if (e.cursorColumn > 0) {
    const o = e.lines[e.cursorLine], s = Te.substr(o, 0, e.cursorColumn), u = Te(s).pop(), l = st(u) || 1;
    e.deletedText.unshift(u), e.deletedText.length > 10 && e.deletedText.pop();
    const c = Te.substr(o, e.cursorColumn), d = Te.substr(s, 0, Te(s).length - 1);
    e.lines[e.cursorLine] = d + c, e.cursorColumn--, t.write(`\x1B[${l}D`), t.write("\x1B[K"), t.write(c), c.length > 0 && t.write(`\x1B[${st(c)}D`);
  } else if (e.cursorLine > 0) {
    if (e.lines[e.cursorLine - 1].length + e.lines[e.cursorLine].length > i) {
      t.write("\x07");
      return;
    }
    const o = e.lines[e.cursorLine - 1], s = e.lines[e.cursorLine];
    e.deletedText.unshift(`
`), e.deletedText.length > 10 && e.deletedText.pop(), e.cursorColumn = o.length, e.lines[e.cursorLine - 1] = o + s, e.lines.splice(e.cursorLine, 1), e.cursorLine--, t.write("\x1B[1F"), t.write(`\x1B[${n ? n.length + 1 : 1}G`), hr(t, e, n, e.cursorLine);
  }
}
function Zw(r, t, e, n) {
  if (e.cursorColumn > 0) {
    const i = e.lines[e.cursorLine], o = Te.substr(i, 0, e.cursorColumn), s = Te.substr(i, e.cursorColumn);
    e.deletedText.unshift(o), e.deletedText.length > 10 && e.deletedText.pop(), e.lines[e.cursorLine] = s, t.write("\r"), n && t.write(n), t.write("\x1B[K"), t.write(s), e.cursorColumn = 0;
  }
}
function jw(r, t, e, n) {
  const i = e.lines[e.cursorLine];
  if (e.cursorColumn < i.length) {
    const o = Te.substr(i, e.cursorColumn);
    e.deletedText.unshift(o), e.deletedText.length > 10 && e.deletedText.pop(), e.lines[e.cursorLine] = Te.substr(i, 0, e.cursorColumn), t.write("\x1B[K");
  }
}
function hl(r, t, e, n) {
  if (e.cursorColumn > 0) {
    const i = e.lines[e.cursorLine], o = Te.substr(i, 0, e.cursorColumn), s = rS(o, Te(o).length), u = Te.substr(o, s);
    e.deletedText.unshift(u), e.deletedText.length > 10 && e.deletedText.pop();
    const l = Te.substr(i, e.cursorColumn);
    e.lines[e.cursorLine] = Te.substr(o, 0, s) + l;
    const c = st(Te.substr(o, 0, s));
    t.write(`\x1B[${n.length + c + 1}G`), t.write("\x1B[K"), t.write(l), t.write(`\x1B[${n.length + c + 1}G`), e.cursorColumn = s;
  }
}
function Qw(r, t) {
  return (e, n, i, o) => {
    if (!i.isNavigatingHistory) {
      const u = i.lines.join(`
`);
      i.currentHistoryContent = u, i.isNavigatingHistory = !0;
    }
    const s = r.previous();
    s !== null ? wi(n, i, o, s) : n.write("\x07");
  };
}
function Xw(r, t) {
  return (e, n, i, o) => {
    if (!i.isNavigatingHistory) {
      n.write("\x07");
      return;
    }
    const s = r.next();
    s !== null ? wi(n, i, o, s) : i.currentHistoryContent !== null ? (wi(n, i, o, i.currentHistoryContent), i.isNavigatingHistory = !1, i.currentHistoryContent = null, r.reset()) : n.write("\x07");
  };
}
function rh(r, t, e, n) {
  if (e.cursorLine === 0) {
    e.cursorColumn = 0, t.write("\r"), n && t.write(n);
    return;
  }
  Pu(0, 0, t, e, n), e.cursorLine = 0, e.cursorColumn = 0;
}
function ih(r, t, e, n) {
  const i = e.lines.length - 1;
  if (e.cursorLine === i) {
    e.cursorColumn = e.lines[i].length, t.write("\r"), n && t.write(n);
    const s = n ? n.length : 0, u = e.lines[i], l = st(u);
    t.write(`\x1B[${l + s + 1}G`);
    return;
  }
  const o = e.lines[i].length;
  Pu(i, o, t, e, n), e.cursorLine = i, e.cursorColumn = o;
}
function wi(r, t, e, n) {
  t.cursorLine > 0 && r.write(`\x1B[${t.cursorLine}F`), r.write("\r");
  for (let o = 0; o < t.lines.length; o++)
    r.write("\x1B[K"), o < t.lines.length - 1 && r.write(`
\r`);
  t.lines.length > 1 && r.write(`\x1B[${t.lines.length - 1}F`);
  const i = n.split(`
`);
  t.lines = i, t.cursorLine = 0, t.cursorColumn = i.length > 0 && i[0]?.trimEnd().length || 0, hr(r, t, e, 0);
}
function eb(r, t, e, n) {
  if (e.deletedText.length > 0) {
    const i = e.deletedText[0];
    if (i === `
`) {
      const o = e.lines[e.cursorLine], s = Te.substr(o, 0, e.cursorColumn), u = Te.substr(o, e.cursorColumn);
      e.lines[e.cursorLine] = s, e.lines.splice(e.cursorLine + 1, 0, u), t.write("\x1B[K"), t.write(`
\r`), t.write(u), t.write("\r"), n && t.write(n), e.cursorLine++, e.cursorColumn = 0;
    } else {
      const o = e.lines[e.cursorLine], s = Te.substr(o, e.cursorColumn);
      e.lines[e.cursorLine] = Te.substr(o, 0, e.cursorColumn) + i + s, t.write(i), t.write(s), s.length > 0 && t.write(`\x1B[${s.length}D`), e.cursorColumn += i.length;
    }
  }
}
function tb(r, t, e, n) {
  t.write("\x1B[2J"), t.write("\x1B[H"), hr(t, e, n, 0);
}
function nb(r, t, e, n) {
  const i = e.lines[e.cursorLine];
  if (e.cursorColumn < i.length) {
    const o = iS(i, e.cursorColumn), s = Te.substr(i, 0, e.cursorColumn), u = Te.substr(i, 0, o), l = st(u) - st(s);
    l > 0 && (t.write(`\x1B[${l}C`), e.cursorColumn = o);
  } else e.cursorLine < e.lines.length - 1 && (t.write(`
\r`), n && t.write(n), e.cursorLine++, e.cursorColumn = 0);
}
function rb(r, t, e, n) {
  const i = e.lines[e.cursorLine];
  if (e.cursorColumn > 0) {
    const o = rS(i, e.cursorColumn), s = Te.substr(i, 0, e.cursorColumn), u = Te.substr(i, 0, o), l = st(s) - st(u);
    l > 0 && (t.write(`\x1B[${l}D`), e.cursorColumn = o);
  } else if (e.cursorLine > 0) {
    t.write("\x1B[1F\r"), n && t.write(n), e.cursorLine--, e.cursorColumn = e.lines[e.cursorLine].length;
    const o = n ? n.length : 0;
    t.write(`\x1B[${e.cursorColumn + o + 1}G`);
  }
}
function hs(r, t, e, n) {
  const i = e.lines[e.cursorLine], o = Te.substr(i, 0, e.cursorColumn), s = Te.substr(i, e.cursorColumn);
  if (e.lines[e.cursorLine] = o, e.lines.splice(e.cursorLine + 1, 0, s), t.write("\x1B[0K"), t.write(`
`), e.cursorLine >= e.lines.length - 2) {
    t.write("\x1B[2K\r"), t.write(n + s), e.cursorLine++, e.cursorColumn = 0, t.write(`\r
`), Fr(t, e), t.write("\x1B[1F"), t.write(`\x1B[${n.length + 1}G`);
    return;
  }
  e.cursorLine++, e.cursorColumn = 0, hr(t, e, n, e.cursorLine);
}
function RG(r) {
  return (t, e, n, i) => {
    Ou(n) && n.completions.length > 0 && r({ type: "cycle-completion", direction: "forward" });
  };
}
function ib(r) {
  return (t, e, n, i) => {
    Ou(n) && n.completions.length > 0 && r({ type: "cycle-completion", direction: "backward" });
  };
}
function pl(r, t, e, n) {
  const i = e.lines[e.cursorLine];
  if (e.cursorColumn < i.length) {
    const s = Te(i)[e.cursorColumn];
    e.deletedText.unshift(s), e.deletedText.length > 10 && e.deletedText.pop();
    const u = Te.substr(i, 0, e.cursorColumn), l = Te.substr(i, e.cursorColumn + 1);
    e.lines[e.cursorLine] = u + l, t.write("\x1B[K"), t.write(l), l.length > 0 && t.write(`\x1B[${st(l)}D`);
  } else if (e.cursorLine < e.lines.length - 1) {
    const o = e.lines[e.cursorLine + 1];
    e.deletedText.unshift(`
`), e.deletedText.length > 10 && e.deletedText.pop(), e.lines[e.cursorLine] = e.lines[e.cursorLine] + o, e.lines.splice(e.cursorLine + 1, 1), hr(t, e, n, e.cursorLine);
  }
}
function ps(r, t, e, n) {
  for (let u = 0; u < t.lines.length - t.cursorLine; u++)
    r.write(`
\r`);
  r.write("\x1B[K"), n(), r.write(`\x1B[${t.lines.length - t.cursorLine}F`);
  const i = t.lines[t.cursorLine], o = Te.substr(i, 0, t.cursorColumn), s = st(o);
  r.write(`\x1B[${s + e.length + 1}G`);
}
function Fr(r, t) {
  const e = t.screenColumns;
  let n = t.status.left, i = t.status.right;
  if (i && i.length > 0) {
    if (st(n) + st(i) + 2 > e)
      if (st(i) >= e)
        i = i.slice(0, e - 3) + "...", n = "";
      else {
        const c = e - st(i) - 2;
        c > 3 ? n = n.slice(0, c - 3) + "..." : n = "";
      }
    r.write(n);
    const s = st(n), u = st(i), l = e - s - u;
    l > 0 && r.write(" ".repeat(l)), r.write("\x1B[0m"), r.write(i);
  } else
    r.write(n);
}
function Ou(r) {
  const t = r.lines[r.cursorLine], e = Te.substr(t, 0, r.cursorColumn), n = Te.substr(t, r.cursorColumn), i = e.match(/\S*$/), o = n.match(/^\S*/), s = i ? i[0] : "", u = o ? o[0] : "", l = s + u;
  if (!l.trim() || !l.startsWith("@"))
    return null;
  const c = r.cursorColumn - s.length, d = c + l.length, g = Te.substr(l, 1);
  return {
    index: c,
    fullWord: l,
    replacement: g,
    wordStartPos: c,
    wordEndPos: d
  };
}
function hr(r, t, e, n) {
  const i = t.cursorLine - n;
  if (i > 0)
    r.write(`\x1B[${i}F`);
  else if (i < 0)
    throw new Error("Invalid redraw start position");
  const o = t.lines.slice(n);
  r.write("\r"), r.write("\x1B[0J");
  for (let d = 0; d < o.length; d++)
    r.write(e + o[d] + `
\r`);
  Fr(r, t);
  const s = o.length - i;
  s > 0 && r.write(`\x1B[${s}F`);
  const u = t.lines[t.cursorLine], l = Te.substr(u, 0, t.cursorColumn), c = st(l);
  r.write(`\x1B[${e.length + c + 1}G`);
}
function ob(r, t, e, n = 0) {
  const i = [
    ...e.slice(n),
    ...e.slice(0, n)
  ], o = "  ";
  let s = 0;
  const u = [];
  for (const d of i)
    s += o.length + st(d), s <= r.columns && u.push(d);
  const [l, ...c] = u;
  return l ? [
    t.print(l, { foreground: "blue" }),
    ...c.map((d) => t.print(d, { foreground: "gray" }))
  ].join(o) : "";
}
function sb(r, t, e, n) {
  const i = Ou(t);
  i !== null ? t.lastCompletionQuery !== i.replacement && (t.lastCompletionQuery = i.replacement, e(i.replacement), oe.debug("Entered file mention mode", { query: i.replacement })) : (t.state = "message", t.status.left = "", t.lastCompletionQuery = null), ps(r, t, n, () => {
    Fr(r, t);
  });
}
const oh = _b(ii);
let Xl = null;
async function IG(r = qr, t) {
  Xl = await MG(35789);
  const e = `${Xl}`;
  return oe.info(`Generated callback port: ${e}`), `${r}/auth/cli-login?authToken=${encodeURIComponent(t)}&callbackPort=${encodeURIComponent(e)}`;
}
async function MG(r, t = 10) {
  oe.info(`Finding available port starting from ${r}`);
  for (let e = 0; e < t; e++) {
    const n = r + e;
    try {
      return await new Promise((i, o) => {
        const s = wb();
        s.once("error", (u) => {
          u.code === "EADDRINUSE" ? o(new Error(`Port ${n} is in use`)) : o(u);
        }), s.once("listening", () => {
          s.close(() => i());
        }), s.listen(n, "127.0.0.1");
      }), oe.info(`Found available port: ${n}`), n;
    } catch {
      oe.info(`Port ${n} is in use, trying port ${n + 1}`);
      continue;
    }
  }
  throw new Error(`Could not find an available port after ${t} attempts`);
}
async function kG(r, t = 5 * 60 * 1e3) {
  if (oe.info("Starting local HTTP server to receive API key from browser"), !Xl)
    throw new Error("No port selected. Call generateLoginLink first.");
  const e = Xl;
  return oe.info(`Using selected port: ${e}`), new Promise((n, i) => {
    const o = wb((u, l) => {
      const c = process.env.NODE_ENV === "production" ? "ampcode.com" : "*";
      if (l.setHeader("Access-Control-Allow-Origin", c), l.setHeader("Access-Control-Allow-Methods", "GET"), u.url?.startsWith("/auth/callback")) {
        const d = new URL(u.url, `http://127.0.0.1:${e}`), g = d.searchParams.get("apiKey");
        if (d.searchParams.get("authToken") !== r) {
          i(new Error("Invalid authentication token"));
          return;
        }
        g ? (oe.info(`Received API key from server: ${g.substring(0, 8)}...`), l.writeHead(200, { "Content-Type": "text/html" }), l.end(`
						<!DOCTYPE html>
						<html>
							<head>
								<title>Amp CLI Login Success</title>
								<style>
									body { font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; max-width: 600px; margin: 0 auto; padding: 2rem; background-color: #fafaf8; color: #0b0d0b; }
								</style>
							</head>
							<body>
								<h1>Login Successful!</h1>
								<p>Your Amp CLI has been configured successfully. You can close this window and return to your terminal.</p>
							</body>
						</html>
					`), o.close(), n(g)) : (l.writeHead(400, { "Content-Type": "text/html" }), l.end(`
						<!DOCTYPE html>
						<html>
							<head>
								<title>Amp CLI Login Error</title>
								<style>
									body { font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; max-width: 600px; margin: 0 auto; padding: 2rem; background-color: #fafaf8; color: #0b0d0b; }
									h1 { color: #d44444; }
								</style>
							</head>
							<body>
								<h1>Login Failed</h1>
								<p>There was an error processing your login. Please try again.</p>
							</body>
						</html>
					`));
      } else
        l.writeHead(404), l.end();
    });
    o.listen(e, "127.0.0.1", () => {
      oe.info(`Listening for auth callback on port ${e}`);
    });
    const s = setTimeout(() => {
      o.close(), i(new Error("Login timed out"));
    }, t);
    o.on("error", (u) => {
      clearTimeout(s), oe.error(`Server error: ${u.message}`), i(u);
    });
  });
}
async function PG(r, t = qr, e) {
  await e.set("apiKey", r, t), oe.info("API key stored successfully");
}
async function OG(r) {
  try {
    switch (sP()) {
      case "win32":
        await oh(`start "" "${r}"`);
        break;
      case "darwin":
        await oh(`open "${r}"`);
        break;
      default:
        await oh(`xdg-open "${r}"`);
        break;
    }
    oe.info(`Opened browser with URL: ${r}`);
  } catch (t) {
    throw oe.error(`Failed to open browser: ${t}`), t;
  }
}
async function Or(r, t, { stdin: e, stdout: n } = { stdin: process.stdin, stdout: process.stdout }) {
  return new Promise((i) => {
    const o = t.map((c, d) => d === 0 ? c.toUpperCase() : c.toLowerCase()).join("/");
    n.write(`${r} (${o}) `);
    function s(c) {
      e.removeListener("data", u), e.removeListener("error", l), n.write(`
`), i(c);
    }
    function u(c) {
      for (let d = 0; d < c.length; d++) {
        if (c[d] === 3) {
          s(null);
          return;
        }
        if (Wh(Ne.CTRL_C, c.subarray(d))) {
          s(null);
          return;
        }
        if (c[d] === 27 && c.length === 1) {
          s(null);
          return;
        }
        if (Wh(Ne.ESC, c.subarray(d))) {
          s(null);
          return;
        }
        const g = String.fromCharCode(c[d]).toLowerCase();
        for (const y of t)
          if (y.toLowerCase() === g) {
            n.write(y), s(y);
            return;
          }
        if (c[d] === 13 || c[d] === 10) {
          n.write(t[0] || ""), s(t[0] || "");
          return;
        }
      }
    }
    function l(c) {
      s(null);
    }
    e.on("data", u), e.once("error", l);
  });
}
async function LG(r) {
  try {
    const t = new AbortController(), e = setTimeout(() => t.abort(), 500), n = await fetch("https://registry.npmjs.org/@sourcegraph/amp/latest", {
      signal: t.signal
    });
    if (clearTimeout(e), !n.ok)
      return { hasUpdate: !1 };
    const o = (await n.json()).version;
    return o === void 0 ? { hasUpdate: !1 } : { hasUpdate: NG(r, o) < 0, latestVersion: o };
  } catch {
    return { hasUpdate: !1 };
  }
}
function NG(r, t) {
  const e = (s) => {
    const [u, l] = s.split("-");
    return { parts: u?.split(".").map(Number) || [], label: l };
  }, n = e(r), i = e(t), o = Math.max(n.parts.length, i.parts.length);
  for (let s = 0; s < o; s++) {
    const u = n.parts[s] || 0, l = i.parts[s] || 0;
    if (u < l) return -1;
    if (u > l) return 1;
  }
  return n.label === i.label ? 0 : !n.label && i.label ? 1 : n.label && !i.label ? -1 : n.label && i.label ? n.label < i.label ? -1 : 1 : 0;
}
async function DG() {
  const r = process.env.npm_config_user_agent;
  if (r) {
    if (r.includes("pnpm")) return "pnpm";
    if (r.includes("yarn")) return "yarn";
    if (r.includes("bun")) return "bun";
    if (r.includes("npm")) return "npm";
  }
  if (process.env.PNPM_HOME || process.env.PNPM_SCRIPT_SRC_DIR) return "pnpm";
  if (process.env.YARN_WRAP_OUTPUT || process.env.YARNPKG_LOCKFILE_VERSION) return "yarn";
  if (process.env.BUN_INSTALL) return "bun";
  const [t, e, n, i] = await Promise.allSettled([
    ml("pnpm"),
    ml("yarn"),
    ml("bun"),
    ml("npm")
  ]);
  return t?.status === "fulfilled" && t?.value ? "pnpm" : e?.status === "fulfilled" && e?.value ? "yarn" : n?.status === "fulfilled" && n?.value ? "bun" : i?.status === "fulfilled" && i?.value ? "npm" : null;
}
async function ml(r) {
  return new Promise((t) => {
    const e = tu(r, ["--version"], { stdio: "ignore" });
    e.on("close", (n) => t(n === 0)), e.on("error", () => t(!1));
  });
}
function FG(r) {
  switch (r) {
    case "pnpm":
      return ["pnpm", ["add", "-g", "@sourcegraph/amp"]];
    case "yarn":
      return ["yarn", ["global", "add", "@sourcegraph/amp"]];
    case "bun":
      return ["bun", ["add", "-g", "@sourcegraph/amp"]];
    case "npm":
    default:
      return ["npm", ["install", "-g", "@sourcegraph/amp"]];
  }
}
async function $G() {
  const r = await DG();
  if (!r)
    throw new Error("No supported package manager found.");
  const [t, e] = FG(r);
  return new Promise((n, i) => {
    const o = tu(t, e, {
      stdio: "pipe"
    });
    let s = "", u = "";
    o.stdout?.on("data", (l) => {
      s += l.toString();
    }), o.stderr?.on("data", (l) => {
      u += l.toString();
    }), o.on("close", (l) => {
      if (l === 0)
        n();
      else {
        const c = u || s || "No output";
        i(
          new Error(`${t} ${e.join(" ")} failed with code ${l}:
${c}`)
        );
      }
    }), o.on("error", (l) => {
      i(new Error(`Failed to spawn ${t}: ${l.message}`));
    });
  });
}
async function UG() {
  const r = Je.join(process.cwd(), Fk), t = Je.join(process.cwd(), ".sourcegraph", "memory.md");
  let e = !0, n = !1;
  try {
    await li(t, "utf-8");
    try {
      await li(r, "utf-8"), e = !1;
    } catch {
      try {
        await Qh(Je.dirname(r), { recursive: !0 });
        const o = await li(t, "utf-8");
        await Xh(r, o, "utf-8"), await Zk(t), e = !1, n = !0;
      } catch (o) {
        oe.error("Failed to migrate memory.md to AGENT.md", o), e = !0;
      }
    }
  } catch {
    try {
      await li(r, "utf-8"), e = !1;
    } catch {
      e = !0;
    }
  }
  return {
    shouldGenerate: e,
    migrated: n
  };
}
async function qG(r) {
  await r.handle({
    type: "user:message",
    message: {
      content: [{ type: "text", text: $k }]
    }
  });
}
const Kh = Je.join(
  TV || Je.join(process.env.HOME || process.cwd(), ".local", "state"),
  "amp",
  "last-thread-id"
);
async function Jh(r) {
  try {
    await Qh(Je.dirname(Kh), { recursive: !0 }), await Xh(Kh, r, "utf-8");
  } catch (t) {
    oe.debug("Failed to save last thread ID", t);
  }
}
async function ab() {
  try {
    return (await li(Kh, "utf-8")).trim();
  } catch {
    return null;
  }
}
const BG = [
  {
    name: "notifications",
    long: "notifications",
    type: "flag",
    default: !1,
    description: (r) => `${r ? "Enable" : "Disable"} sound notifications (enabled by default when interactive)`
  },
  {
    name: "color",
    long: "color",
    type: "flag",
    description: (r) => `${r ? "Enable" : "Disable"} color output (enabled by default if stdout and stderr are sent to a TTY)`
  },
  {
    name: "settingsFile",
    long: "settings-file",
    type: "option",
    description: `Custom settings file path (overrides the default location ${xs})`
  },
  {
    name: "logLevel",
    long: "log-level",
    type: "option",
    description: `Set log level (${Object.keys(oe).join(", ")})`
  },
  {
    name: "logFile",
    long: "log-file",
    type: "option",
    description: "Set log file location"
  }
];
class VG {
  async environment() {
    const t = process.cwd(), e = Mp.file(t), n = await _L(e, {
      workingDirectory: e
    });
    return {
      workspacePaths: [t],
      workingDirectory: t,
      rootDirectoryListing: n
    };
  }
  async agentFile(t) {
    try {
      return await li(Je.join(process.cwd(), t), "utf-8");
    } catch {
      return null;
    }
  }
}
async function xl(r, t) {
  Up({
    logLevel: t.logLevel || process.env.AMP_LOG_LEVEL,
    logFile: t.logFile || process.env.AMP_LOG_FILE
  }), Hk("0.0.1748361686-ga6cbdd");
  const e = t.settingsFile ?? process.env.AMP_SETTINGS_FILE;
  oe.info("Using settings file", { settingsFile: e });
  const n = Gh(), i = AV({ settingsFile: e }), o = process.env.AMP_API_KEY;
  o && await n.set("apiKey", o, r.ampURL);
  const s = wP({
    storage: i,
    secretStorage: n,
    workspaceRoots: It.of([Mp.file(process.cwd())]),
    defaultAmpURL: r.ampURL
  }), u = new VG(), l = vb(), c = hL({ configService: s, toolService: l });
  hC(l);
  let d, g;
  if (r.isInteractiveMode) {
    d = new Ww(), await d.start();
    try {
      xH(d, process.cwd());
    } catch (m) {
      oe.error("Failed to index files for fuzzy completion", m);
    }
    g = RH(d, process.cwd());
  } else
    d = new class extends Ww {
      async start() {
      }
      async query() {
        return [];
      }
      dispose() {
      }
    }(), g = { dispose: () => {
    } };
  await n.get("apiKey", r.ampURL) || (tt.write(`No API key found. Starting login flow...
`), await HG(r, n) || process.exit(1));
  const y = yL(), w = new CL(y), b = new bL(y), _ = new RV(w);
  let C;
  return oe.info("Starting Amp background services"), C = SL({
    threadService: w,
    threadHistoryService: b,
    isExtensionDevelopment: !1
  }), {
    configService: s,
    systemPromptService: u,
    toolService: l,
    mcpService: c,
    threadService: w,
    threadHistoryService: b,
    summaryService: _,
    threadSyncService: C,
    threadStorage: y,
    secretStorage: n,
    settingsStorage: i,
    fileWatcher: g,
    fuzzyServer: d
  };
}
async function HG(r, t) {
  return r.isInteractiveMode && !(await Or("Would you like to log in to Amp?", ["y", "n"]) == "y") ? (tt.write(`Login cancelled. Run the command again to retry.
`), !1) : await oS(r, t);
}
async function oS(r, t) {
  const e = oP(32).toString("hex"), n = await IG(r.ampURL, e);
  tt.write(
    `If your browser doesn't open automatically, visit:

${r.printer.print(n, {
      foreground: "blue",
      style: "bold"
    })}

`
  );
  try {
    await OG(n);
  } catch {
    Ge.write(
      `${r.printer.print("Error opening browser!", { foreground: "red" })}

`
    );
  }
  tt.write(`Waiting for login to complete...
`), tt.write(`Press Ctrl+C to cancel

`);
  try {
    const i = await kG(e);
    return await PG(i, r.ampURL, t), tt.write(`
Login successful! You can now use the Amp CLI.
`), !0;
  } catch (i) {
    return Ge.write(`
Login failed: ${i instanceof Error ? i.message : String(i)}
`), !1;
  }
}
function GG(r) {
  const t = new vV().name("amp").description("AI-powered coding assistant").version("0.0.1748361686-ga6cbdd").option("--thread-id [THREAD_ID]", "ID of the thread to continue running", void 0);
  t.addHelpText(
    "after",
    (() => {
      let i = "";
      i += r.printer.print("Environment variables:", { style: "bold" }) + `

`, i += "  " + r.printer.print("AMP_API_KEY", { foreground: "green" }) + `              API key for Amp (see https://ampcode.com/settings)
`, i += "  " + r.printer.print("AMP_URL", { foreground: "green" }) + "                  URL for the Amp service (default is " + qr + `)
`, i += "  " + r.printer.print("AMP_LOG_LEVEL", { foreground: "green" }) + `            Set log level (can also use --log-level)
`, i += "  " + r.printer.print("AMP_LOG_FILE", { foreground: "green" }) + `             Set log file location (can also use --log-file)
`, i += "  " + r.printer.print("AMP_SETTINGS_FILE", { foreground: "green" }) + "        Set settings file path (can also use --settings-file, default: " + xs + `)
`, i += `
`, i += r.printer.print("Examples:", { style: "bold" }) + `

`;
      for (const o of cl.examples)
        i += o.description + `

`, i += "  " + r.printer.print(o.command, { foreground: "green" }) + `

`;
      i += r.printer.print("Configuration:", { style: "bold" }) + `

`, i += cl.configuration.description + `

`, i += r.printer.print("Sample configuration:", { style: "bold" }) + `

`, i += cl.configuration.sampleConfig + `

`, i += r.printer.print("Settings reference:", { style: "bold" }) + `

`;
      for (const o of cl.configuration.keyDescriptions)
        i += "  " + r.printer.print(o.key, { foreground: "green" }) + `
`, i += "    " + o.description + `

`;
      return i;
    })()
  ), t.configureHelp({
    formatHelp: (i, o) => {
      const s = (d, g) => {
        if (d.length === 0) return "";
        let y = r.printer.print(g, { style: "bold" }) + `

`;
        for (const w of d) {
          const b = w.flags.padEnd(40);
          y += "  " + r.printer.print(b, { foreground: "green" }) + " " + w.description + `
`;
        }
        return y + `
`;
      };
      let u = "";
      i.parent === null && (u += r.printer.print("Amp CLI", { style: "bold" }) + `

`);
      const l = [];
      {
        let d = i;
        for (; d.parent; )
          l.unshift(d.name()), d = d.parent;
        l.unshift(d.name());
      }
      u += r.printer.print("Usage:", { style: "bold" }) + " " + r.printer.print(
        `${l.join(" ")} [options]${i.commands.length > 0 ? " [subcommand]" : ""}`,
        {
          foreground: "green"
        }
      ) + `

`, i.parent !== null && i.description() && (u += i.description() + `

`), u += s(i.options, "Options:"), i.parent && (u += s(i.parent.options, "Global options:"));
      const c = i.commands;
      if (c.length > 0) {
        let d = function(g, y = "  ") {
          let w = "";
          for (const b of g) {
            const _ = b.name().padEnd(Math.max(30 - y.length, 10));
            w += y + r.printer.print(_, { foreground: "green" }) + b.description() + `
`, b.commands && b.commands.length > 0 && (w += d(b.commands, y + "  "));
          }
          return w;
        };
        u += r.printer.print("Commands:", { style: "bold" }) + `

`, u += d(c), u += `
`;
      }
      return u;
    }
  }), t.command("logout").description("Log out by removing stored API key").action(async (i, o) => {
    const s = o.optsWithGlobals(), u = lr(s), l = Gh();
    await l.get("apiKey", u.ampURL) || (tt.write(`Already logged out.
`), process.exit(0)), await l.set("apiKey", "", u.ampURL), tt.write(`Successfully logged out.
`), process.exit(0);
  }), t.command("login").description("Log in to Amp").action(async (i, o) => {
    const s = o.optsWithGlobals(), u = lr(s), l = Gh();
    await l.get("apiKey", u.ampURL) && (tt.write(`Already logged in.
`), await Or("Do you want to log in again?", ["y", "n"]) === "n" && process.exit(0), tt.write(`
`));
    const d = await oS(u, l);
    process.exit(d ? 0 : 1);
  });
  const e = t.command("threads").description("Thread management commands");
  e.command("new").description("Create a new thread and print its ID").action(async (i, o) => {
    const s = o.optsWithGlobals(), u = lr(s), l = await xl(u, s);
    try {
      const c = Il(), d = {
        id: c,
        messages: [],
        created: Date.now(),
        v: 0
      };
      l.threadStorage.set(c, d);
      const g = await Dr(`/api/threads/${c}`, {
        method: "POST",
        body: JSON.stringify(d)
      });
      if (!g.ok) {
        const y = await g.text().catch(() => "Unable to read response body");
        throw new Error(
          `Failed to create thread on server: ${g.status}${y ? `: ${y}` : ""}`
        );
      }
      await Jh(c), tt.write(`${c}
`), l.threadSyncService?.dispose(), l.threadService.dispose(), await l.mcpService.dispose(), process.exit(0);
    } catch (c) {
      Ge.write(
        `Error creating thread: ${c instanceof Error ? c.message : String(c)}
`
      ), process.exit(1);
    }
  }), e.command("continue [threadId]").description("Continue an existing thread (uses last used thread if no ID provided)").action(async (i, o, s) => {
    const u = s.optsWithGlobals(), l = lr(u);
    let c = i;
    c || (c = await ab(), c || (Ge.write(
      l.printer.print("Error: ", { foreground: "red", style: "bold" }) + `No thread ID provided and no previously used thread found.
Provide a thread ID as an argument or run a thread first.
`
    ), process.exit(1))), await lb(l, { ...u, threadId: c });
  }), e.command("fork [threadId]").description(
    "Create a new thread by forking an existing one and print its ID (uses last used thread if no ID provided)"
  ).action(async (i, o, s) => {
    const u = s.optsWithGlobals(), l = lr(u), c = await xl(l, u);
    try {
      let d = i;
      d || (d = await ab(), d || (Ge.write(
        l.printer.print("Error: ", { foreground: "red", style: "bold" }) + `No thread ID provided and no previously used thread found.
Provide a thread ID as an argument or run a thread first.
`
      ), process.exit(1))), yb(d) || (Ge.write(`Invalid thread ID given.
`), process.exit(1));
      const g = await Dr(`/api/threads/${d}`);
      g.ok || (Ge.write(
        `Failed to load thread ${d}: ${await g.text()}
`
      ), process.exit(1));
      const y = await g.json(), w = Il(), b = {
        id: w,
        messages: y.messages,
        created: Date.now(),
        v: 0
      };
      c.threadStorage.set(w, b);
      const _ = await Dr(`/api/threads/${w}`, {
        method: "POST",
        body: JSON.stringify(b)
      });
      if (!_.ok) {
        const C = await _.text().catch(() => "Unable to read response body");
        throw new Error(
          `Failed to create forked thread on server: ${_.status}${C ? `: ${C}` : ""}`
        );
      }
      await Jh(w), tt.write(`${w}
`), c.threadSyncService?.dispose(), c.threadService.dispose(), await c.mcpService.dispose(), process.exit(0);
    } catch (d) {
      Ge.write(
        `Error forking thread: ${d instanceof Error ? d.message : String(d)}
`
      ), process.exit(1);
    }
  }), e.command("list").description("List all your threads with their titles and share status").action(async (i, o) => {
    const s = o.optsWithGlobals(), u = lr(s), l = await xl(u, s);
    try {
      const c = await Dr("/api/threads");
      c.ok || (Ge.write(
        `Failed to load threads: ${c.status} ${await c.text()}
`
      ), process.exit(1));
      const d = await c.json();
      d.length === 0 && (tt.write(`No threads found.
`), process.exit(0));
      const g = ["Title", "Last Updated", "Visibility", "Messages", "Thread ID"], y = d.map((w) => {
        const b = w.title || "Untitled";
        let _ = "Team";
        w.meta.private ? _ = "Private" : w.meta.public && (_ = "Public");
        const C = ZG(new Date(w.updatedAt));
        return [
          b,
          C,
          _,
          w.messageCount.toString(),
          w.id
        ];
      });
      jG(g, y, {
        columnFormatters: [
          (w, b) => (w.length > b ? w.substring(0, b - 3) + "..." : w).padEnd(b),
          void 0,
          void 0,
          (w, b) => w.padStart(b),
          (w, b) => u.printer.print(w.padEnd(b), { foreground: "green" })
        ],
        truncateColumnIndex: 0
      }), l.threadSyncService?.dispose(), l.threadService.dispose(), await l.mcpService.dispose(), process.exit(0);
    } catch (c) {
      Ge.write(
        `Error listing threads: ${c instanceof Error ? c.message : String(c)}
`
      ), process.exit(1);
    }
  }), t.command("tools").description("Tool management commands").command("show").description("Show available tools").action(async (i, o) => {
    try {
      const s = o.optsWithGlobals(), u = lr(s);
      Up({});
      const l = vb();
      hC(l);
      const c = await it(l.tools);
      Ge.write(`# ${c.length} tools
`), Ge.write(`
`);
      for (const d of c)
        Ge.write(`## ${d.spec.name}${d.enabled ? "" : " (disabled)"}
`), d.spec.description && (Ge.write(
          u.printer.print(`${d.spec.description}`, {
            foreground: "gray"
          }) + `
`
        ), Ge.write(`
`)), Ge.write(
          u.printer.print(
            `Input schema: ${JSON.stringify(d.spec.inputSchema, null, 2)}`,
            {
              foreground: "gray"
            }
          ) + `
`
        ), Ge.write(`
`);
    } catch (s) {
      Ge.write(`Error: ${s}
`), process.exit(1);
    }
  });
  for (const i of BG)
    i.type === "flag" ? (t.option(`--${i.long}`, i.description(!0)), t.option(`--no-${i.long}`, i.description(!1))) : t.option(`--${i.long} <value>`, i.description, i.default);
  return t.action(async (i) => {
    const o = i, s = lr(o);
    i.threadId !== void 0 && (Ge.write(
      s.printer.print("Error: ", { foreground: "red", style: "bold" }) + `The --thread-id option has been deprecated.
Use ` + s.printer.print("amp threads continue [THREAD_ID]", {
        foreground: "green"
      }) + ` instead.
`
    ), process.exit(1)), await lb(s, o);
  }), t;
}
async function lb(r, t) {
  const e = await bV(), n = t.notifications !== void 0 ? t.notifications : r.isInteractiveMode, {
    configService: i,
    systemPromptService: o,
    toolService: s,
    mcpService: u,
    threadService: l,
    summaryService: c,
    threadSyncService: d,
    threadStorage: g,
    settingsStorage: y,
    fileWatcher: w,
    fuzzyServer: b
  } = await xl(r, t);
  let _ = Il();
  const C = /* @__PURE__ */ new Set();
  if (t.threadId) {
    yb(t.threadId) || (Ge.write(`Invalid thread ID given.
`), process.exit(1)), _ = t.threadId;
    try {
      const I = await Dr(`/api/threads/${_}`);
      I.ok || (Ge.write(`Failed to load thread ${_}: ${await I.text()}
`), process.exit(0));
      const B = await I.json();
      g.set(_, B), B.messages.map((W, z) => C.add(z));
    } catch (I) {
      oe.error("Failed to load thread", I), process.exit(0);
    }
  }
  await Jh(_), await new Promise((I, B) => {
    d?.threadSyncInfo([_]).subscribe(
      (W) => {
        if (!W[_]) {
          B(new Error(`Thread ${_} not found`));
          return;
        }
        I(W[_]);
      },
      (W) => B(W)
    );
  });
  const m = Zh(
    l.observe(_).pipe(is((I) => I !== void 0))
  ), T = /* @__PURE__ */ new Set();
  await it(m.observable);
  const S = await to.getOrCreateForThread(
    {
      configService: i,
      threadService: l,
      toolService: s,
      getThreadEnvironment: SH,
      systemPromptService: o,
      threadSummaryService: c,
      createFileSystem: await xV
    },
    _
  );
  await S.resume().catch((I) => {
    oe.error("Initial resume", I);
  }), it(S.status.pipe(is((I) => I.state === "active"))).then(
    async () => {
      !r.isInteractiveMode && e && (S.handle({
        type: "user:message",
        message: { content: [{ type: "text", text: e }] }
      }).catch((I) => {
        oe.error("Handle piped message failed", I);
      }), d && d.sync().catch((I) => {
        oe.error("Thread sync error", I, { threadID: _ });
      }));
    }
  );
  const A = n ? () => Ma("idle") : () => {
  };
  async function x(I) {
    try {
      return await b.query(I);
    } catch (B) {
      return oe.error("Completion failed", B), [];
    }
  }
  const D = r.isInteractiveMode ? new PH() : void 0, U = r.isInteractiveMode ? CG({
    prompt: "> ",
    complete: x,
    printer: r.printer,
    history: D
  }) : null, O = U ? U.observable : It.of(), k = S.status.pipe(
    at((I) => ({ type: "worker-state", status: I }))
  ), H = m.observable.pipe(
    at((I) => ({ type: "thread-state", thread: I }))
  ), V = Bk(200).pipe(
    at((I) => ({
      type: "tick",
      number: I
    }))
  ), N = ah(process.stdin, "data").pipe(
    is((I) => I.equals(eS) || I.equals(QC) || I.equals(Ne.CTRL_C)),
    at(() => ({ type: "interrupt" }))
  ), $ = new pr(), j = Rl(
    V,
    k,
    H,
    O,
    // merge only takes 5 args so have to nest them
    Rl(N, $)
  );
  async function K() {
    Ne.disable(), Ge.write(`Shutting down...
`), await d?.sync().catch((I) => {
      oe.error("Thread sync error", I, { threadID: _ });
    }), S.dispose(), d && d.dispose(), l.dispose(), await u.dispose(), w.dispose(), b.dispose(), process.exit(0);
  }
  r.isInteractiveMode && (Ne.enable(), Ge.write(
    `${r.printer.print("Type ", { foreground: "gray" })}${r.printer.print("\\", { foreground: "gray", style: "bold" })}${r.printer.print(" followed by ", { foreground: "gray" })}${r.printer.print("Enter", { foreground: "gray", style: "bold" })}${r.printer.print(" to insert newlines, or use ", { foreground: "gray" })}${r.printer.print("Shift+Enter", { foreground: "gray", style: "bold" })}${r.printer.print(` in supported terminals.
Interrupt the agent with `, { foreground: "gray" })}${r.printer.print("Ctrl+C", { foreground: "gray", style: "bold" })}${r.printer.print(", exit with ", { foreground: "gray" })}${r.printer.print("Ctrl+D", { foreground: "gray", style: "bold" })}${r.printer.print(".", { foreground: "gray" })}

`
  ));
  const P = j.pipe(
    zh(() => {
      K();
    })
  ).pipe(
    Vk(
      KG(function(I, B) {
        async function W() {
          const ee = await c.summarizeThread(_);
          await S.handle({
            type: "summary:created",
            summary: { type: "internal", summary: ee }
          });
        }
        function z() {
          if (I.type === "awaiting-user-message")
            return oe.debug("already accepting, ignoring event", { state: I, event: B }), I;
          const ee = "tokenUsage" in I ? I.tokenUsage : void 0;
          if (d?.sync()?.catch((ne) => {
            oe.error("Thread sync error", ne, { threadID: _ });
          }), r.isInteractiveMode) {
            if (ee && I.type !== "confirming-compaction") {
              const ne = ee.used / ee.maxAvailable;
              let ce, te = I.compactionPromptState;
              if (ne > sS && I.compactionPromptState === "none" ? (ce = r.printer.print(
                "You're running out of tokens. Compact thread?",
                { foreground: "yellow" }
              ), te = "first") : ne > aS && I.compactionPromptState === "first" && (ce = r.printer.print(
                "You're running out of tokens. Compact thread?",
                { foreground: "red" }
              ), te = "final"), ce)
                return sn(), n && Ma("requires-user-input"), Or(ce, ["y", "n"]).then((fe) => {
                  tt.write(`
`), $.next({
                    type: "yes-no-confirmation",
                    value: fe == "y",
                    confirmationType: "compaction"
                  });
                }), {
                  type: "confirming-compaction",
                  tokenUsage: null,
                  // from here we consider the token usage to be unknown
                  compactionPromptState: te,
                  updateState: I.updateState
                };
            }
            return sn(), U?.acceptMessage(), ee ? U?.setRightStatus(
              qp(ee, r.printer)
            ) : U?.setRightStatus(""), { ...I, type: "awaiting-user-message" };
          } else
            return P.unsubscribe(), { ...I, type: "closing" };
        }
        if (I.type === "closing")
          return I;
        if (B.type === "line-editor-state") {
          if (B.state == "off" && I.type === "initial") {
            const ee = m.value.last?.messages.length === 0;
            return r.isInteractiveMode && ee && !t.threadId ? (UG().then((ne) => {
              $.next({
                type: "agent-file-check-complete",
                shouldGenerate: ne.shouldGenerate,
                migrated: ne.migrated
              });
            }).catch((ne) => {
              oe.error("Agent file check failed", ne), $.next({
                type: "agent-file-check-complete",
                shouldGenerate: !1,
                migrated: !1
              });
            }), { ...I, type: "checking-agent-file" }) : (U?.acceptMessage(), { ...I, type: "awaiting-user-message" });
          }
        } else if (B.type == "submit") {
          const { message: ee } = B;
          return oe.info(
            `Processing user message: ${ee.slice(0, 50)}${ee.length > 50 ? "..." : ""}`
          ), S.handle({
            type: "user:message",
            message: { content: [{ type: "text", text: ee }] }
          }).then(() => {
            d && d.sync().catch((ne) => {
              oe.error("Thread sync after submit error", ne, {
                threadID: _
              });
            });
          }).catch((ne) => {
            oe.error("Handle user message failed", ne);
          }), {
            ...I,
            type: "awaiting-agent",
            statusMessage: "Thinking...",
            displayedError: null
          };
        } else if (B.type === "thread-state") {
          if (I.type === "awaiting-user-message" && !r.isInteractiveMode)
            return P.unsubscribe(), { ...I, type: "closing" };
          if (I.type === "awaiting-agent" && !r.isInteractiveMode && e === "" && B.thread.messages.length === 0)
            return P.unsubscribe(), { ...I, type: "closing" };
          let ee = I.tokenUsage;
          const ne = B.thread?.["~debug"]?.lastInferenceUsage;
          if (ne && (ee = {
            used: ne.totalInputTokens,
            maxAvailable: ne.maxInputTokens
          }), I.type === "awaiting-user-confirmation")
            return B.thread.messages.at(-1)?.content.some(
              (ce) => ce.type === "tool_result" && (ce.run.status === "in-progress" || ce.run.status === "done")
            ) ? {
              ...I,
              type: "awaiting-agent",
              statusMessage: B.thread.messages.some(
                (ce) => ce.role === "assistant" && ce.state.type === "streaming"
              ) ? "Thinking..." : "Working...",
              displayedError: null,
              tokenUsage: ee
            } : {
              ...I,
              type: "awaiting-user-confirmation",
              tokenUsage: ee
            };
          if (I.type === "awaiting-agent" || I.type === "compacting") {
            const ce = B.thread.messages.at(-1), te = Gk(
              B.thread,
              C,
              T
            );
            if (te.messages.length > 0 || te.toolResults.length > 0) {
              sn();
              const ie = process.stdout.rows || 24, me = Math.max(
                Math.floor(ie / 2),
                5
              );
              Wk(
                te,
                (Ce) => tt.write(Ce + `
`),
                tt.columns || 80,
                r.printer,
                me
              );
            }
            if (B.thread.messages.at(-1)?.content.some((ie) => ie.type === "summary"))
              return {
                ...z(),
                tokenUsage: null,
                compactionPromptState: "none"
              };
            if (ce?.role === "assistant" && ce?.state.type === "complete" && ce?.state.stopReason === "end_turn") {
              const ie = z();
              return {
                ...ie,
                tokenUsage: ee ?? ie.tokenUsage
              };
            }
            if (!m)
              throw new Error(
                "unexpected: thread is required when waiting for tool input"
              );
            if (!r.isInteractiveMode) {
              const ie = lo(
                B.thread,
                "user"
              )?.content.find(
                (Ce) => Ce.type === "tool_result" && Ce.run.status === "blocked-on-user"
              );
              if (!ie)
                return { ...I, tokenUsage: ee };
              const me = no(B.thread, ie.toolUseID);
              if (me)
                return sn(), Ge.write(
                  `
The ${r.printer.print(me.name, { foreground: "green" })} tool call is not allowed by default.
`
                ), me.name === sh && me.input && typeof me.input == "object" && "cmd" in me.input && ie.run.status === "blocked-on-user" && (Ge.write(
                  `To allow it automatically, add an entry to ${r.printer.print(xs, { foreground: "blue" })} like the following:
`
                ), Ge.write(
                  `
{
  ${r.printer.print(
                    `"amp.commands.allowlist": ${JSON.stringify(ie.run.toAllow ?? [me.input?.cmd])}`,
                    { foreground: "green", style: "bold" }
                  )}
}

`
                )), S.handle({
                  type: "user:tool-input",
                  toolUse: me.id,
                  value: { accepted: !1 }
                }).catch((Ce) => {
                  oe.error("Automatic reject failed", Ce);
                }), { ...I, type: "awaiting-user-message", tokenUsage: ee };
            }
            const fe = lo(
              B.thread,
              "user"
            )?.content.find(
              (ie) => ie.type === "tool_result" && ie.run.status === "blocked-on-user"
            );
            if (!fe)
              return I;
            const Y = fe.run, Z = no(B.thread, fe.toolUseID);
            if (Z && Z.name === sh && Y.status === "blocked-on-user")
              return sn(), (async () => {
                n && Ma("requires-user-input");
                const ie = await Or(
                  Kk(r.printer, Z),
                  ["n", "y", "!"]
                );
                if (tt.write(`
`), ie === "!") {
                  const me = Y.toAllow ?? [];
                  if (me.length > 0) {
                    const F = [
                      ...await y.get(
                        "commands.allowlist",
                        "global"
                      ) ?? [],
                      ...me
                    ];
                    await y.set(
                      "commands.allowlist",
                      F,
                      "global"
                      // TODO: set in workspace when supported
                    );
                  }
                }
                await S.handle({
                  type: "user:tool-input",
                  toolUse: Z.id,
                  value: {
                    accepted: ie === "y" || ie === "!"
                  }
                }).catch((me) => {
                  oe.error("User confirmation send failed", me);
                });
              })(), {
                ...I,
                type: "awaiting-user-confirmation",
                tokenUsage: ee
              };
          }
        } else if (B.type === "worker-state") {
          if (I.type === "awaiting-user-confirmation" && B.status.state === "active" && B.status.ephemeralError)
            return I;
          const ee = m.value.last?.messages.at(-1);
          let ne = null, ce = I.tokenUsage;
          if (B.status.state === "active") {
            const te = m.value.last?.["~debug"]?.lastInferenceUsage;
            te && (ce = {
              used: te.totalInputTokens,
              maxAvailable: te.maxInputTokens
            });
          }
          switch (B.status.state) {
            case "initial":
              return {
                ...I,
                type: "awaiting-user-message",
                tokenUsage: ce
              };
            case "active":
              if (B.status.ephemeralError) {
                if (B.status.ephemeralError.message.includes(
                  mL
                ))
                  return I.type === "out-of-credits" ? I : (sn(), tt.write(
                    r.printer.print("Out of credits. ", {
                      foreground: "red"
                    }) + `

Visit ` + r.printer.print(
                      new URL("/settings", r.ampURL).toString(),
                      {
                        foreground: "blue",
                        style: "bold"
                      }
                    ) + ` to purchase more credits and continue using Amp.

`
                  ), n && Ma("requires-user-input"), Or("Retry?", ["y", "n"]).then((te) => {
                    tt.write(`
`), te === "y" ? $.next({
                      type: "yes-no-confirmation",
                      value: !0,
                      confirmationType: "out-of-credits"
                    }) : P.unsubscribe();
                  }), {
                    ...I,
                    type: "out-of-credits",
                    tokenUsage: ce
                  });
                if (bP(B.status.ephemeralError))
                  sn(), ne = r.printer.print(
                    "The context is full. Please start a new thread.",
                    {
                      foreground: "red"
                    }
                  );
                else if (B.status.ephemeralError.message.includes(
                  "401 unauthorized"
                )) {
                  sn();
                  const te = process.env.AMP_API_KEY ? "environment variable AMP_API_KEY" : `secrets file (${Hh})`;
                  return Ge.write(
                    r.printer.print(
                      `Unauthorized: API key from ${te} may be invalid or expired. See https://ampcode.com/settings`,
                      {
                        foreground: "red"
                      }
                    ) + `

`
                  ), P.unsubscribe(), { ...I, type: "closing" };
                } else
                  return oe.error("Ephemeral error", {
                    error: B.status.ephemeralError
                  }), sn(), ne = r.printer.print(
                    B.status.ephemeralError.message,
                    {
                      foreground: "red"
                    }
                  ), I.type === "awaiting-agent" && I.displayedError !== ne ? (Ge.write(ne + `

`), Or("Retry?", ["y", "n"]).then((te) => {
                    tt.write(`
`), $.next({
                      type: "yes-no-confirmation",
                      value: te === "y",
                      confirmationType: "error-retry"
                    });
                  }), {
                    ...I,
                    type: "awaiting-user-confirmation",
                    tokenUsage: ce
                  }) : I;
              }
              switch (B.status.inferenceState) {
                case "running":
                  return {
                    ...I,
                    type: "awaiting-agent",
                    statusMessage: m.value.last?.messages.some(
                      (te) => te.role === "assistant" && te.state.type === "streaming"
                    ) ? "Thinking..." : "Working...",
                    displayedError: ne,
                    tokenUsage: ce
                  };
                case "cancelled":
                  return { ...z(), tokenUsage: ce };
                case "idle":
                  if (ee?.content.some(
                    (te) => te.type === "tool_result" && te.run.status === "blocked-on-user"
                  ))
                    return {
                      ...I,
                      type: "awaiting-user-confirmation",
                      tokenUsage: ce
                    };
                  if (m.value.last?.messages.some(
                    (te) => te.role === "user" && te.content.some(
                      (fe) => fe.type === "tool_result" && fe.run.status === "in-progress"
                    )
                  ) ?? !1) {
                    const te = m.value.last?.messages.flatMap(
                      (fe) => fe.content
                    ).filter(
                      (fe) => fe.type === "tool_result" && "run" in fe && "status" in fe.run && fe.run.status === "in-progress"
                    ).pop();
                    return {
                      ...I,
                      type: "awaiting-agent",
                      statusMessage: te ? "Running tool..." : m.value.last?.messages.some(
                        (fe) => fe.role === "assistant" && fe.state.type === "streaming"
                      ) ? "Thinking..." : "Working...",
                      displayedError: ne,
                      tokenUsage: ce
                    };
                  } else if (ee?.role === "assistant" && ee?.state.type === "complete" && ee?.state.stopReason === "end_turn")
                    return A(), { ...z(), tokenUsage: ce };
              }
          }
        } else if (B.type === "yes-no-confirmation")
          if (I.type === "out-of-credits" && B.confirmationType === "out-of-credits")
            to.retry(_);
          else {
            if (I.type === "awaiting-user-confirmation" && B.value && B.confirmationType === "error-retry")
              return to.retry(_), {
                ...I,
                type: "awaiting-agent",
                statusMessage: "Retrying...",
                displayedError: null
              };
            if (I.type === "awaiting-user-confirmation" && !B.value && B.confirmationType === "error-retry")
              return tt.write(`
`), z();
            if (I.type === "confirming-compaction" && B.confirmationType === "compaction")
              return B.value ? (W().then(() => {
                $.next({
                  type: "compaction-result",
                  result: !0
                });
              }).catch((ee) => {
                oe.error("Compaction failed", ee), $.next({
                  type: "compaction-result",
                  result: !1
                });
              }), {
                ...I,
                type: "compacting",
                statusMessage: "Compacting..."
              }) : (oe.info("Compaction cancelled"), z());
            if (B.confirmationType === "agent-file-creation" && I.type === "confirming-agent-file-creation")
              return B.value ? (tt.write(`
Generating AGENT.md file...

`), qG(S).catch((ee) => {
                oe.error("Agent file generation failed", ee);
              }), {
                ...I,
                type: "awaiting-agent",
                statusMessage: "Generating AGENT.md...",
                displayedError: null
              }) : (U?.acceptMessage(), { ...I, type: "awaiting-user-message" });
          }
        else {
          if (B.type === "compaction-result")
            return B.result ? I : (Or(
              r.printer.print("Compaction failed! Retry?", {
                foreground: "red"
              }),
              ["y", "n"]
            ).then((ee) => {
              tt.write(`
`), $.next({
                type: "yes-no-confirmation",
                value: ee == "y",
                confirmationType: "compaction"
              });
            }), { ...I, type: "confirming-compaction" });
          if (B.type === "interrupt")
            return I.type === "awaiting-agent" ? (sn(), tt.write(r.printer.print("Cancelled", { foreground: "gray" })), tt.write(`
`), tt.write(`
`), to.cancel(_), I) : I.type === "awaiting-user-message" || I.type === "awaiting-user-confirmation" ? I : (oe.info("Force exit in state", { state: I }), P.unsubscribe(), sn(), { ...I, type: "closing" });
          if (B.type === "exit") {
            if (I.type === "awaiting-user-message")
              return P.unsubscribe(), { ...I, type: "closing" };
          } else if (B.type === "tick") {
            if (I.type === "awaiting-agent" || I.type === "compacting")
              return JG(
                r.printer,
                B.number,
                I.statusMessage,
                I.tokenUsage ?? void 0
              ), I;
            if (I.type === "awaiting-user-message") {
              const ee = zG(I, r.printer);
              return U?.setRightStatus(ee), I;
            }
          } else {
            if (B.type === "update-start-updating")
              return { ...I, updateState: "updating" };
            if (B.type === "update-result")
              return B.success ? (setTimeout(() => {
                $.next({ type: "clear-update-status" });
              }, 1e4), { ...I, updateState: "success" }) : (setTimeout(() => {
                $.next({ type: "clear-update-status" });
              }, 1e4), { ...I, updateState: "error" });
            if (B.type === "clear-update-status")
              return { ...I, updateState: "none" };
            if (B.type === "agent-file-check-complete" && I.type === "checking-agent-file")
              return B.migrated && tt.write(`Migrated .sourcegraph/memory.md to AGENT.md
`), B.shouldGenerate ? (sn(), Or(
                "No AGENT.md file found. Would you like me to create one for this codebase?",
                ["y", "n"]
              ).then((ee) => {
                $.next({
                  type: "yes-no-confirmation",
                  value: ee === "y",
                  confirmationType: "agent-file-creation"
                });
              }), {
                ...I,
                type: "confirming-agent-file-creation"
              }) : (U?.acceptMessage(), { ...I, type: "awaiting-user-message" });
          }
        }
        return I;
      }),
      r.isInteractiveMode ? {
        type: "initial",
        tokenUsage: null,
        compactionPromptState: "none",
        updateState: "none"
      } : {
        type: "awaiting-agent",
        statusMessage: "Syncing...",
        displayedError: null,
        tokenUsage: null,
        compactionPromptState: "none",
        updateState: "none"
      }
    )
  ).subscribe({
    error: (I) => {
      sn(), oe.error("Error in state machine", I), Ge.write(r.printer.print(I.toString(), { foreground: "red" }) + `
`), K();
    },
    complete: () => {
    }
  });
  YG($, r.isInteractiveMode).catch((I) => {
    oe.debug("Update check startup failed", I);
  });
}
function lr(r) {
  const t = process.stdin.isTTY, e = typeof process < "u" && process.stdout?.isTTY && process.stderr?.isTTY, n = process.env.AMP_URL || qr, o = (r?.color !== void 0 ? r.color : e) ? Uk : qk;
  return {
    isInteractiveMode: t,
    isTTY: e,
    printer: o,
    ampURL: n
  };
}
async function WG() {
  Up({
    logLevel: process.env.AMP_LOG_LEVEL,
    logFile: process.env.AMP_LOG_FILE
  }), oe.info("Starting Amp CLI."), parseInt(process.version.slice(1).split(".")[0] ?? "") < 22 && (Ge.write(
    `Amp CLI requires Node.js v22 or higher. Current version: ${process.version}
`
  ), process.exit(1));
  const r = lr();
  await GG(r).parseAsync(process.argv);
}
WG().catch((r) => {
  oe.error("Fatal error", r), Ge.write(`Fatal error: ${r.message}: ${r.stack}
`), process.exit(1);
});
function KG(r) {
  return (t, e) => {
    const n = r(t, e);
    return e.type !== "tick" && oe.debug(`${t.type} + ${e.type} -> ${n.type}
`, {
      before: t,
      event: e,
      after: n
    }), n;
  };
}
function JG(r, t, e, n) {
  const i = "";
  Ge.write("\r\x1B[K");
  const o = e ? e.substring(0, 80).replace(/\n/g, " ") : "", s = (i[t % i.length] ?? "") + " " + o + " ";
  if (Ge.write(s), n) {
    const u = Ge.columns || 80, l = qp(n, r), c = u - s.length - l.length;
    c > 0 && (Ge.write(" ".repeat(c) + l), Ge.write("\r"), Ge.write(`\x1B[${s.length}C`));
  }
}
function qp(r, t) {
  const e = r.used / r.maxAvailable, n = Math.round(e * 100), i = "", o = i[Math.floor(e * i.length)], s = `${n}% ${o}`;
  return e >= aS ? t.print(s, { foreground: "red" }) : e >= sS ? t.print(s, { foreground: "yellow" }) : s;
}
function zG(r, t) {
  const e = [];
  return r.updateState === "updating" ? e.push(" Updating Amp...") : r.updateState === "success" ? e.push(t.print(" Amp updated. Restart to apply.", { foreground: "green" })) : r.updateState === "error" && e.push(t.print(" Amp update failed.", { foreground: "red" })), r.tokenUsage && e.push(qp(r.tokenUsage, t)), e.join(" ");
}
function sn() {
  Ge.write("\r\x1B[K");
}
async function YG(r, t) {
  try {
    const e = await LG("0.0.1748361686-ga6cbdd");
    e.hasUpdate && e.latestVersion && (t ? (r.next({ type: "update-start-updating" }), setTimeout(async () => {
      try {
        await $G(), r.next({
          type: "update-result",
          success: !0,
          version: e.latestVersion
        });
      } catch (n) {
        oe.info("Update failed", n), r.next({
          type: "update-result",
          success: !1,
          version: e.latestVersion
        });
      }
    }, 100)) : oe.info(`New version available: 0.0.1748361686-ga6cbdd  ${e.latestVersion}`));
  } catch (e) {
    oe.debug("Update check failed", e);
  }
}
const sS = 0.8, aS = 0.9;
function ZG(r) {
  const e = (/* @__PURE__ */ new Date()).getTime() - r.getTime(), n = Math.floor(e / 1e3), i = Math.floor(n / 60), o = Math.floor(i / 60), s = Math.floor(o / 24), u = Math.floor(s / 7), l = Math.floor(s / 30), c = Math.floor(s / 365);
  return n < 60 ? n <= 1 ? "now" : `${n}s ago` : i < 60 ? `${i}m ago` : o < 24 ? `${o}h ago` : s < 7 ? `${s}d ago` : u < 4 ? `${u}w ago` : l < 12 ? `${l}mo ago` : `${c}y ago`;
}
function jG(r, t, e = {}) {
  const { columnFormatters: n = [], minimumTruncatedColumnWidth: i = 20, truncateColumnIndex: o } = e;
  for (let C = 0; C < t.length; C++)
    if (t[C].length !== r.length)
      throw new Error(
        `Row ${C} has ${t[C].length} columns, but headers have ${r.length} columns`
      );
  const s = tt.columns || 120, u = "  ", l = r.length - 1, c = o ?? r.length - 1, d = [];
  for (let C = 0; C < r.length; C++)
    C === c ? d.push(0) : d.push(Math.max(r[C].length, ...t.map((m) => m[C].length)));
  const g = d.reduce((C, m) => C + m, 0) + l * u.length, y = Math.max(i, s - g);
  d[c] = y;
  const w = d, b = r.map((C, m) => C.padEnd(w[m])).join(u);
  tt.write(b + `
`);
  const _ = w.map((C) => "".repeat(C)).join(u);
  tt.write(_ + `
`);
  for (const C of t) {
    const m = C.map((T, S) => {
      const A = w[S], x = n[S];
      return x ? x(T, A) : (T.length > A ? T.substring(0, A - 3) + "..." : T).padEnd(A);
    });
    tt.write(m.join(u) + `
`);
  }
}
export {
  tO as J,
  mr as Z,
  Qe as a,
  ln as b,
  JP as c,
  zP as d,
  vi as e,
  dV as f,
  iV as g,
  je as l,
  xe as o,
  YB as p,
  rp as r,
  ue as s,
  Ft as u
};
//# sourceMappingURL=main-CmK9yaC9.js.map
