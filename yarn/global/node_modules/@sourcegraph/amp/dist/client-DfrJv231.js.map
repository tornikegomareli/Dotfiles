{"version":3,"file":"client-DfrJv231.js","sources":["../../core/src/server-api/client.ts"],"sourcesContent":["import type { ThreadOperatorShare } from '@sourcegraph/amp-api-types'\nimport type { Observable } from '@sourcegraph/observable'\nimport {\n\tdistinctUntilChanged,\n\tfirstValueFrom,\n\tmap,\n\ttype pendingOperation,\n\tpromiseFactoryToObservable,\n\tswitchMap,\n\tswitchMapReplayOperation,\n} from '@sourcegraph/observable'\nimport { isEqualJSON } from '../common/isEqualJSON'\nimport { type PickResolvedConfiguration, resolvedConfig } from '../configuration/resolver'\nimport { clientIdentificationHeaders } from '../misc/known-clients'\nimport type { ThreadID } from '../threads/thread'\nimport type { ThreadService } from '../threads/thread-service'\n\nexport const isAmpServerConfigured = resolvedConfig.pipe(\n\tswitchMap(({ settings, secrets }) => {\n\t\treturn promiseFactoryToObservable(async () => {\n\t\t\tconst apiKey = await secrets.getToken('apiKey', settings.url)\n\t\t\treturn apiKey !== undefined\n\t\t})\n\t}),\n)\n\n/**\n * Returns the URL to a thread on the Amp server.\n */\nexport function threadURL(ampURL: URL, threadID: ThreadID): URL {\n\treturn new URL(`/threads/${threadID}`, ampURL)\n}\n\n/**\n * Makes a request to the Amp API with the proper configuration\n */\nexport async function fetchFromAmpServer(\n\tpathAndQuery: string,\n\tinit?: RequestInit,\n): Promise<Response> {\n\tconst config = await firstValueFrom(resolvedConfig, init?.signal ?? undefined)\n\treturn fetchFromAmpServerWithConfig(config, pathAndQuery, init)\n}\n\nexport function watchOnAmpServer<T>(\n\tpathAndQuery: string,\n\tinit?: Omit<RequestInit, 'signal'>,\n): Observable<T | typeof pendingOperation | Error> {\n\treturn resolvedConfig.pipe(\n\t\tmap(\n\t\t\t({ settings, secrets }) =>\n\t\t\t\t({\n\t\t\t\t\tsettings: {\n\t\t\t\t\t\turl: settings.url,\n\t\t\t\t\t},\n\t\t\t\t\tsecrets,\n\t\t\t\t}) satisfies PickResolvedConfiguration<{\n\t\t\t\t\tsettings: 'url'\n\t\t\t\t\tsecrets: true\n\t\t\t\t}>,\n\t\t),\n\t\tdistinctUntilChanged(\n\t\t\t(a, b) => isEqualJSON(a.settings, b.settings) && a.secrets === b.secrets,\n\t\t),\n\t\tswitchMapReplayOperation((config) =>\n\t\t\tpromiseFactoryToObservable(async (signal) => {\n\t\t\t\tconst resp = await fetchFromAmpServerWithConfig(config, pathAndQuery, {\n\t\t\t\t\t...init,\n\t\t\t\t\tsignal,\n\t\t\t\t})\n\t\t\t\tif (!resp.ok) {\n\t\t\t\t\tconst text = await resp.text()\n\t\t\t\t\tif (text) {\n\t\t\t\t\t\tthrow new Error(`HTTP ${resp.status}: ${text}`)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(`HTTP ${resp.status}`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (await resp.json()) as T\n\t\t\t}),\n\t\t),\n\t)\n}\n\n/**\n * Share a thread with the operator (i.e., the Amp team).\n */\nexport async function shareThreadWithOperator(\n\tthreadService: ThreadService,\n\tthreadID: ThreadID,\n): Promise<void> {\n\tconst thread = await firstValueFrom(threadService.observe(threadID))\n\tif (!thread) {\n\t\tthrow new Error(`Thread not found: ${threadID}`)\n\t}\n\n\tconst response = await fetchFromAmpServer('/api/internal/share-thread-with-operator', {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t},\n\t\tbody: JSON.stringify({ threadData: thread } as Pick<ThreadOperatorShare, 'threadData'>),\n\t})\n\tif (!response.ok) {\n\t\tconst text = await response.text()\n\t\tthrow new Error(`Failed to share thread: ${response.status} ${text}`)\n\t}\n}\n\nasync function fetchFromAmpServerWithConfig(\n\tconfig: PickResolvedConfiguration<{\n\t\tsettings: 'url'\n\t\tsecrets: true\n\t}>,\n\tpathAndQuery: string,\n\tinit?: RequestInit,\n): Promise<Response> {\n\tif (pathAndQuery.startsWith('http:') || pathAndQuery.startsWith('https:')) {\n\t\tthrow new Error('input must be a path, not an absolute URL')\n\t}\n\tif (!pathAndQuery.startsWith('/')) {\n\t\tthrow new Error('pathAndQuery must start with /')\n\t}\n\n\tconst baseURL = config.settings.url\n\tif (!baseURL) {\n\t\tthrow new Error('amp.url is not set')\n\t}\n\n\tconst apiKey = await config.secrets.getToken('apiKey', baseURL)\n\tif (!apiKey) {\n\t\tthrow new Error('Amp API key is not set')\n\t}\n\n\treturn fetch(new URL(pathAndQuery, baseURL), {\n\t\t...init,\n\t\theaders: {\n\t\t\t...init?.headers,\n\t\t\t...clientIdentificationHeaders(),\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${apiKey}`,\n\t\t},\n\t})\n}\n"],"names":["isAmpServerConfigured","resolvedConfig","switchMap","settings","secrets","promiseFactoryToObservable","fetchFromAmpServer","pathAndQuery","init","config","firstValueFrom","fetchFromAmpServerWithConfig","baseURL","apiKey","clientIdentificationHeaders"],"mappings":";;AAiBO,MAAMA,IAAwBC,EAAe;AAAA,EACnDC,EAAU,CAAC,EAAE,UAAAC,GAAU,SAAAC,QACfC,EAA2B,YAClB,MAAMD,EAAQ,SAAS,UAAUD,EAAS,GAAG,MAC1C,MAClB,CACD;AACF;AAYsB,eAAAG,EACrBC,GACAC,GACoB;AACpB,QAAMC,IAAS,MAAMC,EAAeT,GAAgBO,GAAM,UAAU,MAAS;AACtE,SAAAG,EAA6BF,GAAQF,GAAcC,CAAI;AAC/D;AAmEA,eAAeG,EACdF,GAIAF,GACAC,GACoB;AACpB,MAAID,EAAa,WAAW,OAAO,KAAKA,EAAa,WAAW,QAAQ;AACjE,UAAA,IAAI,MAAM,2CAA2C;AAE5D,MAAI,CAACA,EAAa,WAAW,GAAG;AACzB,UAAA,IAAI,MAAM,gCAAgC;AAG3C,QAAAK,IAAUH,EAAO,SAAS;AAChC,MAAI,CAACG;AACE,UAAA,IAAI,MAAM,oBAAoB;AAGrC,QAAMC,IAAS,MAAMJ,EAAO,QAAQ,SAAS,UAAUG,CAAO;AAC9D,MAAI,CAACC;AACE,UAAA,IAAI,MAAM,wBAAwB;AAGzC,SAAO,MAAM,IAAI,IAAIN,GAAcK,CAAO,GAAG;AAAA,IAC5C,GAAGJ;AAAA,IACH,SAAS;AAAA,MACR,GAAGA,GAAM;AAAA,MACT,GAAGM,EAA4B;AAAA,MAC/B,gBAAgB;AAAA,MAChB,eAAe,UAAUD,CAAM;AAAA,IAAA;AAAA,EAChC,CACA;AACF;"}