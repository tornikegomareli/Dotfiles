{"version":3,"file":"load-profile-Bu7wgoOq.js","sources":["../../core/src/tools/builtin/bash/load-profile.ts"],"sourcesContent":["import { catchError, Observable, tap } from '@sourcegraph/observable'\nimport { spawn } from 'node:child_process'\nimport os from 'node:os'\nimport logger from '../../../common/logger'\nimport type { ResolvedConfiguration } from '../../../configuration/resolver'\n\ninterface CachedLoginEnvironment {\n\ttimestamp: number\n\tenv: Record<string, string>\n}\nconst dailyTimeout = 24 * 60 * 60 * 1000 // Expire the login environment daily\nconst shellEnvCache = new Map<string, CachedLoginEnvironment>()\nconst defaultEnv = process.env as Record<string, string>\n\n// Adaptation of the equivalent logic from Zed here:\n// https://sourcegraph.com/github.com/zed-industries/zed/-/blob/crates/util/src/util.rs?L309\nexport function loadProfileEnvironmentVariables(\n\tdir: string,\n\tconfig: ResolvedConfiguration['settings']['terminal.commands.node-spawn.load-profile'] = 'always',\n): Observable<Record<string, string>> {\n\tif (config === 'never') {\n\t\treturn Observable.of(defaultEnv)\n\t}\n\tif (import.meta.env.VITE_PLATFORM === 'node') {\n\t\t// Skipping automatic environment detection for the CLI since the user\n\t\t// is presumably already running in a shell.\n\t\treturn Observable.of(defaultEnv)\n\t}\n\tif (isNixShell()) {\n\t\t// Skip automatic detection for Nix users, because they're smart enough\n\t\t// to figure out how to run `code .`\n\t\tlogger.info(\n\t\t\t'Detected Nix Shell, skipping automatic detection of login environment. To skip this Nix detection, set the environment variable IN_NIX_SHELL=false.',\n\t\t)\n\t\treturn Observable.of(defaultEnv)\n\t}\n\tif (config === 'always') {\n\t\treturn loadProfileEnvironmentVariablesUnchached(dir)\n\t}\n\tif (config !== 'daily') {\n\t\tlogger.warn(\n\t\t\t`Unknown setting value for loadLoginShellEnvironment. Valid values are \"never\", \"always\", \"daily\". Falling back to default \"daily\"`,\n\t\t\t{\n\t\t\t\tsetting: config,\n\t\t\t},\n\t\t)\n\t}\n\n\t// Regularly clean up old cached to avoid holding onto an infinitely growing\n\t// number of cached environments.\n\tevictExpiredCache()\n\n\tconst cachedEnv = shellEnvCache.get(dir)\n\tif (cachedEnv) {\n\t\treturn Observable.of(cachedEnv.env)\n\t}\n\treturn loadProfileEnvironmentVariablesUnchached(dir).pipe(\n\t\ttap((env) => {\n\t\t\tshellEnvCache.set(dir, { timestamp: Date.now(), env })\n\t\t}),\n\t\tcatchError((error) => {\n\t\t\tlogger.error('failed to read login environment. Falling back to default environment', {\n\t\t\t\terror,\n\t\t\t})\n\t\t\treturn Observable.of(defaultEnv)\n\t\t}),\n\t)\n}\n\nfunction loadProfileEnvironmentVariablesUnchached(dir: string): Observable<Record<string, string>> {\n\t// For non-Unix systems, just return the current environment\n\tif (os.platform() !== 'darwin' && os.platform() !== 'linux') {\n\t\treturn Observable.of(defaultEnv)\n\t}\n\tconst start = Date.now()\n\n\treturn new Observable<Record<string, string>>((observer) => {\n\t\t// For Unix-like systems, get environment from login shell\n\t\tconst shell = os.userInfo().shell ?? process.env.SHELL ?? '/bin/bash'\n\t\tconst marker = 'AMP_SHELL_ENV_MARKER'\n\n\t\t// Try to cd into the directory to trigger directory-specific env tools\n\t\tconst shellCmdPrefix = dir ? `cd '${dir.replace(/'/g, \"\\\\'\")}';` : ''\n\t\tconst shellCmd = `${shellCmdPrefix}printf '%s' ${marker}; /usr/bin/env;`\n\n\t\t// Set timeout to prevent hanging\n\t\tconst timeout = setTimeout(() => {\n\t\t\tlogger.error('Shell environment collection timed out')\n\t\t\tchild.kill()\n\t\t\tobserver.next(defaultEnv)\n\t\t\tobserver.complete()\n\t\t}, 5000)\n\n\t\t// Run login shell\n\t\tconst child = spawn(shell, ['-l', '-i', '-c', shellCmd], {\n\t\t\tstdio: ['ignore', 'pipe', 'pipe'],\n\t\t\tdetached: true, // Prevent shell from taking control of the terminal\n\t\t\tenv: {\n\t\t\t\t...process.env,\n\t\t\t\tNONINTERACTIVE: '1',\n\t\t\t\tDEBIAN_FRONTEND: 'noninteractive',\n\t\t\t},\n\t\t})\n\n\t\tlet stdout = ''\n\t\tlet stderr = ''\n\n\t\tif (child.stdout) {\n\t\t\tchild.stdout.on('data', (data) => {\n\t\t\t\tstdout += data.toString()\n\t\t\t})\n\t\t}\n\n\t\tif (child.stderr) {\n\t\t\tchild.stderr.on('data', (data) => {\n\t\t\t\tstderr += data.toString()\n\t\t\t})\n\t\t}\n\n\t\tchild.on('error', (err) => {\n\t\t\tlogger.error('Failed to spawn shell:', { err })\n\t\t\tclearTimeout(timeout)\n\t\t\tobserver.next(defaultEnv)\n\t\t\tobserver.complete()\n\t\t})\n\n\t\tchild.on('close', (code) => {\n\t\t\tclearTimeout(timeout)\n\t\t\tconst end = Date.now()\n\t\t\tconst durationMillis = end - start\n\n\t\t\tif (code !== 0) {\n\t\t\t\tlogger.error(`Shell process exited with code ${code}`)\n\t\t\t\tobserver.next(defaultEnv)\n\t\t\t\tobserver.complete()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Parse environment variables after marker\n\t\t\tconst envVars: Record<string, string> = {}\n\t\t\tconst markerIndex = stdout.indexOf(marker)\n\n\t\t\tif (markerIndex !== -1) {\n\t\t\t\tconst envOutput = stdout.substring(markerIndex + marker.length)\n\t\t\t\t// Parse KEY=VALUE lines\n\t\t\t\tenvOutput.split('\\n').forEach((line) => {\n\t\t\t\t\tconst match = line.match(/^([^=]+)=(.*)$/)\n\t\t\t\t\tif (match && match[1] && match[2]) {\n\t\t\t\t\t\tconst key = match[1]\n\t\t\t\t\t\tconst value = match[2]\n\t\t\t\t\t\tenvVars[key] = value\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// Fallback to current environment\n\t\t\t\tObject.assign(envVars, defaultEnv)\n\t\t\t}\n\n\t\t\tlogger.info('Loaded login shell environment', {\n\t\t\t\tdurationMillis,\n\t\t\t\tdirectory: dir,\n\t\t\t\tloadedVariableCount: Object.keys(envVars).length,\n\t\t\t})\n\t\t\tobserver.next(envVars)\n\t\t\tobserver.complete()\n\t\t})\n\n\t\treturn () => {\n\t\t\tclearTimeout(timeout)\n\t\t\tchild.kill()\n\t\t}\n\t})\n}\nfunction evictExpiredCache(): void {\n\tfor (const [key, value] of Object.entries(shellEnvCache)) {\n\t\tif (isExpiredCache(value)) {\n\t\t\tshellEnvCache.delete(key)\n\t\t}\n\t}\n}\n\nfunction isExpiredCache(env: CachedLoginEnvironment): boolean {\n\treturn env.timestamp + dailyTimeout > Date.now()\n}\n\nconst pathDelimeter = os.platform() === 'win32' ? ';' : ':'\nfunction isNixShell(): boolean {\n\tif (process.env.IN_NIX_SHELL === 'false') {\n\t\t// Escape hatch to disable this detection.\n\t\treturn false\n\t}\n\n\tif (process.env.IN_NIX_SHELL) {\n\t\treturn true\n\t}\n\n\t// Check for new `nix shell` using PATH using a heuristic. Borrowed from Starship:\n\t// https://github.com/starship/starship/blob/fccf4ccebf1533989234ec13c5a0f6d44e47e937/src/modules/nix_shell.rs#L14C1-L40C6\n\tconst path = process.env.PATH ?? ''\n\treturn path.split(pathDelimeter).some((p) => p.startsWith('/nix/store'))\n}\n"],"names":["defaultEnv","loadProfileEnvironmentVariables","dir","config","Observable","os"],"mappings":";;;AAYA,MAAMA,IAAa,QAAQ;AAIX,SAAAC,EACfC,GACAC,IAAyF,UACpD;AACrC,SAAIA,MAAW,UACPC,EAAW,GAAGJ,CAAU,IAKxBI,EAAW,GAAGJ,CAAU;AAyCjC;AAsHsBK,EAAG,SAAS;"}