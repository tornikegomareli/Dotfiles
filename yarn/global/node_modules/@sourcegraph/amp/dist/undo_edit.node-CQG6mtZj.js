#!/usr/bin/env node
import F from "node:crypto";
import s, { writeFile as D } from "node:fs/promises";
import g from "node:os";
import c from "node:path";
import { p as b, aV as E, b1 as k, b2 as v, k as m } from "./color-Bf2jGwiV.js";
const x = 50, o = [];
async function J(t, i, d) {
  try {
    const e = y(t), r = await w(), a = c.join(r, e), n = { filePath: t, oldContent: i, newContent: d };
    await s.writeFile(a, JSON.stringify(n), "utf-8");
    const f = o.indexOf(e);
    if (f >= 0 && o.splice(f, 1), o.push(e), o.length > x) {
      const l = o.shift();
      if (l) {
        const h = c.join(r, l);
        await s.unlink(h).catch(() => {
        });
      }
    }
  } catch (e) {
    m.error("Failed to record edit:", e);
  }
}
async function C(t) {
  try {
    const i = y(t), d = await w(), e = c.join(d, i);
    try {
      await s.access(e);
    } catch {
      return;
    }
    const r = await s.readFile(e, "utf-8"), a = JSON.parse(r), n = o.indexOf(i);
    return n >= 0 && o.splice(n, 1), await s.unlink(e).catch(() => {
    }), { oldContent: a.oldContent, newContent: a.newContent };
  } catch (i) {
    m.error("Failed to get last edit:", i);
    return;
  }
}
const U = ({ args: t }, { dir: i, threadID: d, trackFileChange: e }) => b(async (r) => {
  E(i), O(t);
  const a = c.resolve(i.fsPath, t.path), n = await C(t.path);
  if (!n)
    return {
      status: "error",
      progress: {},
      error: {
        message: `No edit history found for file '${t.path}'.`
      }
    };
  const f = k(n.newContent, n.oldContent, t.path), l = v(f);
  return await e(a, async (h) => {
    await D(h, n.oldContent, {
      encoding: "utf-8",
      signal: r
    });
  }), { status: "done", progress: {}, result: l };
});
function O(t) {
  if (typeof t != "object" || t === null)
    throw new Error("args must be an object. received instead: `" + JSON.stringify(t) + "`");
  if (typeof t.path != "string")
    throw new Error(
      "path must be a string. received instead: `" + JSON.stringify(t.path) + "`"
    );
}
let u = "", p = null;
async function w() {
  return u || (p || (p = s.mkdtemp(c.join(g.tmpdir(), "amp-edits-")).then((t) => (u = t, t)).catch((t) => {
    throw m.error("Failed to create edit history directory:", t), t;
  })), p);
}
function y(t) {
  return `${F.createHash("sha256").update(t).digest("hex").slice(0, 16)}-${c.basename(t)}`;
}
export {
  C as getLastEdit,
  U as nodeUndoEditTool,
  J as recordEdit
};
//# sourceMappingURL=undo_edit.node-CQG6mtZj.js.map
