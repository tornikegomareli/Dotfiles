{"version":3,"file":"glob.node-Cfv1JwiF.js","sources":["../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/constants.js","../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/utils.js","../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/scan.js","../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/parse.js","../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/lib/picomatch.js","../../node_modules/.pnpm/picomatch@4.0.2/node_modules/picomatch/index.js","../../core/src/tools/builtin/filesystem/glob.node.ts"],"sourcesContent":["'use strict';\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst SEP = '/';\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR,\n  SEP\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,\n  SEP: '\\\\'\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","/*global navigator*/\n'use strict';\n\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.isWindows = () => {\n  if (typeof navigator !== 'undefined' && navigator.platform) {\n    const platform = navigator.platform.toLowerCase();\n    return platform === 'win32' || platform === 'windows';\n  }\n\n  if (typeof process !== 'undefined' && process.platform) {\n    return process.platform === 'win32';\n  }\n\n  return false;\n};\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\nexports.basename = (path, { windows } = {}) => {\n  const segs = path.split(windows ? /[\\\\/]/ : '/');\n  const last = segs[segs.length - 1];\n\n  if (last === '') {\n    return segs[segs.length - 2];\n  }\n\n  return last;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(opts.windows);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.output = (prev.output || prev.value) + tok.value;\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(opts.windows);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = opts.windows;\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(utils.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst pico = require('./lib/picomatch');\nconst utils = require('./lib/utils');\n\nfunction picomatch(glob, options, returnState = false) {\n  // default to os.platform()\n  if (options && (options.windows === null || options.windows === undefined)) {\n    // don't mutate the original options object\n    options = { ...options, windows: utils.isWindows() };\n  }\n\n  return pico(glob, options, returnState);\n}\n\nObject.assign(picomatch, pico);\nmodule.exports = picomatch;\n","import { combineLatest, map, Observable } from '@sourcegraph/observable'\nimport { spawn } from 'node:child_process'\nimport pm from 'picomatch'\nimport type { URI } from 'vscode-uri'\nimport logger from '../../../common/logger'\nimport type { ToolRun } from '../../tool-service'\nimport { ripgrepExecutable } from '../grep/executable'\nimport { checkDirURIIsFile } from '../node-helpers'\nimport type { GlobToolDef, globToolReg } from './glob.common'\n\nexport interface GlobFilesWithRipgrepOptions {\n\tlimit?: number\n\toffset?: number\n\tmaxDepth?: number\n\tbasePath?: string\n\tsignal?: AbortSignal\n}\n\nexport const nodeGlobTool: NonNullable<(typeof globToolReg)['fn']> = ({ args }, { dirs }) => {\n\tif (dirs.length === 0) {\n\t\treturn new Observable((observer) => {\n\t\t\tobserver.next({\n\t\t\t\tstatus: 'error' as const,\n\t\t\t\terror: { message: 'No directory provided' },\n\t\t\t})\n\t\t\tobserver.complete()\n\t\t})\n\t}\n\n\t// Clean up options to avoid exactOptionalPropertyTypes issues\n\tconst options: GlobFilesWithRipgrepOptions = {}\n\tif (args.limit !== undefined) options.limit = args.limit\n\tif (args.offset !== undefined) options.offset = args.offset\n\n\treturn globFilesWithRipgrep(dirs, args.filePattern, options)\n}\n\nexport function globFilesWithRipgrep(\n\tdirs: URI[],\n\tpattern: string | null,\n\toptions?: GlobFilesWithRipgrepOptions,\n): Observable<ToolRun<GlobToolDef>> {\n\treturn combineLatest(\n\t\t...dirs.map((dir) => globFilesInDirWithRipgrep(dir, pattern, options)),\n\t).pipe(\n\t\tmap<ToolRun<GlobToolDef>[], ToolRun<GlobToolDef>>((results) => {\n\t\t\tconst progress: string[] = []\n\t\t\tfor (const result of results) {\n\t\t\t\tif (result.status === 'in-progress') {\n\t\t\t\t\tprogress.push(...(result?.progress ?? []))\n\t\t\t\t} else if (result.status === 'done') {\n\t\t\t\t\tprogress.push(...result.result)\n\t\t\t\t} else if (result.status === 'error') {\n\t\t\t\t\tprogress.push(...(result.progress ?? []))\n\t\t\t\t} else if (result.status === 'cancelled') {\n\t\t\t\t\tprogress.push(...(result.progress ?? []))\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst errors = results.filter((result) => result.status === 'error')\n\t\t\tif (errors.length > 0) {\n\t\t\t\treturn {\n\t\t\t\t\tstatus: 'error',\n\t\t\t\t\tprogress,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tmessage: errors\n\t\t\t\t\t\t\t.map<string>((error) => error?.error?.message ?? '')\n\t\t\t\t\t\t\t.join('\\n'),\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst status = results.every((result) => result.status === 'done')\n\t\t\t\t? 'done'\n\t\t\t\t: results.some((result) => result.status === 'cancelled')\n\t\t\t\t\t? 'cancelled'\n\t\t\t\t\t: 'in-progress'\n\t\t\treturn {\n\t\t\t\tstatus,\n\t\t\t\tprogress,\n\t\t\t\tresult: progress,\n\t\t\t}\n\t\t}),\n\t)\n}\n\nfunction globFilesInDirWithRipgrep(\n\tdir: URI,\n\tpattern: string | null,\n\toptions?: GlobFilesWithRipgrepOptions,\n): Observable<ToolRun<GlobToolDef>> {\n\tcheckDirURIIsFile(dir)\n\treturn new Observable<ToolRun<GlobToolDef>>((observer) => {\n\t\tobserver.next({\n\t\t\tstatus: 'in-progress',\n\t\t\tprogress: [],\n\t\t})\n\n\t\tripgrepFiles(dir.fsPath, pattern ? { pattern, caseInsensitive: true } : null, options ?? {})\n\t\t\t.then(({ files, remaining }) => {\n\t\t\t\tif (remaining > 0) {\n\t\t\t\t\tfiles.push(`--- ${remaining} more files not shown ---`)\n\t\t\t\t}\n\t\t\t\tobserver.next({\n\t\t\t\t\tstatus: 'done',\n\t\t\t\t\tprogress: files,\n\t\t\t\t\tresult: files,\n\t\t\t\t})\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconst message = error instanceof Error ? error.message : String(error)\n\t\t\t\tobserver.next({\n\t\t\t\t\tstatus: 'error',\n\t\t\t\t\tprogress: [],\n\t\t\t\t\terror: { message },\n\t\t\t\t})\n\t\t\t})\n\t\t\t.finally(() => observer.complete())\n\t})\n}\n\ninterface RipgrepResult {\n\tfiles: string[]\n\tremaining: number\n\taborted?: boolean\n}\n\nconst MAX_GLOB_COUNT = 500_000\n\nexport function ripgrepFiles(\n\tdir: string,\n\tglob: {\n\t\tpattern: string\n\t\tcaseInsensitive?: boolean\n\t} | null,\n\tparams: GlobFilesWithRipgrepOptions,\n): Promise<RipgrepResult> {\n\t// The Chromium repo has ~500k files so this is generous\n\t// enough to cover such a large repo. The fuzzy filtering is\n\t// sluggish in the Chromium repo so we don't want it to be\n\t// slower than that, and we also don't want to load arbitrary\n\t// many files into memory.\n\tconst limit = params.limit ?? MAX_GLOB_COUNT\n\n\tif (glob?.pattern && glob.pattern === '*') {\n\t\tglob.pattern = '**'\n\t}\n\t// IMPORTANT: we implement glob filtering on the TypeScript side instead of\n\t// using the ripgrep --glob option because the --glob option disables the\n\t// built-in gitignore/ignore/rgignore support. Instead, to support only\n\t// including certain patterns like `src/**/*.ts` then we filter those out\n\t// from the ripgrep output.\n\tconst matchesGlobPattern = glob?.pattern\n\t\t? pm(glob.pattern, { nocase: glob.caseInsensitive, dot: true })\n\t\t: undefined\n\n\tconst args = [\n\t\t'--files',\n\t\t'--color',\n\t\t'never',\n\t\t'--no-require-git',\n\t\t// We want to include hidden files because dot-files in a repository are often important.\n\t\t'--hidden',\n\t\t// Ripgrep will include the .git/ directory when using --hidden unless\n\t\t// the user explicitly gitignores the .git/ directory, or rgignores it,\n\t\t// which most people don't.\n\t\t'--glob',\n\t\t'!\\\\.git/',\n\t]\n\n\tif (params.maxDepth !== undefined) {\n\t\targs.push('--max-depth', params.maxDepth.toString())\n\t}\n\tif (params.basePath !== undefined) {\n\t\targs.push(params.basePath)\n\t}\n\n\t// We manually control the spawn here instead of using `spawnAndObserveChildProcess` because\n\t// we don't want to re-process the entire output on every streaming chunk.\n\t// Large repos can have hundreds of thousands of files, and we're processing the output on the extension process host.\n\t// ripgrep --files is fast anyways so there's no point in streaming the results.\n\n\tconst proc = spawn(ripgrepExecutable(), args, {\n\t\tcwd: dir,\n\t\tstdio: ['ignore', 'pipe', 'pipe'],\n\t\tdetached: process.platform !== 'win32',\n\t\tenv: {\n\t\t\t...process.env,\n\t\t\tNONINTERACTIVE: '1',\n\t\t\tDEBIAN_FRONTEND: 'noninteractive',\n\t\t},\n\t})\n\n\treturn new Promise<RipgrepResult>((resolve, reject) => {\n\t\tconst lines: string[] = []\n\t\tlet stderr = ''\n\t\tlet line = ''\n\t\tlet offset = params.offset ?? 0\n\t\tlet isResolved = false\n\t\tconst pushLine = (): void => {\n\t\t\tif (isResolved) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (!line) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (matchesGlobPattern && !matchesGlobPattern(line)) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst toPush = line\n\t\t\tline = ''\n\n\t\t\tif (offset > 0) {\n\t\t\t\toffset--\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlines.push(toPush)\n\t\t\tif (lines.length >= MAX_GLOB_COUNT) {\n\t\t\t\tlogger.warn('Glob limit reached. Returning partial results.', {\n\t\t\t\t\tglob: glob?.pattern,\n\t\t\t\t\tlimit: MAX_GLOB_COUNT,\n\t\t\t\t\tdir,\n\t\t\t\t})\n\t\t\t\tproc.kill()\n\t\t\t\tisResolved = true\n\t\t\t\tresolve({\n\t\t\t\t\tfiles: lines,\n\t\t\t\t\tremaining: 0,\n\t\t\t\t\taborted: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tproc.stdout?.on('data', (data) => {\n\t\t\tfor (const ch of String(data)) {\n\t\t\t\tif (ch === '\\r') {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif (ch === '\\n') {\n\t\t\t\t\tpushLine()\n\t\t\t\t\tline = ''\n\t\t\t\t} else {\n\t\t\t\t\tline += ch\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tproc?.stderr?.on('data', (data) => {\n\t\t\tstderr += String(data)\n\t\t})\n\n\t\tproc.on('exit', (code) => {\n\t\t\t// ripgrep exit code 1 means \"no matches found\" which is valid for our glob tool\n\t\t\tif (code && code >= 2) {\n\t\t\t\treject(new Error(`ripgrep exited with code ${code}:\\n${stderr}`))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// The last line does not end with \\n\n\t\t\tpushLine()\n\n\t\t\tconst filesMatchingLimit = lines.slice(0, limit)\n\t\t\tresolve({\n\t\t\t\tfiles: filesMatchingLimit,\n\t\t\t\tremaining: lines.length - filesMatchingLimit.length,\n\t\t\t})\n\t\t})\n\t})\n}\n"],"names":["WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","PLUS_LITERAL","QMARK_LITERAL","SLASH_LITERAL","ONE_CHAR","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","POSIX_CHARS","WINDOWS_CHARS","POSIX_REGEX_SOURCE","constants","chars","win32","REGEX_BACKSLASH","REGEX_REMOVE_BACKSLASH","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_GLOBAL","require$$0","exports","val","str","platform","match","input","char","lastIdx","idx","state","output","options","prepend","append","path","windows","segs","last","utils","CHAR_ASTERISK","CHAR_AT","CHAR_BACKWARD_SLASH","CHAR_COMMA","CHAR_DOT","CHAR_EXCLAMATION_MARK","CHAR_FORWARD_SLASH","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_PARENTHESES","CHAR_LEFT_SQUARE_BRACKET","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_PARENTHESES","CHAR_RIGHT_SQUARE_BRACKET","require$$1","isPathSeparator","code","depth","token","scan_1","opts","length","scanToEnd","slashes","tokens","parts","index","start","lastIndex","isBrace","isBracket","isGlob","isExtglob","isGlobstar","braceEscaped","backslashes","negated","negatedExtglob","finished","braces","prev","eos","peek","advance","next","base","prefix","glob","prevIndex","n","i","value","MAX_LENGTH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REPLACEMENTS","expandRange","args","v","syntaxError","type","parse","max","len","bos","capture","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","nodot","qmarkNoDot","star","extglobs","stack","remaining","consume","num","negate","count","increment","decrement","push","tok","extglobOpen","extglobClose","rest","extglobStar","expression","m","esc","first","inner","pre","posix","extglob","prevValue","escaped","open","brace","arr","range","out","toks","t","prior","before","isStart","afterStar","after","end","slashDot","create","source","parse_1","scan","require$$2","require$$3","isObject","picomatch","returnState","fns","isMatch","isState","regex","isIgnored","ignoreOpts","matcher","returnObject","result","format","patterns","pattern","p","returnOutput","parsed","err","picomatch_1","pico","nodeGlobTool","dirs","Observable","observer","globFilesWithRipgrep","combineLatest","dir","globFilesInDirWithRipgrep","map","results","progress","errors","error","checkDirURIIsFile","ripgrepFiles","files","message","MAX_GLOB_COUNT","params","limit","matchesGlobPattern","pm","proc","spawn","ripgrepExecutable","resolve","reject","lines","stderr","line","offset","isResolved","pushLine","toPush","logger","data","ch","filesMatchingLimit"],"mappings":";;;;;;;;AAEA,QAAMA,IAAY,SACZC,IAAe,KAAKD,CAAS,KAM7BE,IAAc,OACdC,IAAe,OACfC,IAAgB,OAChBC,IAAgB,OAChBC,IAAW,SACXC,IAAQ,QACRC,IAAa,MAAMH,CAAa,OAChCI,IAAe,QAAQJ,CAAa,KACpCK,IAAa,GAAGR,CAAW,QAAQM,CAAU,IAC7CG,IAAS,MAAMT,CAAW,KAC1BU,IAAU,MAAMH,CAAY,GAAGC,CAAU,KACzCG,IAAe,MAAMX,CAAW,QAAQM,CAAU,KAClDM,IAAgB,MAAMJ,CAAU,KAChCK,IAAe,MAAMV,CAAa,KAClCW,IAAO,GAAGT,CAAK,MAGfU,IAAc;AAAA,IAClB,aAAAf;AAAA,IACA,cAAAC;AAAA,IACA,eAAAC;AAAA,IACA,eAAAC;AAAA,IACA,UAAAC;AAAA,IACA,OAAAC;AAAA,IACA,YAAAC;AAAA,IACA,YAAAE;AAAA,IACA,QAAAC;AAAA,IACA,SAAAC;AAAA,IACA,cAAAC;AAAA,IACA,eAAAC;AAAA,IACA,cAAAC;AAAA,IACA,MAAAC;AAAA,IACA,cAAAP;AAAA,IACA,KAlBU;AAAA,EAmBX,GAMKS,IAAgB;AAAA,IACpB,GAAGD;AAAA,IAEH,eAAe,IAAIjB,CAAS;AAAA,IAC5B,OAAOC;AAAA,IACP,MAAM,GAAGA,CAAY;AAAA,IACrB,YAAY,GAAGC,CAAW,YAAYF,CAAS;AAAA,IAC/C,QAAQ,MAAME,CAAW;AAAA,IACzB,SAAS,YAAYF,CAAS,KAAKE,CAAW,YAAYF,CAAS;AAAA,IACnE,cAAc,MAAME,CAAW,YAAYF,CAAS;AAAA,IACpD,eAAe,MAAME,CAAW,YAAYF,CAAS;AAAA,IACrD,cAAc,MAAMA,CAAS;AAAA,IAC7B,cAAc,SAASA,CAAS;AAAA,IAChC,YAAY,OAAOA,CAAS;AAAA,IAC5B,KAAK;AAAA,EACN,GAMKmB,IAAqB;AAAA,IACzB,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,QAAQ;AAAA,EACT;AAED,SAAAC,KAAiB;AAAA,IACf,YAAY,OAAO;AAAA,IACnB,oBAAAD;AAAA;AAAA,IAGA,iBAAiB;AAAA,IACjB,yBAAyB;AAAA,IACzB,qBAAqB;AAAA,IACrB,6BAA6B;AAAA,IAC7B,4BAA4B;AAAA,IAC5B,wBAAwB;AAAA;AAAA,IAGxB,cAAc;AAAA,MACZ,OAAO;AAAA,MACP,SAAS;AAAA,MACT,YAAY;AAAA,IACb;AAAA;AAAA,IAGD,QAAQ;AAAA;AAAA,IACR,QAAQ;AAAA;AAAA;AAAA,IAGR,kBAAkB;AAAA;AAAA,IAClB,kBAAkB;AAAA;AAAA,IAClB,kBAAkB;AAAA;AAAA,IAClB,kBAAkB;AAAA;AAAA,IAElB,uBAAuB;AAAA;AAAA,IACvB,wBAAwB;AAAA;AAAA,IAExB,eAAe;AAAA;AAAA;AAAA,IAGf,gBAAgB;AAAA;AAAA,IAChB,SAAS;AAAA;AAAA,IACT,qBAAqB;AAAA;AAAA,IACrB,sBAAsB;AAAA;AAAA,IACtB,wBAAwB;AAAA;AAAA,IACxB,YAAY;AAAA;AAAA,IACZ,YAAY;AAAA;AAAA,IACZ,UAAU;AAAA;AAAA,IACV,mBAAmB;AAAA;AAAA,IACnB,YAAY;AAAA;AAAA,IACZ,uBAAuB;AAAA;AAAA,IACvB,gBAAgB;AAAA;AAAA,IAChB,oBAAoB;AAAA;AAAA,IACpB,mBAAmB;AAAA;AAAA,IACnB,WAAW;AAAA;AAAA,IACX,mBAAmB;AAAA;AAAA,IACnB,yBAAyB;AAAA;AAAA,IACzB,uBAAuB;AAAA;AAAA,IACvB,0BAA0B;AAAA;AAAA,IAC1B,gBAAgB;AAAA;AAAA,IAChB,qBAAqB;AAAA;AAAA,IACrB,cAAc;AAAA;AAAA,IACd,WAAW;AAAA;AAAA,IACX,oBAAoB;AAAA;AAAA,IACpB,0BAA0B;AAAA;AAAA,IAC1B,wBAAwB;AAAA;AAAA,IACxB,2BAA2B;AAAA;AAAA,IAC3B,gBAAgB;AAAA;AAAA,IAChB,mBAAmB;AAAA;AAAA,IACnB,YAAY;AAAA;AAAA,IACZ,UAAU;AAAA;AAAA,IACV,iBAAiB;AAAA;AAAA,IACjB,oBAAoB;AAAA;AAAA,IACpB,+BAA+B;AAAA;AAAA;AAAA;AAAA;AAAA,IAM/B,aAAaE,GAAO;AAClB,aAAO;AAAA,QACL,KAAK,EAAE,MAAM,UAAU,MAAM,aAAa,OAAO,KAAKA,EAAM,IAAI,IAAK;AAAA,QACrE,KAAK,EAAE,MAAM,SAAS,MAAM,OAAO,OAAO,KAAM;AAAA,QAChD,KAAK,EAAE,MAAM,QAAQ,MAAM,OAAO,OAAO,KAAM;AAAA,QAC/C,KAAK,EAAE,MAAM,QAAQ,MAAM,OAAO,OAAO,KAAM;AAAA,QAC/C,KAAK,EAAE,MAAM,MAAM,MAAM,OAAO,OAAO,IAAG;AAAA,MAC3C;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,IAMD,UAAUC,GAAO;AACf,aAAOA,MAAU,KAAOJ,IAAgBD;AAAA,IAC5C;AAAA,EACC;;;;;AC/KD,UAAM;AAAA,MACJ,iBAAAM;AAAA,MACA,wBAAAC;AAAA,MACA,qBAAAC;AAAA,MACA,4BAAAC;AAAA,IACD,IAAyBC,gBAAAA,GAAA;AAE1B,IAAAC,EAAA,WAAmB,CAAAC,MAAOA,MAAQ,QAAQ,OAAOA,KAAQ,YAAY,CAAC,MAAM,QAAQA,CAAG,GACvFD,EAAA,gBAAwB,CAAAE,MAAOL,EAAoB,KAAKK,CAAG,GAC3DF,EAAA,cAAsB,CAAAE,MAAOA,EAAI,WAAW,KAAKF,EAAQ,cAAcE,CAAG,GAC1EF,EAAsB,cAAA,CAAAE,MAAOA,EAAI,QAAQJ,GAA4B,MAAM,GAC3EE,EAAyB,iBAAA,CAAAE,MAAOA,EAAI,QAAQP,GAAiB,GAAG,GAEhEK,EAAA,YAAoB,MAAM;AACxB,UAAI,OAAO,YAAc,OAAe,UAAU,UAAU;AAC1D,cAAMG,IAAW,UAAU,SAAS,YAAa;AACjD,eAAOA,MAAa,WAAWA,MAAa;AAAA,MAChD;AAEE,aAAI,OAAO,UAAY,OAAe,QAAQ,WACrC,QAAQ,aAAa,UAGvB;AAAA,IACR,GAEDH,EAAA,oBAA4B,CAAAE,MACnBA,EAAI,QAAQN,GAAwB,CAAAQ,MAClCA,MAAU,OAAO,KAAKA,CAC9B,GAGHJ,EAAA,aAAqB,CAACK,GAAOC,GAAMC,MAAY;AAC7C,YAAMC,IAAMH,EAAM,YAAYC,GAAMC,CAAO;AAC3C,aAAIC,MAAQ,KAAWH,IACnBA,EAAMG,IAAM,CAAC,MAAM,OAAaR,EAAQ,WAAWK,GAAOC,GAAME,IAAM,CAAC,IACpE,GAAGH,EAAM,MAAM,GAAGG,CAAG,CAAC,KAAKH,EAAM,MAAMG,CAAG,CAAC;AAAA,IACnD,GAEDR,EAAA,eAAuB,CAACK,GAAOI,IAAQ,CAAA,MAAO;AAC5C,UAAIC,IAASL;AACb,aAAIK,EAAO,WAAW,IAAI,MACxBA,IAASA,EAAO,MAAM,CAAC,GACvBD,EAAM,SAAS,OAEVC;AAAA,IACR,GAEDV,EAAqB,aAAA,CAACK,GAAOI,IAAQ,CAAE,GAAEE,IAAU,OAAO;AACxD,YAAMC,IAAUD,EAAQ,WAAW,KAAK,KAClCE,IAASF,EAAQ,WAAW,KAAK;AAEvC,UAAID,IAAS,GAAGE,CAAO,MAAMP,CAAK,IAAIQ,CAAM;AAC5C,aAAIJ,EAAM,YAAY,OACpBC,IAAS,UAAUA,CAAM,UAEpBA;AAAA,IACR,GAEDV,EAAmB,WAAA,CAACc,GAAM,EAAE,SAAAC,EAAO,IAAK,CAAA,MAAO;AAC7C,YAAMC,IAAOF,EAAK,MAAMC,IAAU,UAAU,GAAG,GACzCE,IAAOD,EAAKA,EAAK,SAAS,CAAC;AAEjC,aAAIC,MAAS,KACJD,EAAKA,EAAK,SAAS,CAAC,IAGtBC;AAAA;;;;;;;ACpET,QAAMC,IAA0BnB,gBAAAA,GAAA,GAC1B;AAAA,IACJ,eAAAoB;AAAA;AAAA,IACA,SAAAC;AAAA;AAAA,IACA,qBAAAC;AAAA;AAAA,IACA,YAAAC;AAAA;AAAA,IACA,UAAAC;AAAA;AAAA,IACA,uBAAAC;AAAA;AAAA,IACA,oBAAAC;AAAA;AAAA,IACA,uBAAAC;AAAA;AAAA,IACA,uBAAAC;AAAA;AAAA,IACA,0BAAAC;AAAA;AAAA,IACA,WAAAC;AAAA;AAAA,IACA,oBAAAC;AAAA;AAAA,IACA,wBAAAC;AAAA;AAAA,IACA,wBAAAC;AAAA;AAAA,IACA,2BAAAC;AAAA;AAAA,EACD,IAAyBC,gBAAAA,GAAA,GAEpBC,IAAkB,CAAAC,MACfA,MAASX,KAAsBW,MAASf,GAG3CgB,IAAQ,CAAAC,MAAS;AACrB,IAAIA,EAAM,aAAa,OACrBA,EAAM,QAAQA,EAAM,aAAa,QAAW;AAAA,EAE/C;AAyWD,SAAAC,KAtVa,CAAClC,GAAOM,MAAY;AAC/B,UAAM6B,IAAO7B,KAAW,CAAE,GAEpB8B,IAASpC,EAAM,SAAS,GACxBqC,IAAYF,EAAK,UAAU,MAAQA,EAAK,cAAc,IACtDG,IAAU,CAAE,GACZC,IAAS,CAAE,GACXC,KAAQ,CAAE;AAEhB,QAAI3C,IAAMG,GACNyC,IAAQ,IACRC,IAAQ,GACRC,KAAY,GACZC,KAAU,IACVC,IAAY,IACZC,IAAS,IACTC,KAAY,IACZC,IAAa,IACbC,IAAe,IACfC,IAAc,IACdC,IAAU,IACVC,KAAiB,IACjBC,IAAW,IACXC,IAAS,GACTC,IACAxB,GACAE,IAAQ,EAAE,OAAO,IAAI,OAAO,GAAG,QAAQ,GAAO;AAElD,UAAMuB,IAAM,MAAMf,KAASL,GACrBqB,IAAO,MAAM5D,EAAI,WAAW4C,IAAQ,CAAC,GACrCiB,IAAU,OACdH,KAAOxB,GACAlC,EAAI,WAAW,EAAE4C,CAAK;AAG/B,WAAOA,IAAQL,KAAQ;AACrB,MAAAL,IAAO2B,EAAS;AAChB,UAAIC;AAEJ,UAAI5B,MAASf,GAAqB;AAChC,QAAAkC,IAAcjB,EAAM,cAAc,IAClCF,IAAO2B,EAAS,GAEZ3B,MAASV,MACX4B,IAAe;AAEjB;AAAA,MACN;AAEI,UAAIA,MAAiB,MAAQlB,MAASV,GAAuB;AAG3D,aAFAiC,KAEOE,EAAG,MAAO,OAASzB,IAAO2B,EAAS,MAAG;AAC3C,cAAI3B,MAASf,GAAqB;AAChC,YAAAkC,IAAcjB,EAAM,cAAc,IAClCyB,EAAS;AACT;AAAA,UACV;AAEQ,cAAI3B,MAASV,GAAuB;AAClC,YAAAiC;AACA;AAAA,UACV;AAEQ,cAAIL,MAAiB,MAAQlB,MAASb,MAAaa,IAAO2B,EAAS,OAAMxC,GAAU;AAKjF,gBAJA0B,KAAUX,EAAM,UAAU,IAC1Ba,IAASb,EAAM,SAAS,IACxBoB,IAAW,IAEPhB,MAAc;AAChB;AAGF;AAAA,UACV;AAEQ,cAAIY,MAAiB,MAAQlB,MAASd,GAAY;AAKhD,gBAJA2B,KAAUX,EAAM,UAAU,IAC1Ba,IAASb,EAAM,SAAS,IACxBoB,IAAW,IAEPhB,MAAc;AAChB;AAGF;AAAA,UACV;AAEQ,cAAIN,MAASL,MACX4B,KAEIA,MAAW,IAAG;AAChB,YAAAL,IAAe,IACfL,KAAUX,EAAM,UAAU,IAC1BoB,IAAW;AACX;AAAA,UACZ;AAAA,QAEA;AAEM,YAAIhB,MAAc;AAChB;AAGF;AAAA,MACN;AAEI,UAAIN,MAASX,GAAoB;AAK/B,YAJAkB,EAAQ,KAAKG,CAAK,GAClBF,EAAO,KAAKN,CAAK,GACjBA,IAAQ,EAAE,OAAO,IAAI,OAAO,GAAG,QAAQ,GAAO,GAE1CoB,MAAa,GAAM;AACvB,YAAIE,OAASrC,KAAYuB,MAAWC,IAAQ,GAAI;AAC9C,UAAAA,KAAS;AACT;AAAA,QACR;AAEM,QAAAC,KAAYF,IAAQ;AACpB;AAAA,MACN;AAEI,UAAIN,EAAK,UAAU,OACKJ,MAASP,KAC1BO,MAAShB,KACTgB,MAASjB,KACTiB,MAASN,KACTM,MAASZ,OAEQ,MAAQsC,EAAI,MAAOnC,GAAuB;AAQ9D,YAPAwB,IAASb,EAAM,SAAS,IACxBc,KAAYd,EAAM,YAAY,IAC9BoB,IAAW,IACPtB,MAASZ,KAAyBsB,MAAUC,MAC9CU,KAAiB,KAGff,MAAc,IAAM;AACtB,iBAAOmB,EAAG,MAAO,OAASzB,IAAO2B,EAAS,MAAG;AAC3C,gBAAI3B,MAASf,GAAqB;AAChC,cAAAkC,IAAcjB,EAAM,cAAc,IAClCF,IAAO2B,EAAS;AAChB;AAAA,YACd;AAEY,gBAAI3B,MAASJ,GAAwB;AACnC,cAAAmB,IAASb,EAAM,SAAS,IACxBoB,IAAW;AACX;AAAA,YACd;AAAA,UACA;AACU;AAAA,QACV;AACQ;AAAA,MACR;AAGI,UAAItB,MAASjB,GAAe;AAK1B,YAJIyC,OAASzC,MAAekC,IAAaf,EAAM,aAAa,KAC5Da,IAASb,EAAM,SAAS,IACxBoB,IAAW,IAEPhB,MAAc;AAChB;AAEF;AAAA,MACN;AAEI,UAAIN,MAASN,GAAoB;AAI/B,YAHAqB,IAASb,EAAM,SAAS,IACxBoB,IAAW,IAEPhB,MAAc;AAChB;AAEF;AAAA,MACN;AAEI,UAAIN,MAASR,GAA0B;AACrC,eAAOiC,EAAG,MAAO,OAASG,IAAOD,EAAS,MAAG;AAC3C,cAAIC,MAAS3C,GAAqB;AAChC,YAAAkC,IAAcjB,EAAM,cAAc,IAClCyB,EAAS;AACT;AAAA,UACV;AAEQ,cAAIC,MAAS/B,GAA2B;AACtC,YAAAiB,IAAYZ,EAAM,YAAY,IAC9Ba,IAASb,EAAM,SAAS,IACxBoB,IAAW;AACX;AAAA,UACV;AAAA,QACA;AAEM,YAAIhB,MAAc;AAChB;AAGF;AAAA,MACN;AAEI,UAAIF,EAAK,aAAa,MAAQJ,MAASZ,KAAyBsB,MAAUC,GAAO;AAC/E,QAAAS,IAAUlB,EAAM,UAAU,IAC1BS;AACA;AAAA,MACN;AAEI,UAAIP,EAAK,YAAY,MAAQJ,MAAST,GAAuB;AAG3D,YAFAwB,IAASb,EAAM,SAAS,IAEpBI,MAAc,IAAM;AACtB,iBAAOmB,EAAG,MAAO,OAASzB,IAAO2B,EAAS,MAAG;AAC3C,gBAAI3B,MAAST,GAAuB;AAClC,cAAA4B,IAAcjB,EAAM,cAAc,IAClCF,IAAO2B,EAAS;AAChB;AAAA,YACZ;AAEU,gBAAI3B,MAASJ,GAAwB;AACnC,cAAA0B,IAAW;AACX;AAAA,YACZ;AAAA,UACA;AACQ;AAAA,QACR;AACM;AAAA,MACN;AAEI,UAAIP,MAAW,IAAM;AAGnB,YAFAO,IAAW,IAEPhB,MAAc;AAChB;AAGF;AAAA,MACN;AAAA,IACA;AAEE,IAAIF,EAAK,UAAU,OACjBY,KAAY,IACZD,IAAS;AAGX,QAAIc,IAAO/D,GACPgE,KAAS,IACTC,IAAO;AAEX,IAAIpB,IAAQ,MACVmB,KAAShE,EAAI,MAAM,GAAG6C,CAAK,GAC3B7C,IAAMA,EAAI,MAAM6C,CAAK,GACrBC,MAAaD,IAGXkB,KAAQd,MAAW,MAAQH,KAAY,KACzCiB,IAAO/D,EAAI,MAAM,GAAG8C,EAAS,GAC7BmB,IAAOjE,EAAI,MAAM8C,EAAS,KACjBG,MAAW,MACpBc,IAAO,IACPE,IAAOjE,KAEP+D,IAAO/D,GAGL+D,KAAQA,MAAS,MAAMA,MAAS,OAAOA,MAAS/D,KAC9CiC,EAAgB8B,EAAK,WAAWA,EAAK,SAAS,CAAC,CAAC,MAClDA,IAAOA,EAAK,MAAM,GAAG,EAAE,IAIvBzB,EAAK,aAAa,OAChB2B,MAAMA,IAAOjD,EAAM,kBAAkBiD,CAAI,IAEzCF,KAAQV,MAAgB,OAC1BU,IAAO/C,EAAM,kBAAkB+C,CAAI;AAIvC,UAAMxD,IAAQ;AAAA,MACZ,QAAAyD;AAAA,MACA,OAAA7D;AAAA,MACA,OAAA0C;AAAA,MACA,MAAAkB;AAAA,MACA,MAAAE;AAAA,MACA,SAAAlB;AAAA,MACA,WAAAC;AAAA,MACA,QAAAC;AAAA,MACA,WAAAC;AAAA,MACA,YAAAC;AAAA,MACA,SAAAG;AAAA,MACA,gBAAAC;AAAA,IACD;AAUD,QARIjB,EAAK,WAAW,OAClB/B,EAAM,WAAW,GACZ0B,EAAgBC,CAAI,KACvBQ,EAAO,KAAKN,CAAK,GAEnB7B,EAAM,SAASmC,IAGbJ,EAAK,UAAU,MAAQA,EAAK,WAAW,IAAM;AAC/C,UAAI4B;AAEJ,eAAS5D,IAAM,GAAGA,IAAMmC,EAAQ,QAAQnC,KAAO;AAC7C,cAAM6D,IAAID,IAAYA,IAAY,IAAIrB,GAChCuB,IAAI3B,EAAQnC,CAAG,GACf+D,IAAQlE,EAAM,MAAMgE,GAAGC,CAAC;AAC9B,QAAI9B,EAAK,WACHhC,MAAQ,KAAKuC,MAAU,KACzBH,EAAOpC,CAAG,EAAE,WAAW,IACvBoC,EAAOpC,CAAG,EAAE,QAAQ0D,MAEpBtB,EAAOpC,CAAG,EAAE,QAAQ+D,GAEtBlC,EAAMO,EAAOpC,CAAG,CAAC,GACjBC,EAAM,YAAYmC,EAAOpC,CAAG,EAAE,SAE5BA,MAAQ,KAAK+D,MAAU,OACzB1B,GAAM,KAAK0B,CAAK,GAElBH,IAAYE;AAAA,MAClB;AAEI,UAAIF,KAAaA,IAAY,IAAI/D,EAAM,QAAQ;AAC7C,cAAMkE,IAAQlE,EAAM,MAAM+D,IAAY,CAAC;AACvC,QAAAvB,GAAM,KAAK0B,CAAK,GAEZ/B,EAAK,WACPI,EAAOA,EAAO,SAAS,CAAC,EAAE,QAAQ2B,GAClClC,EAAMO,EAAOA,EAAO,SAAS,CAAC,CAAC,GAC/BnC,EAAM,YAAYmC,EAAOA,EAAO,SAAS,CAAC,EAAE;AAAA,MAEpD;AAEI,MAAAnC,EAAM,UAAUkC,GAChBlC,EAAM,QAAQoC;AAAA,IAClB;AAEE,WAAOpC;AAAA,EACR;;;;;;AClYD,QAAMjB,IAAkCO,gBAAAA,GAAA,GAClCmB,IAA0BgB,gBAAAA,GAAA,GAM1B;AAAA,IACJ,YAAAsC;AAAA,IACA,oBAAAjF;AAAA,IACA,yBAAAkF;AAAA,IACA,6BAAAC;AAAA,IACA,cAAAC;AAAA,EACF,IAAInF,GAMEoF,IAAc,CAACC,GAAMlE,MAAY;AACrC,QAAI,OAAOA,EAAQ,eAAgB;AACjC,aAAOA,EAAQ,YAAY,GAAGkE,GAAMlE,CAAO;AAG7C,IAAAkE,EAAK,KAAM;AACX,UAAMN,IAAQ,IAAIM,EAAK,KAAK,GAAG,CAAC;AAEhC,QAAI;AAEF,UAAI,OAAON,CAAK;AAAA,IACjB,QAAY;AACX,aAAOM,EAAK,IAAI,CAAAC,MAAK5D,EAAM,YAAY4D,CAAC,CAAC,EAAE,KAAK,IAAI;AAAA,IACxD;AAEE,WAAOP;AAAA,EACR,GAMKQ,IAAc,CAACC,GAAM1E,MAClB,WAAW0E,CAAI,MAAM1E,CAAI,gBAAgBA,CAAI,iCAUhD2E,IAAQ,CAAC5E,GAAOM,MAAY;AAChC,QAAI,OAAON,KAAU;AACnB,YAAM,IAAI,UAAU,mBAAmB;AAGzC,IAAAA,IAAQsE,EAAatE,CAAK,KAAKA;AAE/B,UAAMmC,IAAO,EAAE,GAAG7B,EAAS,GACrBuE,IAAM,OAAO1C,EAAK,aAAc,WAAW,KAAK,IAAIgC,GAAYhC,EAAK,SAAS,IAAIgC;AAExF,QAAIW,IAAM9E,EAAM;AAChB,QAAI8E,IAAMD;AACR,YAAM,IAAI,YAAY,iBAAiBC,CAAG,qCAAqCD,CAAG,EAAE;AAGtF,UAAME,IAAM,EAAE,MAAM,OAAO,OAAO,IAAI,QAAQ5C,EAAK,WAAW,GAAI,GAC5DI,IAAS,CAACwC,CAAG,GAEbC,IAAU7C,EAAK,UAAU,KAAK,MAG9B8C,IAAiB9F,EAAU,UAAUgD,EAAK,OAAO,GACjD+C,IAAgB/F,EAAU,aAAa8F,CAAc,GAErD;AAAA,MACJ,aAAAhH;AAAA,MACA,cAAAC;AAAA,MACA,eAAAE;AAAA,MACA,UAAAC;AAAA,MACA,YAAAI;AAAA,MACA,QAAAC;AAAA,MACA,cAAAE;AAAA,MACA,eAAAC;AAAA,MACA,OAAAP;AAAA,MACA,cAAAQ;AAAA,MACA,MAAAC;AAAA,MACA,cAAAP;AAAA,IACJ,IAAMyG,GAEEE,IAAW,CAAAhD,MACR,IAAI6C,CAAO,SAASxG,EAAY,GAAG2D,EAAK,MAAM1D,IAAaR,CAAW,UAGzEmH,IAAQjD,EAAK,MAAM,KAAKzD,GACxB2G,KAAalD,EAAK,MAAM7D,IAAQQ;AACtC,QAAIwG,IAAOnD,EAAK,SAAS,KAAOgD,EAAShD,CAAI,IAAIpD;AAEjD,IAAIoD,EAAK,YACPmD,IAAO,IAAIA,CAAI,MAIb,OAAOnD,EAAK,SAAU,cACxBA,EAAK,YAAYA,EAAK;AAGxB,UAAM/B,IAAQ;AAAA,MACZ,OAAAJ;AAAA,MACA,OAAO;AAAA,MACP,OAAO;AAAA,MACP,KAAKmC,EAAK,QAAQ;AAAA,MAClB,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,WAAW;AAAA,MACX,SAAS;AAAA,MACT,UAAU;AAAA,MACV,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,QAAAI;AAAA,IACD;AAED,IAAAvC,IAAQa,EAAM,aAAab,GAAOI,CAAK,GACvC0E,IAAM9E,EAAM;AAEZ,UAAMuF,IAAW,CAAE,GACbjC,IAAS,CAAE,GACXkC,KAAQ,CAAE;AAChB,QAAIjC,IAAOwB,GACPb;AAMJ,UAAMV,KAAM,MAAMpD,EAAM,UAAU0E,IAAM,GAClCrB,IAAOrD,EAAM,OAAO,CAAC4D,IAAI,MAAMhE,EAAMI,EAAM,QAAQ4D,CAAC,GACpDN,IAAUtD,EAAM,UAAU,MAAMJ,EAAM,EAAEI,EAAM,KAAK,KAAK,IACxDqF,IAAY,MAAMzF,EAAM,MAAMI,EAAM,QAAQ,CAAC,GAC7CsF,IAAU,CAACxB,IAAQ,IAAIyB,IAAM,MAAM;AACvC,MAAAvF,EAAM,YAAY8D,GAClB9D,EAAM,SAASuF;AAAA,IAChB,GAEKnF,IAAS,CAAAyB,MAAS;AACtB,MAAA7B,EAAM,UAAU6B,EAAM,UAAU,OAAOA,EAAM,SAASA,EAAM,OAC5DyD,EAAQzD,EAAM,KAAK;AAAA,IACpB,GAEK2D,IAAS,MAAM;AACnB,UAAIC,IAAQ;AAEZ,aAAOpC,EAAM,MAAK,QAAQA,EAAK,CAAC,MAAM,OAAOA,EAAK,CAAC,MAAM;AACvD,QAAAC,EAAS,GACTtD,EAAM,SACNyF;AAGF,aAAIA,IAAQ,MAAM,IACT,MAGTzF,EAAM,UAAU,IAChBA,EAAM,SACC;AAAA,IACR,GAEK0F,KAAY,CAAAnB,MAAQ;AACxB,MAAAvE,EAAMuE,CAAI,KACVa,GAAM,KAAKb,CAAI;AAAA,IAChB,GAEKoB,IAAY,CAAApB,MAAQ;AACxB,MAAAvE,EAAMuE,CAAI,KACVa,GAAM,IAAK;AAAA,IACZ,GAUKQ,IAAO,CAAAC,MAAO;AAClB,UAAI1C,EAAK,SAAS,YAAY;AAC5B,cAAMX,IAAUxC,EAAM,SAAS,MAAM6F,EAAI,SAAS,WAAWA,EAAI,SAAS,UACpElD,IAAYkD,EAAI,YAAY,MAASV,EAAS,WAAWU,EAAI,SAAS,UAAUA,EAAI,SAAS;AAEnG,QAAIA,EAAI,SAAS,WAAWA,EAAI,SAAS,WAAW,CAACrD,KAAW,CAACG,MAC/D3C,EAAM,SAASA,EAAM,OAAO,MAAM,GAAG,CAACmD,EAAK,OAAO,MAAM,GACxDA,EAAK,OAAO,QACZA,EAAK,QAAQ,KACbA,EAAK,SAAS+B,GACdlF,EAAM,UAAUmD,EAAK;AAAA,MAE7B;AAOI,UALIgC,EAAS,UAAUU,EAAI,SAAS,YAClCV,EAASA,EAAS,SAAS,CAAC,EAAE,SAASU,EAAI,SAGzCA,EAAI,SAASA,EAAI,WAAQzF,EAAOyF,CAAG,GACnC1C,KAAQA,EAAK,SAAS,UAAU0C,EAAI,SAAS,QAAQ;AACvD,QAAA1C,EAAK,UAAUA,EAAK,UAAUA,EAAK,SAAS0C,EAAI,OAChD1C,EAAK,SAAS0C,EAAI;AAClB;AAAA,MACN;AAEI,MAAAA,EAAI,OAAO1C,GACXhB,EAAO,KAAK0D,CAAG,GACf1C,IAAO0C;AAAA,IACR,GAEKC,IAAc,CAACvB,GAAMT,MAAU;AACnC,YAAMjC,IAAQ,EAAE,GAAGiD,EAAchB,CAAK,GAAG,YAAY,GAAG,OAAO,GAAI;AAEnE,MAAAjC,EAAM,OAAOsB,GACbtB,EAAM,SAAS7B,EAAM,QACrB6B,EAAM,SAAS7B,EAAM;AACrB,YAAMC,KAAU8B,EAAK,UAAU,MAAM,MAAMF,EAAM;AAEjD,MAAA6D,GAAU,QAAQ,GAClBE,EAAK,EAAE,MAAArB,GAAM,OAAAT,GAAO,QAAQ9D,EAAM,SAAS,KAAK/B,GAAU,GAC1D2H,EAAK,EAAE,MAAM,SAAS,SAAS,IAAM,OAAOtC,KAAW,QAAArD,GAAQ,GAC/DkF,EAAS,KAAKtD,CAAK;AAAA,IACpB,GAEKkE,IAAe,CAAAlE,MAAS;AAC5B,UAAI5B,IAAS4B,EAAM,SAASE,EAAK,UAAU,MAAM,KAC7CiE;AAEJ,UAAInE,EAAM,SAAS,UAAU;AAC3B,YAAIoE,IAAcf;AAUlB,YARIrD,EAAM,SAASA,EAAM,MAAM,SAAS,KAAKA,EAAM,MAAM,SAAS,GAAG,MACnEoE,IAAclB,EAAShD,CAAI,KAGzBkE,MAAgBf,KAAQ9B,GAAG,KAAM,QAAQ,KAAKiC,EAAS,CAAE,OAC3DpF,IAAS4B,EAAM,QAAQ,OAAOoE,CAAW,KAGvCpE,EAAM,MAAM,SAAS,GAAG,MAAMmE,IAAOX,EAAS,MAAO,eAAe,KAAKW,CAAI,GAAG;AAMlF,gBAAME,IAAa1B,EAAMwB,GAAM,EAAE,GAAG9F,GAAS,WAAW,GAAO,CAAA,EAAE;AAEjE,UAAAD,IAAS4B,EAAM,QAAQ,IAAIqE,CAAU,IAAID,CAAW;AAAA,QAC5D;AAEM,QAAIpE,EAAM,KAAK,SAAS,UACtB7B,EAAM,iBAAiB;AAAA,MAE/B;AAEI,MAAA4F,EAAK,EAAE,MAAM,SAAS,SAAS,IAAM,OAAA9B,GAAO,QAAA7D,GAAQ,GACpD0F,EAAU,QAAQ;AAAA,IACnB;AAMD,QAAI5D,EAAK,cAAc,MAAS,CAAC,sBAAsB,KAAKnC,CAAK,GAAG;AAClE,UAAIkD,IAAc,IAEd7C,IAASL,EAAM,QAAQqE,GAA6B,CAACkC,GAAGC,GAAKpH,GAAOqH,GAAOL,GAAM3D,OAC/EgE,MAAU,QACZvD,IAAc,IACPqD,KAGLE,MAAU,MACRD,IACKA,IAAMC,KAASL,IAAO9H,EAAM,OAAO8H,EAAK,MAAM,IAAI,MAEvD3D,OAAU,IACL4C,MAAce,IAAO9H,EAAM,OAAO8H,EAAK,MAAM,IAAI,MAEnD9H,EAAM,OAAOc,EAAM,MAAM,IAG9BqH,MAAU,MACLxI,EAAY,OAAOmB,EAAM,MAAM,IAGpCqH,MAAU,MACRD,IACKA,IAAMC,KAASL,IAAOd,IAAO,MAE/BA,IAEFkB,IAAMD,IAAI,KAAKA,CAAC,EACxB;AAYD,aAVIrD,MAAgB,OACdf,EAAK,aAAa,KACpB9B,IAASA,EAAO,QAAQ,OAAO,EAAE,IAEjCA,IAASA,EAAO,QAAQ,QAAQ,CAAAkG,MACvBA,EAAE,SAAS,MAAM,IAAI,SAAUA,IAAI,OAAO,EAClD,IAIDlG,MAAWL,KAASmC,EAAK,aAAa,MACxC/B,EAAM,SAASJ,GACRI,MAGTA,EAAM,SAASS,EAAM,WAAWR,GAAQD,GAAOE,CAAO,GAC/CF;AAAA,IACX;AAME,WAAO,CAACoD,GAAG,KAAI;AAGb,UAFAU,IAAQR,EAAS,GAEbQ,MAAU;AACZ;AAOF,UAAIA,MAAU,MAAM;AAClB,cAAMP,IAAOF,EAAM;AAMnB,YAJIE,MAAS,OAAOxB,EAAK,SAAS,MAI9BwB,MAAS,OAAOA,MAAS;AAC3B;AAGF,YAAI,CAACA,GAAM;AACT,UAAAO,KAAS,MACT8B,EAAK,EAAE,MAAM,QAAQ,OAAA9B,EAAK,CAAE;AAC5B;AAAA,QACR;AAGM,cAAMnE,IAAQ,OAAO,KAAK0F,EAAS,CAAE;AACrC,YAAInD,IAAU;AAgBd,YAdIvC,KAASA,EAAM,CAAC,EAAE,SAAS,MAC7BuC,IAAUvC,EAAM,CAAC,EAAE,QACnBK,EAAM,SAASkC,GACXA,IAAU,MAAM,MAClB4B,KAAS,QAIT/B,EAAK,aAAa,KACpB+B,IAAQR,EAAS,IAEjBQ,KAASR,EAAS,GAGhBtD,EAAM,aAAa,GAAG;AACxB,UAAA4F,EAAK,EAAE,MAAM,QAAQ,OAAA9B,EAAK,CAAE;AAC5B;AAAA,QACR;AAAA,MACA;AAOI,UAAI9D,EAAM,WAAW,MAAM8D,MAAU,OAAOX,EAAK,UAAU,OAAOA,EAAK,UAAU,OAAO;AACtF,YAAIpB,EAAK,UAAU,MAAS+B,MAAU,KAAK;AACzC,gBAAMwC,IAAQnD,EAAK,MAAM,MAAM,CAAC;AAChC,cAAImD,EAAM,SAAS,GAAG,MACpBnD,EAAK,QAAQ,IAETmD,EAAM,SAAS,GAAG,IAAG;AACvB,kBAAMvG,IAAMoD,EAAK,MAAM,YAAY,GAAG,GAChCoD,IAAMpD,EAAK,MAAM,MAAM,GAAGpD,CAAG,GAC7BiG,IAAO7C,EAAK,MAAM,MAAMpD,IAAM,CAAC,GAC/ByG,IAAQ1H,EAAmBkH,CAAI;AACrC,gBAAIQ,GAAO;AACT,cAAArD,EAAK,QAAQoD,IAAMC,GACnBxG,EAAM,YAAY,IAClBsD,EAAS,GAEL,CAACqB,EAAI,UAAUxC,EAAO,QAAQgB,CAAI,MAAM,MAC1CwB,EAAI,SAAS1G;AAEf;AAAA,YACd;AAAA,UACA;AAAA,QAEA;AAEM,SAAK6F,MAAU,OAAOT,QAAW,OAASS,MAAU,OAAOT,QAAW,SACpES,IAAQ,KAAKA,CAAK,KAGhBA,MAAU,QAAQX,EAAK,UAAU,OAAOA,EAAK,UAAU,UACzDW,IAAQ,KAAKA,CAAK,KAGhB/B,EAAK,UAAU,MAAQ+B,MAAU,OAAOX,EAAK,UAAU,QACzDW,IAAQ,MAGVX,EAAK,SAASW,GACd1D,EAAO,EAAE,OAAA0D,GAAO;AAChB;AAAA,MACN;AAOI,UAAI9D,EAAM,WAAW,KAAK8D,MAAU,KAAK;AACvC,QAAAA,IAAQrD,EAAM,YAAYqD,CAAK,GAC/BX,EAAK,SAASW,GACd1D,EAAO,EAAE,OAAA0D,GAAO;AAChB;AAAA,MACN;AAMI,UAAIA,MAAU,KAAK;AACjB,QAAA9D,EAAM,SAASA,EAAM,WAAW,IAAI,IAAI,GACpC+B,EAAK,eAAe,MACtB6D,EAAK,EAAE,MAAM,QAAQ,OAAA9B,EAAK,CAAE;AAE9B;AAAA,MACN;AAMI,UAAIA,MAAU,KAAK;AACjB,QAAA4B,GAAU,QAAQ,GAClBE,EAAK,EAAE,MAAM,SAAS,OAAA9B,EAAK,CAAE;AAC7B;AAAA,MACN;AAEI,UAAIA,MAAU,KAAK;AACjB,YAAI9D,EAAM,WAAW,KAAK+B,EAAK,mBAAmB;AAChD,gBAAM,IAAI,YAAYuC,EAAY,WAAW,GAAG,CAAC;AAGnD,cAAMmC,IAAUtB,EAASA,EAAS,SAAS,CAAC;AAC5C,YAAIsB,KAAWzG,EAAM,WAAWyG,EAAQ,SAAS,GAAG;AAClD,UAAAV,EAAaZ,EAAS,KAAK;AAC3B;AAAA,QACR;AAEM,QAAAS,EAAK,EAAE,MAAM,SAAS,OAAA9B,GAAO,QAAQ9D,EAAM,SAAS,MAAM,OAAO,GACjE2F,EAAU,QAAQ;AAClB;AAAA,MACN;AAMI,UAAI7B,MAAU,KAAK;AACjB,YAAI/B,EAAK,cAAc,MAAQ,CAACsD,IAAY,SAAS,GAAG,GAAG;AACzD,cAAItD,EAAK,cAAc,MAAQA,EAAK,mBAAmB;AACrD,kBAAM,IAAI,YAAYuC,EAAY,WAAW,GAAG,CAAC;AAGnD,UAAAR,IAAQ,KAAKA,CAAK;AAAA,QAC1B;AACQ,UAAA4B,GAAU,UAAU;AAGtB,QAAAE,EAAK,EAAE,MAAM,WAAW,OAAA9B,EAAK,CAAE;AAC/B;AAAA,MACN;AAEI,UAAIA,MAAU,KAAK;AACjB,YAAI/B,EAAK,cAAc,MAASoB,KAAQA,EAAK,SAAS,aAAaA,EAAK,MAAM,WAAW,GAAI;AAC3F,UAAAyC,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAQ,KAAKA,CAAK,IAAI;AAClD;AAAA,QACR;AAEM,YAAI9D,EAAM,aAAa,GAAG;AACxB,cAAI+B,EAAK,mBAAmB;AAC1B,kBAAM,IAAI,YAAYuC,EAAY,WAAW,GAAG,CAAC;AAGnD,UAAAsB,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAQ,KAAKA,CAAK,IAAI;AAClD;AAAA,QACR;AAEM,QAAA6B,EAAU,UAAU;AAEpB,cAAMe,IAAYvD,EAAK,MAAM,MAAM,CAAC;AAUpC,YATIA,EAAK,UAAU,MAAQuD,EAAU,CAAC,MAAM,OAAO,CAACA,EAAU,SAAS,GAAG,MACxE5C,IAAQ,IAAIA,CAAK,KAGnBX,EAAK,SAASW,GACd1D,EAAO,EAAE,OAAA0D,GAAO,GAIZ/B,EAAK,oBAAoB,MAAStB,EAAM,cAAciG,CAAS;AACjE;AAGF,cAAMC,IAAUlG,EAAM,YAAY0C,EAAK,KAAK;AAK5C,YAJAnD,EAAM,SAASA,EAAM,OAAO,MAAM,GAAG,CAACmD,EAAK,MAAM,MAAM,GAInDpB,EAAK,oBAAoB,IAAM;AACjC,UAAA/B,EAAM,UAAU2G,GAChBxD,EAAK,QAAQwD;AACb;AAAA,QACR;AAGM,QAAAxD,EAAK,QAAQ,IAAIyB,CAAO,GAAG+B,CAAO,IAAIxD,EAAK,KAAK,KAChDnD,EAAM,UAAUmD,EAAK;AACrB;AAAA,MACN;AAMI,UAAIW,MAAU,OAAO/B,EAAK,YAAY,IAAM;AAC1C,QAAA2D,GAAU,QAAQ;AAElB,cAAMkB,IAAO;AAAA,UACX,MAAM;AAAA,UACN,OAAA9C;AAAA,UACA,QAAQ;AAAA,UACR,aAAa9D,EAAM,OAAO;AAAA,UAC1B,aAAaA,EAAM,OAAO;AAAA,QAC3B;AAED,QAAAkD,EAAO,KAAK0D,CAAI,GAChBhB,EAAKgB,CAAI;AACT;AAAA,MACN;AAEI,UAAI9C,MAAU,KAAK;AACjB,cAAM+C,IAAQ3D,EAAOA,EAAO,SAAS,CAAC;AAEtC,YAAInB,EAAK,YAAY,MAAQ,CAAC8E,GAAO;AACnC,UAAAjB,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAQA,GAAO;AAC3C;AAAA,QACR;AAEM,YAAI7D,IAAS;AAEb,YAAI4G,EAAM,SAAS,IAAM;AACvB,gBAAMC,IAAM3E,EAAO,MAAO,GACpB4E,IAAQ,CAAE;AAEhB,mBAASlD,IAAIiD,EAAI,SAAS,GAAGjD,KAAK,MAChC1B,EAAO,IAAK,GACR2E,EAAIjD,CAAC,EAAE,SAAS,UAFeA;AAKnC,YAAIiD,EAAIjD,CAAC,EAAE,SAAS,UAClBkD,EAAM,QAAQD,EAAIjD,CAAC,EAAE,KAAK;AAI9B,UAAA5D,IAASkE,EAAY4C,GAAOhF,CAAI,GAChC/B,EAAM,YAAY;AAAA,QAC1B;AAEM,YAAI6G,EAAM,UAAU,MAAQA,EAAM,SAAS,IAAM;AAC/C,gBAAMG,IAAMhH,EAAM,OAAO,MAAM,GAAG6G,EAAM,WAAW,GAC7CI,IAAOjH,EAAM,OAAO,MAAM6G,EAAM,WAAW;AACjD,UAAAA,EAAM,QAAQA,EAAM,SAAS,OAC7B/C,IAAQ7D,IAAS,OACjBD,EAAM,SAASgH;AACf,qBAAWE,KAAKD;AACd,YAAAjH,EAAM,UAAWkH,EAAE,UAAUA,EAAE;AAAA,QAEzC;AAEM,QAAAtB,EAAK,EAAE,MAAM,SAAS,OAAA9B,GAAO,QAAA7D,EAAM,CAAE,GACrC0F,EAAU,QAAQ,GAClBzC,EAAO,IAAK;AACZ;AAAA,MACN;AAMI,UAAIY,MAAU,KAAK;AACjB,QAAIqB,EAAS,SAAS,KACpBA,EAASA,EAAS,SAAS,CAAC,EAAE,cAEhCS,EAAK,EAAE,MAAM,QAAQ,OAAA9B,EAAK,CAAE;AAC5B;AAAA,MACN;AAMI,UAAIA,MAAU,KAAK;AACjB,YAAI7D,IAAS6D;AAEb,cAAM+C,IAAQ3D,EAAOA,EAAO,SAAS,CAAC;AACtC,QAAI2D,KAASzB,GAAMA,GAAM,SAAS,CAAC,MAAM,aACvCyB,EAAM,QAAQ,IACd5G,IAAS,MAGX2F,EAAK,EAAE,MAAM,SAAS,OAAA9B,GAAO,QAAA7D,EAAM,CAAE;AACrC;AAAA,MACN;AAMI,UAAI6D,MAAU,KAAK;AAKjB,YAAIX,EAAK,SAAS,SAASnD,EAAM,UAAUA,EAAM,QAAQ,GAAG;AAC1D,UAAAA,EAAM,QAAQA,EAAM,QAAQ,GAC5BA,EAAM,WAAW,IACjBA,EAAM,SAAS,IACfmC,EAAO,IAAK,GACZgB,IAAOwB;AACP;AAAA,QACR;AAEM,QAAAiB,EAAK,EAAE,MAAM,SAAS,OAAA9B,GAAO,QAAQ9F,GAAe;AACpD;AAAA,MACN;AAMI,UAAI8F,MAAU,KAAK;AACjB,YAAI9D,EAAM,SAAS,KAAKmD,EAAK,SAAS,OAAO;AAC3C,UAAIA,EAAK,UAAU,QAAKA,EAAK,SAAStF;AACtC,gBAAMgJ,IAAQ3D,EAAOA,EAAO,SAAS,CAAC;AACtC,UAAAC,EAAK,OAAO,QACZA,EAAK,UAAUW,GACfX,EAAK,SAASW,GACd+C,EAAM,OAAO;AACb;AAAA,QACR;AAEM,YAAK7G,EAAM,SAASA,EAAM,WAAY,KAAKmD,EAAK,SAAS,SAASA,EAAK,SAAS,SAAS;AACvF,UAAAyC,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAQjG,GAAa;AACjD;AAAA,QACR;AAEM,QAAA+H,EAAK,EAAE,MAAM,OAAO,OAAA9B,GAAO,QAAQjG,GAAa;AAChD;AAAA,MACN;AAMI,UAAIiG,MAAU,KAAK;AAEjB,YAAI,EADYX,KAAQA,EAAK,UAAU,QACvBpB,EAAK,cAAc,MAAQsB,EAAM,MAAK,OAAOA,EAAK,CAAC,MAAM,KAAK;AAC5E,UAAAyC,EAAY,SAAShC,CAAK;AAC1B;AAAA,QACR;AAEM,YAAIX,KAAQA,EAAK,SAAS,SAAS;AACjC,gBAAMI,IAAOF,EAAM;AACnB,cAAIpD,IAAS6D;AAEb,WAAKX,EAAK,UAAU,OAAO,CAAC,SAAS,KAAKI,CAAI,KAAOA,MAAS,OAAO,CAAC,eAAe,KAAK8B,EAAW,CAAA,OACnGpF,IAAS,KAAK6D,CAAK,KAGrB8B,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAA7D,EAAM,CAAE;AACpC;AAAA,QACR;AAEM,YAAI8B,EAAK,QAAQ,OAASoB,EAAK,SAAS,WAAWA,EAAK,SAAS,QAAQ;AACvE,UAAAyC,EAAK,EAAE,MAAM,SAAS,OAAA9B,GAAO,QAAQpF,GAAc;AACnD;AAAA,QACR;AAEM,QAAAkH,EAAK,EAAE,MAAM,SAAS,OAAA9B,GAAO,QAAQ5F,GAAO;AAC5C;AAAA,MACN;AAMI,UAAI4F,MAAU,KAAK;AACjB,YAAI/B,EAAK,cAAc,MAAQsB,EAAI,MAAO,QACpCA,EAAK,CAAC,MAAM,OAAO,CAAC,SAAS,KAAKA,EAAK,CAAC,CAAC,IAAG;AAC9C,UAAAyC,EAAY,UAAUhC,CAAK;AAC3B;AAAA,QACV;AAGM,YAAI/B,EAAK,aAAa,MAAQ/B,EAAM,UAAU,GAAG;AAC/C,UAAAwF,EAAQ;AACR;AAAA,QACR;AAAA,MACA;AAMI,UAAI1B,MAAU,KAAK;AACjB,YAAI/B,EAAK,cAAc,MAAQsB,EAAI,MAAO,OAAOA,EAAK,CAAC,MAAM,KAAK;AAChE,UAAAyC,EAAY,QAAQhC,CAAK;AACzB;AAAA,QACR;AAEM,YAAKX,KAAQA,EAAK,UAAU,OAAQpB,EAAK,UAAU,IAAO;AACxD,UAAA6D,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAQhG,GAAc;AAClD;AAAA,QACR;AAEM,YAAKqF,MAASA,EAAK,SAAS,aAAaA,EAAK,SAAS,WAAWA,EAAK,SAAS,YAAanD,EAAM,SAAS,GAAG;AAC7G,UAAA4F,EAAK,EAAE,MAAM,QAAQ,OAAA9B,EAAK,CAAE;AAC5B;AAAA,QACR;AAEM,QAAA8B,EAAK,EAAE,MAAM,QAAQ,OAAO9H,EAAY,CAAE;AAC1C;AAAA,MACN;AAMI,UAAIgG,MAAU,KAAK;AACjB,YAAI/B,EAAK,cAAc,MAAQsB,EAAI,MAAO,OAAOA,EAAK,CAAC,MAAM,KAAK;AAChE,UAAAuC,EAAK,EAAE,MAAM,MAAM,SAAS,IAAM,OAAA9B,GAAO,QAAQ,IAAI;AACrD;AAAA,QACR;AAEM,QAAA8B,EAAK,EAAE,MAAM,QAAQ,OAAA9B,EAAK,CAAE;AAC5B;AAAA,MACN;AAMI,UAAIA,MAAU,KAAK;AACjB,SAAIA,MAAU,OAAOA,MAAU,SAC7BA,IAAQ,KAAKA,CAAK;AAGpB,cAAMnE,IAAQqE,EAAwB,KAAKqB,EAAS,CAAE;AACtD,QAAI1F,MACFmE,KAASnE,EAAM,CAAC,GAChBK,EAAM,SAASL,EAAM,CAAC,EAAE,SAG1BiG,EAAK,EAAE,MAAM,QAAQ,OAAA9B,EAAK,CAAE;AAC5B;AAAA,MACN;AAMI,UAAIX,MAASA,EAAK,SAAS,cAAcA,EAAK,SAAS,KAAO;AAC5D,QAAAA,EAAK,OAAO,QACZA,EAAK,OAAO,IACZA,EAAK,SAASW,GACdX,EAAK,SAAS+B,GACdlF,EAAM,YAAY,IAClBA,EAAM,WAAW,IACjBsF,EAAQxB,CAAK;AACb;AAAA,MACN;AAEI,UAAIkC,IAAOX,EAAW;AACtB,UAAItD,EAAK,cAAc,MAAQ,UAAU,KAAKiE,CAAI,GAAG;AACnD,QAAAF,EAAY,QAAQhC,CAAK;AACzB;AAAA,MACN;AAEI,UAAIX,EAAK,SAAS,QAAQ;AACxB,YAAIpB,EAAK,eAAe,IAAM;AAC5B,UAAAuD,EAAQxB,CAAK;AACb;AAAA,QACR;AAEM,cAAMqD,IAAQhE,EAAK,MACbiE,IAASD,EAAM,MACfE,IAAUF,EAAM,SAAS,WAAWA,EAAM,SAAS,OACnDG,IAAYF,MAAWA,EAAO,SAAS,UAAUA,EAAO,SAAS;AAEvE,YAAIrF,EAAK,SAAS,OAAS,CAACsF,KAAYrB,EAAK,CAAC,KAAKA,EAAK,CAAC,MAAM,MAAO;AACpE,UAAAJ,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAQ,IAAI;AACxC;AAAA,QACR;AAEM,cAAMtB,IAAUxC,EAAM,SAAS,MAAMmH,EAAM,SAAS,WAAWA,EAAM,SAAS,UACxExE,KAAYwC,EAAS,WAAWgC,EAAM,SAAS,UAAUA,EAAM,SAAS;AAC9E,YAAI,CAACE,KAAWF,EAAM,SAAS,WAAW,CAAC3E,KAAW,CAACG,IAAW;AAChE,UAAAiD,EAAK,EAAE,MAAM,QAAQ,OAAA9B,GAAO,QAAQ,IAAI;AACxC;AAAA,QACR;AAGM,eAAOkC,EAAK,MAAM,GAAG,CAAC,MAAM,SAAO;AACjC,gBAAMuB,KAAQ3H,EAAMI,EAAM,QAAQ,CAAC;AACnC,cAAIuH,MAASA,OAAU;AACrB;AAEF,UAAAvB,IAAOA,EAAK,MAAM,CAAC,GACnBV,EAAQ,OAAO,CAAC;AAAA,QACxB;AAEM,YAAI6B,EAAM,SAAS,SAAS/D,GAAG,GAAI;AACjC,UAAAD,EAAK,OAAO,YACZA,EAAK,SAASW,GACdX,EAAK,SAAS4B,EAAShD,CAAI,GAC3B/B,EAAM,SAASmD,EAAK,QACpBnD,EAAM,WAAW,IACjBsF,EAAQxB,CAAK;AACb;AAAA,QACR;AAEM,YAAIqD,EAAM,SAAS,WAAWA,EAAM,KAAK,SAAS,SAAS,CAACG,KAAalE,MAAO;AAC9E,UAAApD,EAAM,SAASA,EAAM,OAAO,MAAM,GAAG,EAAEmH,EAAM,SAAShE,EAAK,QAAQ,MAAM,GACzEgE,EAAM,SAAS,MAAMA,EAAM,MAAM,IAEjChE,EAAK,OAAO,YACZA,EAAK,SAAS4B,EAAShD,CAAI,KAAKA,EAAK,gBAAgB,MAAM,QAC3DoB,EAAK,SAASW,GACd9D,EAAM,WAAW,IACjBA,EAAM,UAAUmH,EAAM,SAAShE,EAAK,QACpCmC,EAAQxB,CAAK;AACb;AAAA,QACR;AAEM,YAAIqD,EAAM,SAAS,WAAWA,EAAM,KAAK,SAAS,SAASnB,EAAK,CAAC,MAAM,KAAK;AAC1E,gBAAMwB,KAAMxB,EAAK,CAAC,MAAM,SAAS,OAAO;AAExC,UAAAhG,EAAM,SAASA,EAAM,OAAO,MAAM,GAAG,EAAEmH,EAAM,SAAShE,EAAK,QAAQ,MAAM,GACzEgE,EAAM,SAAS,MAAMA,EAAM,MAAM,IAEjChE,EAAK,OAAO,YACZA,EAAK,SAAS,GAAG4B,EAAShD,CAAI,CAAC,GAAG/D,CAAa,IAAIA,CAAa,GAAGwJ,EAAG,KACtErE,EAAK,SAASW,GAEd9D,EAAM,UAAUmH,EAAM,SAAShE,EAAK,QACpCnD,EAAM,WAAW,IAEjBsF,EAAQxB,IAAQR,GAAS,GAEzBsC,EAAK,EAAE,MAAM,SAAS,OAAO,KAAK,QAAQ,IAAI;AAC9C;AAAA,QACR;AAEM,YAAIuB,EAAM,SAAS,SAASnB,EAAK,CAAC,MAAM,KAAK;AAC3C,UAAA7C,EAAK,OAAO,YACZA,EAAK,SAASW,GACdX,EAAK,SAAS,QAAQnF,CAAa,IAAI+G,EAAShD,CAAI,CAAC,GAAG/D,CAAa,KACrEgC,EAAM,SAASmD,EAAK,QACpBnD,EAAM,WAAW,IACjBsF,EAAQxB,IAAQR,GAAS,GACzBsC,EAAK,EAAE,MAAM,SAAS,OAAO,KAAK,QAAQ,IAAI;AAC9C;AAAA,QACR;AAGM,QAAA5F,EAAM,SAASA,EAAM,OAAO,MAAM,GAAG,CAACmD,EAAK,OAAO,MAAM,GAGxDA,EAAK,OAAO,YACZA,EAAK,SAAS4B,EAAShD,CAAI,GAC3BoB,EAAK,SAASW,GAGd9D,EAAM,UAAUmD,EAAK,QACrBnD,EAAM,WAAW,IACjBsF,EAAQxB,CAAK;AACb;AAAA,MACN;AAEI,YAAMjC,IAAQ,EAAE,MAAM,QAAQ,OAAAiC,GAAO,QAAQoB,EAAM;AAEnD,UAAInD,EAAK,SAAS,IAAM;AACtB,QAAAF,EAAM,SAAS,QACXsB,EAAK,SAAS,SAASA,EAAK,SAAS,aACvCtB,EAAM,SAASmD,IAAQnD,EAAM,SAE/B+D,EAAK/D,CAAK;AACV;AAAA,MACN;AAEI,UAAIsB,MAASA,EAAK,SAAS,aAAaA,EAAK,SAAS,YAAYpB,EAAK,UAAU,IAAM;AACrF,QAAAF,EAAM,SAASiC,GACf8B,EAAK/D,CAAK;AACV;AAAA,MACN;AAEI,OAAI7B,EAAM,UAAUA,EAAM,SAASmD,EAAK,SAAS,WAAWA,EAAK,SAAS,WACpEA,EAAK,SAAS,SAChBnD,EAAM,UAAUxB,IAChB2E,EAAK,UAAU3E,MAENuD,EAAK,QAAQ,MACtB/B,EAAM,UAAUvB,GAChB0E,EAAK,UAAU1E,MAGfuB,EAAM,UAAUgF,GAChB7B,EAAK,UAAU6B,IAGb3B,EAAM,MAAK,QACbrD,EAAM,UAAU/B,GAChBkF,EAAK,UAAUlF,KAInB2H,EAAK/D,CAAK;AAAA,IACd;AAEE,WAAO7B,EAAM,WAAW,KAAG;AACzB,UAAI+B,EAAK,mBAAmB,GAAM,OAAM,IAAI,YAAYuC,EAAY,WAAW,GAAG,CAAC;AACnF,MAAAtE,EAAM,SAASS,EAAM,WAAWT,EAAM,QAAQ,GAAG,GACjD2F,EAAU,UAAU;AAAA,IACxB;AAEE,WAAO3F,EAAM,SAAS,KAAG;AACvB,UAAI+B,EAAK,mBAAmB,GAAM,OAAM,IAAI,YAAYuC,EAAY,WAAW,GAAG,CAAC;AACnF,MAAAtE,EAAM,SAASS,EAAM,WAAWT,EAAM,QAAQ,GAAG,GACjD2F,EAAU,QAAQ;AAAA,IACtB;AAEE,WAAO3F,EAAM,SAAS,KAAG;AACvB,UAAI+B,EAAK,mBAAmB,GAAM,OAAM,IAAI,YAAYuC,EAAY,WAAW,GAAG,CAAC;AACnF,MAAAtE,EAAM,SAASS,EAAM,WAAWT,EAAM,QAAQ,GAAG,GACjD2F,EAAU,QAAQ;AAAA,IACtB;AAOE,QALI5D,EAAK,kBAAkB,OAASoB,EAAK,SAAS,UAAUA,EAAK,SAAS,cACxEyC,EAAK,EAAE,MAAM,eAAe,OAAO,IAAI,QAAQ,GAAG5H,CAAa,KAAK,GAIlEgC,EAAM,cAAc,IAAM;AAC5B,MAAAA,EAAM,SAAS;AAEf,iBAAW6B,KAAS7B,EAAM;AACxB,QAAAA,EAAM,UAAU6B,EAAM,UAAU,OAAOA,EAAM,SAASA,EAAM,OAExDA,EAAM,WACR7B,EAAM,UAAU6B,EAAM;AAAA,IAG9B;AAEE,WAAO7B;AAAA,EACR;AAQD,SAAAwE,EAAM,YAAY,CAAC5E,GAAOM,MAAY;AACpC,UAAM6B,IAAO,EAAE,GAAG7B,EAAS,GACrBuE,IAAM,OAAO1C,EAAK,aAAc,WAAW,KAAK,IAAIgC,GAAYhC,EAAK,SAAS,IAAIgC,GAClFW,IAAM9E,EAAM;AAClB,QAAI8E,IAAMD;AACR,YAAM,IAAI,YAAY,iBAAiBC,CAAG,qCAAqCD,CAAG,EAAE;AAGtF,IAAA7E,IAAQsE,EAAatE,CAAK,KAAKA;AAG/B,UAAM;AAAA,MACJ,aAAA/B;AAAA,MACA,eAAAG;AAAA,MACA,UAAAC;AAAA,MACA,YAAAI;AAAA,MACA,QAAAC;AAAA,MACA,SAAAC;AAAA,MACA,eAAAE;AAAA,MACA,MAAAE;AAAA,MACA,cAAAP;AAAA,IACD,IAAGW,EAAU,UAAUgD,EAAK,OAAO,GAE9BiD,IAAQjD,EAAK,MAAMxD,IAAUD,GAC7BmJ,IAAW1F,EAAK,MAAMtD,IAAgBH,GACtCsG,KAAU7C,EAAK,UAAU,KAAK,MAC9B/B,IAAQ,EAAE,SAAS,IAAO,QAAQ,GAAI;AAC5C,QAAIkF,IAAOnD,EAAK,SAAS,KAAO,QAAQpD;AAExC,IAAIoD,EAAK,YACPmD,IAAO,IAAIA,CAAI;AAGjB,UAAMH,IAAW,CAAAhD,MACXA,EAAK,eAAe,KAAamD,IAC9B,IAAIN,EAAO,SAASxG,CAAY,GAAG2D,EAAK,MAAM1D,IAAaR,CAAW,UAGzE6J,KAAS,CAAAjI,MAAO;AACpB,cAAQA,GAAG;AAAA,QACT,KAAK;AACH,iBAAO,GAAGuF,CAAK,GAAG/G,CAAQ,GAAGiH,CAAI;AAAA,QAEnC,KAAK;AACH,iBAAO,GAAGrH,CAAW,GAAGI,CAAQ,GAAGiH,CAAI;AAAA,QAEzC,KAAK;AACH,iBAAO,GAAGF,CAAK,GAAGE,CAAI,GAAGrH,CAAW,GAAGI,CAAQ,GAAGiH,CAAI;AAAA,QAExD,KAAK;AACH,iBAAO,GAAGF,CAAK,GAAGE,CAAI,GAAGlH,CAAa,GAAGC,CAAQ,GAAGwJ,CAAQ,GAAGvC,CAAI;AAAA,QAErE,KAAK;AACH,iBAAOF,IAAQD,EAAShD,CAAI;AAAA,QAE9B,KAAK;AACH,iBAAO,MAAMiD,CAAK,GAAGD,EAAShD,CAAI,CAAC,GAAG/D,CAAa,KAAKyJ,CAAQ,GAAGxJ,CAAQ,GAAGiH,CAAI;AAAA,QAEpF,KAAK;AACH,iBAAO,MAAMF,CAAK,GAAGD,EAAShD,CAAI,CAAC,GAAG/D,CAAa,KAAKyJ,CAAQ,GAAGvC,CAAI,GAAGrH,CAAW,GAAGI,CAAQ,GAAGiH,CAAI;AAAA,QAEzG,KAAK;AACH,iBAAO,MAAMF,CAAK,GAAGD,EAAShD,CAAI,CAAC,GAAG/D,CAAa,KAAKH,CAAW,GAAGI,CAAQ,GAAGiH,CAAI;AAAA,QAEvF,SAAS;AACP,gBAAMvF,KAAQ,iBAAiB,KAAKF,CAAG;AACvC,cAAI,CAACE,GAAO;AAEZ,gBAAMgI,IAASD,GAAO/H,GAAM,CAAC,CAAC;AAC9B,iBAAKgI,IAEEA,IAAS9J,IAAc8B,GAAM,CAAC,IAFxB;AAAA,QAGrB;AAAA,MACA;AAAA,IACG,GAEKM,KAASQ,EAAM,aAAab,GAAOI,CAAK;AAC9C,QAAI2H,IAASD,GAAOzH,EAAM;AAE1B,WAAI0H,KAAU5F,EAAK,kBAAkB,OACnC4F,KAAU,GAAG3J,CAAa,MAGrB2J;AAAA,EACR,GAEDC,KAAiBpD;;;;;;AC1jCjB,QAAMqD,IAAwBvI,gBAAAA,GAAA,GACxBkF,IAA0B/C,gBAAAA,GAAA,GAC1BhB,IAA0BqH,gBAAAA,GAAA,GAC1B/I,IAAkCgJ,gBAAAA,GAAA,GAClCC,IAAW,CAAAxI,MAAOA,KAAO,OAAOA,KAAQ,YAAY,CAAC,MAAM,QAAQA,CAAG,GAwBtEyI,IAAY,CAACvE,GAAMxD,GAASgI,IAAc,OAAU;AACxD,QAAI,MAAM,QAAQxE,CAAI,GAAG;AACvB,YAAMyE,IAAMzE,EAAK,IAAI,CAAA9D,MAASqI,EAAUrI,GAAOM,GAASgI,CAAW,CAAC;AAQpE,aAPqB,CAAAzI,MAAO;AAC1B,mBAAW2I,KAAWD,GAAK;AACzB,gBAAMnI,IAAQoI,EAAQ3I,CAAG;AACzB,cAAIO,EAAO,QAAOA;AAAA,QAC1B;AACM,eAAO;AAAA,MACR;AAAA,IAEL;AAEE,UAAMqI,IAAUL,EAAStE,CAAI,KAAKA,EAAK,UAAUA,EAAK;AAEtD,QAAIA,MAAS,MAAO,OAAOA,KAAS,YAAY,CAAC2E;AAC/C,YAAM,IAAI,UAAU,2CAA2C;AAGjE,UAAMtG,IAAO7B,KAAW,CAAE,GACpBsG,IAAQzE,EAAK,SACbuG,IAAQD,IACVJ,EAAU,UAAUvE,GAAMxD,CAAO,IACjC+H,EAAU,OAAOvE,GAAMxD,GAAS,IAAO,EAAI,GAEzCF,IAAQsI,EAAM;AACpB,WAAOA,EAAM;AAEb,QAAIC,IAAY,MAAM;AACtB,QAAIxG,EAAK,QAAQ;AACf,YAAMyG,IAAa,EAAE,GAAGtI,GAAS,QAAQ,MAAM,SAAS,MAAM,UAAU,KAAM;AAC9E,MAAAqI,IAAYN,EAAUlG,EAAK,QAAQyG,GAAYN,CAAW;AAAA,IAC9D;AAEE,UAAMO,IAAU,CAAC7I,GAAO8I,IAAe,OAAU;AAC/C,YAAM,EAAE,SAAAN,GAAS,OAAAzI,GAAO,QAAAM,EAAM,IAAKgI,EAAU,KAAKrI,GAAO0I,GAAOpI,GAAS,EAAE,MAAAwD,GAAM,OAAA8C,EAAK,CAAE,GAClFmC,IAAS,EAAE,MAAAjF,GAAM,OAAA1D,GAAO,OAAAsI,GAAO,OAAA9B,GAAO,OAAA5G,GAAO,QAAAK,GAAQ,OAAAN,GAAO,SAAAyI,EAAS;AAM3E,aAJI,OAAOrG,EAAK,YAAa,cAC3BA,EAAK,SAAS4G,CAAM,GAGlBP,MAAY,MACdO,EAAO,UAAU,IACVD,IAAeC,IAAS,MAG7BJ,EAAU3I,CAAK,KACb,OAAOmC,EAAK,YAAa,cAC3BA,EAAK,SAAS4G,CAAM,GAEtBA,EAAO,UAAU,IACVD,IAAeC,IAAS,OAG7B,OAAO5G,EAAK,WAAY,cAC1BA,EAAK,QAAQ4G,CAAM,GAEdD,IAAeC,IAAS;AAAA,IAChC;AAED,WAAIT,MACFO,EAAQ,QAAQzI,IAGXyI;AAAA,EACR;AAmBD,SAAAR,EAAU,OAAO,CAACrI,GAAO0I,GAAOpI,GAAS,EAAE,MAAAwD,GAAM,OAAA8C,EAAO,IAAG,OAAO;AAChE,QAAI,OAAO5G,KAAU;AACnB,YAAM,IAAI,UAAU,+BAA+B;AAGrD,QAAIA,MAAU;AACZ,aAAO,EAAE,SAAS,IAAO,QAAQ,GAAI;AAGvC,UAAMmC,IAAO7B,KAAW,CAAE,GACpB0I,IAAS7G,EAAK,WAAWyE,IAAQ/F,EAAM,iBAAiB;AAC9D,QAAId,IAAQC,MAAU8D,GAClBzD,IAAUN,KAASiJ,IAAUA,EAAOhJ,CAAK,IAAIA;AAEjD,WAAID,MAAU,OACZM,IAAS2I,IAASA,EAAOhJ,CAAK,IAAIA,GAClCD,IAAQM,MAAWyD,KAGjB/D,MAAU,MAASoC,EAAK,YAAY,QAClCA,EAAK,cAAc,MAAQA,EAAK,aAAa,KAC/CpC,IAAQsI,EAAU,UAAUrI,GAAO0I,GAAOpI,GAASsG,CAAK,IAExD7G,IAAQ2I,EAAM,KAAKrI,CAAM,IAItB,EAAE,SAAS,EAAQN,GAAQ,OAAAA,GAAO,QAAAM,EAAQ;AAAA,EAClD,GAgBDgI,EAAU,YAAY,CAACrI,GAAO8D,GAAMxD,OACpBwD,aAAgB,SAASA,IAAOuE,EAAU,OAAOvE,GAAMxD,CAAO,GAC/D,KAAKO,EAAM,SAASb,CAAK,CAAC,GAoBzCqI,EAAU,UAAU,CAACxI,GAAKoJ,GAAU3I,MAAY+H,EAAUY,GAAU3I,CAAO,EAAET,CAAG,GAgBhFwI,EAAU,QAAQ,CAACa,GAAS5I,MACtB,MAAM,QAAQ4I,CAAO,IAAUA,EAAQ,IAAI,CAAAC,MAAKd,EAAU,MAAMc,GAAG7I,CAAO,CAAC,IACxEsE,EAAMsE,GAAS,EAAE,GAAG5I,GAAS,WAAW,IAAO,GA8BxD+H,EAAU,OAAO,CAACrI,GAAOM,MAAY2H,EAAKjI,GAAOM,CAAO,GAcxD+H,EAAU,YAAY,CAACjI,GAAOE,GAAS8I,IAAe,IAAOd,IAAc,OAAU;AACnF,QAAIc,MAAiB;AACnB,aAAOhJ,EAAM;AAGf,UAAM+B,IAAO7B,KAAW,CAAE,GACpBC,IAAU4B,EAAK,WAAW,KAAK,KAC/B3B,IAAS2B,EAAK,WAAW,KAAK;AAEpC,QAAI4F,IAAS,GAAGxH,CAAO,MAAMH,EAAM,MAAM,IAAII,CAAM;AACnD,IAAIJ,KAASA,EAAM,YAAY,OAC7B2H,IAAS,OAAOA,CAAM;AAGxB,UAAMW,IAAQL,EAAU,QAAQN,GAAQzH,CAAO;AAC/C,WAAIgI,MAAgB,OAClBI,EAAM,QAAQtI,IAGTsI;AAAA,EACR,GAqBDL,EAAU,SAAS,CAACrI,GAAOM,IAAU,CAAE,GAAE8I,IAAe,IAAOd,IAAc,OAAU;AACrF,QAAI,CAACtI,KAAS,OAAOA,KAAU;AAC7B,YAAM,IAAI,UAAU,6BAA6B;AAGnD,QAAIqJ,IAAS,EAAE,SAAS,IAAO,WAAW,GAAM;AAEhD,WAAI/I,EAAQ,cAAc,OAAUN,EAAM,CAAC,MAAM,OAAOA,EAAM,CAAC,MAAM,SACnEqJ,EAAO,SAASzE,EAAM,UAAU5E,GAAOM,CAAO,IAG3C+I,EAAO,WACVA,IAASzE,EAAM5E,GAAOM,CAAO,IAGxB+H,EAAU,UAAUgB,GAAQ/I,GAAS8I,GAAcd,CAAW;AAAA,EACtE,GAmBDD,EAAU,UAAU,CAACN,GAAQzH,MAAY;AACvC,QAAI;AACF,YAAM6B,IAAO7B,KAAW,CAAE;AAC1B,aAAO,IAAI,OAAOyH,GAAQ5F,EAAK,UAAUA,EAAK,SAAS,MAAM,GAAG;AAAA,IACjE,SAAQmH,GAAK;AACZ,UAAIhJ,KAAWA,EAAQ,UAAU,GAAM,OAAMgJ;AAC7C,aAAO;AAAA,IACX;AAAA,EACC,GAODjB,EAAU,YAAYlJ,GAMtBoK,KAAiBlB;;;;;;AClVjB,QAAMmB,IAAiC9J,gBAAAA,GAAA,GACjCmB,IAA8BgB,gBAAAA,GAAA;AAEpC,WAASwG,EAAUvE,GAAMxD,GAASgI,IAAc,IAAO;AAErD,WAAIhI,MAAYA,EAAQ,YAAY,QAAQA,EAAQ,YAAY,YAE9DA,IAAU,EAAE,GAAGA,GAAS,SAASO,EAAM,UAAS,EAAI,IAG/C2I,EAAK1F,GAAMxD,GAASgI,CAAW;AAAA,EACxC;AAEA,gBAAO,OAAOD,GAAWmB,CAAI,GAC7BD,KAAiBlB;;;mCCEJoB,KAAwD,CAAC,EAAE,MAAAjF,KAAQ,EAAE,MAAAkF,QAAW;AACxF,MAAAA,EAAK,WAAW;AACZ,WAAA,IAAIC,GAAW,CAACC,MAAa;AACnC,MAAAA,EAAS,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,OAAO,EAAE,SAAS,wBAAwB;AAAA,MAAA,CAC1C,GACDA,EAAS,SAAS;AAAA,IAAA,CAClB;AAIF,QAAMtJ,IAAuC,CAAC;AAC9C,SAAIkE,EAAK,UAAU,WAAWlE,EAAQ,QAAQkE,EAAK,QAC/CA,EAAK,WAAW,WAAWlE,EAAQ,SAASkE,EAAK,SAE9CqF,GAAqBH,GAAMlF,EAAK,aAAalE,CAAO;AAC5D;AAEgB,SAAAuJ,GACfH,GACAR,GACA5I,GACmC;AAC5B,SAAAwJ;AAAA,IACN,GAAGJ,EAAK,IAAI,CAACK,MAAQC,GAA0BD,GAAKb,GAAS5I,CAAO,CAAC;AAAA,EAAA,EACpE;AAAA,IACD2J,GAAkD,CAACC,MAAY;AAC9D,YAAMC,IAAqB,CAAC;AAC5B,iBAAWpB,KAAUmB;AAChB,QAAAnB,EAAO,WAAW,gBACrBoB,EAAS,KAAK,GAAIpB,GAAQ,YAAY,CAAA,CAAG,IAC/BA,EAAO,WAAW,SACnBoB,EAAA,KAAK,GAAGpB,EAAO,MAAM,IACpBA,EAAO,WAAW,UAC5BoB,EAAS,KAAK,GAAIpB,EAAO,YAAY,CAAA,CAAG,IAC9BA,EAAO,WAAW,eAC5BoB,EAAS,KAAK,GAAIpB,EAAO,YAAY,CAAA,CAAG;AAG1C,YAAMqB,IAASF,EAAQ,OAAO,CAACnB,MAAWA,EAAO,WAAW,OAAO;AAC/D,aAAAqB,EAAO,SAAS,IACZ;AAAA,QACN,QAAQ;AAAA,QACR,UAAAD;AAAA,QACA,OAAO;AAAA,UACN,SAASC,EACP,IAAY,CAACC,MAAUA,GAAO,OAAO,WAAW,EAAE,EAClD,KAAK;AAAA,CAAI;AAAA,QAAA;AAAA,MAEb,IAOM;AAAA,QACN,QANcH,EAAQ,MAAM,CAACnB,MAAWA,EAAO,WAAW,MAAM,IAC9D,SACAmB,EAAQ,KAAK,CAACnB,MAAWA,EAAO,WAAW,WAAW,IACrD,cACA;AAAA,QAGH,UAAAoB;AAAA,QACA,QAAQA;AAAA,MACT;AAAA,IACA,CAAA;AAAA,EACF;AACD;AAEA,SAASH,GACRD,GACAb,GACA5I,GACmC;AACnC,SAAAgK,GAAkBP,CAAG,GACd,IAAIJ,GAAiC,CAACC,MAAa;AACzD,IAAAA,EAAS,KAAK;AAAA,MACb,QAAQ;AAAA,MACR,UAAU,CAAA;AAAA,IAAC,CACX,GAEDW,GAAaR,EAAI,QAAQb,IAAU,EAAE,SAAAA,GAAS,iBAAiB,OAAS,MAAM5I,KAAW,CAAA,CAAE,EACzF,KAAK,CAAC,EAAE,OAAAkK,GAAO,WAAA/E,QAAgB;AAC/B,MAAIA,IAAY,KACT+E,EAAA,KAAK,OAAO/E,CAAS,2BAA2B,GAEvDmE,EAAS,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,UAAUY;AAAA,QACV,QAAQA;AAAA,MAAA,CACR;AAAA,IAAA,CACD,EACA,MAAM,CAACH,MAAU;AACjB,YAAMI,IAAUJ,aAAiB,QAAQA,EAAM,UAAU,OAAOA,CAAK;AACrE,MAAAT,EAAS,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,UAAU,CAAC;AAAA,QACX,OAAO,EAAE,SAAAa,EAAQ;AAAA,MAAA,CACjB;AAAA,IACD,CAAA,EACA,QAAQ,MAAMb,EAAS,UAAU;AAAA,EAAA,CACnC;AACF;AAQA,MAAMc,KAAiB;AAEP,SAAAH,GACfR,GACAjG,GAIA6G,GACyB;AAMnB,QAAAC,IAAQD,EAAO,SAASD;AAE9B,EAAI5G,GAAM,WAAWA,EAAK,YAAY,QACrCA,EAAK,UAAU;AAOhB,QAAM+G,IAAqB/G,GAAM,UAC9BgH,GAAGhH,EAAK,SAAS,EAAE,QAAQA,EAAK,iBAAiB,KAAK,GAAA,CAAM,IAC5D,QAEGU,IAAO;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA;AAAA;AAAA;AAAA,IAIA;AAAA,IACA;AAAA,EACD;AAEI,EAAAmG,EAAO,aAAa,UACvBnG,EAAK,KAAK,eAAemG,EAAO,SAAS,UAAU,GAEhDA,EAAO,aAAa,UAClBnG,EAAA,KAAKmG,EAAO,QAAQ;AAQ1B,QAAMI,IAAOC,GAAMC,GAAkB,GAAGzG,GAAM;AAAA,IAC7C,KAAKuF;AAAA,IACL,OAAO,CAAC,UAAU,QAAQ,MAAM;AAAA,IAChC,UAAU,QAAQ,aAAa;AAAA,IAC/B,KAAK;AAAA,MACJ,GAAG,QAAQ;AAAA,MACX,gBAAgB;AAAA,MAChB,iBAAiB;AAAA,IAAA;AAAA,EAClB,CACA;AAED,SAAO,IAAI,QAAuB,CAACmB,GAASC,MAAW;AACtD,UAAMC,IAAkB,CAAC;AACzB,QAAIC,IAAS,IACTC,IAAO,IACPC,IAASZ,EAAO,UAAU,GAC1Ba,IAAa;AACjB,UAAMC,IAAW,MAAY;AAQ5B,UAPID,KAGA,CAACF,KAIDT,KAAsB,CAACA,EAAmBS,CAAI;AACjD;AAGD,YAAMI,IAASJ;AAGf,UAFOA,IAAA,IAEHC,IAAS,GAAG;AACf,QAAAA;AACA;AAAA,MAAA;AAGD,MAAAH,EAAM,KAAKM,CAAM,GACbN,EAAM,UAAUV,OACnBiB,GAAO,KAAK,kDAAkD;AAAA,QAC7D,MAAM7H,GAAM;AAAA,QACZ,OAAO4G;AAAA,QACP,KAAAX;AAAA,MAAA,CACA,GACDgB,EAAK,KAAK,GACGS,IAAA,IACLN,EAAA;AAAA,QACP,OAAOE;AAAA,QACP,WAAW;AAAA,QACX,SAAS;AAAA,MAAA,CACT;AAAA,IAEH;AAEA,IAAAL,EAAK,QAAQ,GAAG,QAAQ,CAACa,MAAS;AACtB,iBAAAC,KAAM,OAAOD,CAAI;AAC3B,QAAIC,MAAO,SAGPA,MAAO;AAAA,KACDJ,EAAA,GACFH,IAAA,MAECA,KAAAO;AAAA,IAEV,CACA,GAEDd,GAAM,QAAQ,GAAG,QAAQ,CAACa,MAAS;AAClC,MAAAP,KAAU,OAAOO,CAAI;AAAA,IAAA,CACrB,GAEIb,EAAA,GAAG,QAAQ,CAAChJ,MAAS;AAErB,UAAAA,KAAQA,KAAQ,GAAG;AACf,QAAAoJ,EAAA,IAAI,MAAM,4BAA4BpJ,CAAI;AAAA,EAAMsJ,CAAM,EAAE,CAAC;AAChE;AAAA,MAAA;AAIQ,MAAAI,EAAA;AAET,YAAMK,IAAqBV,EAAM,MAAM,GAAGR,CAAK;AACvC,MAAAM,EAAA;AAAA,QACP,OAAOY;AAAA,QACP,WAAWV,EAAM,SAASU,EAAmB;AAAA,MAAA,CAC7C;AAAA,IAAA,CACD;AAAA,EAAA,CACD;AACF;","x_google_ignoreList":[0,1,2,3,4,5]}