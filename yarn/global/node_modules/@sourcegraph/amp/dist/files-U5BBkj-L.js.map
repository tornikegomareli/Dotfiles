{"version":3,"file":"files-U5BBkj-L.js","sources":["../../core/src/threads/files.ts"],"sourcesContent":["import path from 'node:path'\nimport logger from '../common/logger'\nimport type { FileSystem } from '../platform/fs/fs'\nimport { getImageFileMetadata } from '../tools/builtin/filesystem/file-type'\nimport { checkFileSizeLimit } from '../tools/builtin/filesystem/read_file.util'\nimport type { FileMention } from './file-mentions'\nimport { FileMentions } from './file-mentions'\nimport { isSupportedImageMIMEType } from './image-attachments'\n\nexport async function getFileMentions(\n\tcontent: string,\n\tworkspaceRoot: string,\n\tfilesystem: Pick<FileSystem, 'stat' | 'readFile' | 'readBinaryFile' | 'listFiles'>,\n): Promise<FileMentions> {\n\tconst files = await filesystem.listFiles(workspaceRoot)\n\tconst fileContents = new Map<string, string>()\n\tconst imageFiles = new Map<string, { mimeType: string; size: number }>() // Track image files separately\n\tconst mentions: FileMention[] = []\n\n\t// Regex patterns for file paths\n\t// Match relative paths with extension within workspace\n\tconst relativePathRegex = /\\b([\\w/_-]+(?:\\\\.|[\\w/_-])*(?:\\.[\\w-]+)+)\\b/g\n\t// Match absolute paths with extension (Unix/Linux/Mac)\n\tconst unixAbsolutePathRegex =\n\t\t/(\\/(?:[\\w-]+\\/|[\\w-]+\\\\[.\\s\\S])+[\\w.-]+(?:\\\\.|[\\w.-])*(?:\\.[\\w-]+)+)\\b/g\n\t// Match absolute paths with extension (Windows) - using a more permissive approach\n\tconst windowsAbsolutePathRegex = /\\b([A-Za-z]:[\\\\\\\\][^\\s\"'<>|]*(?:\\.[\\w-]+)+)\\b/g\n\n\t// Process matches for each regex pattern\n\tawait processMatches(relativePathRegex, false)\n\tawait processMatches(unixAbsolutePathRegex, true)\n\n\tawait processMatches(windowsAbsolutePathRegex, true)\n\n\t// Process matches from a regex pattern\n\tasync function processMatches(regex: RegExp, isAbsolutePath: boolean) {\n\t\t// Reset regex before execution to ensure we don't miss any matches\n\t\tregex.lastIndex = 0\n\n\t\tlet match\n\t\twhile ((match = regex.exec(content)) !== null) {\n\t\t\tconst [word] = match\n\t\t\t// Unescape special characters in the path\n\t\t\t// Unescape characters in file paths\n\t\t\tlet unescapedWord\n\t\t\t// Check if this is a Windows path with drive letter\n\t\t\tconst isWindowsPath = word.match(/^[A-Za-z]:[\\\\]/) !== null\n\t\t\tif (isWindowsPath) {\n\t\t\t\t// For Windows paths, preserve the backslashes as path separators but handle escaped characters\n\t\t\t\tunescapedWord = word\n\t\t\t} else {\n\t\t\t\t// For other paths, unescape everything\n\t\t\t\tunescapedWord = word.replace(/\\\\(.)/g, '$1')\n\t\t\t}\n\n\t\t\tconst isCached = fileContents.has(unescapedWord) || imageFiles.has(unescapedWord)\n\n\t\t\t// Skip if we've already processed this file path\n\t\t\tif (isCached) {\n\t\t\t\taddMention(unescapedWord, match.index)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Determine file path\n\t\t\tconst filePath = isAbsolutePath\n\t\t\t\t? unescapedWord\n\t\t\t\t: path.join(workspaceRoot, unescapedWord)\n\n\t\t\t// For relative paths, check if file exists in the workspace\n\t\t\tif (!isAbsolutePath && !files.includes(unescapedWord)) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// For absolute paths, check if file exists on disk\n\t\t\tif (isAbsolutePath) {\n\t\t\t\ttry {\n\t\t\t\t\t// Just try to stat the file to see if it exists\n\t\t\t\t\tawait filesystem.stat(filePath)\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// File doesn't exist or can't be accessed\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Process the file\n\t\t\ttry {\n\t\t\t\t// Check if this is an image file\n\t\t\t\tconst imageInfo = await getImageFileMetadata(filesystem, filePath)\n\n\t\t\t\tif (imageInfo && isSupportedImageMIMEType(imageInfo.mimeType)) {\n\t\t\t\t\t// This is an image file, treat it as an attachment\n\t\t\t\t\timageFiles.set(unescapedWord, imageInfo)\n\t\t\t\t\t// Read the image file as binary and convert to base64\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst imageBuffer = await filesystem.readBinaryFile(filePath)\n\t\t\t\t\t\tconst base64Data = imageBuffer.toString('base64')\n\t\t\t\t\t\t// Store the base64 data\n\t\t\t\t\t\tfileContents.set(unescapedWord, base64Data)\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t'Failed to read image as binary',\n\t\t\t\t\t\t\t{ path: unescapedWord },\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t// Set a placeholder in case of error\n\t\t\t\t\t\tfileContents.set(\n\t\t\t\t\t\t\tunescapedWord,\n\t\t\t\t\t\t\t`[Image file: ${unescapedWord} (${imageInfo.mimeType}, ${Math.round(imageInfo.size / 1024)} KB)]`,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\taddMention(unescapedWord, match.index)\n\t\t\t\t} else {\n\t\t\t\t\t// Not an image file, handle normally\n\t\t\t\t\tconst isTooLarge = await checkFileSizeLimit(filesystem, filePath)\n\t\t\t\t\tif (isTooLarge) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tconst data = await filesystem.readFile(filePath)\n\t\t\t\t\tfileContents.set(unescapedWord, data)\n\t\t\t\t\taddMention(unescapedWord, match.index)\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Skip file if there's any error reading it\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\t// Helper function to add a mention\n\tfunction addMention(path: string, startIndex: number) {\n\t\tmentions.push({\n\t\t\tpath,\n\t\t\trange: {\n\t\t\t\tstart: startIndex,\n\t\t\t\tend: startIndex + path.length - 1,\n\t\t\t},\n\t\t})\n\t}\n\n\t// Create a FileMentions instance with both text and image file contents\n\tconst fileMentions = new FileMentions(fileContents, mentions)\n\n\t// Add image file metadata to the FileMentions instance\n\tfileMentions.imageFiles = imageFiles\n\n\treturn fileMentions\n}\n"],"names":["getFileMentions","content","workspaceRoot","filesystem","files","fileContents","imageFiles","mentions","relativePathRegex","unixAbsolutePathRegex","windowsAbsolutePathRegex","processMatches","regex","isAbsolutePath","match","word","unescapedWord","addMention","filePath","path","imageInfo","getImageFileMetadata","isSupportedImageMIMEType","base64Data","error","logger","checkFileSizeLimit","data","startIndex","fileMentions","FileMentions"],"mappings":";;;AASsB,eAAAA,EACrBC,GACAC,GACAC,GACwB;AACxB,QAAMC,IAAQ,MAAMD,EAAW,UAAUD,CAAa,GAChDG,wBAAmB,IAAoB,GACvCC,wBAAiB,IAAgD,GACjEC,IAA0B,CAAC,GAI3BC,IAAoB,gDAEpBC,IACL,2EAEKC,IAA2B;AAG3B,QAAAC,EAAeH,GAAmB,EAAK,GACvC,MAAAG,EAAeF,GAAuB,EAAI,GAE1C,MAAAE,EAAeD,GAA0B,EAAI;AAGpC,iBAAAC,EAAeC,GAAeC,GAAyB;AAErE,IAAAD,EAAM,YAAY;AAEd,QAAAE;AACJ,YAAQA,IAAQF,EAAM,KAAKX,CAAO,OAAO,QAAM;AACxC,YAAA,CAACc,CAAI,IAAID;AAGX,UAAAE;AAcJ,UAZsBD,EAAK,MAAM,gBAAgB,MAAM,OAGtCC,IAAAD,IAGAC,IAAAD,EAAK,QAAQ,UAAU,IAAI,GAG3BV,EAAa,IAAIW,CAAa,KAAKV,EAAW,IAAIU,CAAa,GAGlE;AACF,QAAAC,EAAAD,GAAeF,EAAM,KAAK;AACrC;AAAA,MAAA;AAID,YAAMI,IAAWL,IACdG,IACAG,EAAK,KAAKjB,GAAec,CAAa;AAGzC,UAAI,GAACH,KAAkB,CAACT,EAAM,SAASY,CAAa,IAKpD;AAAA,YAAIH;AACC,cAAA;AAEG,kBAAAV,EAAW,KAAKe,CAAQ;AAAA,kBACjB;AAEb;AAAA,UAAA;AAKE,YAAA;AAEH,gBAAME,IAAY,MAAMC,EAAqBlB,GAAYe,CAAQ;AAEjE,cAAIE,KAAaE,EAAyBF,EAAU,QAAQ,GAAG;AAEnD,YAAAd,EAAA,IAAIU,GAAeI,CAAS;AAEnC,gBAAA;AAEG,oBAAAG,KADc,MAAMpB,EAAW,eAAee,CAAQ,GAC7B,SAAS,QAAQ;AAEnC,cAAAb,EAAA,IAAIW,GAAeO,CAAU;AAAA,qBAClCC,GAAO;AACR,cAAAC,EAAA;AAAA,gBACN;AAAA,gBACA,EAAE,MAAMT,EAAc;AAAA,gBACtBQ;AAAA,cACD,GAEanB,EAAA;AAAA,gBACZW;AAAA,gBACA,gBAAgBA,CAAa,KAAKI,EAAU,QAAQ,KAAK,KAAK,MAAMA,EAAU,OAAO,IAAI,CAAC;AAAA,cAC3F;AAAA,YAAA;AAEU,YAAAH,EAAAD,GAAeF,EAAM,KAAK;AAAA,UAAA,OAC/B;AAGN,gBADmB,MAAMY,EAAmBvB,GAAYe,CAAQ;AAE/D;AAGD,kBAAMS,IAAO,MAAMxB,EAAW,SAASe,CAAQ;AAClC,YAAAb,EAAA,IAAIW,GAAeW,CAAI,GACzBV,EAAAD,GAAeF,EAAM,KAAK;AAAA,UAAA;AAAA,gBAEvB;AAEf;AAAA,QAAA;AAAA;AAAA,IACD;AAAA,EACD;AAIQ,WAAAG,EAAWE,GAAcS,GAAoB;AACrD,IAAArB,EAAS,KAAK;AAAA,MACb,MAAAY;AAAAA,MACA,OAAO;AAAA,QACN,OAAOS;AAAA,QACP,KAAKA,IAAaT,EAAK,SAAS;AAAA,MAAA;AAAA,IACjC,CACA;AAAA,EAAA;AAIF,QAAMU,IAAe,IAAIC,EAAazB,GAAcE,CAAQ;AAG5D,SAAAsB,EAAa,aAAavB,GAEnBuB;AACR;"}