#!/usr/bin/env node
import { execFile as m } from "node:child_process";
import * as i from "node:fs";
import * as o from "node:path";
import { join as f } from "node:path";
import { promisify as p } from "node:util";
import { k as l, aP as n } from "./color-Bf2jGwiV.js";
import { homedir as w } from "node:os";
const d = f(w(), ".amp", "file-changes"), u = p(m);
function E(a) {
  const s = o.join(d, a);
  return {
    relativePath: (r, t) => o.relative(r, t),
    joinPath: (...r) => o.join(...r),
    readFile: async (r, t) => {
      try {
        return await i.promises.readFile(r, { encoding: "utf8", signal: t });
      } catch (e) {
        throw c(e) ? new n(r) : e;
      }
    },
    readBinaryFile: async (r, t) => {
      try {
        return await i.promises.readFile(r, { signal: t });
      } catch (e) {
        throw c(e) ? new n(r) : e;
      }
    },
    getMtime: async (r, t) => {
      try {
        return (await i.promises.stat(r)).mtimeMs;
      } catch (e) {
        throw c(e) ? new n(r) : e;
      }
    },
    stat: async (r) => {
      try {
        return {
          size: (await i.promises.stat(r)).size
        };
      } catch (t) {
        throw c(t) ? new n(r) : t;
      }
    },
    writeFile: async (r, t, e) => {
      await i.promises.writeFile(r, t, { encoding: "utf-8", signal: e });
    },
    deleteFile: async (r, t) => {
      try {
        await i.promises.unlink(r);
      } catch (e) {
        throw c(e) ? new n(r) : e;
      }
    },
    mkdirp: async (r) => {
      await i.promises.mkdir(r, { recursive: !0 });
    },
    storeFileChange: async (r, t) => {
      const e = o.join(s, r);
      await i.promises.writeFile(e, JSON.stringify(t, null, 2), "utf8");
    },
    listBackupFiles: async () => {
      try {
        return await i.promises.stat(s).then((r) => r.isDirectory()).catch(() => !1) ? await i.promises.readdir(s) : (await i.promises.mkdir(s, { recursive: !0 }), []);
      } catch (r) {
        return l.error("Error listing backup files:", r), [];
      }
    },
    loadFileChange: async (r) => {
      try {
        const t = o.join(s, r), e = await i.promises.readFile(t, "utf8");
        return JSON.parse(e);
      } catch (t) {
        return l.error(`Error loading backup file ${r}:`, t), null;
      }
    },
    cleanupBackupFiles: async () => {
      try {
        await i.promises.stat(s).then((r) => r.isDirectory()).catch(() => !1) && (await i.promises.rm(s, { recursive: !0, force: !0 }), l.debug(`Cleaned up backup directory: ${s}`));
      } catch (r) {
        l.error(`Error cleaning up backup files in ${s}:`, r);
      }
    },
    listFiles: async (r) => y(r),
    exclusiveWriter: !1
  };
}
function c(a) {
  return a !== null && typeof a == "object" && "code" in a && a.code === "ENOENT";
}
async function y(a) {
  try {
    const { stdout: s } = await u("git", ["ls-files"], {
      cwd: a
    }), { stdout: r } = await u(
      "git",
      ["ls-files", "--others", "--exclude-standard"],
      {
        cwd: a
      }
    );
    return [...s.split(`
`), ...r.split(`
`)].filter(Boolean);
  } catch {
    return [];
  }
}
export {
  y as listFilesGit,
  E as nodeFileSystem
};
//# sourceMappingURL=node-7PIWGuuc.js.map
