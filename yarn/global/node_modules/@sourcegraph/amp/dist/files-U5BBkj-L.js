#!/usr/bin/env node
import y from "node:path";
import { b6 as I, b7 as T, k as z, b8 as B, b9 as P } from "./color-Bf2jGwiV.js";
async function L(p, h, t) {
  const b = await t.listFiles(h), i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), f = [], M = /\b([\w/_-]+(?:\\.|[\w/_-])*(?:\.[\w-]+)+)\b/g, F = /(\/(?:[\w-]+\/|[\w-]+\\[.\s\S])+[\w.-]+(?:\\.|[\w.-])*(?:\.[\w-]+)+)\b/g, x = /\b([A-Za-z]:[\\\\][^\s"'<>|]*(?:\.[\w-]+)+)\b/g;
  await l(M, !1), await l(F, !0), await l(x, !0);
  async function l(s, n) {
    s.lastIndex = 0;
    let o;
    for (; (o = s.exec(p)) !== null; ) {
      const [d] = o;
      let e;
      if (d.match(/^[A-Za-z]:[\\]/) !== null ? e = d : e = d.replace(/\\(.)/g, "$1"), i.has(e) || r.has(e)) {
        w(e, o.index);
        continue;
      }
      const c = n ? e : y.join(h, e);
      if (!(!n && !b.includes(e))) {
        if (n)
          try {
            await t.stat(c);
          } catch {
            continue;
          }
        try {
          const a = await I(t, c);
          if (a && T(a.mimeType)) {
            r.set(e, a);
            try {
              const u = (await t.readBinaryFile(c)).toString("base64");
              i.set(e, u);
            } catch (g) {
              z.error(
                "Failed to read image as binary",
                { path: e },
                g
              ), i.set(
                e,
                `[Image file: ${e} (${a.mimeType}, ${Math.round(a.size / 1024)} KB)]`
              );
            }
            w(e, o.index);
          } else {
            if (await B(t, c))
              continue;
            const u = await t.readFile(c);
            i.set(e, u), w(e, o.index);
          }
        } catch {
          continue;
        }
      }
    }
  }
  function w(s, n) {
    f.push({
      path: s,
      range: {
        start: n,
        end: n + s.length - 1
      }
    });
  }
  const m = new P(i, f);
  return m.imageFiles = r, m;
}
export {
  L as getFileMentions
};
//# sourceMappingURL=files-U5BBkj-L.js.map
