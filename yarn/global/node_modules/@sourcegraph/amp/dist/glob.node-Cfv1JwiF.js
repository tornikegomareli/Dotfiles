#!/usr/bin/env node
import { spawn as yt } from "node:child_process";
import { at as Ht, O as $t, g as mt, m as Lt, aV as Tt, k as vt } from "./color-Bf2jGwiV.js";
import { r as Ot } from "./executable-Cf6tmsfm.js";
var pt = {}, ft, Et;
function it() {
  if (Et) return ft;
  Et = 1;
  const p = "\\\\/", A = `[^${p}]`, R = "\\.", d = "\\+", g = "\\?", o = "\\/", u = "(?=.)", a = "[^/]", f = `(?:${o}|$)`, x = `(?:^|${o})`, c = `${R}{1,2}${f}`, E = `(?!${R})`, r = `(?!${x}${c})`, $ = `(?!${R}{0,1}${f})`, m = `(?!${c})`, y = `[^.${o}]`, S = `${a}*?`, F = {
    DOT_LITERAL: R,
    PLUS_LITERAL: d,
    QMARK_LITERAL: g,
    SLASH_LITERAL: o,
    ONE_CHAR: u,
    QMARK: a,
    END_ANCHOR: f,
    DOTS_SLASH: c,
    NO_DOT: E,
    NO_DOTS: r,
    NO_DOT_SLASH: $,
    NO_DOTS_SLASH: m,
    QMARK_NO_DOT: y,
    STAR: S,
    START_ANCHOR: x,
    SEP: "/"
  }, T = {
    ...F,
    SLASH_LITERAL: `[${p}]`,
    QMARK: A,
    STAR: `${A}*?`,
    DOTS_SLASH: `${R}{1,2}(?:[${p}]|$)`,
    NO_DOT: `(?!${R})`,
    NO_DOTS: `(?!(?:^|[${p}])${R}{1,2}(?:[${p}]|$))`,
    NO_DOT_SLASH: `(?!${R}{0,1}(?:[${p}]|$))`,
    NO_DOTS_SLASH: `(?!${R}{1,2}(?:[${p}]|$))`,
    QMARK_NO_DOT: `[^.${p}]`,
    START_ANCHOR: `(?:^|[${p}])`,
    END_ANCHOR: `(?:[${p}]|$)`,
    SEP: "\\"
  }, G = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  return ft = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: G,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(b) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${b.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(b) {
      return b === !0 ? T : F;
    }
  }, ft;
}
var dt;
function ct() {
  return dt || (dt = 1, function(p) {
    const {
      REGEX_BACKSLASH: A,
      REGEX_REMOVE_BACKSLASH: R,
      REGEX_SPECIAL_CHARS: d,
      REGEX_SPECIAL_CHARS_GLOBAL: g
    } = /* @__PURE__ */ it();
    p.isObject = (o) => o !== null && typeof o == "object" && !Array.isArray(o), p.hasRegexChars = (o) => d.test(o), p.isRegexChar = (o) => o.length === 1 && p.hasRegexChars(o), p.escapeRegex = (o) => o.replace(g, "\\$1"), p.toPosixSlashes = (o) => o.replace(A, "/"), p.isWindows = () => {
      if (typeof navigator < "u" && navigator.platform) {
        const o = navigator.platform.toLowerCase();
        return o === "win32" || o === "windows";
      }
      return typeof process < "u" && process.platform ? process.platform === "win32" : !1;
    }, p.removeBackslashes = (o) => o.replace(R, (u) => u === "\\" ? "" : u), p.escapeLast = (o, u, a) => {
      const f = o.lastIndexOf(u, a);
      return f === -1 ? o : o[f - 1] === "\\" ? p.escapeLast(o, u, f - 1) : `${o.slice(0, f)}\\${o.slice(f)}`;
    }, p.removePrefix = (o, u = {}) => {
      let a = o;
      return a.startsWith("./") && (a = a.slice(2), u.prefix = "./"), a;
    }, p.wrapOutput = (o, u = {}, a = {}) => {
      const f = a.contains ? "" : "^", x = a.contains ? "" : "$";
      let c = `${f}(?:${o})${x}`;
      return u.negated === !0 && (c = `(?:^(?!${c}).*$)`), c;
    }, p.basename = (o, { windows: u } = {}) => {
      const a = o.split(u ? /[\\/]/ : "/"), f = a[a.length - 1];
      return f === "" ? a[a.length - 2] : f;
    };
  }(pt)), pt;
}
var ht, St;
function wt() {
  if (St) return ht;
  St = 1;
  const p = /* @__PURE__ */ ct(), {
    CHAR_ASTERISK: A,
    /* * */
    CHAR_AT: R,
    /* @ */
    CHAR_BACKWARD_SLASH: d,
    /* \ */
    CHAR_COMMA: g,
    /* , */
    CHAR_DOT: o,
    /* . */
    CHAR_EXCLAMATION_MARK: u,
    /* ! */
    CHAR_FORWARD_SLASH: a,
    /* / */
    CHAR_LEFT_CURLY_BRACE: f,
    /* { */
    CHAR_LEFT_PARENTHESES: x,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: c,
    /* [ */
    CHAR_PLUS: E,
    /* + */
    CHAR_QUESTION_MARK: r,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE: $,
    /* } */
    CHAR_RIGHT_PARENTHESES: m,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: y
    /* ] */
  } = /* @__PURE__ */ it(), S = (T) => T === a || T === d, I = (T) => {
    T.isPrefix !== !0 && (T.depth = T.isGlobstar ? 1 / 0 : 1);
  };
  return ht = (T, G) => {
    const b = G || {}, Y = T.length - 1, B = b.parts === !0 || b.scanToEnd === !0, W = [], w = [], st = [];
    let M = T, H = -1, N = 0, tt = 0, rt = !1, j = !1, v = !1, et = !1, X = !1, s = !1, k = !1, z = !1, ut = !1, t = !1, e = 0, nt, l, C = { value: "", depth: 0, isGlob: !1 };
    const Z = () => H >= Y, J = () => M.charCodeAt(H + 1), U = () => (nt = l, M.charCodeAt(++H));
    for (; H < Y; ) {
      l = U();
      let q;
      if (l === d) {
        k = C.backslashes = !0, l = U(), l === f && (s = !0);
        continue;
      }
      if (s === !0 || l === f) {
        for (e++; Z() !== !0 && (l = U()); ) {
          if (l === d) {
            k = C.backslashes = !0, U();
            continue;
          }
          if (l === f) {
            e++;
            continue;
          }
          if (s !== !0 && l === o && (l = U()) === o) {
            if (rt = C.isBrace = !0, v = C.isGlob = !0, t = !0, B === !0)
              continue;
            break;
          }
          if (s !== !0 && l === g) {
            if (rt = C.isBrace = !0, v = C.isGlob = !0, t = !0, B === !0)
              continue;
            break;
          }
          if (l === $ && (e--, e === 0)) {
            s = !1, rt = C.isBrace = !0, t = !0;
            break;
          }
        }
        if (B === !0)
          continue;
        break;
      }
      if (l === a) {
        if (W.push(H), w.push(C), C = { value: "", depth: 0, isGlob: !1 }, t === !0) continue;
        if (nt === o && H === N + 1) {
          N += 2;
          continue;
        }
        tt = H + 1;
        continue;
      }
      if (b.noext !== !0 && (l === E || l === R || l === A || l === r || l === u) === !0 && J() === x) {
        if (v = C.isGlob = !0, et = C.isExtglob = !0, t = !0, l === u && H === N && (ut = !0), B === !0) {
          for (; Z() !== !0 && (l = U()); ) {
            if (l === d) {
              k = C.backslashes = !0, l = U();
              continue;
            }
            if (l === m) {
              v = C.isGlob = !0, t = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (l === A) {
        if (nt === A && (X = C.isGlobstar = !0), v = C.isGlob = !0, t = !0, B === !0)
          continue;
        break;
      }
      if (l === r) {
        if (v = C.isGlob = !0, t = !0, B === !0)
          continue;
        break;
      }
      if (l === c) {
        for (; Z() !== !0 && (q = U()); ) {
          if (q === d) {
            k = C.backslashes = !0, U();
            continue;
          }
          if (q === y) {
            j = C.isBracket = !0, v = C.isGlob = !0, t = !0;
            break;
          }
        }
        if (B === !0)
          continue;
        break;
      }
      if (b.nonegate !== !0 && l === u && H === N) {
        z = C.negated = !0, N++;
        continue;
      }
      if (b.noparen !== !0 && l === x) {
        if (v = C.isGlob = !0, B === !0) {
          for (; Z() !== !0 && (l = U()); ) {
            if (l === x) {
              k = C.backslashes = !0, l = U();
              continue;
            }
            if (l === m) {
              t = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (v === !0) {
        if (t = !0, B === !0)
          continue;
        break;
      }
    }
    b.noext === !0 && (et = !1, v = !1);
    let D = M, ot = "", V = "";
    N > 0 && (ot = M.slice(0, N), M = M.slice(N), tt -= N), D && v === !0 && tt > 0 ? (D = M.slice(0, tt), V = M.slice(tt)) : v === !0 ? (D = "", V = M) : D = M, D && D !== "" && D !== "/" && D !== M && S(D.charCodeAt(D.length - 1)) && (D = D.slice(0, -1)), b.unescape === !0 && (V && (V = p.removeBackslashes(V)), D && k === !0 && (D = p.removeBackslashes(D)));
    const h = {
      prefix: ot,
      input: T,
      start: N,
      base: D,
      glob: V,
      isBrace: rt,
      isBracket: j,
      isGlob: v,
      isExtglob: et,
      isGlobstar: X,
      negated: z,
      negatedExtglob: ut
    };
    if (b.tokens === !0 && (h.maxDepth = 0, S(l) || w.push(C), h.tokens = w), b.parts === !0 || b.tokens === !0) {
      let q;
      for (let K = 0; K < W.length; K++) {
        const i = q ? q + 1 : N, L = W[K], n = T.slice(i, L);
        b.tokens && (K === 0 && N !== 0 ? (w[K].isPrefix = !0, w[K].value = ot) : w[K].value = n, I(w[K]), h.maxDepth += w[K].depth), (K !== 0 || n !== "") && st.push(n), q = L;
      }
      if (q && q + 1 < T.length) {
        const K = T.slice(q + 1);
        st.push(K), b.tokens && (w[w.length - 1].value = K, I(w[w.length - 1]), h.maxDepth += w[w.length - 1].depth);
      }
      h.slashes = W, h.parts = st;
    }
    return h;
  }, ht;
}
var At, Ct;
function Nt() {
  if (Ct) return At;
  Ct = 1;
  const p = /* @__PURE__ */ it(), A = /* @__PURE__ */ ct(), {
    MAX_LENGTH: R,
    POSIX_REGEX_SOURCE: d,
    REGEX_NON_SPECIAL_CHARS: g,
    REGEX_SPECIAL_CHARS_BACKREF: o,
    REPLACEMENTS: u
  } = p, a = (c, E) => {
    if (typeof E.expandRange == "function")
      return E.expandRange(...c, E);
    c.sort();
    const r = `[${c.join("-")}]`;
    try {
      new RegExp(r);
    } catch {
      return c.map((m) => A.escapeRegex(m)).join("..");
    }
    return r;
  }, f = (c, E) => `Missing ${c}: "${E}" - use "\\\\${E}" to match literal characters`, x = (c, E) => {
    if (typeof c != "string")
      throw new TypeError("Expected a string");
    c = u[c] || c;
    const r = { ...E }, $ = typeof r.maxLength == "number" ? Math.min(R, r.maxLength) : R;
    let m = c.length;
    if (m > $)
      throw new SyntaxError(`Input length: ${m}, exceeds maximum allowed length: ${$}`);
    const y = { type: "bos", value: "", output: r.prepend || "" }, S = [y], I = r.capture ? "" : "?:", F = p.globChars(r.windows), T = p.extglobChars(F), {
      DOT_LITERAL: G,
      PLUS_LITERAL: b,
      SLASH_LITERAL: Y,
      ONE_CHAR: B,
      DOTS_SLASH: W,
      NO_DOT: w,
      NO_DOT_SLASH: st,
      NO_DOTS_SLASH: M,
      QMARK: H,
      QMARK_NO_DOT: N,
      STAR: tt,
      START_ANCHOR: rt
    } = F, j = (i) => `(${I}(?:(?!${rt}${i.dot ? W : G}).)*?)`, v = r.dot ? "" : w, et = r.dot ? H : N;
    let X = r.bash === !0 ? j(r) : tt;
    r.capture && (X = `(${X})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
    const s = {
      input: c,
      index: -1,
      start: 0,
      dot: r.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens: S
    };
    c = A.removePrefix(c, s), m = c.length;
    const k = [], z = [], ut = [];
    let t = y, e;
    const nt = () => s.index === m - 1, l = s.peek = (i = 1) => c[s.index + i], C = s.advance = () => c[++s.index] || "", Z = () => c.slice(s.index + 1), J = (i = "", L = 0) => {
      s.consumed += i, s.index += L;
    }, U = (i) => {
      s.output += i.output != null ? i.output : i.value, J(i.value);
    }, D = () => {
      let i = 1;
      for (; l() === "!" && (l(2) !== "(" || l(3) === "?"); )
        C(), s.start++, i++;
      return i % 2 === 0 ? !1 : (s.negated = !0, s.start++, !0);
    }, ot = (i) => {
      s[i]++, ut.push(i);
    }, V = (i) => {
      s[i]--, ut.pop();
    }, h = (i) => {
      if (t.type === "globstar") {
        const L = s.braces > 0 && (i.type === "comma" || i.type === "brace"), n = i.extglob === !0 || k.length && (i.type === "pipe" || i.type === "paren");
        i.type !== "slash" && i.type !== "paren" && !L && !n && (s.output = s.output.slice(0, -t.output.length), t.type = "star", t.value = "*", t.output = X, s.output += t.output);
      }
      if (k.length && i.type !== "paren" && (k[k.length - 1].inner += i.value), (i.value || i.output) && U(i), t && t.type === "text" && i.type === "text") {
        t.output = (t.output || t.value) + i.value, t.value += i.value;
        return;
      }
      i.prev = t, S.push(i), t = i;
    }, q = (i, L) => {
      const n = { ...T[L], conditions: 1, inner: "" };
      n.prev = t, n.parens = s.parens, n.output = s.output;
      const _ = (r.capture ? "(" : "") + n.open;
      ot("parens"), h({ type: i, value: L, output: s.output ? "" : B }), h({ type: "paren", extglob: !0, value: C(), output: _ }), k.push(n);
    }, K = (i) => {
      let L = i.close + (r.capture ? ")" : ""), n;
      if (i.type === "negate") {
        let _ = X;
        if (i.inner && i.inner.length > 1 && i.inner.includes("/") && (_ = j(r)), (_ !== X || nt() || /^\)+$/.test(Z())) && (L = i.close = `)$))${_}`), i.inner.includes("*") && (n = Z()) && /^\.[^\\/.]+$/.test(n)) {
          const O = x(n, { ...E, fastpaths: !1 }).output;
          L = i.close = `)${O})${_})`;
        }
        i.prev.type === "bos" && (s.negatedExtglob = !0);
      }
      h({ type: "paren", extglob: !0, value: e, output: L }), V("parens");
    };
    if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(c)) {
      let i = !1, L = c.replace(o, (n, _, O, Q, P, lt) => Q === "\\" ? (i = !0, n) : Q === "?" ? _ ? _ + Q + (P ? H.repeat(P.length) : "") : lt === 0 ? et + (P ? H.repeat(P.length) : "") : H.repeat(O.length) : Q === "." ? G.repeat(O.length) : Q === "*" ? _ ? _ + Q + (P ? X : "") : X : _ ? n : `\\${n}`);
      return i === !0 && (r.unescape === !0 ? L = L.replace(/\\/g, "") : L = L.replace(/\\+/g, (n) => n.length % 2 === 0 ? "\\\\" : n ? "\\" : "")), L === c && r.contains === !0 ? (s.output = c, s) : (s.output = A.wrapOutput(L, s, E), s);
    }
    for (; !nt(); ) {
      if (e = C(), e === "\0")
        continue;
      if (e === "\\") {
        const n = l();
        if (n === "/" && r.bash !== !0 || n === "." || n === ";")
          continue;
        if (!n) {
          e += "\\", h({ type: "text", value: e });
          continue;
        }
        const _ = /^\\+/.exec(Z());
        let O = 0;
        if (_ && _[0].length > 2 && (O = _[0].length, s.index += O, O % 2 !== 0 && (e += "\\")), r.unescape === !0 ? e = C() : e += C(), s.brackets === 0) {
          h({ type: "text", value: e });
          continue;
        }
      }
      if (s.brackets > 0 && (e !== "]" || t.value === "[" || t.value === "[^")) {
        if (r.posix !== !1 && e === ":") {
          const n = t.value.slice(1);
          if (n.includes("[") && (t.posix = !0, n.includes(":"))) {
            const _ = t.value.lastIndexOf("["), O = t.value.slice(0, _), Q = t.value.slice(_ + 2), P = d[Q];
            if (P) {
              t.value = O + P, s.backtrack = !0, C(), !y.output && S.indexOf(t) === 1 && (y.output = B);
              continue;
            }
          }
        }
        (e === "[" && l() !== ":" || e === "-" && l() === "]") && (e = `\\${e}`), e === "]" && (t.value === "[" || t.value === "[^") && (e = `\\${e}`), r.posix === !0 && e === "!" && t.value === "[" && (e = "^"), t.value += e, U({ value: e });
        continue;
      }
      if (s.quotes === 1 && e !== '"') {
        e = A.escapeRegex(e), t.value += e, U({ value: e });
        continue;
      }
      if (e === '"') {
        s.quotes = s.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && h({ type: "text", value: e });
        continue;
      }
      if (e === "(") {
        ot("parens"), h({ type: "paren", value: e });
        continue;
      }
      if (e === ")") {
        if (s.parens === 0 && r.strictBrackets === !0)
          throw new SyntaxError(f("opening", "("));
        const n = k[k.length - 1];
        if (n && s.parens === n.parens + 1) {
          K(k.pop());
          continue;
        }
        h({ type: "paren", value: e, output: s.parens ? ")" : "\\)" }), V("parens");
        continue;
      }
      if (e === "[") {
        if (r.nobracket === !0 || !Z().includes("]")) {
          if (r.nobracket !== !0 && r.strictBrackets === !0)
            throw new SyntaxError(f("closing", "]"));
          e = `\\${e}`;
        } else
          ot("brackets");
        h({ type: "bracket", value: e });
        continue;
      }
      if (e === "]") {
        if (r.nobracket === !0 || t && t.type === "bracket" && t.value.length === 1) {
          h({ type: "text", value: e, output: `\\${e}` });
          continue;
        }
        if (s.brackets === 0) {
          if (r.strictBrackets === !0)
            throw new SyntaxError(f("opening", "["));
          h({ type: "text", value: e, output: `\\${e}` });
          continue;
        }
        V("brackets");
        const n = t.value.slice(1);
        if (t.posix !== !0 && n[0] === "^" && !n.includes("/") && (e = `/${e}`), t.value += e, U({ value: e }), r.literalBrackets === !1 || A.hasRegexChars(n))
          continue;
        const _ = A.escapeRegex(t.value);
        if (s.output = s.output.slice(0, -t.value.length), r.literalBrackets === !0) {
          s.output += _, t.value = _;
          continue;
        }
        t.value = `(${I}${_}|${t.value})`, s.output += t.value;
        continue;
      }
      if (e === "{" && r.nobrace !== !0) {
        ot("braces");
        const n = {
          type: "brace",
          value: e,
          output: "(",
          outputIndex: s.output.length,
          tokensIndex: s.tokens.length
        };
        z.push(n), h(n);
        continue;
      }
      if (e === "}") {
        const n = z[z.length - 1];
        if (r.nobrace === !0 || !n) {
          h({ type: "text", value: e, output: e });
          continue;
        }
        let _ = ")";
        if (n.dots === !0) {
          const O = S.slice(), Q = [];
          for (let P = O.length - 1; P >= 0 && (S.pop(), O[P].type !== "brace"); P--)
            O[P].type !== "dots" && Q.unshift(O[P].value);
          _ = a(Q, r), s.backtrack = !0;
        }
        if (n.comma !== !0 && n.dots !== !0) {
          const O = s.output.slice(0, n.outputIndex), Q = s.tokens.slice(n.tokensIndex);
          n.value = n.output = "\\{", e = _ = "\\}", s.output = O;
          for (const P of Q)
            s.output += P.output || P.value;
        }
        h({ type: "brace", value: e, output: _ }), V("braces"), z.pop();
        continue;
      }
      if (e === "|") {
        k.length > 0 && k[k.length - 1].conditions++, h({ type: "text", value: e });
        continue;
      }
      if (e === ",") {
        let n = e;
        const _ = z[z.length - 1];
        _ && ut[ut.length - 1] === "braces" && (_.comma = !0, n = "|"), h({ type: "comma", value: e, output: n });
        continue;
      }
      if (e === "/") {
        if (t.type === "dot" && s.index === s.start + 1) {
          s.start = s.index + 1, s.consumed = "", s.output = "", S.pop(), t = y;
          continue;
        }
        h({ type: "slash", value: e, output: Y });
        continue;
      }
      if (e === ".") {
        if (s.braces > 0 && t.type === "dot") {
          t.value === "." && (t.output = G);
          const n = z[z.length - 1];
          t.type = "dots", t.output += e, t.value += e, n.dots = !0;
          continue;
        }
        if (s.braces + s.parens === 0 && t.type !== "bos" && t.type !== "slash") {
          h({ type: "text", value: e, output: G });
          continue;
        }
        h({ type: "dot", value: e, output: G });
        continue;
      }
      if (e === "?") {
        if (!(t && t.value === "(") && r.noextglob !== !0 && l() === "(" && l(2) !== "?") {
          q("qmark", e);
          continue;
        }
        if (t && t.type === "paren") {
          const _ = l();
          let O = e;
          (t.value === "(" && !/[!=<:]/.test(_) || _ === "<" && !/<([!=]|\w+>)/.test(Z())) && (O = `\\${e}`), h({ type: "text", value: e, output: O });
          continue;
        }
        if (r.dot !== !0 && (t.type === "slash" || t.type === "bos")) {
          h({ type: "qmark", value: e, output: N });
          continue;
        }
        h({ type: "qmark", value: e, output: H });
        continue;
      }
      if (e === "!") {
        if (r.noextglob !== !0 && l() === "(" && (l(2) !== "?" || !/[!=<:]/.test(l(3)))) {
          q("negate", e);
          continue;
        }
        if (r.nonegate !== !0 && s.index === 0) {
          D();
          continue;
        }
      }
      if (e === "+") {
        if (r.noextglob !== !0 && l() === "(" && l(2) !== "?") {
          q("plus", e);
          continue;
        }
        if (t && t.value === "(" || r.regex === !1) {
          h({ type: "plus", value: e, output: b });
          continue;
        }
        if (t && (t.type === "bracket" || t.type === "paren" || t.type === "brace") || s.parens > 0) {
          h({ type: "plus", value: e });
          continue;
        }
        h({ type: "plus", value: b });
        continue;
      }
      if (e === "@") {
        if (r.noextglob !== !0 && l() === "(" && l(2) !== "?") {
          h({ type: "at", extglob: !0, value: e, output: "" });
          continue;
        }
        h({ type: "text", value: e });
        continue;
      }
      if (e !== "*") {
        (e === "$" || e === "^") && (e = `\\${e}`);
        const n = g.exec(Z());
        n && (e += n[0], s.index += n[0].length), h({ type: "text", value: e });
        continue;
      }
      if (t && (t.type === "globstar" || t.star === !0)) {
        t.type = "star", t.star = !0, t.value += e, t.output = X, s.backtrack = !0, s.globstar = !0, J(e);
        continue;
      }
      let i = Z();
      if (r.noextglob !== !0 && /^\([^?]/.test(i)) {
        q("star", e);
        continue;
      }
      if (t.type === "star") {
        if (r.noglobstar === !0) {
          J(e);
          continue;
        }
        const n = t.prev, _ = n.prev, O = n.type === "slash" || n.type === "bos", Q = _ && (_.type === "star" || _.type === "globstar");
        if (r.bash === !0 && (!O || i[0] && i[0] !== "/")) {
          h({ type: "star", value: e, output: "" });
          continue;
        }
        const P = s.braces > 0 && (n.type === "comma" || n.type === "brace"), lt = k.length && (n.type === "pipe" || n.type === "paren");
        if (!O && n.type !== "paren" && !P && !lt) {
          h({ type: "star", value: e, output: "" });
          continue;
        }
        for (; i.slice(0, 3) === "/**"; ) {
          const at = c[s.index + 4];
          if (at && at !== "/")
            break;
          i = i.slice(3), J("/**", 3);
        }
        if (n.type === "bos" && nt()) {
          t.type = "globstar", t.value += e, t.output = j(r), s.output = t.output, s.globstar = !0, J(e);
          continue;
        }
        if (n.type === "slash" && n.prev.type !== "bos" && !Q && nt()) {
          s.output = s.output.slice(0, -(n.output + t.output).length), n.output = `(?:${n.output}`, t.type = "globstar", t.output = j(r) + (r.strictSlashes ? ")" : "|$)"), t.value += e, s.globstar = !0, s.output += n.output + t.output, J(e);
          continue;
        }
        if (n.type === "slash" && n.prev.type !== "bos" && i[0] === "/") {
          const at = i[1] !== void 0 ? "|$" : "";
          s.output = s.output.slice(0, -(n.output + t.output).length), n.output = `(?:${n.output}`, t.type = "globstar", t.output = `${j(r)}${Y}|${Y}${at})`, t.value += e, s.output += n.output + t.output, s.globstar = !0, J(e + C()), h({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (n.type === "bos" && i[0] === "/") {
          t.type = "globstar", t.value += e, t.output = `(?:^|${Y}|${j(r)}${Y})`, s.output = t.output, s.globstar = !0, J(e + C()), h({ type: "slash", value: "/", output: "" });
          continue;
        }
        s.output = s.output.slice(0, -t.output.length), t.type = "globstar", t.output = j(r), t.value += e, s.output += t.output, s.globstar = !0, J(e);
        continue;
      }
      const L = { type: "star", value: e, output: X };
      if (r.bash === !0) {
        L.output = ".*?", (t.type === "bos" || t.type === "slash") && (L.output = v + L.output), h(L);
        continue;
      }
      if (t && (t.type === "bracket" || t.type === "paren") && r.regex === !0) {
        L.output = e, h(L);
        continue;
      }
      (s.index === s.start || t.type === "slash" || t.type === "dot") && (t.type === "dot" ? (s.output += st, t.output += st) : r.dot === !0 ? (s.output += M, t.output += M) : (s.output += v, t.output += v), l() !== "*" && (s.output += B, t.output += B)), h(L);
    }
    for (; s.brackets > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(f("closing", "]"));
      s.output = A.escapeLast(s.output, "["), V("brackets");
    }
    for (; s.parens > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(f("closing", ")"));
      s.output = A.escapeLast(s.output, "("), V("parens");
    }
    for (; s.braces > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(f("closing", "}"));
      s.output = A.escapeLast(s.output, "{"), V("braces");
    }
    if (r.strictSlashes !== !0 && (t.type === "star" || t.type === "bracket") && h({ type: "maybe_slash", value: "", output: `${Y}?` }), s.backtrack === !0) {
      s.output = "";
      for (const i of s.tokens)
        s.output += i.output != null ? i.output : i.value, i.suffix && (s.output += i.suffix);
    }
    return s;
  };
  return x.fastpaths = (c, E) => {
    const r = { ...E }, $ = typeof r.maxLength == "number" ? Math.min(R, r.maxLength) : R, m = c.length;
    if (m > $)
      throw new SyntaxError(`Input length: ${m}, exceeds maximum allowed length: ${$}`);
    c = u[c] || c;
    const {
      DOT_LITERAL: y,
      SLASH_LITERAL: S,
      ONE_CHAR: I,
      DOTS_SLASH: F,
      NO_DOT: T,
      NO_DOTS: G,
      NO_DOTS_SLASH: b,
      STAR: Y,
      START_ANCHOR: B
    } = p.globChars(r.windows), W = r.dot ? G : T, w = r.dot ? b : T, st = r.capture ? "" : "?:", M = { negated: !1, prefix: "" };
    let H = r.bash === !0 ? ".*?" : Y;
    r.capture && (H = `(${H})`);
    const N = (v) => v.noglobstar === !0 ? H : `(${st}(?:(?!${B}${v.dot ? F : y}).)*?)`, tt = (v) => {
      switch (v) {
        case "*":
          return `${W}${I}${H}`;
        case ".*":
          return `${y}${I}${H}`;
        case "*.*":
          return `${W}${H}${y}${I}${H}`;
        case "*/*":
          return `${W}${H}${S}${I}${w}${H}`;
        case "**":
          return W + N(r);
        case "**/*":
          return `(?:${W}${N(r)}${S})?${w}${I}${H}`;
        case "**/*.*":
          return `(?:${W}${N(r)}${S})?${w}${H}${y}${I}${H}`;
        case "**/.*":
          return `(?:${W}${N(r)}${S})?${y}${I}${H}`;
        default: {
          const et = /^(.*?)\.(\w+)$/.exec(v);
          if (!et) return;
          const X = tt(et[1]);
          return X ? X + y + et[2] : void 0;
        }
      }
    }, rt = A.removePrefix(c, M);
    let j = tt(rt);
    return j && r.strictSlashes !== !0 && (j += `${S}?`), j;
  }, At = x, At;
}
var Rt, bt;
function It() {
  if (bt) return Rt;
  bt = 1;
  const p = /* @__PURE__ */ wt(), A = /* @__PURE__ */ Nt(), R = /* @__PURE__ */ ct(), d = /* @__PURE__ */ it(), g = (u) => u && typeof u == "object" && !Array.isArray(u), o = (u, a, f = !1) => {
    if (Array.isArray(u)) {
      const S = u.map((F) => o(F, a, f));
      return (F) => {
        for (const T of S) {
          const G = T(F);
          if (G) return G;
        }
        return !1;
      };
    }
    const x = g(u) && u.tokens && u.input;
    if (u === "" || typeof u != "string" && !x)
      throw new TypeError("Expected pattern to be a non-empty string");
    const c = a || {}, E = c.windows, r = x ? o.compileRe(u, a) : o.makeRe(u, a, !1, !0), $ = r.state;
    delete r.state;
    let m = () => !1;
    if (c.ignore) {
      const S = { ...a, ignore: null, onMatch: null, onResult: null };
      m = o(c.ignore, S, f);
    }
    const y = (S, I = !1) => {
      const { isMatch: F, match: T, output: G } = o.test(S, r, a, { glob: u, posix: E }), b = { glob: u, state: $, regex: r, posix: E, input: S, output: G, match: T, isMatch: F };
      return typeof c.onResult == "function" && c.onResult(b), F === !1 ? (b.isMatch = !1, I ? b : !1) : m(S) ? (typeof c.onIgnore == "function" && c.onIgnore(b), b.isMatch = !1, I ? b : !1) : (typeof c.onMatch == "function" && c.onMatch(b), I ? b : !0);
    };
    return f && (y.state = $), y;
  };
  return o.test = (u, a, f, { glob: x, posix: c } = {}) => {
    if (typeof u != "string")
      throw new TypeError("Expected input to be a string");
    if (u === "")
      return { isMatch: !1, output: "" };
    const E = f || {}, r = E.format || (c ? R.toPosixSlashes : null);
    let $ = u === x, m = $ && r ? r(u) : u;
    return $ === !1 && (m = r ? r(u) : u, $ = m === x), ($ === !1 || E.capture === !0) && (E.matchBase === !0 || E.basename === !0 ? $ = o.matchBase(u, a, f, c) : $ = a.exec(m)), { isMatch: !!$, match: $, output: m };
  }, o.matchBase = (u, a, f) => (a instanceof RegExp ? a : o.makeRe(a, f)).test(R.basename(u)), o.isMatch = (u, a, f) => o(a, f)(u), o.parse = (u, a) => Array.isArray(u) ? u.map((f) => o.parse(f, a)) : A(u, { ...a, fastpaths: !1 }), o.scan = (u, a) => p(u, a), o.compileRe = (u, a, f = !1, x = !1) => {
    if (f === !0)
      return u.output;
    const c = a || {}, E = c.contains ? "" : "^", r = c.contains ? "" : "$";
    let $ = `${E}(?:${u.output})${r}`;
    u && u.negated === !0 && ($ = `^(?!${$}).*$`);
    const m = o.toRegex($, a);
    return x === !0 && (m.state = u), m;
  }, o.makeRe = (u, a = {}, f = !1, x = !1) => {
    if (!u || typeof u != "string")
      throw new TypeError("Expected a non-empty string");
    let c = { negated: !1, fastpaths: !0 };
    return a.fastpaths !== !1 && (u[0] === "." || u[0] === "*") && (c.output = A.fastpaths(u, a)), c.output || (c = A(u, a)), o.compileRe(c, a, f, x);
  }, o.toRegex = (u, a) => {
    try {
      const f = a || {};
      return new RegExp(u, f.flags || (f.nocase ? "i" : ""));
    } catch (f) {
      if (a && a.debug === !0) throw f;
      return /$^/;
    }
  }, o.constants = d, Rt = o, Rt;
}
var _t, xt;
function kt() {
  if (xt) return _t;
  xt = 1;
  const p = /* @__PURE__ */ It(), A = /* @__PURE__ */ ct();
  function R(d, g, o = !1) {
    return g && (g.windows === null || g.windows === void 0) && (g = { ...g, windows: A.isWindows() }), p(d, g, o);
  }
  return Object.assign(R, p), _t = R, _t;
}
var Pt = /* @__PURE__ */ kt();
const Dt = /* @__PURE__ */ Ht(Pt), Xt = ({ args: p }, { dirs: A }) => {
  if (A.length === 0)
    return new $t((d) => {
      d.next({
        status: "error",
        error: { message: "No directory provided" }
      }), d.complete();
    });
  const R = {};
  return p.limit !== void 0 && (R.limit = p.limit), p.offset !== void 0 && (R.offset = p.offset), Gt(A, p.filePattern, R);
};
function Gt(p, A, R) {
  return mt(
    ...p.map((d) => Bt(d, A, R))
  ).pipe(
    Lt((d) => {
      const g = [];
      for (const a of d)
        a.status === "in-progress" ? g.push(...a?.progress ?? []) : a.status === "done" ? g.push(...a.result) : a.status === "error" ? g.push(...a.progress ?? []) : a.status === "cancelled" && g.push(...a.progress ?? []);
      const o = d.filter((a) => a.status === "error");
      return o.length > 0 ? {
        status: "error",
        progress: g,
        error: {
          message: o.map((a) => a?.error?.message ?? "").join(`
`)
        }
      } : {
        status: d.every((a) => a.status === "done") ? "done" : d.some((a) => a.status === "cancelled") ? "cancelled" : "in-progress",
        progress: g,
        result: g
      };
    })
  );
}
function Bt(p, A, R) {
  return Tt(p), new $t((d) => {
    d.next({
      status: "in-progress",
      progress: []
    }), Mt(p.fsPath, A ? { pattern: A, caseInsensitive: !0 } : null, R ?? {}).then(({ files: g, remaining: o }) => {
      o > 0 && g.push(`--- ${o} more files not shown ---`), d.next({
        status: "done",
        progress: g,
        result: g
      });
    }).catch((g) => {
      const o = g instanceof Error ? g.message : String(g);
      d.next({
        status: "error",
        progress: [],
        error: { message: o }
      });
    }).finally(() => d.complete());
  });
}
const gt = 5e5;
function Mt(p, A, R) {
  const d = R.limit ?? gt;
  A?.pattern && A.pattern === "*" && (A.pattern = "**");
  const g = A?.pattern ? Dt(A.pattern, { nocase: A.caseInsensitive, dot: !0 }) : void 0, o = [
    "--files",
    "--color",
    "never",
    "--no-require-git",
    // We want to include hidden files because dot-files in a repository are often important.
    "--hidden",
    // Ripgrep will include the .git/ directory when using --hidden unless
    // the user explicitly gitignores the .git/ directory, or rgignores it,
    // which most people don't.
    "--glob",
    "!\\.git/"
  ];
  R.maxDepth !== void 0 && o.push("--max-depth", R.maxDepth.toString()), R.basePath !== void 0 && o.push(R.basePath);
  const u = yt(Ot(), o, {
    cwd: p,
    stdio: ["ignore", "pipe", "pipe"],
    detached: process.platform !== "win32",
    env: {
      ...process.env,
      NONINTERACTIVE: "1",
      DEBIAN_FRONTEND: "noninteractive"
    }
  });
  return new Promise((a, f) => {
    const x = [];
    let c = "", E = "", r = R.offset ?? 0, $ = !1;
    const m = () => {
      if ($ || !E || g && !g(E))
        return;
      const y = E;
      if (E = "", r > 0) {
        r--;
        return;
      }
      x.push(y), x.length >= gt && (vt.warn("Glob limit reached. Returning partial results.", {
        glob: A?.pattern,
        limit: gt,
        dir: p
      }), u.kill(), $ = !0, a({
        files: x,
        remaining: 0,
        aborted: !0
      }));
    };
    u.stdout?.on("data", (y) => {
      for (const S of String(y))
        S !== "\r" && (S === `
` ? (m(), E = "") : E += S);
    }), u?.stderr?.on("data", (y) => {
      c += String(y);
    }), u.on("exit", (y) => {
      if (y && y >= 2) {
        f(new Error(`ripgrep exited with code ${y}:
${c}`));
        return;
      }
      m();
      const S = x.slice(0, d);
      a({
        files: S,
        remaining: x.length - S.length
      });
    });
  });
}
export {
  Gt as globFilesWithRipgrep,
  Xt as nodeGlobTool,
  Mt as ripgrepFiles
};
//# sourceMappingURL=glob.node-Cfv1JwiF.js.map
