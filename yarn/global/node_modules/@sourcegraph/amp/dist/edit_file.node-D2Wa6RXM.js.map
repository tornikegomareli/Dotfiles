{"version":3,"file":"edit_file.node-D2Wa6RXM.js","sources":["../../core/src/utils/async_mutex.ts","../../core/src/tools/builtin/filesystem/edit_file.node.ts"],"sourcesContent":["export class AsyncMutex {\n\t#locked = false\n\t#queue: (() => void)[] = []\n\n\t/**\n\t * Acquires the lock. If the lock is already held, waits until it is released.\n\t * @returns A promise that resolves when the lock is acquired.\n\t */\n\tasync acquire(): Promise<void> {\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tif (!this.#locked) {\n\t\t\t\t// Lock is free, acquire it immediately\n\t\t\t\tthis.#locked = true\n\t\t\t\tresolve()\n\t\t\t} else {\n\t\t\t\t// Lock is held, add the resolver to the queue\n\t\t\t\tthis.#queue.push(resolve)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Releases the lock. If there are waiters in the queue, the next one acquires the lock.\n\t * Otherwise, the lock becomes free.\n\t */\n\trelease(): void {\n\t\tif (this.#queue.length > 0) {\n\t\t\t// Pass the lock to the next waiter without setting #locked to false\n\t\t\tconst nextResolve = this.#queue.shift()\n\t\t\t// The next waiter's promise resolves, and *they* now hold the lock.\n\t\t\t// #locked remains true.\n\t\t\tnextResolve?.()\n\t\t} else {\n\t\t\t// No waiters, release the lock\n\t\t\tthis.#locked = false\n\t\t}\n\t}\n}\n","import { promiseFactoryToObservable } from '@sourcegraph/observable'\nimport { getFileModTime } from '../../../threads/file-tracking/common'\nimport { AsyncMutex } from '../../../utils/async_mutex'\nimport { checkDirURIIsFile } from '../node-helpers'\nimport type { EditFileToolDef, editFileToolReg } from './edit_file.common'\nimport { applyFileEdits, editFileArgsSchema } from './edit_file.common'\nimport { resolveArgumentPath } from './read_file.util'\nimport { recordEdit } from './undo_edit.node'\n\nconst runningMutex = new AsyncMutex()\n\nexport const nodeEditFileTool: NonNullable<(typeof editFileToolReg)['fn']> = (\n\t{ args },\n\t{ dir, dirs, threadID, trackFileChange, filesystem },\n) => {\n\treturn promiseFactoryToObservable(async (signal) => {\n\t\tawait runningMutex.acquire()\n\t\ttry {\n\t\t\tcheckEditArgs(args)\n\n\t\t\tcheckDirURIIsFile(dir)\n\n\t\t\tconst filePath = await resolveArgumentPath(filesystem, dirs, args.path, signal)\n\n\t\t\tif (!filesystem.exclusiveWriter) {\n\t\t\t\tconst lastReadTime = getFileModTime(filePath, threadID)\n\t\t\t\tconst currentMtime = await filesystem.getMtime(filePath)\n\t\t\t\tif (lastReadTime && currentMtime && lastReadTime !== currentMtime) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: 'error' as const,\n\t\t\t\t\t\tprogress: {},\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: `The file '${args.path}' has been modified since you last read it. Please use read_file to view the current version before making edits.`,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst content = await filesystem.readFile(filePath, signal)\n\t\t\tconst { modifiedContent, formattedDiff, lineRange } = await applyFileEdits(\n\t\t\t\targs.path,\n\t\t\t\tcontent,\n\t\t\t\targs.old_str,\n\t\t\t\targs.new_str,\n\t\t\t)\n\n\t\t\tawait recordEdit(args.path, content, modifiedContent)\n\n\t\t\tawait trackFileChange(filePath, async (path) => {\n\t\t\t\tawait filesystem.writeFile(path, modifiedContent, signal)\n\t\t\t})\n\n\t\t\tconst result = {\n\t\t\t\tdiff: formattedDiff,\n\t\t\t\tlineRange,\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tstatus: 'done',\n\t\t\t\tprogress: {},\n\t\t\t\tresult,\n\t\t\t\tfiles: [args.path],\n\t\t\t}\n\t\t} finally {\n\t\t\trunningMutex.release()\n\t\t}\n\t})\n}\n\nfunction checkEditArgs(args: EditFileToolDef['args']): asserts args is EditFileToolDef['args'] {\n\targs = editFileArgsSchema.parse(args)\n\tif (args.old_str === args.new_str) {\n\t\tthrow new Error('old_str and new_str must be different from each other.')\n\t}\n}\n"],"names":["AsyncMutex","#locked","#queue","resolve","runningMutex","nodeEditFileTool","args","dir","dirs","threadID","trackFileChange","filesystem","promiseFactoryToObservable","signal","checkEditArgs","checkDirURIIsFile","filePath","resolveArgumentPath","lastReadTime","getFileModTime","currentMtime","content","modifiedContent","formattedDiff","lineRange","applyFileEdits","recordEdit","path","editFileArgsSchema"],"mappings":";;;AAAO,MAAMA,EAAW;AAAA,EACvBC,KAAU;AAAA,EACVC,KAAyB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAM1B,MAAM,UAAyB;AACvB,WAAA,IAAI,QAAc,CAACC,MAAY;AACjC,MAAC,KAAKF,KAMJ,KAAAC,GAAO,KAAKC,CAAO,KAJxB,KAAKF,KAAU,IACPE,EAAA;AAAA,IAIT,CACA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOF,UAAgB;AACX,IAAA,KAAKD,GAAO,SAAS,IAEJ,KAAKA,GAAO,MAAM,IAGxB,IAGd,KAAKD,KAAU;AAAA,EAChB;AAEF;AC5BA,MAAMG,IAAe,IAAIJ,EAAW,GAEvBK,IAAgE,CAC5E,EAAE,MAAAC,EAAK,GACP,EAAE,KAAAC,GAAK,MAAAC,GAAM,UAAAC,GAAU,iBAAAC,GAAiB,YAAAC,QAEjCC,EAA2B,OAAOC,MAAW;AACnD,QAAMT,EAAa,QAAQ;AACvB,MAAA;AACH,IAAAU,EAAcR,CAAI,GAElBS,EAAkBR,CAAG;AAErB,UAAMS,IAAW,MAAMC,EAAoBN,GAAYH,GAAMF,EAAK,MAAMO,CAAM;AAE1E,QAAA,CAACF,EAAW,iBAAiB;AAC1B,YAAAO,IAAeC,EAAeH,GAAUP,CAAQ,GAChDW,IAAe,MAAMT,EAAW,SAASK,CAAQ;AACnD,UAAAE,KAAgBE,KAAgBF,MAAiBE;AAC7C,eAAA;AAAA,UACN,QAAQ;AAAA,UACR,UAAU,CAAC;AAAA,UACX,OAAO;AAAA,YACN,SAAS,aAAad,EAAK,IAAI;AAAA,UAAA;AAAA,QAEjC;AAAA,IACD;AAGD,UAAMe,IAAU,MAAMV,EAAW,SAASK,GAAUH,CAAM,GACpD,EAAE,iBAAAS,GAAiB,eAAAC,GAAe,WAAAC,EAAA,IAAc,MAAMC;AAAA,MAC3DnB,EAAK;AAAA,MACLe;AAAA,MACAf,EAAK;AAAA,MACLA,EAAK;AAAA,IACN;AAEA,iBAAMoB,EAAWpB,EAAK,MAAMe,GAASC,CAAe,GAE9C,MAAAZ,EAAgBM,GAAU,OAAOW,MAAS;AAC/C,YAAMhB,EAAW,UAAUgB,GAAML,GAAiBT,CAAM;AAAA,IAAA,CACxD,GAOM;AAAA,MACN,QAAQ;AAAA,MACR,UAAU,CAAC;AAAA,MACX,QARc;AAAA,QACd,MAAMU;AAAA,QACN,WAAAC;AAAA,MACD;AAAA,MAMC,OAAO,CAAClB,EAAK,IAAI;AAAA,IAClB;AAAA,EAAA,UACC;AACD,IAAAF,EAAa,QAAQ;AAAA,EAAA;AACtB,CACA;AAGF,SAASU,EAAcR,GAAwE;AAE1F,MADGA,IAAAsB,EAAmB,MAAMtB,CAAI,GAChCA,EAAK,YAAYA,EAAK;AACnB,UAAA,IAAI,MAAM,wDAAwD;AAE1E;"}