#!/usr/bin/env node
import { z as ee, at as re } from "./color-Bf2jGwiV.js";
import ne from "node:child_process";
import D from "node:path";
import L from "node:fs";
import R from "node:process";
import { PassThrough as te } from "node:stream";
import { J as se } from "./main-CmK9yaC9.js";
var S = { exports: {} }, T, k;
function oe() {
  if (k) return T;
  k = 1, T = n, n.sync = u;
  var c = L;
  function t(e, o) {
    var f = o.pathExt !== void 0 ? o.pathExt : process.env.PATHEXT;
    if (!f || (f = f.split(";"), f.indexOf("") !== -1))
      return !0;
    for (var i = 0; i < f.length; i++) {
      var s = f[i].toLowerCase();
      if (s && e.substr(-s.length).toLowerCase() === s)
        return !0;
    }
    return !1;
  }
  function a(e, o, f) {
    return !e.isSymbolicLink() && !e.isFile() ? !1 : t(o, f);
  }
  function n(e, o, f) {
    c.stat(e, function(i, s) {
      f(i, i ? !1 : a(s, e, o));
    });
  }
  function u(e, o) {
    return a(c.statSync(e), e, o);
  }
  return T;
}
var O, B;
function ie() {
  if (B) return O;
  B = 1, O = t, t.sync = a;
  var c = L;
  function t(e, o, f) {
    c.stat(e, function(i, s) {
      f(i, i ? !1 : n(s, o));
    });
  }
  function a(e, o) {
    return n(c.statSync(e), o);
  }
  function n(e, o) {
    return e.isFile() && u(e, o);
  }
  function u(e, o) {
    var f = e.mode, i = e.uid, s = e.gid, r = o.uid !== void 0 ? o.uid : process.getuid && process.getuid(), l = o.gid !== void 0 ? o.gid : process.getgid && process.getgid(), h = parseInt("100", 8), d = parseInt("010", 8), m = parseInt("001", 8), v = h | d, w = f & m || f & d && s === l || f & h && i === r || f & v && r === 0;
    return w;
  }
  return O;
}
var A, W;
function ce() {
  if (W) return A;
  W = 1;
  var c;
  process.platform === "win32" || ee.TESTING_WINDOWS ? c = oe() : c = ie(), A = t, t.sync = a;
  function t(n, u, e) {
    if (typeof u == "function" && (e = u, u = {}), !e) {
      if (typeof Promise != "function")
        throw new TypeError("callback not provided");
      return new Promise(function(o, f) {
        t(n, u || {}, function(i, s) {
          i ? f(i) : o(s);
        });
      });
    }
    c(n, u || {}, function(o, f) {
      o && (o.code === "EACCES" || u && u.ignoreErrors) && (o = null, f = !1), e(o, f);
    });
  }
  function a(n, u) {
    try {
      return c.sync(n, u || {});
    } catch (e) {
      if (u && u.ignoreErrors || e.code === "EACCES")
        return !1;
      throw e;
    }
  }
  return A;
}
var q, F;
function ae() {
  if (F) return q;
  F = 1;
  const c = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", t = D, a = c ? ";" : ":", n = ce(), u = (i) => Object.assign(new Error(`not found: ${i}`), { code: "ENOENT" }), e = (i, s) => {
    const r = s.colon || a, l = i.match(/\//) || c && i.match(/\\/) ? [""] : [
      // windows always checks the cwd first
      ...c ? [process.cwd()] : [],
      ...(s.path || process.env.PATH || /* istanbul ignore next: very unusual */
      "").split(r)
    ], h = c ? s.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", d = c ? h.split(r) : [""];
    return c && i.indexOf(".") !== -1 && d[0] !== "" && d.unshift(""), {
      pathEnv: l,
      pathExt: d,
      pathExtExe: h
    };
  }, o = (i, s, r) => {
    typeof s == "function" && (r = s, s = {}), s || (s = {});
    const { pathEnv: l, pathExt: h, pathExtExe: d } = e(i, s), m = [], v = (p) => new Promise((g, _) => {
      if (p === l.length)
        return s.all && m.length ? g(m) : _(u(i));
      const E = l[p], x = /^".*"$/.test(E) ? E.slice(1, -1) : E, y = t.join(x, i), P = !x && /^\.[\\\/]/.test(i) ? i.slice(0, 2) + y : y;
      g(w(P, p, 0));
    }), w = (p, g, _) => new Promise((E, x) => {
      if (_ === h.length)
        return E(v(g + 1));
      const y = h[_];
      n(p + y, { pathExt: d }, (P, Z) => {
        if (!P && Z)
          if (s.all)
            m.push(p + y);
          else
            return E(p + y);
        return E(w(p, g, _ + 1));
      });
    });
    return r ? v(0).then((p) => r(null, p), r) : v(0);
  }, f = (i, s) => {
    s = s || {};
    const { pathEnv: r, pathExt: l, pathExtExe: h } = e(i, s), d = [];
    for (let m = 0; m < r.length; m++) {
      const v = r[m], w = /^".*"$/.test(v) ? v.slice(1, -1) : v, p = t.join(w, i), g = !w && /^\.[\\\/]/.test(i) ? i.slice(0, 2) + p : p;
      for (let _ = 0; _ < l.length; _++) {
        const E = g + l[_];
        try {
          if (n.sync(E, { pathExt: h }))
            if (s.all)
              d.push(E);
            else
              return E;
        } catch {
        }
      }
    }
    if (s.all && d.length)
      return d;
    if (s.nothrow)
      return null;
    throw u(i);
  };
  return q = o, o.sync = f, q;
}
var b = { exports: {} }, z;
function ue() {
  if (z) return b.exports;
  z = 1;
  const c = (t = {}) => {
    const a = t.env || process.env;
    return (t.platform || process.platform) !== "win32" ? "PATH" : Object.keys(a).reverse().find((u) => u.toUpperCase() === "PATH") || "Path";
  };
  return b.exports = c, b.exports.default = c, b.exports;
}
var N, U;
function fe() {
  if (U) return N;
  U = 1;
  const c = D, t = ae(), a = ue();
  function n(e, o) {
    const f = e.options.env || process.env, i = process.cwd(), s = e.options.cwd != null, r = s && process.chdir !== void 0 && !process.chdir.disabled;
    if (r)
      try {
        process.chdir(e.options.cwd);
      } catch {
      }
    let l;
    try {
      l = t.sync(e.command, {
        path: f[a({ env: f })],
        pathExt: o ? c.delimiter : void 0
      });
    } catch {
    } finally {
      r && process.chdir(i);
    }
    return l && (l = c.resolve(s ? e.options.cwd : "", l)), l;
  }
  function u(e) {
    return n(e) || n(e, !0);
  }
  return N = u, N;
}
var C = {}, K;
function le() {
  if (K) return C;
  K = 1;
  const c = /([()\][%!^"`<>&|;, *?])/g;
  function t(n) {
    return n = n.replace(c, "^$1"), n;
  }
  function a(n, u) {
    return n = `${n}`, n = n.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"'), n = n.replace(/(?=(\\+?)?)\1$/, "$1$1"), n = `"${n}"`, n = n.replace(c, "^$1"), u && (n = n.replace(c, "^$1")), n;
  }
  return C.command = t, C.argument = a, C;
}
var $, V;
function he() {
  return V || (V = 1, $ = /^#!(.*)/), $;
}
var M, G;
function de() {
  if (G) return M;
  G = 1;
  const c = he();
  return M = (t = "") => {
    const a = t.match(c);
    if (!a)
      return null;
    const [n, u] = a[0].replace(/#! ?/, "").split(" "), e = n.split("/").pop();
    return e === "env" ? u : u ? `${e} ${u}` : e;
  }, M;
}
var H, J;
function pe() {
  if (J) return H;
  J = 1;
  const c = L, t = de();
  function a(n) {
    const e = Buffer.alloc(150);
    let o;
    try {
      o = c.openSync(n, "r"), c.readSync(o, e, 0, 150, 0), c.closeSync(o);
    } catch {
    }
    return t(e.toString());
  }
  return H = a, H;
}
var I, Y;
function me() {
  if (Y) return I;
  Y = 1;
  const c = D, t = fe(), a = le(), n = pe(), u = process.platform === "win32", e = /\.(?:com|exe)$/i, o = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function f(r) {
    r.file = t(r);
    const l = r.file && n(r.file);
    return l ? (r.args.unshift(r.file), r.command = l, t(r)) : r.file;
  }
  function i(r) {
    if (!u)
      return r;
    const l = f(r), h = !e.test(l);
    if (r.options.forceShell || h) {
      const d = o.test(l);
      r.command = c.normalize(r.command), r.command = a.command(r.command), r.args = r.args.map((v) => a.argument(v, d));
      const m = [r.command].concat(r.args).join(" ");
      r.args = ["/d", "/s", "/c", `"${m}"`], r.command = process.env.comspec || "cmd.exe", r.options.windowsVerbatimArguments = !0;
    }
    return r;
  }
  function s(r, l, h) {
    l && !Array.isArray(l) && (h = l, l = null), l = l ? l.slice(0) : [], h = Object.assign({}, h);
    const d = {
      command: r,
      args: l,
      options: h,
      file: void 0,
      original: {
        command: r,
        args: l
      }
    };
    return h.shell ? d : i(d);
  }
  return I = s, I;
}
var j, X;
function ve() {
  if (X) return j;
  X = 1;
  const c = process.platform === "win32";
  function t(e, o) {
    return Object.assign(new Error(`${o} ${e.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${o} ${e.command}`,
      path: e.command,
      spawnargs: e.args
    });
  }
  function a(e, o) {
    if (!c)
      return;
    const f = e.emit;
    e.emit = function(i, s) {
      if (i === "exit") {
        const r = n(s, o);
        if (r)
          return f.call(e, "error", r);
      }
      return f.apply(e, arguments);
    };
  }
  function n(e, o) {
    return c && e === 1 && !o.file ? t(o.original, "spawn") : null;
  }
  function u(e, o) {
    return c && e === 1 && !o.file ? t(o.original, "spawnSync") : null;
  }
  return j = {
    hookChildProcess: a,
    verifyENOENT: n,
    verifyENOENTSync: u,
    notFoundError: t
  }, j;
}
var Q;
function Ee() {
  if (Q) return S.exports;
  Q = 1;
  const c = ne, t = me(), a = ve();
  function n(e, o, f) {
    const i = t(e, o, f), s = c.spawn(i.command, i.args, i.options);
    return a.hookChildProcess(s, i), s;
  }
  function u(e, o, f) {
    const i = t(e, o, f), s = c.spawnSync(i.command, i.args, i.options);
    return s.error = s.error || a.verifyENOENTSync(s.status, i), s;
  }
  return S.exports = n, S.exports.spawn = n, S.exports.sync = u, S.exports._parse = t, S.exports._enoent = a, S.exports;
}
var _e = Ee();
const we = /* @__PURE__ */ re(_e);
class ge {
  append(t) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, t]) : t;
  }
  readMessage() {
    if (!this._buffer)
      return null;
    const t = this._buffer.indexOf(`
`);
    if (t === -1)
      return null;
    const a = this._buffer.toString("utf8", 0, t).replace(/\r$/, "");
    return this._buffer = this._buffer.subarray(t + 1), Se(a);
  }
  clear() {
    this._buffer = void 0;
  }
}
function Se(c) {
  return se.parse(JSON.parse(c));
}
function ye(c) {
  return JSON.stringify(c) + `
`;
}
const xe = R.platform === "win32" ? [
  "APPDATA",
  "HOMEDRIVE",
  "HOMEPATH",
  "LOCALAPPDATA",
  "PATH",
  "PROCESSOR_ARCHITECTURE",
  "SYSTEMDRIVE",
  "SYSTEMROOT",
  "TEMP",
  "USERNAME",
  "USERPROFILE"
] : (
  /* list inspired by the default env inheritance of sudo */
  ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"]
);
function be() {
  const c = {};
  for (const t of xe) {
    const a = R.env[t];
    a !== void 0 && (a.startsWith("()") || (c[t] = a));
  }
  return c;
}
class $e {
  constructor(t) {
    this._abortController = new AbortController(), this._readBuffer = new ge(), this._stderrStream = null, this._serverParams = t, (t.stderr === "pipe" || t.stderr === "overlapped") && (this._stderrStream = new te());
  }
  /**
   * Starts the server process and prepares to communicate with it.
   */
  async start() {
    if (this._process)
      throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    return new Promise((t, a) => {
      var n, u, e, o, f, i;
      this._process = we(this._serverParams.command, (n = this._serverParams.args) !== null && n !== void 0 ? n : [], {
        env: (u = this._serverParams.env) !== null && u !== void 0 ? u : be(),
        stdio: ["pipe", "pipe", (e = this._serverParams.stderr) !== null && e !== void 0 ? e : "inherit"],
        shell: !1,
        signal: this._abortController.signal,
        windowsHide: R.platform === "win32" && Ce(),
        cwd: this._serverParams.cwd
      }), this._process.on("error", (s) => {
        var r, l;
        if (s.name === "AbortError") {
          (r = this.onclose) === null || r === void 0 || r.call(this);
          return;
        }
        a(s), (l = this.onerror) === null || l === void 0 || l.call(this, s);
      }), this._process.on("spawn", () => {
        t();
      }), this._process.on("close", (s) => {
        var r;
        this._process = void 0, (r = this.onclose) === null || r === void 0 || r.call(this);
      }), (o = this._process.stdin) === null || o === void 0 || o.on("error", (s) => {
        var r;
        (r = this.onerror) === null || r === void 0 || r.call(this, s);
      }), (f = this._process.stdout) === null || f === void 0 || f.on("data", (s) => {
        this._readBuffer.append(s), this.processReadBuffer();
      }), (i = this._process.stdout) === null || i === void 0 || i.on("error", (s) => {
        var r;
        (r = this.onerror) === null || r === void 0 || r.call(this, s);
      }), this._stderrStream && this._process.stderr && this._process.stderr.pipe(this._stderrStream);
    });
  }
  /**
   * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to "pipe" or "overlapped".
   *
   * If stderr piping was requested, a PassThrough stream is returned _immediately_, allowing callers to
   * attach listeners before the start method is invoked. This prevents loss of any early
   * error output emitted by the child process.
   */
  get stderr() {
    var t, a;
    return this._stderrStream ? this._stderrStream : (a = (t = this._process) === null || t === void 0 ? void 0 : t.stderr) !== null && a !== void 0 ? a : null;
  }
  processReadBuffer() {
    for (var t, a; ; )
      try {
        const n = this._readBuffer.readMessage();
        if (n === null)
          break;
        (t = this.onmessage) === null || t === void 0 || t.call(this, n);
      } catch (n) {
        (a = this.onerror) === null || a === void 0 || a.call(this, n);
      }
  }
  async close() {
    this._abortController.abort(), this._process = void 0, this._readBuffer.clear();
  }
  send(t) {
    return new Promise((a) => {
      var n;
      if (!(!((n = this._process) === null || n === void 0) && n.stdin))
        throw new Error("Not connected");
      const u = ye(t);
      this._process.stdin.write(u) ? a() : this._process.stdin.once("drain", a);
    });
  }
}
function Ce() {
  return "type" in R;
}
export {
  xe as DEFAULT_INHERITED_ENV_VARS,
  $e as StdioClientTransport,
  be as getDefaultEnvironment
};
//# sourceMappingURL=stdio-CNkqPrBz.js.map
