#!/usr/bin/env node
import { Z as Y, a4 as k, $ as I, av as C, a0 as L, aH as D, f as j, a3 as J, bb as V, C as Z, O as z, X as M, ak as W, au as H, k as X } from "./color-Bf2jGwiV.js";
import { a as x, o as A, s as g, d as q, b as G, l as h, r as _, u as K, e as Q, c as F, p as ee, Z as te, f as se, g as N } from "./main-CmK9yaC9.js";
const S = A({
  context: Q(["continue", "none"]).optional().default("continue"),
  tools: K([h("all"), x(g())]).optional(),
  prompt: g(),
  verify: _(F()).optional()
}), oe = S.extend({
  type: h("agent"),
  model: g().optional(),
  // Default could be set in implementation
  interactive_confirmation: G().optional()
}), re = S.extend({
  type: h("llm"),
  model: g().optional()
}), ne = S.extend({
  type: h("loop_agent"),
  model: g().optional(),
  input_file: g()
}), ae = S.extend({
  type: h("loop_llm"),
  model: g().optional(),
  input_file: g()
}), ie = A({
  type: h("tool_call"),
  tool: g(),
  parameters: _(F()).optional()
}), le = A({
  type: h("bash"),
  command: g()
}), pe = q("type", [
  oe,
  re,
  ne,
  ae,
  ie,
  le
]), ue = A({
  id: g(),
  steps: x(pe)
}), P = x(ue);
x(P);
function ce(r) {
  try {
    const e = ee(r);
    return P.parse(e);
  } catch (e) {
    throw e instanceof te ? new Error(
      `Invalid routine format: ${e.errors.map((t) => `${t.path.join(".")} - ${t.message}`).join(", ")}`
    ) : e instanceof Error ? new Error(`Failed to parse YAML: ${e.message}`) : new Error(`Unknown error during routine deserialization: ${String(e)}`);
  }
}
class me {
  constructor(e, t) {
    this.observer = e, this.signal = t;
  }
  progressMessages = [];
  /**
   * Adds the latest message to the list of all status updates and then invokes the observer
   * with the updated 'in-progress' status.
   */
  update(e) {
    this.signal.throwIfAborted(), "progress" in e && e.progress ? (Array.isArray(e.progress) ? this.progressMessages.push(...e.progress) : this.progressMessages.push(e.progress), this.observer.next({
      ...e,
      progress: this.progressMessages
    })) : this.observer.next(e);
  }
  error(e) {
    this.observer.error(e);
  }
  complete() {
    this.observer.complete();
  }
}
function O(r, e) {
  let t = r;
  return e.userInput && (t = t.replace(/\{\{\s*userInput\s*\}\}/g, e.userInput), t = t.replace(/\{\{\s*user_input\s*\}\}/g, e.userInput)), t;
}
function de(r, e, t, s, o, a = new AbortController().signal) {
  switch (r.type) {
    case "agent":
      return ge(r, e, t, s, o, a);
    case "llm":
      return fe(r, e, s, o, a);
    default:
      throw new Error(`Unknown step type: ${r.type}`);
  }
}
async function ge(r, e, t, s, o, a) {
  const l = D();
  await se(l);
  const c = O(r.prompt, o);
  let i = e;
  const m = (p) => {
    i = N(i, p);
  };
  m({
    type: "user:message",
    message: {
      content: [{ type: "text", text: c }],
      meta: {
        sentAt: Date.now()
      }
    }
  }), s.update({
    status: "in-progress",
    progress: { type: "message", speaker: "user", message: c }
  });
  const u = (await j(l.tools, a)).map((p) => p.spec), T = I;
  let f = 0;
  const d = 100;
  for (; f < d; ) {
    a.throwIfAborted(), f++;
    const p = new V(), w = await J(
      p,
      t.threadEnvironment,
      !1
    );
    w.push({
      type: "text",
      text: "You are a helpful AI assistant running as a subagent within a larger system. Your task is to handle this specific step in a routine. You can use tools to complete your task. When you are completely done, do not ask to use more tools."
    });
    const U = w;
    a.throwIfAborted();
    let b;
    try {
      const n = k.fromNativeThread(i);
      b = await C(
        n,
        u,
        U,
        T,
        a
      );
    } catch (n) {
      throw new Error(`Anthropic API error: ${n}`);
    }
    if (!b.message || !("content" in b.message))
      throw new Error("Unexpected response format from Anthropic");
    if (b.message.content.length === 0)
      break;
    const v = L(b.message);
    m(v);
    const E = b.message.content.filter((n) => n.type === "text").map((n) => "text" in n ? n.text : "").join(" ").trim();
    if (E && s.update({
      status: "in-progress",
      progress: { type: "message", speaker: "assistant", message: E }
    }), v.type !== "assistant:message")
      break;
    const B = ye(
      i,
      v.message
    );
    for (const n of B) {
      s.update({
        status: "in-progress",
        progress: {
          id: n.id,
          type: "toolCall",
          toolName: n.name,
          args: JSON.stringify(n.input)
        }
      });
      let y;
      try {
        if (y = await R(
          l,
          n.name,
          n.input,
          t,
          a
        ), a.throwIfAborted(), y.status !== "done")
          throw new Error(JSON.stringify(y));
      } catch ($) {
        m({
          type: "tool:data",
          toolUse: n.id,
          data: {
            status: "error",
            error: { message: `Tool call error: ${$}` }
          }
        }), s.update({
          status: "in-progress",
          progress: {
            id: n.id,
            type: "toolResult",
            toolName: n.name,
            result: `Tool call error: ${$}`
          }
        });
        continue;
      }
      m({
        type: "tool:data",
        toolUse: n.id,
        data: y
      }), s.update({
        status: "in-progress",
        progress: {
          id: n.id,
          type: "toolResult",
          toolName: n.name,
          result: typeof y.result == "string" ? y.result : JSON.stringify(y.result)
        }
      });
    }
  }
  return i;
}
async function fe(r, e, t, s, o) {
  const a = O(r.prompt, s);
  let l = e;
  const c = (d) => {
    l = N(l, d);
  };
  c({
    type: "user:message",
    message: {
      content: [{ type: "text", text: a }],
      meta: {
        sentAt: Date.now()
      }
    }
  }), t.update({
    status: "in-progress",
    progress: { type: "message", speaker: "user", message: a }
  });
  const i = k.fromNativeThread(l), m = r.model || I, u = await C(
    i,
    [],
    // No tools for LLM-only step
    [],
    // No system prompt
    m,
    o
  );
  if (!u.message)
    throw new Error("Failed to get response from Anthropic");
  const T = L(u.message);
  c(T);
  const f = u.message.content.filter((d) => d.type === "text").map((d) => d.type === "text" ? d.text : "").join(" ").trim();
  return t.update({
    status: "in-progress",
    progress: { type: "message", speaker: "assistant", message: f }
  }), l;
}
function ye(r, e) {
  const t = Z(r);
  return e.content.filter((s) => s.type === "tool_use").filter((s) => !s.inputPartialJSON).filter(
    (s) => (
      // Only include tools that haven't been invoked yet.
      !t.has(s.id)
    )
  );
}
async function R(r, e, t, s, o = new AbortController().signal, a) {
  return new Promise((l, c) => {
    let i = !1;
    const m = r.invokeTool(e, { args: t, userInput: a }, s).subscribe({
      next: (u) => {
        Y(u) && (m.unsubscribe(), i || (i = !0, l(u)));
      },
      error: (u) => {
        i || (i = !0, c(u));
      },
      complete: () => {
      }
    });
    o.addEventListener("abort", () => {
      m.unsubscribe(), i || (i = !0, c(new Error("Tool execution was aborted")));
    });
  });
}
const Te = ({ args: r }, e) => new z((t) => {
  const s = new AbortController(), o = new me(t, s.signal);
  return he(r, e, o, s.signal).catch((a) => {
    M(a) ? (o.update({
      status: "cancelled",
      progress: { type: "meta", message: "Operation cancelled" }
    }), o.complete()) : o.error(a);
  }), () => {
    s.abort();
  };
});
async function he(r, e, t, s) {
  try {
    const { id: o, file: a } = r, l = a || "routines.amp.yaml";
    t.update({
      status: "in-progress",
      progress: { type: "meta", message: `Loading routine: ${o} from ${l}` }
    });
    const c = D();
    c.registerTool(W);
    const i = await R(
      c,
      "read_file",
      { path: l },
      e,
      s
    );
    if (i.status !== "done")
      throw new Error(`Failed to read routine file: ${l}`);
    const m = typeof i.result == "string" ? i.result : i.result.content, u = String(m).split(`
`).map((p) => p.replace(/^\d+:\s/, "")).join(`
`);
    s.throwIfAborted();
    const T = ce(u);
    s.throwIfAborted();
    const f = T.find((p) => p.id === o);
    if (!f)
      throw new Error(`Routine with id "${o}" not found in ${l}`);
    let d = {
      id: H(),
      created: Date.now(),
      v: 0,
      messages: []
    };
    t.update({
      status: "in-progress",
      progress: [
        {
          type: "meta",
          message: `Executing routine ${o}`
        }
      ]
    });
    for (let p = 0; p < f.steps.length; p++) {
      const w = f.steps[p];
      w && (t.update({
        status: "in-progress",
        progress: [
          {
            type: "meta",
            message: `Executing step ${p + 1}/${f.steps.length}: ${w.type}`,
            variant: "header"
          }
        ]
      }), s.throwIfAborted(), d = await de(w, d, e, t, {
        userInput: r.userInput
      }));
    }
    t.update({
      status: "done",
      progress: {
        type: "meta",
        message: `Finished executing all ${f.steps.length} steps of routine: ${o}.`,
        variant: "header"
      },
      result: ""
      // No output for now
    }), t.complete();
  } catch (o) {
    M(o) ? (t.update({
      status: "cancelled",
      progress: {
        type: "meta",
        message: "Operation cancelled"
      }
    }), t.complete()) : (X.error("Error in run_routine", {
      error: o,
      stack: o instanceof Error ? o.stack : ""
    }), t.error(o));
  }
}
export {
  Te as runRoutine
};
//# sourceMappingURL=node-W217cnDV.js.map
