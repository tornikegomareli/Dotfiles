{"version":3,"file":"list_directory.node-Dmx2XM_W.js","sources":["../../core/src/tools/builtin/filesystem/list_directory.node.ts"],"sourcesContent":["import { Observable, concatMap, map, promiseToObservable } from '@sourcegraph/observable'\nimport fs from 'node:fs/promises'\nimport os from 'node:os'\nimport path from 'path'\nimport { FileNotExistError } from '../../../platform/fs/fs'\nimport type { listDirectoryToolReg } from './list_directory.common'\n\nexport const nodeListDirectoryTool: NonNullable<(typeof listDirectoryToolReg)['fn']> = (\n\t{ args },\n\t{ dirs },\n) => {\n\t// Handle case where dir is null\n\tif (dirs.length === 0) {\n\t\treturn new Observable((observer) => {\n\t\t\tobserver.next({\n\t\t\t\tstatus: 'error' as const,\n\t\t\t\terror: { message: 'No directory provided' },\n\t\t\t})\n\t\t\tobserver.complete()\n\t\t})\n\t}\n\n\tconst absoluteDir = resolveArgumentDirectoryNode(\n\t\tdirs.map((dir) => dir.fsPath),\n\t\targs.path,\n\t)\n\n\treturn promiseToObservable(absoluteDir).pipe(\n\t\tconcatMap((absoluteDir) =>\n\t\t\tpromiseToObservable(\n\t\t\t\tfs.readdir(absoluteDir, { withFileTypes: true }).catch((error) => {\n\t\t\t\t\tthrow new FileNotExistError(absoluteDir)\n\t\t\t\t}),\n\t\t\t),\n\t\t),\n\t\tmap((value) => {\n\t\t\tconst result = value.map((dirent) => dirent.name + (dirent.isDirectory() ? '/' : ''))\n\t\t\treturn {\n\t\t\t\tstatus: 'done' as const,\n\t\t\t\tfiles: result,\n\t\t\t\tresult,\n\t\t\t}\n\t\t}),\n\t)\n}\n\n/**\n * IMPORTANT: Do not use this function directly especially in shared services. Use @link:resolveArgumentDirectory\n * from path-utils.ts instead.\n * Tries to find a directory that exists on disk in a potentially multi-root workspace.\n *\n * See read_file.util.resolveArgumentPath() for the equivalent file-based implementation. We can't use\n * the same helper for files and directories because the VS Code `stat` API only works with files.\n */\nexport async function resolveArgumentDirectoryNode(\n\tdirs: string[],\n\tdirPath: string | undefined,\n): Promise<string> {\n\tif (!dirPath) {\n\t\treturn dirs[0]!\n\t}\n\tif (dirPath.startsWith('~')) {\n\t\tdirPath = path.join(os.homedir(), dirPath.slice(1))\n\t}\n\tif (path.isAbsolute(dirPath)) {\n\t\treturn dirPath\n\t}\n\tfor (const dir of dirs) {\n\t\tconst absoluteDir = path.resolve(dir, dirPath)\n\t\ttry {\n\t\t\tconst stat = await fs.stat(absoluteDir)\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\treturn absoluteDir\n\t\t\t}\n\t\t} catch {\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn path.resolve(dirs[0]!, dirPath)\n}\n"],"names":["nodeListDirectoryTool","args","dirs","Observable","observer","absoluteDir","resolveArgumentDirectoryNode","dir","promiseToObservable","concatMap","fs","error","FileNotExistError","map","value","result","dirent","dirPath","path","os"],"mappings":";;;;;AAOO,MAAMA,IAA0E,CACtF,EAAE,MAAAC,KACF,EAAE,MAAAC,QACE;AAEA,MAAAA,EAAK,WAAW;AACZ,WAAA,IAAIC,EAAW,CAACC,MAAa;AACnC,MAAAA,EAAS,KAAK;AAAA,QACb,QAAQ;AAAA,QACR,OAAO,EAAE,SAAS,wBAAwB;AAAA,MAAA,CAC1C,GACDA,EAAS,SAAS;AAAA,IAAA,CAClB;AAGF,QAAMC,IAAcC;AAAA,IACnBJ,EAAK,IAAI,CAACK,MAAQA,EAAI,MAAM;AAAA,IAC5BN,EAAK;AAAA,EACN;AAEO,SAAAO,EAAoBH,CAAW,EAAE;AAAA,IACvCI;AAAA,MAAU,CAACJ,MACVG;AAAA,QACCE,EAAG,QAAQL,GAAa,EAAE,eAAe,IAAM,EAAE,MAAM,CAACM,MAAU;AAC3D,gBAAA,IAAIC,EAAkBP,CAAW;AAAA,QACvC,CAAA;AAAA,MAAA;AAAA,IAEH;AAAA,IACAQ,EAAI,CAACC,MAAU;AACR,YAAAC,IAASD,EAAM,IAAI,CAACE,MAAWA,EAAO,QAAQA,EAAO,YAAA,IAAgB,MAAM,GAAG;AAC7E,aAAA;AAAA,QACN,QAAQ;AAAA,QACR,OAAOD;AAAA,QACP,QAAAA;AAAA,MACD;AAAA,IACA,CAAA;AAAA,EACF;AACD;AAUsB,eAAAT,EACrBJ,GACAe,GACkB;AAClB,MAAI,CAACA;AACJ,WAAOf,EAAK,CAAC;AAKV,MAHAe,EAAQ,WAAW,GAAG,MACfA,IAAAC,EAAK,KAAKC,EAAG,QAAA,GAAWF,EAAQ,MAAM,CAAC,CAAC,IAE/CC,EAAK,WAAWD,CAAO;AACnB,WAAAA;AAER,aAAWV,KAAOL,GAAM;AACvB,UAAMG,IAAca,EAAK,QAAQX,GAAKU,CAAO;AACzC,QAAA;AAEC,WADS,MAAMP,EAAG,KAAKL,CAAW,GAC7B;AACD,eAAAA;AAAA,IACR,QACO;AACP;AAAA,IAAA;AAAA,EACD;AAED,SAAOa,EAAK,QAAQhB,EAAK,CAAC,GAAIe,CAAO;AACtC;"}