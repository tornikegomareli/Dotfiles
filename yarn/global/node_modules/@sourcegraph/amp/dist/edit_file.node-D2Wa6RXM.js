#!/usr/bin/env node
import { p, aV as m, a7 as F, aZ as _, a_ as v, a$ as b } from "./color-Bf2jGwiV.js";
import { recordEdit as x } from "./undo_edit.node-CQG6mtZj.js";
class y {
  #e = !1;
  #t = [];
  /**
   * Acquires the lock. If the lock is already held, waits until it is released.
   * @returns A promise that resolves when the lock is acquired.
   */
  async acquire() {
    return new Promise((t) => {
      this.#e ? this.#t.push(t) : (this.#e = !0, t());
    });
  }
  /**
   * Releases the lock. If there are waiters in the queue, the next one acquires the lock.
   * Otherwise, the lock becomes free.
   */
  release() {
    this.#t.length > 0 ? this.#t.shift()?.() : this.#e = !1;
  }
}
const l = new y(), k = ({ args: e }, { dir: t, dirs: d, threadID: u, trackFileChange: h, filesystem: i }) => p(async (a) => {
  await l.acquire();
  try {
    E(e), m(t);
    const r = await F(i, d, e.path, a);
    if (!i.exclusiveWriter) {
      const s = _(r, u), c = await i.getMtime(r);
      if (s && c && s !== c)
        return {
          status: "error",
          progress: {},
          error: {
            message: `The file '${e.path}' has been modified since you last read it. Please use read_file to view the current version before making edits.`
          }
        };
    }
    const n = await i.readFile(r, a), { modifiedContent: o, formattedDiff: f, lineRange: w } = await v(
      e.path,
      n,
      e.old_str,
      e.new_str
    );
    return await x(e.path, n, o), await h(r, async (s) => {
      await i.writeFile(s, o, a);
    }), {
      status: "done",
      progress: {},
      result: {
        diff: f,
        lineRange: w
      },
      files: [e.path]
    };
  } finally {
    l.release();
  }
});
function E(e) {
  if (e = b.parse(e), e.old_str === e.new_str)
    throw new Error("old_str and new_str must be different from each other.");
}
export {
  k as nodeEditFileTool
};
//# sourceMappingURL=edit_file.node-D2Wa6RXM.js.map
