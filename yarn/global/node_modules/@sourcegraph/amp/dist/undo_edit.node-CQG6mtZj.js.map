{"version":3,"file":"undo_edit.node-CQG6mtZj.js","sources":["../../core/src/tools/builtin/filesystem/undo_edit.node.ts"],"sourcesContent":["import { promiseFactoryToObservable } from '@sourcegraph/observable'\nimport crypto from 'node:crypto'\nimport fs, { writeFile } from 'node:fs/promises'\nimport os from 'node:os'\nimport path from 'path'\nimport logger from '../../../common/logger'\nimport { checkDirURIIsFile } from '../node-helpers'\nimport { createUnifiedDiff, formatDiffAsMarkdown } from './edit_file.common'\nimport type { UndoEditToolDef, undoEditToolReg } from './undo_edit.common'\n\nconst MAX_FILES = 50\nconst editQueue: string[] = []\n\nexport async function recordEdit(\n\tfilePath: string,\n\toldContent: string,\n\tnewContent: string,\n): Promise<void> {\n\ttry {\n\t\tconst hashedFilename = getHashedFilename(filePath)\n\t\tconst tempDir = await getTempDir()\n\t\tconst editFile = path.join(tempDir, hashedFilename)\n\n\t\tconst editData = { filePath, oldContent, newContent }\n\t\tawait fs.writeFile(editFile, JSON.stringify(editData), 'utf-8')\n\n\t\t// Update the FIFO queue\n\t\t// Remove if already in queue (to add it to the end)\n\t\tconst existingIndex = editQueue.indexOf(hashedFilename)\n\t\tif (existingIndex >= 0) {\n\t\t\teditQueue.splice(existingIndex, 1)\n\t\t}\n\n\t\t// Add to end of queue (most recent)\n\t\teditQueue.push(hashedFilename)\n\n\t\t// If we exceed the limit, remove the oldest edit\n\t\tif (editQueue.length > MAX_FILES) {\n\t\t\tconst oldestFile = editQueue.shift()\n\t\t\tif (oldestFile) {\n\t\t\t\tconst oldestPath = path.join(tempDir, oldestFile)\n\t\t\t\tawait fs.unlink(oldestPath).catch(() => {})\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tlogger.error('Failed to record edit:', error)\n\t}\n}\n\n// Function to get and remove the most recent edit for a file\nexport async function getLastEdit(\n\tfilePath: string,\n): Promise<{ oldContent: string; newContent: string } | undefined> {\n\ttry {\n\t\tconst hashedFilename = getHashedFilename(filePath)\n\t\tconst tempDir = await getTempDir()\n\t\tconst editFile = path.join(tempDir, hashedFilename)\n\n\t\ttry {\n\t\t\tawait fs.access(editFile)\n\t\t} catch {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst editDataStr = await fs.readFile(editFile, 'utf-8')\n\t\tconst editData = JSON.parse(editDataStr) as {\n\t\t\tfilePath: string\n\t\t\toldContent: string\n\t\t\tnewContent: string\n\t\t}\n\n\t\t// Remove from queue and delete file\n\t\tconst queueIndex = editQueue.indexOf(hashedFilename)\n\t\tif (queueIndex >= 0) {\n\t\t\teditQueue.splice(queueIndex, 1)\n\t\t}\n\t\tawait fs.unlink(editFile).catch(() => {})\n\n\t\treturn { oldContent: editData.oldContent, newContent: editData.newContent }\n\t} catch (error) {\n\t\tlogger.error('Failed to get last edit:', error)\n\t\treturn undefined\n\t}\n}\n\nexport const nodeUndoEditTool: NonNullable<(typeof undoEditToolReg)['fn']> = (\n\t{ args },\n\t{ dir, threadID, trackFileChange },\n) => {\n\treturn promiseFactoryToObservable(async (signal) => {\n\t\tcheckDirURIIsFile(dir)\n\t\tcheckUndoEditArgs(args)\n\n\t\tconst filePath = path.resolve(dir.fsPath, args.path)\n\n\t\t// Get the last edit from history (now async)\n\t\tconst lastEdit = await getLastEdit(args.path)\n\t\tif (!lastEdit) {\n\t\t\treturn {\n\t\t\t\tstatus: 'error' as const,\n\t\t\t\tprogress: {},\n\t\t\t\terror: {\n\t\t\t\t\tmessage: `No edit history found for file '${args.path}'.`,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tconst diff = createUnifiedDiff(lastEdit.newContent, lastEdit.oldContent, args.path)\n\t\tconst formattedDiff = formatDiffAsMarkdown(diff)\n\n\t\tawait trackFileChange(filePath, async (path) => {\n\t\t\tawait writeFile(path, lastEdit.oldContent, {\n\t\t\t\tencoding: 'utf-8',\n\t\t\t\tsignal,\n\t\t\t})\n\t\t})\n\n\t\treturn { status: 'done', progress: {}, result: formattedDiff }\n\t})\n}\n\nfunction checkUndoEditArgs(args: UndoEditToolDef['args']): asserts args is UndoEditToolDef['args'] {\n\tif (typeof args !== 'object' || args === null) {\n\t\tthrow new Error('args must be an object. received instead: `' + JSON.stringify(args) + '`')\n\t}\n\tif (typeof args.path !== 'string') {\n\t\tthrow new Error(\n\t\t\t'path must be a string. received instead: `' + JSON.stringify(args.path) + '`',\n\t\t)\n\t}\n}\n\nlet tempDir = ''\nlet tempDirPromise: Promise<string> | null = null\n\nasync function getTempDir(): Promise<string> {\n\tif (tempDir) return tempDir\n\tif (!tempDirPromise) {\n\t\ttempDirPromise = fs\n\t\t\t.mkdtemp(path.join(os.tmpdir(), 'amp-edits-'))\n\t\t\t.then((dir) => {\n\t\t\t\ttempDir = dir\n\t\t\t\treturn dir\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tlogger.error('Failed to create edit history directory:', error)\n\t\t\t\tthrow error\n\t\t\t})\n\t}\n\treturn tempDirPromise\n}\n\nfunction getHashedFilename(filePath: string): string {\n\tconst hash = crypto.createHash('sha256').update(filePath).digest('hex').slice(0, 16)\n\treturn `${hash}-${path.basename(filePath)}`\n}\n"],"names":["MAX_FILES","editQueue","recordEdit","filePath","oldContent","newContent","hashedFilename","getHashedFilename","tempDir","getTempDir","editFile","path","editData","fs","existingIndex","oldestFile","oldestPath","error","logger","getLastEdit","editDataStr","queueIndex","nodeUndoEditTool","args","dir","threadID","trackFileChange","promiseFactoryToObservable","signal","checkDirURIIsFile","checkUndoEditArgs","lastEdit","diff","createUnifiedDiff","formattedDiff","formatDiffAsMarkdown","writeFile","tempDirPromise","os","crypto"],"mappings":"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"}